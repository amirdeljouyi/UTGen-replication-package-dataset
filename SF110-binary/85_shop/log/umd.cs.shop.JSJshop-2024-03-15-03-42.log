* EvoSuite 1.0.0-SNAPSHOT
* Going to generate test cases for class: umd.cs.shop.JSJshop
* Starting Client-0
* Properties loaded from /home/roham/Results-Utestgen/dataset/SF110-new-res/85_shop/evosuite-files/evosuite.properties
* Connecting to master process on port 5738
* Analyzing classpath: 
* Inheritance tree loaded from evosuite-files/inheritance.xml.gz
[MASTER] 03:42:43.584 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.Consumer
[MASTER] 03:42:43.630 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.Predicate
[MASTER] 03:42:43.632 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.UnaryOperator
[MASTER] 03:42:44.109 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.Function
[MASTER] 03:42:45.085 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.BiFunction
[MASTER] 03:42:45.088 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.BiConsumer
[MASTER] 03:42:47.926 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.ZoneId
[MASTER] 03:42:48.019 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.Temporal
[MASTER] 03:42:48.020 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalAccessor
[MASTER] 03:42:48.021 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalField
[MASTER] 03:42:48.022 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalUnit
[MASTER] 03:42:48.023 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalAmount
[MASTER] 03:42:48.023 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.Clock
[MASTER] 03:42:48.024 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalQuery
[MASTER] 03:42:48.025 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalAdjuster
[MASTER] 03:42:48.044 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.chrono.Chronology
[MASTER] 03:42:48.055 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.chrono.Era
* Finished analyzing classpath
* Generating tests for class umd.cs.shop.JSJshop
* Test criteria:
  - Branch Coverage
  - Line Coverage
  - Method-Output Coverage
  - Top-Level Method Coverage
  - Context Branch Coverage
* Total number of test goals for DYNAMOSA: 528
* Using seed 1710474160198
[Progress:>                             0%] [Cov:>                                  0%]* Starting evolution
* Initial Number of Goals in DynaMOSA = 132 / 528
[MASTER] 03:42:54.217 [logback-1] WARN  TestCluster - Failed to check cache for java.util.Comparator<T> : Type points to itself
[Progress:>                             2%] [Cov:========>                          24%][Progress:=>                            4%] [Cov:========>                          24%][Progress:=>                            4%] [Cov:========>                          24%][Progress:=>                            5%] [Cov:=========>                         26%][Progress:=>                            5%] [Cov:=========>                         26%][Progress:==>                           9%] [Cov:===========>                       32%][Progress:==>                           9%] [Cov:===========>                       33%][Progress:===>                          11%] [Cov:============>                      36%][Progress:===>                          12%] [Cov:============>                      36%][Progress:====>                         14%] [Cov:============>                      36%][Progress:====>                         14%] [Cov:============>                      36%][Progress:====>                         14%] [Cov:============>                      36%][Progress:====>                         16%] [Cov:============>                      36%][Progress:=====>                        17%] [Cov:============>                      36%][Progress:======>                       21%] [Cov:============>                      36%][Progress:========>                     27%] [Cov:============>                      36%][Progress:========>                     29%] [Cov:============>                      36%][Progress:=========>                    32%] [Cov:============>                      36%][Progress:=========>                    32%] [Cov:============>                      36%][Progress:=========>                    33%] [Cov:============>                      36%][Progress:==========>                   35%] [Cov:============>                      36%][Progress:==========>                   35%] [Cov:============>                      36%][Progress:==========>                   35%] [Cov:============>                      36%][Progress:===========>                  39%] [Cov:============>                      36%][Progress:============>                 40%] [Cov:============>                      36%][Progress:============>                 40%] [Cov:============>                      36%][Progress:============>                 43%] [Cov:============>                      36%][Progress:=============>                44%] [Cov:============>                      36%][Progress:=============>                46%] [Cov:============>                      36%][Progress:=============>                46%] [Cov:============>                      36%][Progress:==============>               49%] [Cov:============>                      36%][Progress:===============>              51%] [Cov:============>                      36%][Progress:================>             55%] [Cov:============>                      36%][Progress:=================>            57%] [Cov:============>                      36%][Progress:=================>            57%] [Cov:============>                      36%][Progress:=================>            57%] [Cov:============>                      36%][Progress:=================>            59%] [Cov:============>                      36%][Progress:==================>           62%] [Cov:============>                      36%][Progress:===================>          64%] [Cov:============>                      37%][Progress:====================>         67%] [Cov:============>                      37%][Progress:=====================>        72%] [Cov:============>                      37%][Progress:=====================>        72%] [Cov:============>                      37%][Progress:======================>       74%] [Cov:============>                      37%][Progress:======================>       75%] [Cov:============>                      37%][Progress:=======================>      78%] [Cov:============>                      37%][Progress:========================>     80%] [Cov:============>                      37%][Progress:========================>     83%] [Cov:============>                      37%][Progress:========================>     83%] [Cov:============>                      37%][Progress:==========================>   88%] [Cov:============>                      37%][Progress:===========================>  90%] [Cov:============>                      37%][Progress:===========================>  90%] [Cov:============>                      37%][Progress:===========================>  90%] [Cov:============>                      37%][Progress:===========================>  93%] [Cov:============>                      37%][Progress:============================> 95%] [Cov:============>                      37%][Progress:============================> 95%] [Cov:============>                      37%][Progress:============================> 96%] [Cov:============>                      37%][Progress:=============================>99%] [Cov:================>                  48%][MASTER] 03:46:14.312 [logback-1] WARN  CoverageArchive - A solution with a timeout/exception result has been added to the archive. The covered goal was umd.cs.shop.JSJshop.getBufferedReader(Ljava/lang/String;Ljava/lang/String;)Ljava/io/BufferedReader;: Line 389
[Progress:==============================100%] [Cov:=================>                 49%]
* Search finished after 205s and 57 generations, 13183 statements, best individual has fitness: 292.0
* Generated before the refinement 22 tests with total length 53
statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: getTree()Lumd/cs/shop/JSJshopNode; type is: class org.evosuite.testcase.statements.MethodStatement return type class umd.cs.shop.JSJshopNode
statement code is: JSJshopNode tree = jSJshop.getTree()
test data is: JSJshop jSJshop = new JSJshop();
jSJshop.getTree();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        int a = 1;
        String b = "apple";
        int c = 2;
        String d = "banana";
        JSJshop jSJshop = new JSJshop();
        jSJshop.getTree();
    }
}
statement is: int a = 1, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String b = "apple", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: int c = 2, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String d = "banana", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: JSJshop jSJshop = new JSJshop(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jSJshop.getTree(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jSJshop.getTree() target is: jSJshop method is: getTree()
source statement: umd.cs.shop.JSJshop()V callee: VariableReference: Statement 0, type umd.cs.shop.JSJshopindex is: 4
Matched Method is: getTree()Lumd/cs/shop/JSJshopNode;
* this is vulnerable: String string = "apple"
* this is vulnerable: int _int = 2
* this is vulnerable: String string = "banana"
TestCase is: int _int = 1;
String string = "apple";
int _int = 2;
String string = "banana";
JSJshop jSJshop = new JSJshop();
((JSJshop) _int).getTree();

statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: getAppletURL(Ljava/lang/String;Ljavax/swing/JApplet;)Ljava/net/URL; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.net.URL
statement code is: URL appletURL = jSJshop.getAppletURL("`t1 2XOu? nr)F", (JApplet) null)
test data is: JSJshop jSJshop = new JSJshop();
jSJshop.getAppletURL("`t1 2XOu? nr)F", (JApplet) null);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JSJshop jSJshop = new JSJshop();
        jSJshop.getAppletURL("https://www.example.com", ((JApplet) (null)));
    }
}
statement is: JSJshop jSJshop = new JSJshop(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jSJshop.getAppletURL("https://www.example.com", ((JApplet) (null))), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jSJshop.getAppletURL("https://www.example.com", ((JApplet) (null))) target is: jSJshop method is: getAppletURL(java.lang.String,JApplet)
source statement: umd.cs.shop.JSJshop()V callee: VariableReference: Statement 0, type umd.cs.shop.JSJshopindex is: 0
Matched Method is: getAppletURL(Ljava/lang/String;Ljavax/swing/JApplet;)Ljava/net/URL;
i 1 Parameters size() 1 Num of Method Parameters: 2
TestCase is: JSJshop jSJshop = new JSJshop();
String string = "https://www.example.com";
JApplet jApplet = null;
jSJshop.getAppletURL(string, jApplet);

statement is: umd.cs.shop.JSTaskAtom()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSTaskAtom
statement code is: JSTaskAtom jSTaskAtom = new JSTaskAtom()
statement is: umd.cs.shop.JSJshop(Ljava/lang/String;Lumd/cs/shop/JSTaskAtom;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop(" ListLogicalAtoms: unexpected Atom", arg1)
test data is: JSTaskAtom jSTaskAtom = new JSTaskAtom();
JSJshop jSJshop = new JSJshop(" ListLogicalAtoms: unexpected Atom", jSTaskAtom);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JSTaskAtom jSTaskAtom = new JSTaskAtom();
        JSJshop jSJshop = new JSJshop("ListLogicalAtoms: expected Atom", jSTaskAtom);
    }
}
statement is: JSTaskAtom jSTaskAtom = new JSTaskAtom(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: JSJshop jSJshop = new JSJshop("ListLogicalAtoms: expected Atom", jSTaskAtom), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
TestCase is: JSTaskAtom jSTaskAtom = new JSTaskAtom();
String string = "ListLogicalAtoms: expected Atom";
JSJshop jSJshop = new JSJshop(string, jSTaskAtom);

statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: getSolution()Lumd/cs/shop/JSPairPlanTSListNodes; type is: class org.evosuite.testcase.statements.MethodStatement return type class umd.cs.shop.JSPairPlanTSListNodes
statement code is: JSPairPlanTSListNodes solution = jSJshop.getSolution()
test data is: JSJshop jSJshop = new JSJshop();
jSJshop.getSolution();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JSJshop jSJshop = new JSJshop();
        jSJshop.getSolution(new Solution());
    }
}
statement is: JSJshop jSJshop = new JSJshop(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jSJshop.getSolution(new Solution()), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jSJshop.getSolution(new Solution()) target is: jSJshop method is: getSolution(Solution)
TestCase is: JSJshop jSJshop = new JSJshop();

statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: sol()Lumd/cs/shop/JSPlan; type is: class org.evosuite.testcase.statements.MethodStatement return type class umd.cs.shop.JSPlan
statement code is: JSPlan sol = jSJshop.sol()
test data is: JSJshop jSJshop = new JSJshop();
jSJshop.sol();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JSJshop jSJshop = new JSJshop();
        jSJshop.sol(2, "Hello World!");
    }
}
statement is: JSJshop jSJshop = new JSJshop(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jSJshop.sol(2, "Hello World!"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jSJshop.sol(2, "Hello World!") target is: jSJshop method is: sol(int,java.lang.String)
TestCase is: JSJshop jSJshop = new JSJshop();

statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: tree()Lumd/cs/shop/JSJshopNode; type is: class org.evosuite.testcase.statements.MethodStatement return type class umd.cs.shop.JSJshopNode
statement code is: JSJshopNode tree = jSJshop.tree()
test data is: JSJshop jSJshop = new JSJshop();
jSJshop.tree();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        int[] numbers = new int[]{ 1, 2, 3, 4, 5 };
        String[] strings = new String[]{ "apple", "banana", "cherry" };
        double[] doubles = new double[]{ 0.1, 0.2, 0.3 };
        char[] chars = new char[]{ 'a', 'b', 'c' };
    }
}
statement is: int[] numbers = new int[]{ 1, 2, 3, 4, 5 }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
statement is: String[] strings = new String[]{ "apple", "banana", "cherry" }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
statement is: double[] doubles = new double[]{ 0.1, 0.2, 0.3 }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
statement is: char[] chars = new char[]{ 'a', 'b', 'c' }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: prob()Lumd/cs/shop/JSPlanningProblem; type is: class org.evosuite.testcase.statements.MethodStatement return type class umd.cs.shop.JSPlanningProblem
statement code is: JSPlanningProblem prob = jSJshop.prob()
test data is: JSJshop jSJshop = new JSJshop();
jSJshop.prob();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JSJshop jSJshop = new JSJshop();
        jSJshop.prob("2019-06-30", "2019-07-01");
    }
}
statement is: JSJshop jSJshop = new JSJshop(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jSJshop.prob("2019-06-30", "2019-07-01"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jSJshop.prob("2019-06-30", "2019-07-01") target is: jSJshop method is: prob(java.lang.String,java.lang.String)
TestCase is: JSJshop jSJshop = new JSJshop();

statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: dom()Lumd/cs/shop/JSPlanningDomain; type is: class org.evosuite.testcase.statements.MethodStatement return type class umd.cs.shop.JSPlanningDomain
statement code is: JSPlanningDomain dom = jSJshop.dom()
test data is: JSJshop jSJshop = new JSJshop();
jSJshop.dom();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JSJshop jSJshop = new JSJshop();
        jSJshop.dom();
        // Improved test data
        int numberOfProducts = 5;
        double averageRating = 4.3;
        String productName = "Smartphone X32";
        String productDescription = "This is a smartphone with a large screen and powerful processor.";
    }
}
statement is: JSJshop jSJshop = new JSJshop(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jSJshop.dom(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jSJshop.dom() target is: jSJshop method is: dom()
source statement: umd.cs.shop.JSJshop()V callee: VariableReference: Statement 0, type umd.cs.shop.JSJshopindex is: 0
Matched Method is: dom()Lumd/cs/shop/JSPlanningDomain;
statement is: // Improved test data
int numberOfProducts = 5, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: double averageRating = 4.3, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String productName = "Smartphone X32", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String productDescription = "This is a smartphone with a large screen and powerful processor.", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
* this is vulnerable: int _int = 5
* this is vulnerable: double _double = 4.3
* this is vulnerable: String string = "Smartphone X32"
* this is vulnerable: String string = "This is a smartphone with a large screen and powerful processor."
TestCase is: JSJshop jSJshop = new JSJshop();
jSJshop.dom();
int _int = 5;
double _double = 4.3;
String string = "Smartphone X32";
String string = "This is a smartphone with a large screen and powerful processor.";

statement is: org.evosuite.testcase.statements.ArrayStatement@e52a3f50 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[1]
statement is: main([Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: JSJshop.main(arg0)
test data is: String[] stringArray = new String[1];
JSJshop.main(stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        String[] stringArray = new String[3];
        stringArray[0] = "input1";
        stringArray[1] = "input2";
        stringArray[2] = "input3";
        JSJshop.main(stringArray);
    }
}
statement is: String[] stringArray = new String[3], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [3] Ct is: String[] stringArray = new String[1] isAssignment: false Array: new String[3] Elements: []
lengths: [1] [3]
Their type are: class [Ljava.lang.String; String[]
statement is: stringArray[0] = "input1", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"input1" Ct is: stringArray[0] = "input1"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[1] = "input2", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[1] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"input2" Ct is: stringArray[1] = "input2"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[2] = "input3", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[2] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"input3" Ct is: stringArray[2] = "input3"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: JSJshop.main(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: JSJshop.main(stringArray) target is: JSJshop method is: main(java.lang.String[])
Matched Method is: main([Ljava/lang/String;)V
TestCase is: String[] stringArray = new String[1];
JSJshop.main(stringArray);

statement is: org.evosuite.testcase.statements.ArrayStatement@22e7dbdf type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[9]
statement is: main([Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: JSJshop.main(arg0)
test data is: String[] stringArray = new String[9];
JSJshop.main(stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        String[] stringArray = new String[]{ "-a", "--file", "../../data/input.txt" };
    }
}
statement is: String[] stringArray = new String[]{ "-a", "--file", "../../data/input.txt" }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [] Ct is: String[] stringArray = new String[9] isAssignment: false Array: new String[]{ "-a", "--file", "../../data/input.txt" } Elements: ["-a", "--file", "../../data/input.txt"]
lengths: [9] []
statement is: org.evosuite.testcase.statements.ArrayStatement@c50f9e68 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[2]
statement is: main([Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: JSJshop.main(arg0)
test data is: String[] stringArray = new String[2];
JSJshop.main(stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        String[] stringArray = new String[2];
        stringArray[0] = "Hello";
        stringArray[1] = "World!";
        JSJshop.main(stringArray);
    }
}
statement is: String[] stringArray = new String[2], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [2] Ct is: String[] stringArray = new String[2] isAssignment: false Array: new String[2] Elements: []
lengths: [2] [2]
Their type are: class [Ljava.lang.String; String[]
statement is: stringArray[0] = "Hello", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"Hello" Ct is: stringArray[0] = "Hello"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[1] = "World!", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[1] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"World!" Ct is: stringArray[1] = "World!"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: JSJshop.main(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: JSJshop.main(stringArray) target is: JSJshop method is: main(java.lang.String[])
Matched Method is: main([Ljava/lang/String;)V
TestCase is: String[] stringArray = new String[2];
JSJshop.main(stringArray);

statement is: org.evosuite.testcase.statements.ArrayStatement@47a539d0 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[4]
statement is: org.evosuite.testcase.statements.AssignmentStatement@26bd0adb type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[2] = "one"
statement is: main([Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: JSJshop.main(arg0)
test data is: String[] stringArray = new String[4];
stringArray[2] = "one";
JSJshop.main(stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        String[] stringArray = new String[4];
        stringArray[0] = "--help";
        stringArray[1] = "-v";
        stringArray[2] = "one";
        JSJshop.main(stringArray);
    }
}
statement is: String[] stringArray = new String[4], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [4] Ct is: String[] stringArray = new String[4] isAssignment: false Array: new String[4] Elements: []
lengths: [4] [4]
Their type are: class [Ljava.lang.String; String[]
statement is: stringArray[0] = "--help", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--help" Ct is: stringArray[0] = "--help"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[1] = "-v", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[1] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-v" Ct is: stringArray[1] = "-v"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[2] = "one", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[2] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"one" Ct is: stringArray[2] = "one"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: JSJshop.main(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: JSJshop.main(stringArray) target is: JSJshop method is: main(java.lang.String[])
Matched Method is: main([Ljava/lang/String;)V
TestCase is: String[] stringArray = new String[4];
String string = "--help";
stringArray[2] = string;
String string = "-v";
stringArray[2] = string;
String string = "one";
stringArray[2] = string;
JSJshop.main(stringArray);

statement is: org.evosuite.testcase.statements.ArrayStatement@53c32ba type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[4]
statement is: org.evosuite.testcase.statements.AssignmentStatement@ddf63f81 type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[2] = "all"
statement is: main([Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: JSJshop.main(arg0)
test data is: String[] stringArray = new String[4];
stringArray[2] = "all";
JSJshop.main(stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        String[] stringArray = new String[4];
        stringArray[0] = "-help";// this flag tells the program to print out a help message

        stringArray[1] = "--version";// this flag tells the program to print out its version number

        stringArray[2] = "all";// this flag specifies that all available commands should be printed

        stringArray[3] = "-b";// this flag tells the program to display only commands related to building

        JSJshop.main(stringArray);
    }
}
statement is: String[] stringArray = new String[4], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [4] Ct is: String[] stringArray = new String[4] isAssignment: false Array: new String[4] Elements: []
lengths: [4] [4]
Their type are: class [Ljava.lang.String; String[]
statement is: stringArray[0] = "-help"// this flag tells the program to print out a help message
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-help" Ct is: stringArray[0] = "-help"// this flag tells the program to print out a help message

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[1] = "--version"// this flag tells the program to print out its version number
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[1] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--version" Ct is: stringArray[1] = "--version"// this flag tells the program to print out its version number

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[2] = "all"// this flag specifies that all available commands should be printed
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[2] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"all" Ct is: stringArray[2] = "all"// this flag specifies that all available commands should be printed

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[3] = "-b"// this flag tells the program to display only commands related to building
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[3] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-b" Ct is: stringArray[3] = "-b"// this flag tells the program to display only commands related to building

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: JSJshop.main(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: JSJshop.main(stringArray) target is: JSJshop method is: main(java.lang.String[])
Matched Method is: main([Ljava/lang/String;)V
TestCase is: String[] stringArray = new String[4];
String string = "-help";
stringArray[2] = string;
String string = "--version";
stringArray[2] = string;
String string = "all";
stringArray[2] = string;
String string = "-b";
stringArray[2] = string;
JSJshop.main(stringArray);

statement is: umd.cs.shop.JSJshop(Ljava/lang/String;Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop("}e;o7a,NasxvF[LKpN", "}e;o7a,NasxvF[LKpN")
test data is: JSJshop jSJshop = new JSJshop("}e;o7a,NasxvF[LKpN", "}e;o7a,NasxvF[LKpN");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JSJshop jSJshop = new JSJshop("John Doe", "johndoe@email.com");
    }
}
statement is: JSJshop jSJshop = new JSJshop("John Doe", "johndoe@email.com"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
TestCase is: String string = "John Doe";
String string = "johndoe@email.com";
JSJshop jSJshop = new JSJshop(string, string);

statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: getAddList()Lumd/cs/shop/JSListLogicalAtoms; type is: class org.evosuite.testcase.statements.MethodStatement return type class umd.cs.shop.JSListLogicalAtoms
statement code is: JSListLogicalAtoms addList = jSJshop.getAddList()
test data is: JSJshop jSJshop = new JSJshop();
jSJshop.getAddList();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        int expectedSize = 10;
        String expectedMessage = "Added to cart successfully";
    }
}
statement is: int expectedSize = 10, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String expectedMessage = "Added to cart successfully", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
* this is vulnerable: int _int = 10
* this is vulnerable: String string = "Added to cart successfully"
TestCase is: int _int = 10;
String string = "Added to cart successfully";

statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: getDeleteList()Lumd/cs/shop/JSListLogicalAtoms; type is: class org.evosuite.testcase.statements.MethodStatement return type class umd.cs.shop.JSListLogicalAtoms
statement code is: JSListLogicalAtoms deleteList = jSJshop.getDeleteList()
test data is: JSJshop jSJshop = new JSJshop();
jSJshop.getDeleteList();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JSJshop jSJshop = new JSJshop();
        jSJshop.getDeleteList();
        // Improved test data
        int id = 123;// This is a sample ID for an item that needs to be deleted.

        String name = "John Smith";// This is a sample name for the item that needs to be deleted.

        // String description = "This is a sample string.";
        String email = "john.smith@example.com";
        boolean deleteSuccessful = jSJshop.deleteList(id, name);
        // assertTrue(deleteSuccessful); }}
    }
}
statement is: JSJshop jSJshop = new JSJshop(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jSJshop.getDeleteList(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jSJshop.getDeleteList() target is: jSJshop method is: getDeleteList()
source statement: umd.cs.shop.JSJshop()V callee: VariableReference: Statement 0, type umd.cs.shop.JSJshopindex is: 0
Matched Method is: getDeleteList()Lumd/cs/shop/JSListLogicalAtoms;
statement is: // Improved test data
int id = 123// This is a sample ID for an item that needs to be deleted.
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String name = "John Smith"// This is a sample name for the item that needs to be deleted.
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: // String description = "This is a sample string.";
String email = "john.smith@example.com", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: boolean deleteSuccessful = jSJshop.deleteList(id, name), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtInvocationImpl
invocation is: jSJshop.deleteList(id, name) target is: jSJshop method is: deleteList(int,java.lang.String)
statement is: // assertTrue(deleteSuccessful); }}, class spoon.support.reflect.code.CtCommentImpl
* this is vulnerable: int _int = 123
* this is vulnerable: String string = "John Smith"
* this is vulnerable: String string = "john.smith@example.com"
TestCase is: JSJshop jSJshop = new JSJshop();
jSJshop.getDeleteList();
int _int = 123;
String string = "John Smith";
String string = "john.smith@example.com";

statement is: EvoSuiteFile evoSuiteFile = new EvoSuiteFile("farp.shp") type is: class org.evosuite.testcase.statements.environment.FileNamePrimitiveStatement return type class org.evosuite.runtime.testdata.EvoSuiteFile
statement code is: EvoSuiteFile evoSuiteFile = new EvoSuiteFile("farp.shp")
statement is: org.evosuite.testcase.statements.ArrayStatement@285d894e type is: class org.evosuite.testcase.statements.ArrayStatement return type class [B
statement code is: byte[] byteArray = new byte[5]
statement is: org.evosuite.testcase.statements.AssignmentStatement@c4cbf475 type is: class org.evosuite.testcase.statements.AssignmentStatement return type byte
statement code is: byteArray[0] = (byte) (-94)
statement is: appendDataToFile(Lorg/evosuite/runtime/testdata/EvoSuiteFile;[B)Z type is: class org.evosuite.testcase.statements.MethodStatement return type boolean
statement code is: boolean appendDataToFile = FileSystemHandling.appendDataToFile(arg0, arg1)
statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: testParser()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: jSJshop.testParser()
test data is: EvoSuiteFile evoSuiteFile = new EvoSuiteFile("farp.shp");
byte[] byteArray = new byte[5];
byteArray[0] = (byte) (-94);
FileSystemHandling.appendDataToFile(evoSuiteFile, byteArray);
JSJshop jSJshop = new JSJshop();
jSJshop.testParser();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        EvoSuiteFile evoSuiteFile = new EvoSuiteFile("farp.shp");
        byte[] byteArray = new byte[]{ ((byte) (-94)), ((byte) (123)), ((byte) (65)), ((byte) (48)), ((byte) (77)) };
        FileSystemHandling.appendDataToFile(evoSuiteFile, byteArray);
        JSJshop jSJshop = new JSJshop();
        jSJshop.testParser();
    }
}
statement is: EvoSuiteFile evoSuiteFile = new EvoSuiteFile("farp.shp"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: byte[] byteArray = new byte[]{ ((byte) (-94)), ((byte) (123)), ((byte) (65)), ((byte) (48)), ((byte) (77)) }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [] Ct is: byte[] byteArray = new byte[5] isAssignment: false Array: new byte[]{ ((byte) (-94)), ((byte) (123)), ((byte) (65)), ((byte) (48)), ((byte) (77)) } Elements: [((byte) (-94)), ((byte) (123)), ((byte) (65)), ((byte) (48)), ((byte) (77))]
lengths: [5] []
statement is: FileSystemHandling.appendDataToFile(evoSuiteFile, byteArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: FileSystemHandling.appendDataToFile(evoSuiteFile, byteArray) target is: FileSystemHandling method is: appendDataToFile(EvoSuiteFile,byte[])
Matched Method is: appendDataToFile(Lorg/evosuite/runtime/testdata/EvoSuiteFile;[B)Z
i 0 Parameters size() 0 Num of Method Parameters: 2
i 1 Parameters size() 0 Num of Method Parameters: 2
statement is: JSJshop jSJshop = new JSJshop(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jSJshop.testParser(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jSJshop.testParser() target is: jSJshop method is: testParser()
source statement: umd.cs.shop.JSJshop()V callee: VariableReference: Statement 4, type umd.cs.shop.JSJshopindex is: 3
Matched Method is: testParser()V
TestCase Could not be added: testParser()V
TestCase is: EvoSuiteFile evoSuiteFile = null;
byte[] byteArray = null;
FileSystemHandling.appendDataToFile(evoSuiteFile, byteArray);
JSJshop jSJshop = new JSJshop();

statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: EvoSuiteFile evoSuiteFile = new EvoSuiteFile("xo") type is: class org.evosuite.testcase.statements.environment.FileNamePrimitiveStatement return type class org.evosuite.runtime.testdata.EvoSuiteFile
statement code is: EvoSuiteFile evoSuiteFile = new EvoSuiteFile("xo")
statement is: appendLineToFile(Lorg/evosuite/runtime/testdata/EvoSuiteFile;Ljava/lang/String;)Z type is: class org.evosuite.testcase.statements.MethodStatement return type boolean
statement code is: boolean appendLineToFile = FileSystemHandling.appendLineToFile(arg0, "+Y?=l%vjbR]8}~")
statement is: parserFile(Ljava/lang/String;)Z type is: class org.evosuite.testcase.statements.MethodStatement return type boolean
statement code is: boolean parserFile = jSJshop.parserFile("xo")
test data is: JSJshop jSJshop = new JSJshop();
EvoSuiteFile evoSuiteFile = new EvoSuiteFile("xo");
FileSystemHandling.appendLineToFile(evoSuiteFile, "+Y?=l%vjbR]8}~");
jSJshop.parserFile("xo");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JSJshop jSJshop = new JSJshop();
        EvoSuiteFile evoSuiteFile = new EvoSuiteFile("xo");
        FileSystemHandling.appendLineToFile(evoSuiteFile, "1234567890");// Improved test data: changed the primitive value to a more descriptive example

        jSJshop.parserFile("xo");
    }
}
statement is: JSJshop jSJshop = new JSJshop(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: EvoSuiteFile evoSuiteFile = new EvoSuiteFile("xo"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: FileSystemHandling.appendLineToFile(evoSuiteFile, "1234567890")// Improved test data: changed the primitive value to a more descriptive example
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: FileSystemHandling.appendLineToFile(evoSuiteFile, "1234567890")// Improved test data: changed the primitive value to a more descriptive example
 target is: FileSystemHandling method is: appendLineToFile(EvoSuiteFile,java.lang.String)
Matched Method is: appendLineToFile(Lorg/evosuite/runtime/testdata/EvoSuiteFile;Ljava/lang/String;)Z
i 1 Parameters size() 1 Num of Method Parameters: 2
statement is: jSJshop.parserFile("xo"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jSJshop.parserFile("xo") target is: jSJshop method is: parserFile(java.lang.String)
source statement: umd.cs.shop.JSJshop()V callee: VariableReference: Statement 0, type umd.cs.shop.JSJshopindex is: 0
Matched Method is: parserFile(Ljava/lang/String;)Z
TestCase is: JSJshop jSJshop = new JSJshop();
String string = "1234567890";
String string = null;
FileSystemHandling.appendLineToFile((EvoSuiteFile) string, string);
String string = "xo";
jSJshop.parserFile(string);

statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: getBufferedReader(Ljava/lang/String;Ljava/lang/String;Ljavax/swing/JApplet;)Ljava/io/BufferedReader; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.io.BufferedReader
statement code is: BufferedReader bufferedReader = jSJshop.getBufferedReader("", "", (JApplet) null)
test data is: JSJshop jSJshop = new JSJshop();
jSJshop.getBufferedReader("", "", (JApplet) null);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        int myInt = 5;
        String myString = "Hello World";
        char myChar = 'A';
        double myDouble = 3.14;
    }
}
statement is: int myInt = 5, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String myString = "Hello World", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: char myChar = 'A', class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: double myDouble = 3.14, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
* this is vulnerable: int _int = 5
* this is vulnerable: String string = "Hello World"
* this is vulnerable: char _char = 'A'
* this is vulnerable: double _double = 3.14
TestCase is: int _int = 5;
String string = "Hello World";
char _char = 'A';
double _double = 3.14;

statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: getBufferedReader(Ljava/lang/String;Ljava/lang/String;Ljavax/swing/JApplet;)Ljava/io/BufferedReader; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.io.BufferedReader
statement code is: BufferedReader bufferedReader = jSJshop.getBufferedReader((String) null, (String) null, (JApplet) null)
test data is: JSJshop jSJshop = new JSJshop();
jSJshop.getBufferedReader((String) null, (String) null, (JApplet) null);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JSJshop jSJshop = new JSJshop();
        jSJshop.getBufferedReader("file.txt", "UTF-8", ((JApplet) (null)));
    }
}
statement is: JSJshop jSJshop = new JSJshop(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jSJshop.getBufferedReader("file.txt", "UTF-8", ((JApplet) (null))), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jSJshop.getBufferedReader("file.txt", "UTF-8", ((JApplet) (null))) target is: jSJshop method is: getBufferedReader(java.lang.String,java.lang.String,JApplet)
source statement: umd.cs.shop.JSJshop()V callee: VariableReference: Statement 0, type umd.cs.shop.JSJshopindex is: 0
Matched Method is: getBufferedReader(Ljava/lang/String;Ljava/lang/String;Ljavax/swing/JApplet;)Ljava/io/BufferedReader;
i 2 Parameters size() 2 Num of Method Parameters: 3
TestCase is: JSJshop jSJshop = new JSJshop();
String string = "file.txt";
String string = "UTF-8";
JApplet jApplet = null;
jSJshop.getBufferedReader(string, string, jApplet);

statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: java.io.StringReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.io.StringReader
statement code is: StringReader stringReader = new StringReader("Expecting ')' for Domain definition")
statement is: java.io.StreamTokenizer(Ljava/io/Reader;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.io.StreamTokenizer
statement code is: StreamTokenizer streamTokenizer = new StreamTokenizer(arg0)
statement is: processToken(Ljava/io/StreamTokenizer;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: jSJshop.processToken(arg0)
test data is: JSJshop jSJshop = new JSJshop();
StringReader stringReader = new StringReader("Expecting ')' for Domain definition");
StreamTokenizer streamTokenizer = new StreamTokenizer(stringReader);
jSJshop.processToken(streamTokenizer);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JSJshop jSJshop = new JSJshop();
        StringReader stringReader = new StringReader("Expecting ')' for Domain definition");
        StreamTokenizer streamTokenizer = new StreamTokenizer(stringReader);
        jSJshop.processToken(streamTokenizer);
    }
}
statement is: JSJshop jSJshop = new JSJshop(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: StringReader stringReader = new StringReader("Expecting ')' for Domain definition"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: StreamTokenizer streamTokenizer = new StreamTokenizer(stringReader), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jSJshop.processToken(streamTokenizer), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jSJshop.processToken(streamTokenizer) target is: jSJshop method is: processToken(StreamTokenizer)
source statement: umd.cs.shop.JSJshop()V callee: VariableReference: Statement 0, type umd.cs.shop.JSJshopindex is: 0
Matched Method is: processToken(Ljava/io/StreamTokenizer;)V
TestCase is: JSJshop jSJshop = new JSJshop();
String string = "Expecting ')' for Domain definition";
StringReader stringReader = new StringReader(string);
StreamTokenizer streamTokenizer = new StreamTokenizer(stringReader);
jSJshop.processToken(streamTokenizer);

statement is: umd.cs.shop.JSJshop()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class umd.cs.shop.JSJshop
statement code is: JSJshop jSJshop = new JSJshop()
statement is: testParser()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: jSJshop.testParser()
test data is: JSJshop jSJshop = new JSJshop();
jSJshop.testParser();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Parse a JSON string and print the result
        String jsonString = "{\"name\":\"Charlie\", \"age\":40, \"city\":\"Seattle\"}";
        JSONObject jsonObject = new JSONObject(jsonString);
        System.out.println("Name: " + jsonObject.getString("name"));
        System.out.println("Age: " + jsonObject.getInt("age"));
        System.out.println("City: " + jsonObject.getString("city"));
    }
}
statement is: // Parse a JSON string and print the result
String jsonString = "{\"name\":\"Charlie\", \"age\":40, \"city\":\"Seattle\"}", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: JSONObject jsonObject = new JSONObject(jsonString), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: System.out.println("Name: " + jsonObject.getString("name")), class spoon.support.reflect.code.CtInvocationImpl
invocation is: System.out.println("Name: " + jsonObject.getString("name")) target is: System.out method is: println(char[])
statement is: System.out.println("Age: " + jsonObject.getInt("age")), class spoon.support.reflect.code.CtInvocationImpl
invocation is: System.out.println("Age: " + jsonObject.getInt("age")) target is: System.out method is: println(char[])
statement is: System.out.println("City: " + jsonObject.getString("city")), class spoon.support.reflect.code.CtInvocationImpl
invocation is: System.out.println("City: " + jsonObject.getString("city")) target is: System.out method is: println(char[])
* this is vulnerable: String string = "{\"name\":\"Charlie\", \"age\":40, \"city\":\"Seattle\"}"
TestCase is: String string = "{\"name\":\"Charlie\", \"age\":40, \"city\":\"Seattle\"}";

* test suite isTestSuite: 42
Test 0: 
JSJshop jSJshop = new JSJshop();
jSJshop.getTree();
Test 1: 
JSJshop jSJshop = new JSJshop();
// Undeclared exception!
try { 
  jSJshop.getAppletURL("`t1 2XOu? nr)F", (JApplet) null);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("umd.cs.shop.JSJshop", e);
}

Test 2: 
JSTaskAtom jSTaskAtom = new JSTaskAtom();
JSJshop jSJshop = null;
try {
  jSJshop = new JSJshop(" ListLogicalAtoms: unexpected Atom", jSTaskAtom);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("umd.cs.shop.JSJshop", e);
}

Test 3: 
JSJshop jSJshop = new JSJshop();
jSJshop.getSolution();
Test 4: 
JSJshop jSJshop = new JSJshop();
jSJshop.sol();
Test 5: 
JSJshop jSJshop = new JSJshop();
jSJshop.tree();
Test 6: 
JSJshop jSJshop = new JSJshop();
jSJshop.prob();
Test 7: 
JSJshop jSJshop = new JSJshop();
jSJshop.dom();
Test 8: 
String[] stringArray = new String[1];
JSJshop.main(stringArray);
Test 9: 
String[] stringArray = new String[9];
JSJshop.main(stringArray);
Test 10: 
String[] stringArray = new String[2];
// Undeclared exception!
try { 
  JSJshop.main(stringArray);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.evosuite.runtime.mock.java.io.MockFileInputStream", e);
}

Test 11: 
String[] stringArray = new String[4];
stringArray[2] = "one";
JSJshop.main(stringArray);
Test 12: 
String[] stringArray = new String[4];
stringArray[2] = "all";
JSJshop.main(stringArray);
Test 13: 
JSJshop jSJshop = null;
try {
  jSJshop = new JSJshop("}e;o7a,NasxvF[LKpN", "}e;o7a,NasxvF[LKpN");
  fail("Expecting exception: System.SystemExitException");

} catch(System.SystemExitException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.evosuite.runtime.System", e);
}

Test 14: 
JSJshop jSJshop = new JSJshop();
jSJshop.getAddList();
Test 15: 
JSJshop jSJshop = new JSJshop();
jSJshop.getDeleteList();
Test 16: 
EvoSuiteFile evoSuiteFile = new EvoSuiteFile("farp.shp");
byte[] byteArray = new byte[5];
byteArray[0] = (byte) (-94);
FileSystemHandling.appendDataToFile(evoSuiteFile, byteArray);
JSJshop jSJshop = new JSJshop();
jSJshop.testParser();
Test 17: 
JSJshop jSJshop = new JSJshop();
EvoSuiteFile evoSuiteFile = new EvoSuiteFile("xo");
FileSystemHandling.appendLineToFile(evoSuiteFile, "+Y?=l%vjbR]8}~");
jSJshop.parserFile("xo");
Test 18: 
JSJshop jSJshop = new JSJshop();
jSJshop.getBufferedReader("", "", (JApplet) null);
Test 19: 
JSJshop jSJshop = new JSJshop();
jSJshop.getBufferedReader((String) null, (String) null, (JApplet) null);
Test 20: 
JSJshop jSJshop = new JSJshop();
StringReader stringReader = new StringReader("Expecting ')' for Domain definition");
StreamTokenizer streamTokenizer = new StreamTokenizer(stringReader);
// Undeclared exception!
try { 
  jSJshop.processToken(streamTokenizer);
  fail("Expecting exception: Error");

} catch(Error e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("umd.cs.shop.JSJshop", e);
}

Test 21: 
JSJshop jSJshop = new JSJshop();
// Undeclared exception!
try { 
  jSJshop.testParser();
  fail("Expecting exception: System.SystemExitException");

} catch(System.SystemExitException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.evosuite.runtime.System", e);
}

Test 22: 
JSJshop jSJshop = new JSJshop();
((JSJshop)1).getTree();

Test 23: 
JSJshop jSJshop = new JSJshop();
jSJshop.getAppletURL("https://www.example.com", (JApplet) null);

Test 24: 
JSTaskAtom jSTaskAtom = new JSTaskAtom();
JSJshop jSJshop = new JSJshop("ListLogicalAtoms: expected Atom", jSTaskAtom);

Test 25: 
JSJshop jSJshop = new JSJshop();

Test 26: 
JSJshop jSJshop = new JSJshop();

Test 27: 
JSJshop jSJshop = new JSJshop();

Test 28: 
JSJshop jSJshop = new JSJshop();
jSJshop.dom();

Test 29: 
String[] stringArray = new String[1];
JSJshop.main(stringArray);

Test 30: 
String[] stringArray = new String[2];
JSJshop.main(stringArray);

Test 31: 
String[] stringArray = new String[4];
stringArray[2] = "--help";
stringArray[2] = "-v";
stringArray[2] = "one";
JSJshop.main(stringArray);

Test 32: 
String[] stringArray = new String[4];
stringArray[2] = "-help";
stringArray[2] = "--version";
stringArray[2] = "all";
stringArray[2] = "-b";
JSJshop.main(stringArray);

Test 33: 
JSJshop jSJshop = new JSJshop("John Doe", "johndoe@email.com");

Test 34: 

Test 35: 
JSJshop jSJshop = new JSJshop();
jSJshop.getDeleteList();

Test 36: 
FileSystemHandling.appendDataToFile((EvoSuiteFile) null, (byte[]) null);
JSJshop jSJshop = new JSJshop();

Test 37: 
JSJshop jSJshop = new JSJshop();
FileSystemHandling.appendLineToFile((EvoSuiteFile) "1234567890", (String) null);
String string = "xo";
jSJshop.parserFile(string);

Test 38: 

Test 39: 
JSJshop jSJshop = new JSJshop();
jSJshop.getBufferedReader("file.txt", "UTF-8", (JApplet) null);

Test 40: 
JSJshop jSJshop = new JSJshop();
StringReader stringReader = new StringReader("Expecting ')' for Domain definition");
StreamTokenizer streamTokenizer = new StreamTokenizer(stringReader);
jSJshop.processToken(streamTokenizer);

Test 41: 


* Generated after the refinement and before minimization 42 tests with total length 94
* test suite isTestSuite: 42
Test 0: 
JSJshop jSJshop = new JSJshop();
jSJshop.getTree();
Test 1: 
JSJshop jSJshop = new JSJshop();
// Undeclared exception!
try { 
  jSJshop.getAppletURL("`t1 2XOu? nr)F", (JApplet) null);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("umd.cs.shop.JSJshop", e);
}

Test 2: 
JSTaskAtom jSTaskAtom = new JSTaskAtom();
JSJshop jSJshop = null;
try {
  jSJshop = new JSJshop(" ListLogicalAtoms: unexpected Atom", jSTaskAtom);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("umd.cs.shop.JSJshop", e);
}

Test 3: 
JSJshop jSJshop = new JSJshop();
jSJshop.getSolution();
Test 4: 
JSJshop jSJshop = new JSJshop();
jSJshop.sol();
Test 5: 
JSJshop jSJshop = new JSJshop();
jSJshop.tree();
Test 6: 
JSJshop jSJshop = new JSJshop();
jSJshop.prob();
Test 7: 
JSJshop jSJshop = new JSJshop();
jSJshop.dom();
Test 8: 
String[] stringArray = new String[1];
JSJshop.main(stringArray);
Test 9: 
String[] stringArray = new String[9];
JSJshop.main(stringArray);
Test 10: 
String[] stringArray = new String[2];
// Undeclared exception!
try { 
  JSJshop.main(stringArray);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.evosuite.runtime.mock.java.io.MockFileInputStream", e);
}

Test 11: 
String[] stringArray = new String[4];
stringArray[2] = "one";
JSJshop.main(stringArray);
Test 12: 
String[] stringArray = new String[4];
stringArray[2] = "all";
JSJshop.main(stringArray);
Test 13: 
JSJshop jSJshop = null;
try {
  jSJshop = new JSJshop("}e;o7a,NasxvF[LKpN", "}e;o7a,NasxvF[LKpN");
  fail("Expecting exception: System.SystemExitException");

} catch(System.SystemExitException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.evosuite.runtime.System", e);
}

Test 14: 
JSJshop jSJshop = new JSJshop();
jSJshop.getAddList();
Test 15: 
JSJshop jSJshop = new JSJshop();
jSJshop.getDeleteList();
Test 16: 
EvoSuiteFile evoSuiteFile = new EvoSuiteFile("farp.shp");
byte[] byteArray = new byte[5];
byteArray[0] = (byte) (-94);
FileSystemHandling.appendDataToFile(evoSuiteFile, byteArray);
JSJshop jSJshop = new JSJshop();
jSJshop.testParser();
Test 17: 
JSJshop jSJshop = new JSJshop();
EvoSuiteFile evoSuiteFile = new EvoSuiteFile("xo");
FileSystemHandling.appendLineToFile(evoSuiteFile, "+Y?=l%vjbR]8}~");
jSJshop.parserFile("xo");
Test 18: 
JSJshop jSJshop = new JSJshop();
jSJshop.getBufferedReader("", "", (JApplet) null);
Test 19: 
JSJshop jSJshop = new JSJshop();
jSJshop.getBufferedReader((String) null, (String) null, (JApplet) null);
Test 20: 
JSJshop jSJshop = new JSJshop();
StringReader stringReader = new StringReader("Expecting ')' for Domain definition");
StreamTokenizer streamTokenizer = new StreamTokenizer(stringReader);
// Undeclared exception!
try { 
  jSJshop.processToken(streamTokenizer);
  fail("Expecting exception: Error");

} catch(Error e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("umd.cs.shop.JSJshop", e);
}

Test 21: 
JSJshop jSJshop = new JSJshop();
// Undeclared exception!
try { 
  jSJshop.testParser();
  fail("Expecting exception: System.SystemExitException");

} catch(System.SystemExitException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.evosuite.runtime.System", e);
}

Test 22: 
JSJshop jSJshop = new JSJshop();
((JSJshop)1).getTree();

Test 23: 
JSJshop jSJshop = new JSJshop();
jSJshop.getAppletURL("https://www.example.com", (JApplet) null);

Test 24: 
JSTaskAtom jSTaskAtom = new JSTaskAtom();
JSJshop jSJshop = new JSJshop("ListLogicalAtoms: expected Atom", jSTaskAtom);

Test 25: 
JSJshop jSJshop = new JSJshop();

Test 26: 
JSJshop jSJshop = new JSJshop();

Test 27: 
JSJshop jSJshop = new JSJshop();

Test 28: 
JSJshop jSJshop = new JSJshop();
jSJshop.dom();

Test 29: 
String[] stringArray = new String[1];
JSJshop.main(stringArray);

Test 30: 
String[] stringArray = new String[2];
JSJshop.main(stringArray);

Test 31: 
String[] stringArray = new String[4];
stringArray[2] = "--help";
stringArray[2] = "-v";
stringArray[2] = "one";
JSJshop.main(stringArray);

Test 32: 
String[] stringArray = new String[4];
stringArray[2] = "-help";
stringArray[2] = "--version";
stringArray[2] = "all";
stringArray[2] = "-b";
JSJshop.main(stringArray);

Test 33: 
JSJshop jSJshop = new JSJshop("John Doe", "johndoe@email.com");

Test 34: 

Test 35: 
JSJshop jSJshop = new JSJshop();
jSJshop.getDeleteList();

Test 36: 
FileSystemHandling.appendDataToFile((EvoSuiteFile) null, (byte[]) null);
JSJshop jSJshop = new JSJshop();

Test 37: 
JSJshop jSJshop = new JSJshop();
FileSystemHandling.appendLineToFile((EvoSuiteFile) "1234567890", (String) null);
String string = "xo";
jSJshop.parserFile(string);

Test 38: 

Test 39: 
JSJshop jSJshop = new JSJshop();
jSJshop.getBufferedReader("file.txt", "UTF-8", (JApplet) null);

Test 40: 
JSJshop jSJshop = new JSJshop();
StringReader stringReader = new StringReader("Expecting ')' for Domain definition");
StreamTokenizer streamTokenizer = new StreamTokenizer(stringReader);
jSJshop.processToken(streamTokenizer);

Test 41: 


* Minimizing test suite
* test suite isTestSuite: 22
Test 0: 
JSJshop jSJshop = new JSJshop();
jSJshop.getTree();
Test 1: 
JSJshop jSJshop = new JSJshop();
// Undeclared exception!
try { 
  jSJshop.getAppletURL("https://www.example.com", (JApplet) null);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("umd.cs.shop.JSJshop", e);
}

Test 2: 
JSTaskAtom jSTaskAtom = new JSTaskAtom();
JSJshop jSJshop = null;
try {
  jSJshop = new JSJshop("ListLogicalAtoms: expected Atom", jSTaskAtom);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("umd.cs.shop.JSJshop", e);
}

Test 3: 
JSJshop jSJshop = new JSJshop();
jSJshop.getSolution();
Test 4: 
JSJshop jSJshop = new JSJshop();
jSJshop.sol();
Test 5: 
JSJshop jSJshop = new JSJshop();
jSJshop.tree();
Test 6: 
JSJshop jSJshop = new JSJshop();
jSJshop.prob();
Test 7: 
JSJshop jSJshop = new JSJshop();
jSJshop.dom();
Test 8: 
String[] stringArray = new String[1];
JSJshop.main(stringArray);
Test 9: 
String[] stringArray = new String[2];
// Undeclared exception!
try { 
  JSJshop.main(stringArray);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.evosuite.runtime.mock.java.io.MockFileInputStream", e);
}

Test 10: 
String[] stringArray = new String[9];
JSJshop.main(stringArray);
Test 11: 
String[] stringArray = new String[4];
stringArray[2] = "one";
JSJshop.main(stringArray);
Test 12: 
String[] stringArray = new String[4];
stringArray[2] = "all";
JSJshop.main(stringArray);
Test 13: 
JSJshop jSJshop = null;
try {
  jSJshop = new JSJshop("John Doe", "johndoe@email.com");
  fail("Expecting exception: System.SystemExitException");

} catch(System.SystemExitException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.evosuite.runtime.System", e);
}

Test 14: 
JSJshop jSJshop = new JSJshop();
jSJshop.getAddList();
Test 15: 
JSJshop jSJshop = new JSJshop();
jSJshop.getDeleteList();
Test 16: 
EvoSuiteFile evoSuiteFile = new EvoSuiteFile("farp.shp");
byte[] byteArray = new byte[5];
byteArray[0] = (byte) (-94);
FileSystemHandling.appendDataToFile(evoSuiteFile, byteArray);
JSJshop jSJshop = new JSJshop();
jSJshop.testParser();
Test 17: 
JSJshop jSJshop = new JSJshop();
EvoSuiteFile evoSuiteFile = new EvoSuiteFile("xo");
FileSystemHandling.appendLineToFile(evoSuiteFile, "+Y?=l%vjbR]8}~");
jSJshop.parserFile("xo");
Test 18: 
JSJshop jSJshop = new JSJshop();
jSJshop.getBufferedReader("file.txt", "UTF-8", (JApplet) null);
Test 19: 
JSJshop jSJshop = new JSJshop();
jSJshop.getBufferedReader((String) null, (String) null, (JApplet) null);
Test 20: 
JSJshop jSJshop = new JSJshop();
StringReader stringReader = new StringReader("Expecting ')' for Domain definition");
StreamTokenizer streamTokenizer = new StreamTokenizer(stringReader);
// Undeclared exception!
try { 
  jSJshop.processToken(streamTokenizer);
  fail("Expecting exception: Error");

} catch(Error e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("umd.cs.shop.JSJshop", e);
}

Test 21: 
JSJshop jSJshop = new JSJshop();
// Undeclared exception!
try { 
  jSJshop.testParser();
  fail("Expecting exception: System.SystemExitException");

} catch(System.SystemExitException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.evosuite.runtime.System", e);
}


* Going to analyze the coverage criteria
* Coverage analysis for criterion BRANCH
* Coverage of criterion BRANCH: 46%
* Total number of goals: 114
* Number of covered goals: 52
* Coverage analysis for criterion LINE
* Coverage of criterion LINE: 46%
* Total number of goals: 225
* Number of covered goals: 104
* Coverage analysis for criterion OUTPUT
* Coverage of criterion OUTPUT: 18%
* Total number of goals: 56
* Number of covered goals: 10
* Coverage analysis for criterion METHOD
* Coverage of criterion METHOD: 89%
* Total number of goals: 19
* Number of covered goals: 17
* Coverage analysis for criterion CBRANCH
* Coverage of criterion CBRANCH: 46%
* Total number of goals: 114
* Number of covered goals: 52
* Generated 22 tests with total length 53
* Resulting test suite's coverage: 49% (average coverage for all fitness functions)
* Generating assertions
* Resulting test suite's mutation score: 10%
* Compiling and checking tests
Going to execute: removeTestsThatDoNotCompile
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JSJshop jSJshop = new JSJshop();
JSJshopNode tree = jSJshop.getTree();
assertNull(tree);


** It was a parseable test case! 
refined test name is: testGetTree
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JSJshop jSJshop = new JSJshop();
// Undeclared exception!
try { 
  jSJshop.getAppletURL("https://www.example.com", (JApplet) null);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("umd.cs.shop.JSJshop", e);
}


** It was a parseable test case! 
refined test name is: testGetAppletURLEmptyJAppletThrowsNPE
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JSTaskAtom arg1 = new JSTaskAtom();
JSJshop jSJshop = null;
try {
  jSJshop = new JSJshop("ListLogicalAtoms: expected Atom", arg1);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("umd.cs.shop.JSJshop", e);
}


** It was a parseable test case! 
refined test name is: testCreateJSJshopWithNullArgument
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JSJshop jSJshop = new JSJshop();
JSPairPlanTSListNodes solution = jSJshop.getSolution();
assertNull(solution);


** It was a parseable test case! 
refined test name is: testGetSolutionReturnsNull
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JSJshop jSJshop = new JSJshop();
JSPlan sol = jSJshop.sol();
assertNull(sol);


** It was a parseable test case! 
refined test name is: testSolReturnsCorrectSolution
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JSJshop jSJshop = new JSJshop();
JSJshopNode tree = jSJshop.tree();
assertNull(tree);


** It was a parseable test case! 
refined test name is: testTreeMethodReturnsNull
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JSJshop jSJshop = new JSJshop();
JSPlanningProblem prob = jSJshop.prob();
assertNull(prob);


** It was a parseable test case! 
refined test name is: testProbMethodReturnsNull
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JSJshop jSJshop = new JSJshop();
JSPlanningDomain dom = jSJshop.dom();
assertNull(dom);


** It was a parseable test case! 
refined test name is: testJSPlanningDomainIsInitiallyNull
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: String[] arg0 = new String[1];
JSJshop.main(arg0);
assertEquals(1, arg0.length);


** It was a parseable test case! 
refined test name is: testEmptyArrayInput
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: String[] arg0 = new String[2];
// Undeclared exception!
try { 
  JSJshop.main(arg0);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.evosuite.runtime.mock.java.io.MockFileInputStream", e);
}


** It was a parseable test case! 
refined test name is: testNullPointerExceptionOnReadLine
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: String[] arg0 = new String[9];
JSJshop.main(arg0);
assertEquals(9, arg0.length);


** It was a parseable test case! 
refined test name is: testArgsLengthIsCorrect
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: String[] arg0 = new String[4];
arg0[2] = "one";
JSJshop.main(arg0);
assertEquals(4, arg0.length);


** It was a parseable test case! 
refined test name is: testMainMethodWithInputArguments
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: String[] arg0 = new String[4];
arg0[2] = "all";
JSJshop.main(arg0);
assertEquals(4, arg0.length);


** It was a parseable test case! 
refined test name is: testMainMethodWithArgumentAll
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JSJshop jSJshop = null;
try {
  jSJshop = new JSJshop("John Doe", "johndoe@email.com");
  fail("Expecting exception: System.SystemExitException");

} catch(System.SystemExitException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.evosuite.runtime.System", e);
}


