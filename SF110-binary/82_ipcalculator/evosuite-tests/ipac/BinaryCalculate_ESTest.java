/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Thu Mar 14 12:58:01 GMT 2024
 */

package ipac;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import ipac.BinaryCalculate;
import java.awt.HeadlessException;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class BinaryCalculate_ESTest extends BinaryCalculate_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSubBinaryReturningNonEmptyString() throws Throwable  {
      // Set up the binary calculator with two strings as input
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      String binary1 = "1100101";
      String binary2 = "1100101";
      
      // Call the subtractBinary method and save the result in a variable
      String subBinary = binaryCalculate.subBinary(binary1, binary2);
      
      // Assert that the result is equal to the expected value
      assertEquals("0000000", subBinary);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddBinaryReturningEmptyString() throws Throwable  {
      // Given two binary strings, "c1j54$M2)Am$[8TAP$" and "t0]B#r/,T2hc[ ~c8"
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      String addBinary = binaryCalculate.addBinary("c1j54$M2)Am$[8TAP$", "t0]B#r/,T2hc[ ~c8");
      
      // When the method "addBinary" is called with these two strings as input
      
      // Then the result should be an empty string, which means that the addition of the two binary strings results in a carry over and no digit is produced
      assertEquals("", addBinary);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSubBinaryReturningEmptyString() throws Throwable  {
      // Create a new instance of the BinaryCalculate class
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      
      // Set up the input parameters for the subBinary method
      String firstString = "10101010";
      String secondString = "Total Range:  -- \nUsable Range:  -- \n\nTotal usable IP Addresses : 0\nSubnet: \nBinary Subnet: \nBroadcast Address: \nPrefix: /-2\nNetmask: \nBinary Netmask: ";
      
      // Call the subBinary method and store the result in a variable
      String subBinary = binaryCalculate.subBinary(firstString, secondString);
      
      // Verify that the method returned an empty string
      assertEquals("", subBinary);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddBinary0() throws Throwable  {
      // Arrange
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      
      // Act
      String addBinary = binaryCalculate.addBinary("1010", "111");
      
      // Assert
      assertEquals("10001", addBinary);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddBinary1() throws Throwable  {
      // Given a binary calculator and two binary strings representing numbers
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      String binaryString1 = "000000000000000000000000010000000000000000";
      String binaryString2 = "5~487`3DyOp',T";
      
      // When we add the two binary strings using the calculator's addBinary method
      String result = binaryCalculate.addBinary(binaryString1, binaryString2);
      
      // Then the result should be a binary string representing the sum of the two numbers
      assertEquals("00000000000000000000000001000000000000000", result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddBinary2() throws Throwable  {
      // Given
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      
      // When
      String addBinary = binaryCalculate.addBinary("10101010", "11110000");
      
      // Then
      assertEquals("110011010", addBinary);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddBinary3() throws Throwable  {
      // Set up the test data
      String str1 = "1C`lnNTBn";
      String str2 = "0BrzTm#c[1(gRHc,uA";
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      
      // Perform the calculation
      String addBinary = binaryCalculate.addBinary(str1, str2);
      
      // Verify the results
      assertEquals("10", addBinary);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIPCalculateWithEmptyString() throws Throwable  {
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      binaryCalculate.isIPv6 = true;
      binaryCalculate.lengthOfToken = 1;
      // Test that an empty string raises a NumberFormatException
      try {
      binaryCalculate.IPCalculate("", "pD5W@(QEu Ar7,");
      fail("Expecting exception: NumberFormatException");
      } catch (NumberFormatException e) {
      // Verify that the exception is thrown due to an empty string
      verifyException("java.math.BigInteger", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIPCalculate0() throws Throwable  {
      // rollbacked to evosuite
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      binaryCalculate.lengthOfToken = 1;
      String IPCalculate = binaryCalculate.IPCalculate("a|KCot", "a|KCot");
      assertEquals("Total Range:  -- \nUsable Range:  -- \n\nTotal usable IP Addresses : 0\nSubnet: \nBinary Subnet: \nBroadcast Address: \nPrefix: /-2\nNetmask: \nBinary Netmask: ", IPCalculate);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIPCalculate1() throws Throwable  {
      // Given: A BinaryCalculate object is created with a length of 824 bits and an IPv6 flag set to true.
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      binaryCalculate.lengthOfToken = 824;
      binaryCalculate.isIPv6 = true;
      
      // When: The IPCalculate method is called with two strings as input, the first representing a binary string and the second representing an IP address in decimal notation.
      String IPCalculate = binaryCalculate.IPCalculate("00000000000000001000000000000000000", "00000000000000000000000");
      
      // Then: The method should return a non-null value, representing the calculated IP address in decimal notation.
      assertNotNull(IPCalculate);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIPCalculate2() throws Throwable  {
      // Setup
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      binaryCalculate.isIPv6 = true;
      
      // Execution
      String IPCalculate = binaryCalculate.IPCalculate("0000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000", "Dotalsabl IPGAddzesses : ");
      
      // Assertion
      assertEquals("Total Range:  -- 255.255.255.255\nUsable Range:  -- \n\nTotal usable IP Addresses : 1,427,247,692,705,959,881,048,614,562,892,578,744,635,577,940\nSubnet: \nBinary Subnet: \nBroadcast Address: 255.255.255.255\nPrefix: /-128\nNetmask: \nBinary Netmask: ", IPCalculate);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIPCalculate3() throws Throwable  {
      // No Comments were added
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      String IPCalculate = binaryCalculate.IPCalculate("000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000", "Dotalsbl IPAdzesses : ");
      assertEquals("Total Range:  -- \nUsable Range:  -- \n\nTotal usable IP Addresses : 1,427,247,692,705,959,881,048,614,562,892,578,102,985,097,215\nSubnet: \nBinary Subnet: \nBroadcast Address: \nPrefix: /0\nNetmask: \nBinary Netmask: ", IPCalculate);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIPCalculateThrowsNumberFormatException() throws Throwable  {
      // Given
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      String input1 = "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000001";
      String input2 = "000000000000000000000000001";
      
      // When
      binaryCalculate.IPCalculate(input1, input2);
      
      // Then
      fail("Expecting exception: NumberFormatException");
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIPCalculate4() throws Throwable  {
      // rollbacked to evosuite
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      binaryCalculate.MAXPREFIX = 32;
      String IPCalculate = binaryCalculate.IPCalculate("Total Range:  -- \nUsable Range:  -- \n\nTotal usable IP Addresses : 2\nSubnet: \nBinary Subnet: \nBroadcast Address: \nPrefix: /0\nNetmask: \nBinary Netmask: ", "Total Range:  -- \nUsable Range:  -- \n\nTotal usable IP Addresses : 2\nSubnet: \nBinary Subnet: \nBroadcast Address: \nPrefix: /0\nNetmask: \nBinary Netmask: ");
      assertEquals("Total Range: 255.255.255.255 -- \nUsable Range:  -- 255.255.255.255\n\nTotal usable IP Addresses : 134,217,728\nSubnet: \nBinary Subnet: Total Ra.nge:  --. \nUsable. Range: .\nBroadcast Address: \nPrefix: /4\nNetmask: 0.0.0.0\nBinary Netmask: 00000000.00000000.00000000.00000000", IPCalculate);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIPCalculate5() throws Throwable  {
      // Given a valid IP address range with prefix 2
      String ipAddress1 = "0";
      String ipAddress2 = "0";
      int prefixLength = 2;
      
      // When calculating the IP addresses within the range
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      String IPCalculate = binaryCalculate.IPCalculate(ipAddress1, ipAddress2);
      
      // Then the total and usable IP addresses are calculated correctly
      assertEquals("Total Range:  -- \nUsable Range:  -- \n\nTotal usable IP Addresses : 1\nSubnet: \nBinary Subnet: 0\nBroadcast Address: \nPrefix: /0\nNetmask: \nBinary Netmask: 01", IPCalculate);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddBinary4() throws Throwable  {
      // Create a new instance of the BinaryCalculate class
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      
      // Test the addBinary method with two binary strings
      String result = binaryCalculate.addBinary("11001101", "01110101");
      
      // Assert that the result is equal to the expected value
      assertEquals("101000010", result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPrefixInPrefixCalculateThrowsHeadlessException() throws Throwable  {
      // Given a binary calculator instance
      BinaryCalculate binaryCalculate = new BinaryCalculate();
      
      // And the IP address is valid (in this case, it's an IPv4 address)
      binaryCalculate.isIPv4 = true;
      
      // And the length of the token is 1
      binaryCalculate.lengthOfToken = 1;
      
      // When we call the prefixInPrefixCalculate method with the following arguments:
      // * An empty string as the IP address (this is invalid)
      // * A valid subnet mask (in this case, it's "O46%?u`|qM1Pup")
      // * A valid prefix length (in this case, it's 1)
      // * An empty string as the broadcast address (this is invalid)
      try {
      binaryCalculate.prefixInPrefixCalculate("", "O46%?u`|qM1Pup", 1, "Total Range: 0 -- 1\nUsable Range: 1 -- 0\n\nTotal usable IP Addresses : -1\nSubnet: \nBinary Subnet: \nBroadcast Address: 1\nPrefix: /0\nNetmask: \nBinary Netmask: ");
      fail("Expecting exception: HeadlessException");
      } catch(HeadlessException e) {
      // Then an exception should be thrown with the message "java.awt.GraphicsEnvironment"
      verifyException("java.awt.GraphicsEnvironment", e);}
  }
}
