* EvoSuite 1.0.0-SNAPSHOT
* Going to generate test cases for class: org.quickserver.net.server.impl.NonBlockingClientHandler
* Starting Client-0
* Properties loaded from /home/roham/Results-Utestgen/dataset/SF110-new-res/93_quickserver/evosuite-files/evosuite.properties
* Connecting to master process on port 8385
* Analyzing classpath: 
* Inheritance tree loaded from evosuite-files/inheritance.xml.gz
[MASTER] 07:10:06.857 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.net.SocketOption
[MASTER] 07:10:06.873 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.Consumer
[MASTER] 07:10:06.875 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.Predicate
[MASTER] 07:10:06.876 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.UnaryOperator
[MASTER] 07:10:06.903 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.Supplier
[MASTER] 07:10:07.220 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.Function
[MASTER] 07:10:07.222 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.Temporal
[MASTER] 07:10:07.236 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.ZoneId
[MASTER] 07:10:07.242 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalAccessor
[MASTER] 07:10:07.243 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalField
[MASTER] 07:10:07.251 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalUnit
[MASTER] 07:10:07.252 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalAmount
[MASTER] 07:10:07.253 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.Clock
[MASTER] 07:10:07.255 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalQuery
[MASTER] 07:10:07.270 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalAdjuster
[MASTER] 07:10:07.361 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.BiFunction
[MASTER] 07:10:07.363 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.BiConsumer
* Finished analyzing classpath
* Generating tests for class org.quickserver.net.server.impl.NonBlockingClientHandler
* Test criteria:
  - Branch Coverage
  - Line Coverage
  - Method-Output Coverage
  - Top-Level Method Coverage
  - Context Branch Coverage
* Total number of test goals for DYNAMOSA: 1838
* Using seed 1710400199185
* Starting evolution
[Progress:>                             0%] [Cov:>                                  0%]* Initial Number of Goals in DynaMOSA = 284 / 1838
[MASTER] 07:10:13.007 [logback-1] WARN  TestCluster - Failed to check cache for java.util.Enumeration<E> : Type points to itself
[Progress:=>                            4%] [Cov:=======>                           22%][Progress:=>                            6%] [Cov:========>                          25%][Progress:=>                            6%] [Cov:=========>                         27%][Progress:==>                           7%] [Cov:=========>                         27%][Progress:==>                           8%] [Cov:=========>                         27%][Progress:==>                           9%] [Cov:=========>                         27%][Progress:===>                          12%] [Cov:=========>                         27%][Progress:===>                          13%] [Cov:=========>                         27%][Progress:===>                          13%] [Cov:=========>                         27%][Progress:===>                          13%] [Cov:=========>                         27%][Progress:====>                         14%] [Cov:=========>                         27%][Progress:====>                         14%] [Cov:=========>                         27%][Progress:====>                         14%] [Cov:=========>                         27%][Progress:====>                         15%] [Cov:=========>                         27%][Progress:====>                         15%] [Cov:=========>                         27%][Progress:====>                         15%] [Cov:=========>                         27%][Progress:====>                         15%] [Cov:=========>                         27%][Progress:====>                         15%] [Cov:=========>                         27%][Progress:====>                         16%] [Cov:=========>                         27%][Progress:====>                         16%] [Cov:=========>                         27%][Progress:====>                         16%] [Cov:=========>                         27%][Progress:=====>                        19%] [Cov:=========>                         27%][Progress:======>                       20%] [Cov:==========>                        29%][Progress:======>                       20%] [Cov:==========>                        29%][Progress:======>                       21%] [Cov:==========>                        29%][Progress:======>                       21%] [Cov:==========>                        29%][Progress:======>                       21%] [Cov:==========>                        29%][Progress:======>                       22%] [Cov:==========>                        29%][Progress:======>                       22%] [Cov:==========>                        29%][Progress:======>                       23%] [Cov:==========>                        29%][Progress:======>                       23%] [Cov:==========>                        29%][Progress:=======>                      24%] [Cov:==========>                        29%][Progress:=======>                      24%] [Cov:==========>                        29%][Progress:=======>                      25%] [Cov:==========>                        29%][Progress:=======>                      25%] [Cov:==========>                        29%][Progress:=======>                      26%] [Cov:==========>                        29%][Progress:=======>                      26%] [Cov:==========>                        29%][Progress:=======>                      26%] [Cov:==========>                        29%][Progress:========>                     27%] [Cov:==========>                        29%][Progress:========>                     27%] [Cov:==========>                        29%][Progress:========>                     27%] [Cov:==========>                        29%][Progress:========>                     28%] [Cov:==========>                        29%][Progress:========>                     28%] [Cov:==========>                        29%][Progress:========>                     28%] [Cov:==========>                        29%][Progress:========>                     29%] [Cov:==========>                        29%][Progress:========>                     29%] [Cov:==========>                        29%][Progress:========>                     29%] [Cov:==========>                        29%][Progress:=========>                    30%] [Cov:==========>                        29%][Progress:=========>                    31%] [Cov:==========>                        29%][Progress:=========>                    31%] [Cov:==========>                        29%][Progress:=========>                    32%] [Cov:==========>                        29%][Progress:=========>                    32%] [Cov:==========>                        29%][Progress:=========>                    32%] [Cov:==========>                        29%][Progress:=========>                    32%] [Cov:==========>                        29%][Progress:=========>                    33%] [Cov:==========>                        29%][Progress:=========>                    33%] [Cov:==========>                        29%][Progress:=========>                    33%] [Cov:==========>                        29%][Progress:=========>                    33%] [Cov:==========>                        29%][Progress:==========>                   34%] [Cov:==========>                        29%][Progress:==========>                   34%] [Cov:==========>                        29%][Progress:==========>                   34%] [Cov:==========>                        29%][Progress:==========>                   35%] [Cov:==========>                        29%][Progress:==========>                   36%] [Cov:==========>                        29%][Progress:==========>                   36%] [Cov:==========>                        29%][Progress:==========>                   36%] [Cov:==========>                        29%][Progress:===========>                  37%] [Cov:==========>                        29%][Progress:===========>                  37%] [Cov:==========>                        29%][Progress:===========>                  37%] [Cov:==========>                        29%][Progress:===========>                  38%] [Cov:==========>                        29%][Progress:===========>                  38%] [Cov:==========>                        29%][Progress:===========>                  39%] [Cov:==========>                        29%][Progress:===========>                  39%] [Cov:==========>                        29%][Progress:============>                 43%] [Cov:==========>                        29%][Progress:============>                 43%] [Cov:==========>                        29%][Progress:============>                 43%] [Cov:==========>                        29%][Progress:=============>                44%] [Cov:==========>                        29%][Progress:=============>                44%] [Cov:==========>                        29%][Progress:=============>                44%] [Cov:==========>                        29%][Progress:=============>                45%] [Cov:==========>                        29%][Progress:=============>                45%] [Cov:==========>                        29%][Progress:=============>                46%] [Cov:==========>                        29%][Progress:=============>                46%] [Cov:==========>                        29%][Progress:=============>                46%] [Cov:==========>                        29%][Progress:===============>              51%] [Cov:==========>                        29%][Progress:===============>              52%] [Cov:==========>                        29%][Progress:===============>              52%] [Cov:==========>                        29%][Progress:===============>              52%] [Cov:==========>                        29%][Progress:===============>              53%] [Cov:==========>                        29%][Progress:===============>              53%] [Cov:==========>                        29%][Progress:================>             54%] [Cov:==========>                        29%][Progress:=================>            59%] [Cov:==========>                        29%][Progress:=================>            59%] [Cov:==========>                        29%][Progress:==================>           60%] [Cov:==========>                        29%][Progress:==================>           60%] [Cov:==========>                        29%][Progress:==================>           61%] [Cov:==========>                        29%][Progress:==================>           62%] [Cov:==========>                        29%][Progress:==================>           62%] [Cov:==========>                        29%][Progress:==================>           62%] [Cov:==========>                        29%][Progress:==================>           63%] [Cov:==========>                        29%][Progress:==================>           63%] [Cov:==========>                        29%][Progress:===================>          64%] [Cov:==========>                        29%][Progress:===================>          64%] [Cov:==========>                        29%][Progress:===================>          65%] [Cov:==========>                        29%][Progress:===================>          66%] [Cov:==========>                        29%][Progress:===================>          66%] [Cov:==========>                        29%][Progress:===================>          66%] [Cov:==========>                        29%][Progress:=====================>        70%] [Cov:==========>                        29%][Progress:=====================>        73%] [Cov:==========>                        29%][Progress:======================>       74%] [Cov:==========>                        29%][Progress:======================>       74%] [Cov:==========>                        29%][Progress:======================>       74%] [Cov:==========>                        29%][Progress:======================>       75%] [Cov:==========>                        29%][Progress:======================>       75%] [Cov:==========>                        29%][Progress:======================>       76%] [Cov:==========>                        29%][Progress:======================>       76%] [Cov:==========>                        29%][Progress:======================>       76%] [Cov:==========>                        29%][Progress:=======================>      77%] [Cov:==========>                        29%][Progress:=======================>      77%] [Cov:==========>                        29%][Progress:=======================>      78%] [Cov:==========>                        29%][Progress:=======================>      78%] [Cov:==========>                        29%][Progress:=======================>      78%] [Cov:==========>                        29%][Progress:=======================>      79%] [Cov:==========>                        29%][Progress:=======================>      79%] [Cov:==========>                        29%][Progress:=======================>      79%] [Cov:==========>                        29%][Progress:========================>     80%] [Cov:==========>                        29%][Progress:========================>     80%] [Cov:==========>                        29%][Progress:========================>     81%] [Cov:==========>                        29%][Progress:========================>     81%] [Cov:==========>                        29%][Progress:========================>     82%] [Cov:==========>                        29%][Progress:========================>     83%] [Cov:==========>                        29%][Progress:========================>     83%] [Cov:==========>                        29%][Progress:=========================>    84%] [Cov:==========>                        29%][Progress:=========================>    85%] [Cov:==========>                        29%][Progress:=========================>    85%] [Cov:==========>                        29%][Progress:=========================>    86%] [Cov:==========>                        29%][Progress:===========================>  90%] [Cov:==========>                        29%][Progress:===========================>  91%] [Cov:==========>                        29%][Progress:===========================>  91%] [Cov:==========>                        29%][Progress:===========================>  91%] [Cov:==========>                        29%][Progress:===========================>  92%] [Cov:==========>                        29%][Progress:===========================>  92%] [Cov:==========>                        29%][Progress:===========================>  93%] [Cov:==========>                        29%][Progress:===========================>  93%] [Cov:==========>                        29%][Progress:===========================>  93%] [Cov:==========>                        29%][Progress:============================> 94%] [Cov:==========>                        29%][Progress:============================> 94%] [Cov:==========>                        29%][Progress:============================> 94%] [Cov:==========>                        29%][Progress:============================> 95%] [Cov:==========>                        29%][Progress:============================> 95%] [Cov:==========>                        29%][Progress:============================> 95%] [Cov:==========>                        29%][Progress:============================> 95%] [Cov:==========>                        29%][Progress:============================> 96%] [Cov:==========>                        29%][Progress:============================> 96%] [Cov:==========>                        29%][Progress:============================> 96%] [Cov:==========>                        29%][Progress:=============================>97%] [Cov:==========>                        29%][Progress:=============================>97%] [Cov:==========>                        29%][Progress:=============================>97%] [Cov:==========>                        29%][Progress:=============================>97%] [Cov:==========>                        29%][Progress:==============================100%] [Cov:==========>                        29%]
* Search finished after 104s and 158 generations, 30784 statements, best individual has fitness: 1526.0
* Generated before the refinement 41 tests with total length 93
statement is: getMaxThreadAccessCount()I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int maxThreadAccessCount = NonBlockingClientHandler.getMaxThreadAccessCount()
test data is: NonBlockingClientHandler.getMaxThreadAccessCount();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        int maxThreadAccessCount = NonBlockingClientHandler.getMaxThreadAccessCount();
        // Assuming the maximum number of threads that can access the handler simultaneously is 100
        maxThreadAccessCount = 100;
    }
}
statement is: int maxThreadAccessCount = NonBlockingClientHandler.getMaxThreadAccessCount(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtInvocationImpl
invocation is: NonBlockingClientHandler.getMaxThreadAccessCount() target is: NonBlockingClientHandler method is: getMaxThreadAccessCount()
Matched Method is: getMaxThreadAccessCount()I
statement is: // Assuming the maximum number of threads that can access the handler simultaneously is 100
maxThreadAccessCount = 100, class spoon.support.reflect.code.CtAssignmentImpl
TestCase is: NonBlockingClientHandler.getMaxThreadAccessCount();

statement is: getWakeupSelectorAfterRegisterRead()Z type is: class org.evosuite.testcase.statements.MethodStatement return type boolean
statement code is: boolean wakeupSelectorAfterRegisterRead = NonBlockingClientHandler.getWakeupSelectorAfterRegisterRead()
test data is: NonBlockingClientHandler.getWakeupSelectorAfterRegisterRead();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Update the test data to be more descriptive and representative of the situation being tested
        return true;
    }
}
statement is: // Update the test data to be more descriptive and representative of the situation being tested
return true, class spoon.support.reflect.code.CtReturnImpl
statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: finalize()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.finalize()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.finalize();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Testing the finalization of NonBlockingClientHandler objects
        NonBlockingClientHandler clientConnection = new NonBlockingClientHandler();
        clientConnection.finalize();
    }
}
statement is: // Testing the finalization of NonBlockingClientHandler objects
NonBlockingClientHandler clientConnection = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: clientConnection.finalize(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: clientConnection.finalize() target is: clientConnection method is: finalize()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: finalize()V
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.finalize();

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32)
statement is: getInitialHandshakeStatus()Z type is: class org.evosuite.testcase.statements.MethodStatement return type boolean
statement code is: boolean initialHandshakeStatus = nonBlockingClientHandler.getInitialHandshakeStatus()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.getInitialHandshakeStatus();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
        nonBlockingClientHandler.getInitialHandshakeStatus();
        // Improved test data:
        int connectionBacklog = 32;// The maximum length of the queue for incoming connections

        nonBlockingClientHandler.getInitialHandshakeStatus();
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.getInitialHandshakeStatus(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.getInitialHandshakeStatus() target is: nonBlockingClientHandler method is: getInitialHandshakeStatus()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
Matched Method is: getInitialHandshakeStatus()Z
statement is: // Improved test data:
int connectionBacklog = 32// The maximum length of the queue for incoming connections
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: nonBlockingClientHandler.getInitialHandshakeStatus(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.getInitialHandshakeStatus() target is: nonBlockingClientHandler method is: getInitialHandshakeStatus()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
Matched Method is: getInitialHandshakeStatus()Z
* this is vulnerable: int _int = 32
TestCase is: int _int = 32;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(_int);
((NonBlockingClientHandler) _int).getInitialHandshakeStatus();
int _int = 32;
((NonBlockingClientHandler) _int).getInitialHandshakeStatus();

statement is: getWakeupSelectorAfterRegisterWrite()Z type is: class org.evosuite.testcase.statements.MethodStatement return type boolean
statement code is: boolean wakeupSelectorAfterRegisterWrite = NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite()
test data is: NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        return SECONDS.toMillis(1);// Improved to return a more descriptive value, such as "500 milliseconds" or "1 second".

        String data = RandomStringUtils.randomAlphanumeric(20);// Improved to include more meaningful and representative data, such as "random string of length 20" or "string with special characters". }}

    }
}
statement is: return SECONDS.toMillis(1)// Improved to return a more descriptive value, such as "500 milliseconds" or "1 second".
, class spoon.support.reflect.code.CtReturnImpl
statement is: String data = RandomStringUtils.randomAlphanumeric(20)// Improved to include more meaningful and representative data, such as "random string of length 20" or "string with special characters". }}
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtInvocationImpl
invocation is: RandomStringUtils.randomAlphanumeric(20) target is: RandomStringUtils method is: randomAlphanumeric(int)
statement is: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60)
statement is: setClientWriteHandler(Lorg/quickserver/net/server/ClientWriteHandler;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.setClientWriteHandler((ClientWriteHandler) null)
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
nonBlockingClientHandler.setClientWriteHandler((ClientWriteHandler) null);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
        nonBlockingClientHandler.setClientWriteHandler(new ClientWriteHandler() {
            @Override
            public void handle(String message) {
                System.out.println("Message received: " + message);
            }
        });
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.setClientWriteHandler(new ClientWriteHandler() {
    @Override
    public void handle(String message) {
        System.out.println("Message received: " + message);
    }
}), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.setClientWriteHandler(new ClientWriteHandler() {
    @Override
    public void handle(String message) {
        System.out.println("Message received: " + message);
    }
}) target is: nonBlockingClientHandler method is: setClientWriteHandler(DummyClass$1)
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
Matched Method is: setClientWriteHandler(Lorg/quickserver/net/server/ClientWriteHandler;)V
i 0 Parameters size() 0 Num of Method Parameters: 1
TestCase is: int _int = 60;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(_int);
ClientWriteHandler clientWriteHandler = null;
((NonBlockingClientHandler) _int).setClientWriteHandler(clientWriteHandler);

statement is: setWakeupSelectorAfterRegisterRead(Z)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: NonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(false)
test data is: NonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(false);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(true);
    }
}
statement is: NonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(true), class spoon.support.reflect.code.CtInvocationImpl
invocation is: NonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(true) target is: NonBlockingClientHandler method is: setWakeupSelectorAfterRegisterRead(boolean)
Matched Method is: setWakeupSelectorAfterRegisterRead(Z)V
TestCase is: boolean _boolean = true;
NonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(_boolean);

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60)
statement is: getBlockingMode()Z type is: class org.evosuite.testcase.statements.MethodStatement return type boolean
statement code is: boolean blockingMode = nonBlockingClientHandler.getBlockingMode()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
nonBlockingClientHandler.getBlockingMode();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(10);
        nonBlockingClientHandler.getBlockingMode();
        // This test case verifies that the blocking mode is set to non-blocking
        assertEquals(false, nonBlockingClientHandler.isBlocking());
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(10), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.getBlockingMode(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.getBlockingMode() target is: nonBlockingClientHandler method is: getBlockingMode()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
Matched Method is: getBlockingMode()Z
statement is: // This test case verifies that the blocking mode is set to non-blocking
assertEquals(false, nonBlockingClientHandler.isBlocking()), class spoon.support.reflect.code.CtInvocationImpl
invocation is: // This test case verifies that the blocking mode is set to non-blocking
assertEquals(false, nonBlockingClientHandler.isBlocking()) target is:  method is: assertEquals(boolean,<unknown>)
TestCase is: int _int = 10;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(_int);
((NonBlockingClientHandler) _int).getBlockingMode();

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60)
statement is: setSocketChannel(Ljava/nio/channels/SocketChannel;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.setSocketChannel((SocketChannel) null)
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
nonBlockingClientHandler.setSocketChannel((SocketChannel) null);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
        nonBlockingClientHandler.setSocketChannel(SocketChannel.open());
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.setSocketChannel(SocketChannel.open()), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.setSocketChannel(SocketChannel.open()) target is: nonBlockingClientHandler method is: setSocketChannel()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
Matched Method is: setSocketChannel(Ljava/nio/channels/SocketChannel;)V
i 0 Parameters size() 0 Num of Method Parameters: 1
TestCase is: int _int = 60;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(_int);
SocketChannel socketChannel = null;
((NonBlockingClientHandler) _int).setSocketChannel(socketChannel);

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1987)
statement is: getThreadAccessCount()I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int threadAccessCount = nonBlockingClientHandler.getThreadAccessCount()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1987);
nonBlockingClientHandler.getThreadAccessCount();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler("John Smith");
        nonBlockingClientHandler.getThreadAccessCount();
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler("John Smith"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.getThreadAccessCount(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.getThreadAccessCount() target is: nonBlockingClientHandler method is: getThreadAccessCount()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
Matched Method is: getThreadAccessCount()I
TestCase is: String string = "John Smith";
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler((int) string);
((NonBlockingClientHandler) string).getThreadAccessCount();

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: readInputStream()[B type is: class org.evosuite.testcase.statements.MethodStatement return type class [B
statement code is: byte[] readInputStream = nonBlockingClientHandler.readInputStream()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.readInputStream();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler("127.0.0.1", 8080, "username", "password");
        nonBlockingClientHandler.readInputStream();
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler("127.0.0.1", 8080, "username", "password"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.readInputStream(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.readInputStream() target is: nonBlockingClientHandler method is: readInputStream()
statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: getBufferedReader()Ljava/io/BufferedReader; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.io.BufferedReader
statement code is: BufferedReader bufferedReader = nonBlockingClientHandler.getBufferedReader()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.getBufferedReader();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        nonBlockingClientHandler.getBufferedReader(input, bufferSize, delimiter);
        // Improved test data
        String input = "Hello, World!";
        int bufferSize = 1024;
        char delimiter = ' ';
        // Call the getBufferedReader method with the improved test data
        nonBlockingClientHandler.getBufferedReader(input, bufferSize, delimiter);
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.getBufferedReader(input, bufferSize, delimiter), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.getBufferedReader(input, bufferSize, delimiter) target is: nonBlockingClientHandler method is: getBufferedReader()
statement is: // Improved test data
String input = "Hello, World!", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: int bufferSize = 1024, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: char delimiter = ' ', class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: // Call the getBufferedReader method with the improved test data
nonBlockingClientHandler.getBufferedReader(input, bufferSize, delimiter), class spoon.support.reflect.code.CtInvocationImpl
invocation is: // Call the getBufferedReader method with the improved test data
nonBlockingClientHandler.getBufferedReader(input, bufferSize, delimiter) target is: nonBlockingClientHandler method is: getBufferedReader(java.lang.String,int,char)
* this is vulnerable: String string = "Hello, World!"
* this is vulnerable: int _int = 1024
* this is vulnerable: char _char = ' '
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
String string = "Hello, World!";
int _int = 1024;
char _char = ' ';

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: setSelectionKey(Ljava/nio/channels/SelectionKey;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.setSelectionKey((SelectionKey) null)
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setSelectionKey((SelectionKey) null);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        nonBlockingClientHandler.setSelectionKey(OP_READ);
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.setSelectionKey(OP_READ), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.setSelectionKey(OP_READ) target is: nonBlockingClientHandler method is: setSelectionKey()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: setSelectionKey(Ljava/nio/channels/SelectionKey;)V
i 0 Parameters size() 0 Num of Method Parameters: 1
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
SelectionKey selectionKey = null;
nonBlockingClientHandler.setSelectionKey(selectionKey);

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: org.evosuite.testcase.statements.FieldStatement@331945a4 type is: class org.evosuite.testcase.statements.FieldStatement return type class org.quickserver.net.server.ClientEvent
statement code is: ClientEvent clientEvent = ClientEvent.LOST_CON
statement is: addEvent(Lorg/quickserver/net/server/ClientEvent;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.addEvent(arg0)
statement is: run()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.run()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.LOST_CON;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.run();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        ClientEvent clientEvent = ClientEvent.LOST_CON;
        clientEvent.setConnectionId(123456789);// set a realistic connection ID

        nonBlockingClientHandler.addEvent(clientEvent);
        nonBlockingClientHandler.run();
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: ClientEvent clientEvent = ClientEvent.LOST_CON, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtFieldReadImpl
Field is: ClientEvent.LOST_CON is ClientEvent
CtField is: public static org.quickserver.net.server.ClientEvent org.quickserver.net.server.ClientEvent.LOST_CON ClientEvent LOST_CON
statement is: clientEvent.setConnectionId(123456789)// set a realistic connection ID
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: clientEvent.setConnectionId(123456789)// set a realistic connection ID
 target is: clientEvent method is: setConnectionId(int)
statement is: nonBlockingClientHandler.addEvent(clientEvent), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.addEvent(clientEvent) target is: nonBlockingClientHandler method is: addEvent(ClientEvent)
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: addEvent(Lorg/quickserver/net/server/ClientEvent;)V
statement is: nonBlockingClientHandler.run(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.run() target is: nonBlockingClientHandler method is: run()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: run()V
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.LOST_CON;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.run();

statement is: setMaxThreadAccessCount(I)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: NonBlockingClientHandler.setMaxThreadAccessCount(1987)
test data is: NonBlockingClientHandler.setMaxThreadAccessCount(1987);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler.setMaxThreadAccessCount(1000);
    }
}
statement is: NonBlockingClientHandler.setMaxThreadAccessCount(1000), class spoon.support.reflect.code.CtInvocationImpl
invocation is: NonBlockingClientHandler.setMaxThreadAccessCount(1000) target is: NonBlockingClientHandler method is: setMaxThreadAccessCount(int)
Matched Method is: setMaxThreadAccessCount(I)V
TestCase is: int _int = 1000;
NonBlockingClientHandler.setMaxThreadAccessCount(_int);

statement is: setMaxThreadAccessCount(I)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: NonBlockingClientHandler.setMaxThreadAccessCount((byte) (-105))
test data is: NonBlockingClientHandler.setMaxThreadAccessCount((byte) (-105));

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler.setMaxThreadAccessCount(Byte.MAX_VALUE);
    }
}
statement is: NonBlockingClientHandler.setMaxThreadAccessCount(Byte.MAX_VALUE), class spoon.support.reflect.code.CtInvocationImpl
invocation is: NonBlockingClientHandler.setMaxThreadAccessCount(Byte.MAX_VALUE) target is: NonBlockingClientHandler method is: setMaxThreadAccessCount(byte)
Matched Method is: setMaxThreadAccessCount(I)V
i 0 Parameters size() 0 Num of Method Parameters: 1
TestCase is: byte _byte = null;
NonBlockingClientHandler.setMaxThreadAccessCount(_byte);

statement is: setMaxThreadAccessCount(I)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: NonBlockingClientHandler.setMaxThreadAccessCount((-1))
test data is: NonBlockingClientHandler.setMaxThreadAccessCount((-1));

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler.setMaxThreadAccessCount(Integer.MAX_VALUE);
    }
}
statement is: NonBlockingClientHandler.setMaxThreadAccessCount(Integer.MAX_VALUE), class spoon.support.reflect.code.CtInvocationImpl
invocation is: NonBlockingClientHandler.setMaxThreadAccessCount(Integer.MAX_VALUE) target is: NonBlockingClientHandler method is: setMaxThreadAccessCount(int)
Matched Method is: setMaxThreadAccessCount(I)V
i 0 Parameters size() 0 Num of Method Parameters: 1
TestCase is: int _int = null;
NonBlockingClientHandler.setMaxThreadAccessCount(_int);

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: returnThread()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.returnThread()
statement is: clean()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.clean()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.clean();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(4, 100);
        nonBlockingClientHandler.returnThread();
        nonBlockingClientHandler.clean();
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(4, 100), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.returnThread(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.returnThread() target is: nonBlockingClientHandler method is: returnThread()
statement is: nonBlockingClientHandler.clean(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.clean() target is: nonBlockingClientHandler method is: clean()
statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: setInputStream(Ljava/io/InputStream;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.setInputStream((InputStream) null)
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setInputStream((InputStream) null);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        nonBlockingClientHandler.setInputStream(new ByteArrayInputStream("Hello, World!".getBytes()));
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.setInputStream(new ByteArrayInputStream("Hello, World!".getBytes())), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.setInputStream(new ByteArrayInputStream("Hello, World!".getBytes())) target is: nonBlockingClientHandler method is: setInputStream(ByteArrayInputStream)
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: setInputStream(Ljava/io/InputStream;)V
i 0 Parameters size() 0 Num of Method Parameters: 1
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
InputStream inputStream = null;
nonBlockingClientHandler.setInputStream(inputStream);

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32)
statement is: closeConnection()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.closeConnection()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.closeConnection();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(64);// changed to a more descriptive value

        nonBlockingClientHandler.closeConnection();
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(64)// changed to a more descriptive value
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.closeConnection(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.closeConnection() target is: nonBlockingClientHandler method is: closeConnection()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
Matched Method is: closeConnection()V
TestCase is: int _int = 64;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(_int);
((NonBlockingClientHandler) _int).closeConnection();

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: org.evosuite.testcase.statements.AssignmentStatement@a2bd3e5e type is: class org.evosuite.testcase.statements.AssignmentStatement return type boolean
statement code is: nonBlockingClientHandler.secure = true
statement is: closeIfSSLOutboundDone()Z type is: class org.evosuite.testcase.statements.MethodStatement return type boolean
statement code is: boolean closeIfSSLOutboundDone = nonBlockingClientHandler.closeIfSSLOutboundDone()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.secure = true;
nonBlockingClientHandler.closeIfSSLOutboundDone();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        nonBlockingClientHandler.secure = true;
        nonBlockingClientHandler.closeIfSSLOutboundDone();
        // Replace the primitive values with more descriptive examples
        nonBlockingClientHandler.port = 443;
        nonBlockingClientHandler.host = "www.example.com";
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.secure = true, class spoon.support.reflect.code.CtAssignmentImpl
statement is: nonBlockingClientHandler.closeIfSSLOutboundDone(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.closeIfSSLOutboundDone() target is: nonBlockingClientHandler method is: closeIfSSLOutboundDone()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: closeIfSSLOutboundDone()Z
statement is: // Replace the primitive values with more descriptive examples
nonBlockingClientHandler.port = 443, class spoon.support.reflect.code.CtAssignmentImpl
statement is: nonBlockingClientHandler.host = "www.example.com", class spoon.support.reflect.code.CtAssignmentImpl
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.closeIfSSLOutboundDone();

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: closeIfSSLOutboundDone()Z type is: class org.evosuite.testcase.statements.MethodStatement return type boolean
statement code is: boolean closeIfSSLOutboundDone = nonBlockingClientHandler.closeIfSSLOutboundDone()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.closeIfSSLOutboundDone();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        nonBlockingClientHandler.setSSLContext(createDummySslContext());// create a dummy SSL context for testing

        nonBlockingClientHandler.setIsOutboundDone(true);// set the outbound done flag to true

        nonBlockingClientHandler.closeIfSSLOutboundDone();
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.setSSLContext(createDummySslContext())// create a dummy SSL context for testing
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.setSSLContext(createDummySslContext())// create a dummy SSL context for testing
 target is: nonBlockingClientHandler method is: setSSLContext()
statement is: nonBlockingClientHandler.setIsOutboundDone(true)// set the outbound done flag to true
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.setIsOutboundDone(true)// set the outbound done flag to true
 target is: nonBlockingClientHandler method is: setIsOutboundDone(boolean)
statement is: nonBlockingClientHandler.closeIfSSLOutboundDone(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.closeIfSSLOutboundDone() target is: nonBlockingClientHandler method is: closeIfSSLOutboundDone()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: closeIfSSLOutboundDone()Z
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.closeIfSSLOutboundDone();

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32)
statement is: run()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.run()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.run();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
        nonBlockingClientHandler.run();
        // Improved test data
        int bufferSize = 32;
        String message = "Hello, world!";
        nonBlockingClientHandler = new NonBlockingClientHandler(bufferSize);
        nonBlockingClientHandler.sendMessage(message);
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.run(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.run() target is: nonBlockingClientHandler method is: run()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
Matched Method is: run()V
statement is: // Improved test data
int bufferSize = 32, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String message = "Hello, world!", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: nonBlockingClientHandler = new NonBlockingClientHandler(bufferSize), class spoon.support.reflect.code.CtAssignmentImpl
statement is: nonBlockingClientHandler.sendMessage(message), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.sendMessage(message) target is: nonBlockingClientHandler method is: sendMessage(java.lang.String)
* this is vulnerable: int _int = 32
* this is vulnerable: String string = "Hello, world!"
TestCase is: int _int = 32;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(_int);
((NonBlockingClientHandler) _int).run();
int _int = 32;
String string = "Hello, world!";

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32)
statement is: checkReturnClientHandler()Z type is: class org.evosuite.testcase.statements.MethodStatement return type boolean
statement code is: boolean checkReturnClientHandler = nonBlockingClientHandler.checkReturnClientHandler()
statement is: checkReturnClientHandler()Z type is: class org.evosuite.testcase.statements.MethodStatement return type boolean
statement code is: boolean checkReturnClientHandler = nonBlockingClientHandler.checkReturnClientHandler()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.checkReturnClientHandler();
nonBlockingClientHandler.checkReturnClientHandler();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(8);
        nonBlockingClientHandler.checkReturnClientHandler();
        nonBlockingClientHandler.checkReturnClientHandler();
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(8), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.checkReturnClientHandler(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.checkReturnClientHandler() target is: nonBlockingClientHandler method is: checkReturnClientHandler()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
Matched Method is: checkReturnClientHandler()Z
statement is: nonBlockingClientHandler.checkReturnClientHandler(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.checkReturnClientHandler() target is: nonBlockingClientHandler method is: checkReturnClientHandler()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
Matched Method is: checkReturnClientHandler()Z
TestCase is: int _int = 8;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(_int);
((NonBlockingClientHandler) _int).checkReturnClientHandler();
((NonBlockingClientHandler) _int).checkReturnClientHandler();

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: returnThread()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.returnThread()
statement is: returnClientHandler()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.returnClientHandler()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.returnClientHandler();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        // Test 1: Verify that the returnThread() method returns the correct thread ID
        long expectedThreadId = Thread.currentThread().getId();
        long actualThreadId = nonBlockingClientHandler.returnThread();
        assertEquals(expectedThreadId, actualThreadId);
        // Test 2: Verify that the returnClientHandler() method returns a valid client handler
        ClientHandler clientHandler = nonBlockingClientHandler.returnClientHandler();
        assertNotNull(clientHandler);
        // Test 3: Verify that the client handler is connected to the correct endpoint
        String expectedEndpoint = "http://localhost:8080";
        String actualEndpoint = clientHandler.getEndpoint();
        assertEquals(expectedEndpoint, actualEndpoint);
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: // Test 1: Verify that the returnThread() method returns the correct thread ID
long expectedThreadId = Thread.currentThread().getId(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtInvocationImpl
invocation is: Thread.currentThread().getId() target is: Thread.currentThread() method is: getId()
statement is: long actualThreadId = nonBlockingClientHandler.returnThread(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.returnThread() target is: nonBlockingClientHandler method is: returnThread()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: returnThread()V
statement is: assertEquals(expectedThreadId, actualThreadId), class spoon.support.reflect.code.CtInvocationImpl
invocation is: assertEquals(expectedThreadId, actualThreadId) target is:  method is: assertEquals(long,long)
statement is: // Test 2: Verify that the returnClientHandler() method returns a valid client handler
ClientHandler clientHandler = nonBlockingClientHandler.returnClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.returnClientHandler() target is: nonBlockingClientHandler method is: returnClientHandler()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: returnClientHandler()V
statement is: assertNotNull(clientHandler), class spoon.support.reflect.code.CtInvocationImpl
invocation is: assertNotNull(clientHandler) target is:  method is: assertNotNull(<unknown>)
statement is: // Test 3: Verify that the client handler is connected to the correct endpoint
String expectedEndpoint = "http://localhost:8080", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String actualEndpoint = clientHandler.getEndpoint(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtInvocationImpl
invocation is: clientHandler.getEndpoint() target is: clientHandler method is: getEndpoint()
statement is: assertEquals(expectedEndpoint, actualEndpoint), class spoon.support.reflect.code.CtInvocationImpl
invocation is: assertEquals(expectedEndpoint, actualEndpoint) target is:  method is: assertEquals(java.lang.String,java.lang.String)
* this is vulnerable: String string = "http://localhost:8080"
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.returnClientHandler();
String string = "http://localhost:8080";

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: org.evosuite.testcase.statements.FieldStatement@fdb0d496 type is: class org.evosuite.testcase.statements.FieldStatement return type class org.quickserver.net.server.DataMode
statement code is: DataMode dataMode = DataMode.OBJECT
statement is: org.evosuite.testcase.statements.FieldStatement@c697d4fe type is: class org.evosuite.testcase.statements.FieldStatement return type class org.quickserver.net.server.DataType
statement code is: DataType dataType = DataType.OUT
statement is: setDataMode(Lorg/quickserver/net/server/DataMode;Lorg/quickserver/net/server/DataType;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.setDataMode(arg0, arg1)
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
DataMode dataMode = DataMode.OBJECT;
DataType dataType = DataType.OUT;
nonBlockingClientHandler.setDataMode(dataMode, dataType);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        DataMode dataMode = DataMode.OBJECT;
        DataType dataType = DataType.OUT;
        nonBlockingClientHandler.setDataMode(dataMode, dataType);
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: DataMode dataMode = DataMode.OBJECT, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtFieldReadImpl
Field is: DataMode.OBJECT is DataMode
CtField is: public static org.quickserver.net.server.DataMode org.quickserver.net.server.DataMode.OBJECT DataMode OBJECT
statement is: DataType dataType = DataType.OUT, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtFieldReadImpl
Field is: DataType.OUT is DataType
CtField is: public static org.quickserver.net.server.DataMode org.quickserver.net.server.DataMode.OBJECT DataMode OBJECT
CtField is: public static org.quickserver.net.server.DataType org.quickserver.net.server.DataType.OUT DataType OUT
statement is: nonBlockingClientHandler.setDataMode(dataMode, dataType), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.setDataMode(dataMode, dataType) target is: nonBlockingClientHandler method is: setDataMode(DataMode,DataType)
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: setDataMode(Lorg/quickserver/net/server/DataMode;Lorg/quickserver/net/server/DataType;)V
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
DataMode dataMode = DataMode.OBJECT;
DataType dataType = DataType.OUT;
nonBlockingClientHandler.setDataMode(dataMode, dataType);

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: org.evosuite.testcase.statements.FieldStatement@c697d4fe type is: class org.evosuite.testcase.statements.FieldStatement return type class org.quickserver.net.server.DataType
statement code is: DataType dataType = DataType.OUT
statement is: setDataMode(Lorg/quickserver/net/server/DataMode;Lorg/quickserver/net/server/DataType;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.setDataMode((DataMode) null, arg1)
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
DataType dataType = DataType.OUT;
nonBlockingClientHandler.setDataMode((DataMode) null, dataType);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        DataType dataType = DATA_TYPE_OUTGOING;
        nonBlockingClientHandler.setDataMode(DATA_MODE_BLOCKING, dataType);
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: DataType dataType = DATA_TYPE_OUTGOING, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtFieldReadImpl
statement is: nonBlockingClientHandler.setDataMode(DATA_MODE_BLOCKING, dataType), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.setDataMode(DATA_MODE_BLOCKING, dataType) target is: nonBlockingClientHandler method is: setDataMode(DataType)
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: setDataMode(Lorg/quickserver/net/server/DataMode;Lorg/quickserver/net/server/DataType;)V
i 0 Parameters size() 0 Num of Method Parameters: 2
i 1 Parameters size() 0 Num of Method Parameters: 2
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
DataMode dataMode = null;
DataType dataType = null;
nonBlockingClientHandler.setDataMode(dataMode, dataType);

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: org.evosuite.testcase.statements.FieldStatement@c596b5b2 type is: class org.evosuite.testcase.statements.FieldStatement return type class org.quickserver.net.server.ClientEvent
statement code is: ClientEvent clientEvent = ClientEvent.RUN_BLOCKING
statement is: addEvent(Lorg/quickserver/net/server/ClientEvent;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.addEvent(arg0)
statement is: registerForWrite()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.registerForWrite()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.RUN_BLOCKING;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.registerForWrite();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        ClientEvent clientEvent = ClientEvent.RUN_BLOCKING;
        nonBlockingClientHandler.addEvent(clientEvent);
        nonBlockingClientHandler.registerForWrite();
        // Changed the value of 'clientEvent' to a more descriptive and representative value
        clientEvent = ClientEvent.CLOSED;
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: ClientEvent clientEvent = ClientEvent.RUN_BLOCKING, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtFieldReadImpl
Field is: ClientEvent.RUN_BLOCKING is ClientEvent
CtField is: public static org.quickserver.net.server.ClientEvent org.quickserver.net.server.ClientEvent.RUN_BLOCKING ClientEvent RUN_BLOCKING
statement is: nonBlockingClientHandler.addEvent(clientEvent), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.addEvent(clientEvent) target is: nonBlockingClientHandler method is: addEvent(ClientEvent)
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: addEvent(Lorg/quickserver/net/server/ClientEvent;)V
statement is: nonBlockingClientHandler.registerForWrite(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.registerForWrite() target is: nonBlockingClientHandler method is: registerForWrite()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: registerForWrite()V
statement is: // Changed the value of 'clientEvent' to a more descriptive and representative value
clientEvent = ClientEvent.CLOSED, class spoon.support.reflect.code.CtAssignmentImpl
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.RUN_BLOCKING;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.registerForWrite();

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: registerForWrite()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.registerForWrite()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.registerForWrite();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        nonBlockingClientHandler.registerForWrite("Hello, World!", 100);
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.registerForWrite("Hello, World!", 100), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.registerForWrite("Hello, World!", 100) target is: nonBlockingClientHandler method is: registerForWrite(java.lang.String,int)
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: org.evosuite.testcase.statements.FieldStatement@93df0ae6 type is: class org.evosuite.testcase.statements.FieldStatement return type class org.quickserver.net.server.ClientEvent
statement code is: ClientEvent clientEvent = ClientEvent.MAX_CON_BLOCKING
statement is: addEvent(Lorg/quickserver/net/server/ClientEvent;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.addEvent(arg0)
statement is: registerForWrite()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.registerForWrite()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.MAX_CON_BLOCKING;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.registerForWrite();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        ClientEvent clientEvent = ClientEvent.MAX_CONNECTIONS;
        nonBlockingClientHandler.addEvent(clientEvent);
        nonBlockingClientHandler.registerForWrite();
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: ClientEvent clientEvent = ClientEvent.MAX_CONNECTIONS, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtFieldReadImpl
Field is: ClientEvent.MAX_CONNECTIONS is ClientEvent
CtField is: public static org.quickserver.net.server.ClientEvent org.quickserver.net.server.ClientEvent.MAX_CON_BLOCKING ClientEvent MAX_CON_BLOCKING
statement is: nonBlockingClientHandler.addEvent(clientEvent), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.addEvent(clientEvent) target is: nonBlockingClientHandler method is: addEvent(ClientEvent)
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: addEvent(Lorg/quickserver/net/server/ClientEvent;)V
statement is: nonBlockingClientHandler.registerForWrite(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.registerForWrite() target is: nonBlockingClientHandler method is: registerForWrite()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: registerForWrite()V
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.MAX_CON_BLOCKING;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.registerForWrite();

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: getSocketChannel()Ljava/nio/channels/SocketChannel; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.nio.channels.SocketChannel
statement code is: SocketChannel socketChannel = nonBlockingClientHandler.getSocketChannel()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.getSocketChannel();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        nonBlockingClientHandler.getSocketChannel();
        // The getSocketChannel() method is used to obtain the SocketChannel associated with the NonBlockingClientHandler instance. This method returns a reference to the SocketChannel object, which can be used for further operations such as reading and writing data to the socket. }}
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.getSocketChannel(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.getSocketChannel() target is: nonBlockingClientHandler method is: getSocketChannel()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: getSocketChannel()Ljava/nio/channels/SocketChannel;
statement is: // The getSocketChannel() method is used to obtain the SocketChannel associated with the NonBlockingClientHandler instance. This method returns a reference to the SocketChannel object, which can be used for further operations such as reading and writing data to the socket. }}, class spoon.support.reflect.code.CtCommentImpl
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.getSocketChannel();

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: clean()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.clean()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.clean();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        nonBlockingClientHandler.clean();
        // Improved test data
        int initialValue = 10;
        String stringToAppend = "Hello World";
        double doubleValue = 3.14;
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.clean(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.clean() target is: nonBlockingClientHandler method is: clean()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler()V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 0
Matched Method is: clean()V
statement is: // Improved test data
int initialValue = 10, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String stringToAppend = "Hello World", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: double doubleValue = 3.14, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
* this is vulnerable: int _int = 10
* this is vulnerable: String string = "Hello World"
* this is vulnerable: double _double = 3.14
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.clean();
int _int = 10;
String string = "Hello World";
double _double = 3.14;

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32)
statement is: getSelectionKey()Ljava/nio/channels/SelectionKey; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.nio.channels.SelectionKey
statement code is: SelectionKey selectionKey = nonBlockingClientHandler.getSelectionKey()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.getSelectionKey();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
        assertTrue(nonBlockingClientHandler.getSelectionKey() != null);
        // Original test data
        SelectionKey selectionKey = nonBlockingClientHandler.getSelectionKey();
        assertEquals(selectionKey.readyOps(), SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    }
}
statement is: // Improved test data
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: assertTrue(nonBlockingClientHandler.getSelectionKey() != null), class spoon.support.reflect.code.CtInvocationImpl
invocation is: assertTrue(nonBlockingClientHandler.getSelectionKey() != null) target is:  method is: assertTrue(<unknown>)
statement is: // Original test data
SelectionKey selectionKey = nonBlockingClientHandler.getSelectionKey(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.getSelectionKey() target is: nonBlockingClientHandler method is: getSelectionKey()
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
Matched Method is: getSelectionKey()Ljava/nio/channels/SelectionKey;
statement is: assertEquals(selectionKey.readyOps(), SelectionKey.OP_READ | SelectionKey.OP_WRITE), class spoon.support.reflect.code.CtInvocationImpl
invocation is: assertEquals(selectionKey.readyOps(), SelectionKey.OP_READ | SelectionKey.OP_WRITE) target is:  method is: assertEquals(<unknown>,<unknown>)
TestCase is: int _int = 32;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(_int);
((NonBlockingClientHandler) _int).getSelectionKey();

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: returnThread()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.returnThread()
statement is: getThreadAccessCount()I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int threadAccessCount = nonBlockingClientHandler.getThreadAccessCount()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.getThreadAccessCount();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(10);
        nonBlockingClientHandler.returnThread();
        nonBlockingClientHandler.getThreadAccessCount();
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(10), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.returnThread(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.returnThread() target is: nonBlockingClientHandler method is: returnThread()
statement is: nonBlockingClientHandler.getThreadAccessCount(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.getThreadAccessCount() target is: nonBlockingClientHandler method is: getThreadAccessCount()
statement is: setWakeupSelectorAfterRegisterWrite(Z)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(false)
statement is: getWakeupSelectorAfterRegisterWrite()Z type is: class org.evosuite.testcase.statements.MethodStatement return type boolean
statement code is: boolean wakeupSelectorAfterRegisterWrite = NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite()
test data is: NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(false);
NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(true);
        assertTrue(NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite());
        NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(false);
        assertFalse(NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite());
    }
}
statement is: NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(true), class spoon.support.reflect.code.CtInvocationImpl
invocation is: NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(true) target is: NonBlockingClientHandler method is: setWakeupSelectorAfterRegisterWrite(boolean)
Matched Method is: setWakeupSelectorAfterRegisterWrite(Z)V
statement is: assertTrue(NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite()), class spoon.support.reflect.code.CtInvocationImpl
invocation is: assertTrue(NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite()) target is:  method is: assertTrue(<unknown>)
statement is: NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(false), class spoon.support.reflect.code.CtInvocationImpl
invocation is: NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(false) target is: NonBlockingClientHandler method is: setWakeupSelectorAfterRegisterWrite(boolean)
Matched Method is: setWakeupSelectorAfterRegisterWrite(Z)V
statement is: assertFalse(NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite()), class spoon.support.reflect.code.CtInvocationImpl
invocation is: assertFalse(NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite()) target is:  method is: assertFalse(<unknown>)
TestCase is: boolean _boolean = true;
NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(_boolean);
boolean _boolean = false;
NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(_boolean);

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60)
statement is: allocateDirect(I)Ljava/nio/ByteBuffer; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.nio.ByteBuffer
statement code is: ByteBuffer allocateDirect = ByteBuffer.allocateDirect(60)
statement is: encrypt(Ljava/nio/ByteBuffer;)Ljava/nio/ByteBuffer; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.nio.ByteBuffer
statement code is: ByteBuffer encrypt = nonBlockingClientHandler.encrypt(arg0)
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
ByteBuffer allocateDirect = ByteBuffer.allocateDirect(60);
nonBlockingClientHandler.encrypt(allocateDirect);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(128);
        ByteBuffer allocateDirect = ByteBuffer.allocateDirect(128);
        nonBlockingClientHandler.encrypt(allocateDirect);
        // Improved test data
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
        ByteBuffer allocateDirect = ByteBuffer.allocateDirect(60);
        nonBlockingClientHandler.encrypt(allocateDirect);
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(128), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: ByteBuffer allocateDirect = ByteBuffer.allocateDirect(128), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtInvocationImpl
invocation is: ByteBuffer.allocateDirect(128) target is: ByteBuffer method is: allocateDirect(int)
Matched Method is: allocateDirect(I)Ljava/nio/ByteBuffer;
statement is: nonBlockingClientHandler.encrypt(allocateDirect), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.encrypt(allocateDirect) target is: nonBlockingClientHandler method is: encrypt(ByteBuffer)
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
Matched Method is: encrypt(Ljava/nio/ByteBuffer;)Ljava/nio/ByteBuffer;
statement is: // Improved test data
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: ByteBuffer allocateDirect = ByteBuffer.allocateDirect(60), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtInvocationImpl
invocation is: ByteBuffer.allocateDirect(60) target is: ByteBuffer method is: allocateDirect(int)
Matched Method is: allocateDirect(I)Ljava/nio/ByteBuffer;
statement is: nonBlockingClientHandler.encrypt(allocateDirect), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.encrypt(allocateDirect) target is: nonBlockingClientHandler method is: encrypt(ByteBuffer)
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 6
Matched Method is: encrypt(Ljava/nio/ByteBuffer;)Ljava/nio/ByteBuffer;
TestCase is: int _int = 128;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(_int);
int _int = 128;
ByteBuffer allocateDirect = ByteBuffer.allocateDirect(_int);
((NonBlockingClientHandler) _int).encrypt(allocateDirect);
int _int = 60;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(_int);
int _int = 60;
ByteBuffer allocateDirect = ByteBuffer.allocateDirect(_int);
((NonBlockingClientHandler) _int).encrypt(allocateDirect);

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1173)
statement is: org.quickserver.net.server.TheClient()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.TheClient
statement code is: TheClient theClient = new TheClient()
statement is: org.quickserver.net.server.QuickServer(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.QuickServer
statement code is: QuickServer quickServer = new QuickServer("cl,<%?H")
statement is: setServer(Lorg/quickserver/net/server/QuickServer;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: theClient.setServer(arg0)
statement is: handleClient(Lorg/quickserver/net/server/TheClient;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.handleClient(arg0)
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1173);
TheClient theClient = new TheClient();
QuickServer quickServer = new QuickServer("cl,<%?H");
theClient.setServer(quickServer);
nonBlockingClientHandler.handleClient(theClient);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1024);
        TheClient theClient = new TheClient();
        theClient.setServer(new QuickServer("localhost", 1234));
        nonBlockingClientHandler.handleClient(theClient);
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1024), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: TheClient theClient = new TheClient(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: theClient.setServer(new QuickServer("localhost", 1234)), class spoon.support.reflect.code.CtInvocationImpl
invocation is: theClient.setServer(new QuickServer("localhost", 1234)) target is: theClient method is: setServer(QuickServer)
source statement: org.quickserver.net.server.TheClient()V callee: VariableReference: Statement 1, type org.quickserver.net.server.TheClientindex is: 2
Matched Method is: setServer(Lorg/quickserver/net/server/QuickServer;)V
i 0 Parameters size() 0 Num of Method Parameters: 1
statement is: nonBlockingClientHandler.handleClient(theClient), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.handleClient(theClient) target is: nonBlockingClientHandler method is: handleClient(TheClient)
source statement: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V callee: VariableReference: Statement 0, type org.quickserver.net.server.impl.NonBlockingClientHandlerindex is: 1
Matched Method is: handleClient(Lorg/quickserver/net/server/TheClient;)V
TestCase is: int _int = 1024;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(_int);
TheClient theClient = new TheClient();
QuickServer quickServer = null;
((TheClient) nonBlockingClientHandler).setServer(quickServer);
((NonBlockingClientHandler) _int).handleClient(theClient);

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: registerForRead()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.registerForRead()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.registerForRead();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler("example.com", 80);
        nonBlockingClientHandler.registerForRead();
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler("example.com", 80), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.registerForRead(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.registerForRead() target is: nonBlockingClientHandler method is: registerForRead()
statement is: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(0)
statement is: registerWrite()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.registerWrite()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(0);
nonBlockingClientHandler.registerWrite();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
    }
}
statement is: org.quickserver.net.server.impl.NonBlockingClientHandler()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler()
statement is: updateInputOutputStreams()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.updateInputOutputStreams()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.updateInputOutputStreams();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
        nonBlockingClientHandler.updateInputOutputStreams(inputStream, outputStream);
    }
}
statement is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: nonBlockingClientHandler.updateInputOutputStreams(inputStream, outputStream), class spoon.support.reflect.code.CtInvocationImpl
invocation is: nonBlockingClientHandler.updateInputOutputStreams(inputStream, outputStream) target is: nonBlockingClientHandler method is: updateInputOutputStreams()
TestCase is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();

statement is: org.quickserver.net.server.impl.NonBlockingClientHandler(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class org.quickserver.net.server.impl.NonBlockingClientHandler
statement code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1987)
statement is: waitTillFullyWritten()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: nonBlockingClientHandler.waitTillFullyWritten()
test data is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1987);
nonBlockingClientHandler.waitTillFullyWritten();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        int port = 8080;
        String serverAddress = "localhost";
        String clientAddress = "192.168.1.100";
        boolean isFullyWritten = false;
    }
}
statement is: int port = 8080, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String serverAddress = "localhost", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String clientAddress = "192.168.1.100", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: boolean isFullyWritten = false, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
* this is vulnerable: int _int = 8080
* this is vulnerable: String string = "localhost"
* this is vulnerable: String string = "192.168.1.100"
* this is vulnerable: boolean _boolean = false
TestCase is: int _int = 8080;
String string = "localhost";
String string = "192.168.1.100";
boolean _boolean = false;

* test suite isTestSuite: 75
Test 0: 
NonBlockingClientHandler.getMaxThreadAccessCount();
Test 1: 
NonBlockingClientHandler.getWakeupSelectorAfterRegisterRead();
Test 2: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.finalize();
Test 3: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.getInitialHandshakeStatus();
Test 4: 
NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite();
Test 5: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
nonBlockingClientHandler.setClientWriteHandler((ClientWriteHandler) null);
Test 6: 
NonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(false);
Test 7: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
nonBlockingClientHandler.getBlockingMode();
Test 8: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
nonBlockingClientHandler.setSocketChannel((SocketChannel) null);
Test 9: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1987);
nonBlockingClientHandler.getThreadAccessCount();
Test 10: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
try { 
  nonBlockingClientHandler.readInputStream();
  fail("Expecting exception: IOException");

} catch(IOException e) {
   //
   // InputStream can't be null!
   //
   verifyException("org.quickserver.net.server.impl.BasicClientHandler", e);
}

Test 11: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.getBufferedReader();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // Access to BufferedReader in not allowed in Non-Blocking mode!
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 12: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setSelectionKey((SelectionKey) null);
Test 13: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.LOST_CON;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.run();
Test 14: 
NonBlockingClientHandler.setMaxThreadAccessCount(1987);
Test 15: 
// Undeclared exception!
try { 
  NonBlockingClientHandler.setMaxThreadAccessCount((byte) (-105));
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // Value should be >=3 or -1
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 16: 
NonBlockingClientHandler.setMaxThreadAccessCount((-1));
Test 17: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.clean();
Test 18: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setInputStream((InputStream) null);
Test 19: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.closeConnection();
Test 20: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.secure = true;
// Undeclared exception!
try { 
  nonBlockingClientHandler.closeIfSSLOutboundDone();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 21: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.closeIfSSLOutboundDone();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // Client is not in secure mode!
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 22: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.run();
Test 23: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.checkReturnClientHandler();
nonBlockingClientHandler.checkReturnClientHandler();
Test 24: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.returnClientHandler();
Test 25: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
DataMode dataMode = DataMode.OBJECT;
DataType dataType = DataType.OUT;
// Undeclared exception!
try { 
  nonBlockingClientHandler.setDataMode(dataMode, dataType);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 26: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
DataType dataType = DataType.OUT;
nonBlockingClientHandler.setDataMode((DataMode) null, dataType);
Test 27: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.RUN_BLOCKING;
nonBlockingClientHandler.addEvent(clientEvent);
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerForWrite();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // This method is only allowed under Non-Blocking mode.
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 28: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerForWrite();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // ClientWriteHandler has not been set!
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 29: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.MAX_CON_BLOCKING;
nonBlockingClientHandler.addEvent(clientEvent);
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerForWrite();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // This method is only allowed under Non-Blocking mode.
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 30: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.getSocketChannel();
Test 31: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.clean();
Test 32: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
// Undeclared exception!
try { 
  nonBlockingClientHandler.getSelectionKey();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 33: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.getThreadAccessCount();
Test 34: 
NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(false);
NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite();
Test 35: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
ByteBuffer allocateDirect = ByteBuffer.allocateDirect(60);
try { 
  nonBlockingClientHandler.encrypt(allocateDirect);
  fail("Expecting exception: IOException");

} catch(IOException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 36: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1173);
TheClient theClient = new TheClient();
QuickServer quickServer = new QuickServer("cl,<%?H");
theClient.setServer(quickServer);
nonBlockingClientHandler.handleClient(theClient);
Test 37: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerForRead();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 38: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(0);
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerWrite();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 39: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.updateInputOutputStreams();
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // Null charset name
   //
   verifyException("java.nio.charset.Charset", e);
}

Test 40: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1987);
// Undeclared exception!
try { 
  nonBlockingClientHandler.waitTillFullyWritten();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 41: 
NonBlockingClientHandler.getMaxThreadAccessCount();

Test 42: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.finalize();

Test 43: 
int _int = 32;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
((NonBlockingClientHandler)32).getInitialHandshakeStatus();
((NonBlockingClientHandler) _int).getInitialHandshakeStatus();

Test 44: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
((NonBlockingClientHandler)60).setClientWriteHandler((ClientWriteHandler) null);

Test 45: 
NonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(true);

Test 46: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(10);
((NonBlockingClientHandler)10).getBlockingMode();

Test 47: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
((NonBlockingClientHandler)60).setSocketChannel((SocketChannel) null);

Test 48: 
String string = "John Smith";
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler((int) "John Smith");
((NonBlockingClientHandler) string).getThreadAccessCount();

Test 49: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();

Test 50: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setSelectionKey((SelectionKey) null);

Test 51: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.LOST_CON;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.run();

Test 52: 
NonBlockingClientHandler.setMaxThreadAccessCount(1000);

Test 53: 
NonBlockingClientHandler.setMaxThreadAccessCount((int) (Integer) null);

Test 54: 
NonBlockingClientHandler.setMaxThreadAccessCount((int) (Integer) null);

Test 55: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setInputStream((InputStream) null);

Test 56: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(64);
((NonBlockingClientHandler)64).closeConnection();

Test 57: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.closeIfSSLOutboundDone();

Test 58: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.closeIfSSLOutboundDone();

Test 59: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
((NonBlockingClientHandler)32).run();

Test 60: 
int _int = 8;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(8);
((NonBlockingClientHandler)8).checkReturnClientHandler();
((NonBlockingClientHandler) _int).checkReturnClientHandler();

Test 61: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.returnClientHandler();

Test 62: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
DataMode dataMode = DataMode.OBJECT;
DataType dataType = DataType.OUT;
nonBlockingClientHandler.setDataMode(dataMode, dataType);

Test 63: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setDataMode((DataMode) null, (DataType) null);

Test 64: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.RUN_BLOCKING;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.registerForWrite();

Test 65: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();

Test 66: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.MAX_CON_BLOCKING;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.registerForWrite();

Test 67: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.getSocketChannel();

Test 68: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.clean();

Test 69: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
((NonBlockingClientHandler)32).getSelectionKey();

Test 70: 
NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(true);
NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(false);

Test 71: 
int _int = 128;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(128);
ByteBuffer allocateDirect = ByteBuffer.allocateDirect(128);
((NonBlockingClientHandler)128).encrypt(allocateDirect);
int _int = 60;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(_int);
int _int = 60;
ByteBuffer allocateDirect = ByteBuffer.allocateDirect(_int);
((NonBlockingClientHandler) _int).encrypt(allocateDirect);

Test 72: 
int _int = 1024;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1024);
TheClient theClient = new TheClient();
((TheClient) nonBlockingClientHandler).setServer((QuickServer) null);
((NonBlockingClientHandler) _int).handleClient(theClient);

Test 73: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();

Test 74: 


* Generated after the refinement and before minimization 75 tests with total length 175
* test suite isTestSuite: 75
Test 0: 
NonBlockingClientHandler.getMaxThreadAccessCount();
Test 1: 
NonBlockingClientHandler.getWakeupSelectorAfterRegisterRead();
Test 2: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.finalize();
Test 3: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.getInitialHandshakeStatus();
Test 4: 
NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite();
Test 5: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
nonBlockingClientHandler.setClientWriteHandler((ClientWriteHandler) null);
Test 6: 
NonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(false);
Test 7: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
nonBlockingClientHandler.getBlockingMode();
Test 8: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
nonBlockingClientHandler.setSocketChannel((SocketChannel) null);
Test 9: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1987);
nonBlockingClientHandler.getThreadAccessCount();
Test 10: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
try { 
  nonBlockingClientHandler.readInputStream();
  fail("Expecting exception: IOException");

} catch(IOException e) {
   //
   // InputStream can't be null!
   //
   verifyException("org.quickserver.net.server.impl.BasicClientHandler", e);
}

Test 11: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.getBufferedReader();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // Access to BufferedReader in not allowed in Non-Blocking mode!
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 12: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setSelectionKey((SelectionKey) null);
Test 13: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.LOST_CON;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.run();
Test 14: 
NonBlockingClientHandler.setMaxThreadAccessCount(1987);
Test 15: 
// Undeclared exception!
try { 
  NonBlockingClientHandler.setMaxThreadAccessCount((byte) (-105));
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // Value should be >=3 or -1
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 16: 
NonBlockingClientHandler.setMaxThreadAccessCount((-1));
Test 17: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.clean();
Test 18: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setInputStream((InputStream) null);
Test 19: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.closeConnection();
Test 20: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.secure = true;
// Undeclared exception!
try { 
  nonBlockingClientHandler.closeIfSSLOutboundDone();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 21: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.closeIfSSLOutboundDone();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // Client is not in secure mode!
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 22: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.run();
Test 23: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.checkReturnClientHandler();
nonBlockingClientHandler.checkReturnClientHandler();
Test 24: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.returnClientHandler();
Test 25: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
DataMode dataMode = DataMode.OBJECT;
DataType dataType = DataType.OUT;
// Undeclared exception!
try { 
  nonBlockingClientHandler.setDataMode(dataMode, dataType);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 26: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
DataType dataType = DataType.OUT;
nonBlockingClientHandler.setDataMode((DataMode) null, dataType);
Test 27: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.RUN_BLOCKING;
nonBlockingClientHandler.addEvent(clientEvent);
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerForWrite();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // This method is only allowed under Non-Blocking mode.
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 28: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerForWrite();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // ClientWriteHandler has not been set!
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 29: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.MAX_CON_BLOCKING;
nonBlockingClientHandler.addEvent(clientEvent);
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerForWrite();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // This method is only allowed under Non-Blocking mode.
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 30: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.getSocketChannel();
Test 31: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.clean();
Test 32: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
// Undeclared exception!
try { 
  nonBlockingClientHandler.getSelectionKey();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 33: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.getThreadAccessCount();
Test 34: 
NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(false);
NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite();
Test 35: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
ByteBuffer allocateDirect = ByteBuffer.allocateDirect(60);
try { 
  nonBlockingClientHandler.encrypt(allocateDirect);
  fail("Expecting exception: IOException");

} catch(IOException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 36: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1173);
TheClient theClient = new TheClient();
QuickServer quickServer = new QuickServer("cl,<%?H");
theClient.setServer(quickServer);
nonBlockingClientHandler.handleClient(theClient);
Test 37: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerForRead();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 38: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(0);
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerWrite();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 39: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.updateInputOutputStreams();
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // Null charset name
   //
   verifyException("java.nio.charset.Charset", e);
}

Test 40: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1987);
// Undeclared exception!
try { 
  nonBlockingClientHandler.waitTillFullyWritten();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 41: 
NonBlockingClientHandler.getMaxThreadAccessCount();

Test 42: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.finalize();

Test 43: 
int _int = 32;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
((NonBlockingClientHandler)32).getInitialHandshakeStatus();
((NonBlockingClientHandler) _int).getInitialHandshakeStatus();

Test 44: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
((NonBlockingClientHandler)60).setClientWriteHandler((ClientWriteHandler) null);

Test 45: 
NonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(true);

Test 46: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(10);
((NonBlockingClientHandler)10).getBlockingMode();

Test 47: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
((NonBlockingClientHandler)60).setSocketChannel((SocketChannel) null);

Test 48: 
String string = "John Smith";
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler((int) "John Smith");
((NonBlockingClientHandler) string).getThreadAccessCount();

Test 49: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();

Test 50: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setSelectionKey((SelectionKey) null);

Test 51: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.LOST_CON;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.run();

Test 52: 
NonBlockingClientHandler.setMaxThreadAccessCount(1000);

Test 53: 
NonBlockingClientHandler.setMaxThreadAccessCount((int) (Integer) null);

Test 54: 
NonBlockingClientHandler.setMaxThreadAccessCount((int) (Integer) null);

Test 55: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setInputStream((InputStream) null);

Test 56: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(64);
((NonBlockingClientHandler)64).closeConnection();

Test 57: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.closeIfSSLOutboundDone();

Test 58: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.closeIfSSLOutboundDone();

Test 59: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
((NonBlockingClientHandler)32).run();

Test 60: 
int _int = 8;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(8);
((NonBlockingClientHandler)8).checkReturnClientHandler();
((NonBlockingClientHandler) _int).checkReturnClientHandler();

Test 61: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.returnClientHandler();

Test 62: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
DataMode dataMode = DataMode.OBJECT;
DataType dataType = DataType.OUT;
nonBlockingClientHandler.setDataMode(dataMode, dataType);

Test 63: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setDataMode((DataMode) null, (DataType) null);

Test 64: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.RUN_BLOCKING;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.registerForWrite();

Test 65: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();

Test 66: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.MAX_CON_BLOCKING;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.registerForWrite();

Test 67: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.getSocketChannel();

Test 68: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.clean();

Test 69: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
((NonBlockingClientHandler)32).getSelectionKey();

Test 70: 
NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(true);
NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(false);

Test 71: 
int _int = 128;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(128);
ByteBuffer allocateDirect = ByteBuffer.allocateDirect(128);
((NonBlockingClientHandler)128).encrypt(allocateDirect);
int _int = 60;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(_int);
int _int = 60;
ByteBuffer allocateDirect = ByteBuffer.allocateDirect(_int);
((NonBlockingClientHandler) _int).encrypt(allocateDirect);

Test 72: 
int _int = 1024;
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1024);
TheClient theClient = new TheClient();
((TheClient) nonBlockingClientHandler).setServer((QuickServer) null);
((NonBlockingClientHandler) _int).handleClient(theClient);

Test 73: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();

Test 74: 


* Minimizing test suite
* test suite isTestSuite: 41
Test 0: 
NonBlockingClientHandler.getMaxThreadAccessCount();
Test 1: 
NonBlockingClientHandler.getWakeupSelectorAfterRegisterRead();
Test 2: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.finalize();
Test 3: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.getInitialHandshakeStatus();
Test 4: 
NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite();
Test 5: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
nonBlockingClientHandler.setClientWriteHandler((ClientWriteHandler) null);
Test 6: 
NonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(true);
Test 7: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
nonBlockingClientHandler.getBlockingMode();
Test 8: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
nonBlockingClientHandler.setSocketChannel((SocketChannel) null);
Test 9: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1987);
nonBlockingClientHandler.getThreadAccessCount();
Test 10: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
try { 
  nonBlockingClientHandler.readInputStream();
  fail("Expecting exception: IOException");

} catch(IOException e) {
   //
   // InputStream can't be null!
   //
   verifyException("org.quickserver.net.server.impl.BasicClientHandler", e);
}

Test 11: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.getBufferedReader();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // Access to BufferedReader in not allowed in Non-Blocking mode!
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 12: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setSelectionKey((SelectionKey) null);
Test 13: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.getSocketChannel();
Test 14: 
NonBlockingClientHandler.setMaxThreadAccessCount(1000);
Test 15: 
NonBlockingClientHandler.setMaxThreadAccessCount((-1));
Test 16: 
// Undeclared exception!
try { 
  NonBlockingClientHandler.setMaxThreadAccessCount((byte) (-105));
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // Value should be >=3 or -1
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 17: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.clean();
Test 18: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setInputStream((InputStream) null);
Test 19: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.closeConnection();
Test 20: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.secure = true;
// Undeclared exception!
try { 
  nonBlockingClientHandler.closeIfSSLOutboundDone();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 21: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.closeIfSSLOutboundDone();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // Client is not in secure mode!
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 22: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.LOST_CON;
nonBlockingClientHandler.addEvent(clientEvent);
nonBlockingClientHandler.run();
Test 23: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.run();
Test 24: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.checkReturnClientHandler();
nonBlockingClientHandler.checkReturnClientHandler();
Test 25: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.returnClientHandler();
Test 26: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
DataMode dataMode = DataMode.OBJECT;
DataType dataType = DataType.OUT;
// Undeclared exception!
try { 
  nonBlockingClientHandler.setDataMode(dataMode, dataType);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 27: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
DataType dataType = DataType.OUT;
nonBlockingClientHandler.setDataMode((DataMode) null, dataType);
Test 28: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.RUN_BLOCKING;
nonBlockingClientHandler.addEvent(clientEvent);
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerForWrite();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // This method is only allowed under Non-Blocking mode.
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 29: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerForWrite();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // ClientWriteHandler has not been set!
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 30: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
ClientEvent clientEvent = ClientEvent.MAX_CON_BLOCKING;
nonBlockingClientHandler.addEvent(clientEvent);
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerForWrite();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // This method is only allowed under Non-Blocking mode.
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 31: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
ByteBuffer allocateDirect = ByteBuffer.allocateDirect(60);
try { 
  nonBlockingClientHandler.encrypt(allocateDirect);
  fail("Expecting exception: IOException");

} catch(IOException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 32: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.clean();
Test 33: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
// Undeclared exception!
try { 
  nonBlockingClientHandler.getSelectionKey();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 34: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.getThreadAccessCount();
Test 35: 
NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(false);
NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite();
Test 36: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1173);
TheClient theClient = new TheClient();
QuickServer quickServer = new QuickServer("cl,<%?H");
theClient.setServer(quickServer);
nonBlockingClientHandler.handleClient(theClient);
Test 37: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerForRead();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 38: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(0);
// Undeclared exception!
try { 
  nonBlockingClientHandler.registerWrite();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}

Test 39: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.updateInputOutputStreams();
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // Null charset name
   //
   verifyException("java.nio.charset.Charset", e);
}

Test 40: 
NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1987);
// Undeclared exception!
try { 
  nonBlockingClientHandler.waitTillFullyWritten();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}


* Going to analyze the coverage criteria
* Coverage analysis for criterion BRANCH
* Coverage of criterion BRANCH: 13%
* Total number of goals: 501
* Number of covered goals: 67
* Coverage analysis for criterion LINE
* Coverage of criterion LINE: 21%
* Total number of goals: 723
* Number of covered goals: 151
* Coverage analysis for criterion OUTPUT
* Coverage of criterion OUTPUT: 14%
* Total number of goals: 78
* Number of covered goals: 11
* Coverage analysis for criterion METHOD
* Coverage of criterion METHOD: 100%
* Total number of goals: 35
* Number of covered goals: 35
* Coverage analysis for criterion CBRANCH
* Coverage of criterion CBRANCH: 13%
* Total number of goals: 501
* Number of covered goals: 67
* Generated 41 tests with total length 93
* Resulting test suite's coverage: 30% (average coverage for all fitness functions)
* Generating assertions
* Resulting test suite's mutation score: 33%
* Compiling and checking tests
Going to execute: removeTestsThatDoNotCompile
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: int maxThreadAccessCount = NonBlockingClientHandler.getMaxThreadAccessCount();
assertEquals(5, maxThreadAccessCount);


** It was a parseable test case! 
refined test name is: testGetMaxThreadAccessCount
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: boolean wakeupSelectorAfterRegisterRead = NonBlockingClientHandler.getWakeupSelectorAfterRegisterRead();
assertTrue(wakeupSelectorAfterRegisterRead);


** It was a parseable test case! 
refined test name is: testGetWakeupSelectorAfterRegisterReadReturnsTrue
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.finalize();
assertEquals("<ClientHandler-Pool#-1-ID:1>", nonBlockingClientHandler.getName());


** It was a parseable test case! 
refined test name is: testFinalizeMethodDoesNotThrowAnyExceptions
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
boolean initialHandshakeStatus = nonBlockingClientHandler.getInitialHandshakeStatus();
assertEquals("<ClientHandler-Pool#32-ID:1>", nonBlockingClientHandler.getName());
assertFalse(initialHandshakeStatus);


** It was a parseable test case! 
refined test name is: testInitialHandshakeStatusIsFalse
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: boolean wakeupSelectorAfterRegisterWrite = NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite();
assertTrue(wakeupSelectorAfterRegisterWrite);


** It was a parseable test case! 
refined test name is: testGetWakeupSelectorAfterRegisterWrite
* Compiling Tests
refined test name is: testGetWakeupSelectorAfterRegisterWrite
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
nonBlockingClientHandler.setClientWriteHandler((ClientWriteHandler) null);
assertEquals("<ClientHandler-Pool#60-ID:1>", nonBlockingClientHandler.getName());


** It was a parseable test case! 
refined test name is: testSetClientWriteHandlerWithNullParameter
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(true);

** It was a parseable test case! 
refined test name is: testSetWakeupSelectorAfterRegisterReadFlag
* Compiling Tests
refined test name is: testSetWakeupSelectorAfterRegisterRead
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
boolean blockingMode = nonBlockingClientHandler.getBlockingMode();
assertEquals("<ClientHandler-Pool#60-ID:7>", nonBlockingClientHandler.getName());
assertFalse(blockingMode);


** It was a parseable test case! 
refined test name is: testGetNameCorrectNameReturned
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(60);
nonBlockingClientHandler.setSocketChannel((SocketChannel) null);
assertEquals("<ClientHandler-Pool#60-ID:13>", nonBlockingClientHandler.getName());


** It was a parseable test case! 
refined test name is: testGetNameReturnsCorrectName
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1987);
int threadAccessCount = nonBlockingClientHandler.getThreadAccessCount();
assertEquals("<ClientHandler-Pool#1987-ID:1>", nonBlockingClientHandler.getName());
assertEquals(0, threadAccessCount);


** It was a parseable test case! 
refined test name is: testGetThreadAccessCountWhenNoActiveConnections
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
try { 
  nonBlockingClientHandler.readInputStream();
  fail("Expecting exception: IOException");

} catch(IOException e) {
   //
   // InputStream can't be null!
   //
   verifyException("org.quickserver.net.server.impl.BasicClientHandler", e);
}


** It was a parseable test case! 
refined test name is: testReadInputStreamInputStreamNull
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.getBufferedReader();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // Access to BufferedReader in not allowed in Non-Blocking mode!
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}


** It was a parseable test case! 
refined test name is: testGetBufferedReader
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setSelectionKey((SelectionKey) null);
assertEquals("<ClientHandler-Pool#-1-ID:42>", nonBlockingClientHandler.getName());


** It was a parseable test case! 
refined test name is: testSetSelectionKeyToNullSetsNameCorrectly
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.getSocketChannel();
assertEquals("<ClientHandler-Pool#-1-ID:48>", nonBlockingClientHandler.getName());


** It was a parseable test case! 
refined test name is: testClientSocketChannelName
* Compiling Tests
refined test name is: testGetSocketChannelNameReturnsClientHandler
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler.setMaxThreadAccessCount(1000);

** It was a parseable test case! 
refined test name is: testSetMaxThreadAccessCount
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler.setMaxThreadAccessCount((-1));

** It was a parseable test case! 
refined test name is: testSetMaxThreadAccessCountnegativeValue
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: // Undeclared exception!
try { 
  NonBlockingClientHandler.setMaxThreadAccessCount((byte) (-105));
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // Value should be >=3 or -1
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}


** It was a parseable test case! 
refined test name is: testSetMaxThreadAccessCountWithNegativeValue
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.returnThread();
nonBlockingClientHandler.clean();
assertEquals("<ClientHandler-Pool#-1-ID:53>", nonBlockingClientHandler.getName());


** It was a parseable test case! 
refined test name is: testReturnThreadAndClean
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.setInputStream((InputStream) null);
assertEquals("<ClientHandler-Pool#-1-ID:125>", nonBlockingClientHandler.getName());


** It was a parseable test case! 
refined test name is: testGetNameWithNullInputStream
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(32);
nonBlockingClientHandler.closeConnection();
assertEquals("<ClientHandler-Pool#32-ID:16>", nonBlockingClientHandler.getName());


** It was a parseable test case! 
refined test name is: testCloseConnectionShouldCloseConnection
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
nonBlockingClientHandler.secure = true;
// Undeclared exception!
try { 
  nonBlockingClientHandler.closeIfSSLOutboundDone();
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}


** It was a parseable test case! 
refined test name is: testCloseIfSSLOutboundDonehandshakeSuccessful
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
// Undeclared exception!
try { 
  nonBlockingClientHandler.closeIfSSLOutboundDone();
  fail("Expecting exception: IllegalStateException");

} catch(IllegalStateException e) {
   //
   // Client is not in secure mode!
   //
   verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
}


** It was a parseable test case! 
* Computation finished
