* EvoSuite 1.0.0-SNAPSHOT
* Going to generate test cases for class: wheel.asm.ClassWriter
* Starting Client-0
* Properties loaded from /home/roham/Results-Utestgen/dataset/SF110-new-res/80_wheelwebtool/evosuite-files/evosuite.properties
* Connecting to master process on port 6962
* Analyzing classpath: 
* Inheritance tree loaded from evosuite-files/inheritance.xml.gz
[MASTER] 22:10:26.167 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.Consumer
[MASTER] 22:10:26.177 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.Predicate
[MASTER] 22:10:26.178 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.UnaryOperator
[MASTER] 22:10:26.189 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.Temporal
[MASTER] 22:10:26.190 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.ZoneId
[MASTER] 22:10:26.192 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalAccessor
[MASTER] 22:10:26.193 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalField
[MASTER] 22:10:26.196 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalUnit
[MASTER] 22:10:26.198 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalAmount
[MASTER] 22:10:26.199 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.Clock
[MASTER] 22:10:26.201 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalQuery
[MASTER] 22:10:26.208 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalAdjuster
[MASTER] 22:10:26.211 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.Function
[MASTER] 22:10:26.261 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.BiFunction
[MASTER] 22:10:26.265 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.BiConsumer
* Finished analyzing classpath
* Generating tests for class wheel.asm.ClassWriter
* Test criteria:
  - Branch Coverage
  - Line Coverage
  - Method-Output Coverage
  - Top-Level Method Coverage
  - Context Branch Coverage
* Total number of test goals for DYNAMOSA: 778
* Using seed 1710367822263
* Starting evolution
[Progress:>                             0%] [Cov:>                                  0%]* Initial Number of Goals in DynaMOSA = 346 / 778
[Progress:>                             0%] [Cov:=================>                 51%][Progress:>                             1%] [Cov:====================>              58%][Progress:>                             1%] [Cov:=====================>             61%][Progress:>                             2%] [Cov:=====================>             62%][Progress:>                             2%] [Cov:======================>            65%][Progress:>                             2%] [Cov:=======================>           66%][Progress:>                             2%] [Cov:=======================>           66%][Progress:>                             2%] [Cov:=======================>           66%][Progress:>                             2%] [Cov:=======================>           67%][Progress:>                             2%] [Cov:=======================>           67%][Progress:>                             3%] [Cov:=======================>           67%][Progress:>                             3%] [Cov:=======================>           67%][Progress:>                             3%] [Cov:=======================>           67%][Progress:=>                            6%] [Cov:=======================>           67%][Progress:=>                            6%] [Cov:========================>          69%][Progress:=>                            6%] [Cov:========================>          70%][Progress:=>                            6%] [Cov:========================>          71%][Progress:=>                            6%] [Cov:========================>          71%][Progress:=>                            6%] [Cov:=========================>         72%][Progress:=>                            6%] [Cov:=========================>         72%][Progress:=>                            6%] [Cov:=========================>         72%][Progress:=>                            6%] [Cov:=========================>         72%][Progress:=>                            6%] [Cov:=========================>         73%][Progress:=>                            6%] [Cov:=========================>         73%][Progress:==>                           7%] [Cov:=========================>         73%][Progress:==>                           7%] [Cov:=========================>         73%][Progress:==>                           7%] [Cov:=========================>         73%][Progress:==>                           7%] [Cov:=========================>         73%][Progress:==>                           7%] [Cov:=========================>         73%][Progress:==>                           7%] [Cov:=========================>         74%][Progress:==>                           7%] [Cov:=========================>         74%][Progress:==>                           7%] [Cov:=========================>         74%][Progress:==>                           7%] [Cov:=========================>         74%][Progress:==>                           7%] [Cov:=========================>         74%][Progress:===>                          10%] [Cov:=========================>         74%][Progress:===>                          10%] [Cov:==========================>        75%][Progress:===>                          10%] [Cov:==========================>        75%][Progress:===>                          10%] [Cov:==========================>        75%][Progress:===>                          10%] [Cov:==========================>        75%][Progress:===>                          10%] [Cov:==========================>        75%][Progress:===>                          11%] [Cov:==========================>        75%][Progress:===>                          11%] [Cov:==========================>        76%][Progress:===>                          11%] [Cov:==========================>        76%][Progress:===>                          11%] [Cov:==========================>        76%][Progress:===>                          11%] [Cov:==========================>        76%][Progress:===>                          11%] [Cov:==========================>        76%][Progress:===>                          11%] [Cov:==========================>        76%][Progress:===>                          11%] [Cov:==========================>        77%][Progress:===>                          11%] [Cov:===========================>       78%][Progress:===>                          11%] [Cov:===========================>       78%][Progress:===>                          12%] [Cov:===========================>       78%][Progress:===>                          12%] [Cov:===========================>       78%][Progress:===>                          12%] [Cov:===========================>       78%][Progress:===>                          12%] [Cov:===========================>       78%][Progress:===>                          12%] [Cov:===========================>       78%][Progress:===>                          12%] [Cov:===========================>       78%][Progress:===>                          12%] [Cov:===========================>       78%][Progress:===>                          12%] [Cov:===========================>       78%][Progress:===>                          12%] [Cov:===========================>       78%][Progress:===>                          12%] [Cov:===========================>       78%][Progress:===>                          12%] [Cov:============================>      80%][Progress:===>                          12%] [Cov:============================>      80%][Progress:===>                          12%] [Cov:============================>      80%][Progress:===>                          12%] [Cov:============================>      80%][Progress:===>                          12%] [Cov:============================>      80%][Progress:===>                          13%] [Cov:============================>      80%][Progress:===>                          13%] [Cov:============================>      80%][Progress:===>                          13%] [Cov:============================>      80%][Progress:===>                          13%] [Cov:============================>      80%][Progress:=====>                        18%] [Cov:============================>      80%][Progress:=====>                        18%] [Cov:============================>      80%][Progress:=====>                        18%] [Cov:============================>      80%][Progress:=====>                        18%] [Cov:============================>      80%][Progress:======>                       21%] [Cov:============================>      80%][Progress:======>                       21%] [Cov:============================>      80%][Progress:======>                       21%] [Cov:============================>      81%][Progress:======>                       21%] [Cov:============================>      81%][Progress:======>                       21%] [Cov:============================>      81%][Progress:======>                       21%] [Cov:============================>      81%][Progress:======>                       21%] [Cov:============================>      81%][Progress:======>                       21%] [Cov:============================>      81%][Progress:======>                       21%] [Cov:============================>      81%][Progress:======>                       21%] [Cov:============================>      81%][Progress:======>                       21%] [Cov:============================>      81%][Progress:======>                       21%] [Cov:============================>      81%][Progress:======>                       21%] [Cov:============================>      81%][Progress:======>                       21%] [Cov:============================>      81%][Progress:======>                       22%] [Cov:============================>      81%][Progress:======>                       22%] [Cov:============================>      81%][Progress:======>                       22%] [Cov:============================>      81%][Progress:======>                       22%] [Cov:============================>      81%][Progress:======>                       22%] [Cov:============================>      81%][Progress:======>                       22%] [Cov:============================>      81%][Progress:======>                       22%] [Cov:============================>      81%][Progress:======>                       22%] [Cov:============================>      81%][Progress:========>                     27%] [Cov:============================>      81%][Progress:========>                     27%] [Cov:============================>      81%][Progress:========>                     27%] [Cov:============================>      81%][Progress:========>                     27%] [Cov:============================>      81%][Progress:========>                     27%] [Cov:============================>      81%][Progress:========>                     27%] [Cov:============================>      81%][Progress:=========>                    30%] [Cov:============================>      81%][Progress:=========>                    30%] [Cov:============================>      81%][Progress:=========>                    30%] [Cov:============================>      81%][Progress:=========>                    30%] [Cov:============================>      81%][Progress:=========>                    30%] [Cov:============================>      81%][Progress:=========>                    30%] [Cov:============================>      81%][Progress:=========>                    30%] [Cov:============================>      81%][Progress:=========>                    30%] [Cov:============================>      81%][Progress:=========>                    31%] [Cov:============================>      81%][Progress:=========>                    31%] [Cov:============================>      81%][Progress:=========>                    31%] [Cov:============================>      81%][Progress:==========>                   34%] [Cov:============================>      81%][Progress:==========>                   34%] [Cov:============================>      81%][Progress:==========>                   36%] [Cov:============================>      81%][Progress:==========>                   36%] [Cov:============================>      81%][Progress:==========>                   36%] [Cov:============================>      81%][Progress:==========>                   36%] [Cov:============================>      81%][Progress:==========>                   36%] [Cov:============================>      81%][Progress:===========>                  37%] [Cov:============================>      81%][Progress:===========>                  37%] [Cov:============================>      81%][Progress:===========>                  37%] [Cov:============================>      81%][Progress:===========>                  37%] [Cov:============================>      81%][Progress:===========>                  37%] [Cov:============================>      81%][Progress:===========>                  37%] [Cov:============================>      81%][Progress:===========>                  37%] [Cov:============================>      81%][Progress:===========>                  37%] [Cov:============================>      81%][Progress:============>                 40%] [Cov:============================>      81%][Progress:============>                 40%] [Cov:============================>      81%][Progress:============>                 40%] [Cov:============================>      81%][Progress:============>                 40%] [Cov:============================>      81%][Progress:============>                 40%] [Cov:============================>      81%][Progress:============>                 40%] [Cov:============================>      81%][Progress:============>                 40%] [Cov:============================>      81%][Progress:============>                 41%] [Cov:============================>      81%][Progress:============>                 41%] [Cov:============================>      81%][Progress:============>                 41%] [Cov:============================>      81%][Progress:============>                 41%] [Cov:============================>      81%][Progress:============>                 41%] [Cov:============================>      81%][Progress:============>                 41%] [Cov:============================>      81%][Progress:============>                 41%] [Cov:============================>      81%][Progress:============>                 41%] [Cov:============================>      81%][Progress:============>                 41%] [Cov:============================>      81%][Progress:============>                 41%] [Cov:============================>      81%][Progress:============>                 41%] [Cov:============================>      81%][Progress:============>                 41%] [Cov:============================>      81%][Progress:============>                 41%] [Cov:============================>      81%][Progress:============>                 41%] [Cov:============================>      81%][Progress:=============>                44%] [Cov:============================>      81%][Progress:=============>                44%] [Cov:============================>      81%][Progress:=============>                44%] [Cov:============================>      81%][Progress:=============>                44%] [Cov:============================>      81%][Progress:=============>                44%] [Cov:============================>      81%][Progress:==============>               47%] [Cov:============================>      81%][Progress:==============>               47%] [Cov:============================>      81%][Progress:==============>               47%] [Cov:============================>      81%][Progress:===============>              50%] [Cov:============================>      81%][Progress:================>             55%] [Cov:============================>      81%][Progress:================>             55%] [Cov:============================>      81%][Progress:================>             55%] [Cov:============================>      81%][Progress:================>             55%] [Cov:============================>      81%][Progress:================>             55%] [Cov:=============================>     83%][Progress:=================>            57%] [Cov:=============================>     83%][Progress:=================>            57%] [Cov:=============================>     83%][Progress:=================>            57%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            58%] [Cov:=============================>     83%][Progress:=================>            59%] [Cov:=============================>     83%][Progress:=================>            59%] [Cov:=============================>     83%][Progress:=================>            59%] [Cov:=============================>     83%][Progress:=================>            59%] [Cov:=============================>     83%][Progress:=================>            59%] [Cov:=============================>     83%][Progress:=================>            59%] [Cov:=============================>     83%][Progress:=================>            59%] [Cov:=============================>     83%][Progress:=================>            59%] [Cov:=============================>     83%][Progress:=================>            59%] [Cov:=============================>     84%][Progress:=================>            59%] [Cov:=============================>     84%][Progress:=================>            59%] [Cov:=============================>     84%][Progress:=================>            59%] [Cov:=============================>     84%][Progress:=================>            59%] [Cov:=============================>     84%][Progress:=================>            59%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           62%] [Cov:=============================>     84%][Progress:==================>           63%] [Cov:=============================>     84%][Progress:===================>          65%] [Cov:=============================>     84%][Progress:===================>          65%] [Cov:=============================>     84%][Progress:===================>          65%] [Cov:=============================>     84%][Progress:===================>          65%] [Cov:=============================>     84%][Progress:====================>         68%] [Cov:=============================>     84%][Progress:====================>         68%] [Cov:=============================>     84%][Progress:====================>         68%] [Cov:=============================>     84%][Progress:====================>         68%] [Cov:=============================>     84%][Progress:====================>         68%] [Cov:=============================>     84%][Progress:====================>         68%] [Cov:=============================>     84%][Progress:====================>         68%] [Cov:=============================>     84%][Progress:====================>         68%] [Cov:=============================>     84%][Progress:====================>         68%] [Cov:=============================>     84%][Progress:====================>         68%] [Cov:=============================>     84%][Progress:====================>         68%] [Cov:=============================>     84%][Progress:====================>         68%] [Cov:=============================>     84%][Progress:====================>         68%] [Cov:=============================>     84%][Progress:====================>         69%] [Cov:=============================>     84%][Progress:====================>         69%] [Cov:=============================>     84%][Progress:====================>         69%] [Cov:=============================>     84%][Progress:====================>         69%] [Cov:=============================>     84%][Progress:====================>         69%] [Cov:=============================>     84%][Progress:====================>         69%] [Cov:=============================>     84%][Progress:====================>         69%] [Cov:=============================>     84%][Progress:====================>         69%] [Cov:=============================>     84%][Progress:====================>         69%] [Cov:=============================>     84%][Progress:====================>         69%] [Cov:=============================>     84%][Progress:=====================>        71%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:=====================>        72%] [Cov:=============================>     84%][Progress:======================>       75%] [Cov:=============================>     84%][Progress:=======================>      77%] [Cov:=============================>     85%][Progress:=======================>      77%] [Cov:=============================>     85%][Progress:=======================>      77%] [Cov:=============================>     85%][Progress:=======================>      77%] [Cov:=============================>     85%][Progress:=======================>      77%] [Cov:=============================>     85%][Progress:=======================>      77%] [Cov:=============================>     85%][Progress:=======================>      77%] [Cov:=============================>     85%][Progress:=======================>      77%] [Cov:=============================>     85%][Progress:=======================>      78%] [Cov:=============================>     85%][Progress:=======================>      78%] [Cov:=============================>     85%][Progress:=======================>      78%] [Cov:=============================>     85%][Progress:=======================>      78%] [Cov:=============================>     85%][Progress:========================>     80%] [Cov:=============================>     85%][Progress:========================>     80%] [Cov:=============================>     85%][Progress:========================>     80%] [Cov:=============================>     85%][Progress:========================>     80%] [Cov:=============================>     85%][Progress:========================>     80%] [Cov:=============================>     85%][Progress:========================>     81%] [Cov:=============================>     85%][Progress:========================>     81%] [Cov:=============================>     85%][Progress:========================>     81%] [Cov:=============================>     85%][Progress:========================>     81%] [Cov:=============================>     85%][Progress:========================>     83%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:=========================>    86%] [Cov:=============================>     85%][Progress:==========================>   87%] [Cov:=============================>     85%][Progress:==========================>   87%] [Cov:=============================>     85%][Progress:==========================>   89%] [Cov:=============================>     85%][Progress:==========================>   89%] [Cov:=============================>     85%][Progress:===========================>  92%] [Cov:=============================>     85%][Progress:===========================>  92%] [Cov:=============================>     85%][Progress:===========================>  92%] [Cov:=============================>     85%][Progress:===========================>  92%] [Cov:=============================>     85%][Progress:===========================>  92%] [Cov:=============================>     85%][Progress:===========================>  92%] [Cov:=============================>     85%][Progress:===========================>  92%] [Cov:=============================>     85%][Progress:============================> 94%] [Cov:=============================>     85%][Progress:============================> 95%] [Cov:=============================>     85%][Progress:============================> 95%] [Cov:=============================>     85%][Progress:============================> 95%] [Cov:=============================>     85%][Progress:============================> 95%] [Cov:=============================>     85%][Progress:============================> 95%] [Cov:=============================>     85%][Progress:============================> 95%] [Cov:=============================>     85%][Progress:============================> 95%] [Cov:=============================>     85%][Progress:============================> 95%] [Cov:=============================>     85%][Progress:============================> 95%] [Cov:=============================>     85%][Progress:============================> 95%] [Cov:=============================>     85%][Progress:============================> 95%] [Cov:=============================>     85%][Progress:=============================>97%] [Cov:=============================>     85%][Progress:=============================>97%] [Cov:=============================>     85%][Progress:=============================>98%] [Cov:=============================>     85%][Progress:=============================>98%] [Cov:=============================>     85%][Progress:==============================100%] [Cov:=============================>     85%]
* Search finished after 202s and 332 generations, 107995 statements, best individual has fitness: 75.0
* Generated before the refinement 47 tests with total length 145
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(59)
statement is: visitField(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)Lwheel/asm/FieldVisitor; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.FieldWriter
statement code is: FieldWriter visitField = (FieldWriter)classWriter.visitField(59, "", "7$l;2/V[pfu:w", "", "7$l;2/V[pfu:w")
statement is: toByteArray()[B type is: class org.evosuite.testcase.statements.MethodStatement return type class [B
statement code is: byte[] byteArray = classWriter.toByteArray()
test data is: ClassWriter classWriter = new ClassWriter(59);
classWriter.visitField(59, "", "7$l;2/V[pfu:w", "", "7$l;2/V[pfu:w");
classWriter.toByteArray();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.visitField(59, "", "PI", "double", "3.14");
        classWriter.toByteArray();
    }
}
statement is: classWriter.visitField(59, "", "PI", "double", "3.14"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visitField(59, "", "PI", "double", "3.14") target is: classWriter method is: visitField(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String)
statement is: classWriter.toByteArray(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.toByteArray() target is: classWriter method is: toByteArray()
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-2385))
statement is: newMethod(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Z)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int newMethod = classWriter.newMethod("", "", "", false)
statement is: newMethod(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Z)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int newMethod = classWriter.newMethod("", "", "", false)
test data is: ClassWriter classWriter = new ClassWriter((-2385));
classWriter.newMethod("", "", "", false);
classWriter.newMethod("", "", "", false);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data }}
    }
}
statement is: // Improved test data }}, class spoon.support.reflect.code.CtCommentImpl
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("java/lang/String")
statement is: wheel.asm.ClassWriter(Lwheel/asm/ClassReader;I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(arg0, 4)
statement is: accept(Lwheel/asm/ClassVisitor;I)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classReader.accept((ClassVisitor) arg0, 21)
test data is: ClassReader classReader = new ClassReader("java/lang/String");
ClassWriter classWriter = new ClassWriter(classReader, 4);
classReader.accept((ClassVisitor) classWriter, 21);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data
        int value = 5;
        double doubleValue = 3.14;
        String stringValue = "Hello World!";
        char charValue = 'A';
    }
}
statement is: // Improved test data
int value = 5, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: double doubleValue = 3.14, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String stringValue = "Hello World!", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: char charValue = 'A', class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
* this is vulnerable: int _int = 5
* this is vulnerable: double _double = 3.14
* this is vulnerable: String string = "Hello World!"
* this is vulnerable: char _char = 'A'
TestCase is: int _int = 5;
double _double = 3.14;
String string = "Hello World!";
char _char = 'A';

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(2620)
statement is: org.evosuite.testcase.statements.ArrayStatement@4c7ac48a type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[8]
statement is: visit(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", (String) null, (String) null, arg5)
test data is: ClassWriter classWriter = new ClassWriter(2620);
String[] stringArray = new String[8];
classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", (String) null, (String) null, stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        String[] stringArray = new String[8];
        classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", ((String) (null)), ((String) (null)), stringArray);
        // Improved test data
        ClassWriter classWriter = new ClassWriter(2620);
        String[] stringArray = new String[8];
        classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", ((String) (null)), ((String) (null)), stringArray);
        // The values in the test data have been changed to more descriptive and representative examples:
        ClassWriter classWriter = new ClassWriter(30);// Changed from 2620 to make it more clear that this is a value for the "max_stack" field.

        String[] stringArray = new String[8];// Changed from an empty array to include some more realistic data in the String[] array.

        classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", ((String) (null)), ((String) (null)), stringArray);
    }
}
statement is: String[] stringArray = new String[8], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [8] Ct is: String[] stringArray = new String[8] isAssignment: false Array: new String[8] Elements: []
lengths: [8] [8]
Their type are: class [Ljava.lang.String; String[]
statement is: classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", ((String) (null)), ((String) (null)), stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", ((String) (null)), ((String) (null)), stringArray) target is: classWriter method is: visit(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[])
statement is: // Improved test data
ClassWriter classWriter = new ClassWriter(2620), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: String[] stringArray = new String[8], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [8] Ct is: String[] stringArray = new String[8] isAssignment: false Array: new String[8] Elements: []
lengths: [8] [8]
Their type are: class [Ljava.lang.String; String[]
statement is: classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", ((String) (null)), ((String) (null)), stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", ((String) (null)), ((String) (null)), stringArray) target is: classWriter method is: visit(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[])
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 2
Matched Method is: visit(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V
i 4 Parameters size() 4 Num of Method Parameters: 6
i 5 Parameters size() 4 Num of Method Parameters: 6
statement is: // The values in the test data have been changed to more descriptive and representative examples:
ClassWriter classWriter = new ClassWriter(30)// Changed from 2620 to make it more clear that this is a value for the "max_stack" field.
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: String[] stringArray = new String[8]// Changed from an empty array to include some more realistic data in the String[] array.
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [8] Ct is: String[] stringArray = new String[8] isAssignment: false Array: new String[8] Elements: []
lengths: [8] [8]
Their type are: class [Ljava.lang.String; String[]
statement is: classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", ((String) (null)), ((String) (null)), stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", ((String) (null)), ((String) (null)), stringArray) target is: classWriter method is: visit(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[])
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 11
Matched Method is: visit(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V
i 4 Parameters size() 4 Num of Method Parameters: 6
i 5 Parameters size() 4 Num of Method Parameters: 6
TestCase is: String[] stringArray = new String[8];
int _int = 2620;
ClassWriter classWriter = new ClassWriter(_int);
String[] stringArray = new String[8];
int _int = 14;
int _int = 16777215;
String string = "RuntimeVisibleAnnotations";
String string = null;
String[] stringArray = null;
((ClassWriter) stringArray).visit(_int, _int, string, (String) stringArray, string, stringArray);
int _int = 30;
ClassWriter classWriter = new ClassWriter(_int);
String[] stringArray = new String[8];
int _int = 14;
int _int = 16777215;
String string = "RuntimeVisibleAnnotations";
String string = null;
String[] stringArray = null;
((ClassWriter) stringArray).visit(_int, _int, string, (String) stringArray, string, stringArray);

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(14)
statement is: visit(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classWriter.visit(16777217, 6, "a|4F!Tx}", "", "", (String[]) null)
test data is: ClassWriter classWriter = new ClassWriter(14);
classWriter.visit(16777217, 6, "a|4F!Tx}", "", "", (String[]) null);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improve the test data by changing the primitive values and Strings to more illustrative examples
        ClassWriter classWriter = new ClassWriter(14);
        classWriter.visit(16777217, 6, "a|4F!Tx}", "", "", ((String[]) (null)));
    }
}
statement is: // Improve the test data by changing the primitive values and Strings to more illustrative examples
ClassWriter classWriter = new ClassWriter(14), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: classWriter.visit(16777217, 6, "a|4F!Tx}", "", "", ((String[]) (null))), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visit(16777217, 6, "a|4F!Tx}", "", "", ((String[]) (null))) target is: classWriter method is: visit(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[])
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 1
Matched Method is: visit(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V
i 5 Parameters size() 5 Num of Method Parameters: 6
TestCase is: int _int = 14;
ClassWriter classWriter = new ClassWriter(_int);
int _int = 16777217;
int _int = 6;
String string = "a|4F!Tx}";
String string = "";
String string = "";
String[] stringArray = null;
((ClassWriter) _int).visit(_int, _int, string, string, string, stringArray);

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-2420))
statement is: visitSource(Ljava/lang/String;Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classWriter.visitSource((String) null, "")
test data is: ClassWriter classWriter = new ClassWriter((-2420));
classWriter.visitSource((String) null, "");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.visitSource("Test.java", "");
    }
}
statement is: classWriter.visitSource("Test.java", ""), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visitSource("Test.java", "") target is: classWriter method is: visitSource(java.lang.String,java.lang.String)
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(66)
statement is: visitOuterClass(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classWriter.visitOuterClass("", (String) null, "")
test data is: ClassWriter classWriter = new ClassWriter(66);
classWriter.visitOuterClass("", (String) null, "");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.visitOuterClass("MyClass", "com/mypackage/MyClass", "public static void main(String[] args) { ... }");
    }
}
statement is: classWriter.visitOuterClass("MyClass", "com/mypackage/MyClass", "public static void main(String[] args) { ... }"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visitOuterClass("MyClass", "com/mypackage/MyClass", "public static void main(String[] args) { ... }") target is: classWriter method is: visitOuterClass(java.lang.String,java.lang.String,java.lang.String)
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-2420))
statement is: visitOuterClass(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classWriter.visitOuterClass("", "wheel.asm.ClassWriter", (String) null)
test data is: ClassWriter classWriter = new ClassWriter((-2420));
classWriter.visitOuterClass("", "wheel.asm.ClassWriter", (String) null);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data
        int classWriterSize = -1234;
    }
}
statement is: // Improved test data
int classWriterSize = -1234, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtUnaryOperatorImpl
IT HAS NOT BEEN SUPPORTED YET: -1234
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(2855)
statement is: visitOuterClass(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classWriter.visitOuterClass("}MNV?", "}MNV?", "Deprecated")
statement is: toByteArray()[B type is: class org.evosuite.testcase.statements.MethodStatement return type class [B
statement code is: byte[] byteArray = classWriter.toByteArray()
test data is: ClassWriter classWriter = new ClassWriter(2855);
classWriter.visitOuterClass("}MNV?", "}MNV?", "Deprecated");
classWriter.toByteArray();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.toByteArray();
    }
}
statement is: classWriter.toByteArray(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.toByteArray() target is: classWriter method is: toByteArray()
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(65)
statement is: visitInnerClass(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classWriter.visitInnerClass((String) null, "Sensitive", (String) null, 17)
test data is: ClassWriter classWriter = new ClassWriter(65);
classWriter.visitInnerClass((String) null, "Sensitive", (String) null, 17);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        and = $missing$;
    }
}
statement is: and = $missing$, class spoon.support.reflect.code.CtAssignmentImpl
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(10)
statement is: wheel.asm.MethodWriter(Lwheel/asm/ClassWriter;ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;ZZ)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.MethodWriter
statement code is: MethodWriter methodWriter = new MethodWriter(arg0, 0, "wheel.asm.ClassWriter", "wheel.asm.ClassWriter", "tU/M\"wIn!:%F", (String[]) null, false, false)
statement is: toByteArray()[B type is: class org.evosuite.testcase.statements.MethodStatement return type class [B
statement code is: byte[] byteArray = classWriter.toByteArray()
test data is: ClassWriter classWriter = new ClassWriter(10);
MethodWriter methodWriter = new MethodWriter(classWriter, 0, "wheel.asm.ClassWriter", "wheel.asm.ClassWriter", "tU/M\"wIn!:%F", (String[]) null, false, false);
classWriter.toByteArray();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        MethodWriter methodWriter = new MethodWriter(classWriter, 0, "wheel.asm.ClassWriter", "wheel.asm.ClassWriter", "tU/M\"wIn!:%F", ((String[]) (null)), false, false);
        // Add a more descriptive test data
        int[] sampleInts = new int[]{ 1, 2, 3, 4, 5 };
        double[] sampleDoubles = new double[]{ 1.0, 2.0, 3.0, 4.0, 5.0 };
        String[] sampleStrings = new String[]{ "hello", "world", "abc", "def", "ghi" };
        char[] sampleChars = new char[]{ 'a', 'b', 'c', 'd', 'e' };
        classWriter.toByteArray();
    }
}
statement is: MethodWriter methodWriter = new MethodWriter(classWriter, 0, "wheel.asm.ClassWriter", "wheel.asm.ClassWriter", "tU/M\"wIn!:%F", ((String[]) (null)), false, false), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: // Add a more descriptive test data
int[] sampleInts = new int[]{ 1, 2, 3, 4, 5 }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
statement is: double[] sampleDoubles = new double[]{ 1.0, 2.0, 3.0, 4.0, 5.0 }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
statement is: String[] sampleStrings = new String[]{ "hello", "world", "abc", "def", "ghi" }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
statement is: char[] sampleChars = new char[]{ 'a', 'b', 'c', 'd', 'e' }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
statement is: classWriter.toByteArray(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.toByteArray() target is: classWriter method is: toByteArray()
TestCase is: int _int = 0;
String string = "wheel.asm.ClassWriter";
String string = "wheel.asm.ClassWriter";
String string = "tU/M\"wIn!:%F";
boolean _boolean = false;
boolean _boolean = false;
MethodWriter methodWriter = new MethodWriter((ClassWriter) _int, (int) string, string, string, (String) _boolean, (String[]) _boolean, false, false);

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-36))
statement is: visitSource(Ljava/lang/String;Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classWriter.visitSource("{LGT", "{LGT")
statement is: toByteArray()[B type is: class org.evosuite.testcase.statements.MethodStatement return type class [B
statement code is: byte[] byteArray = classWriter.toByteArray()
test data is: ClassWriter classWriter = new ClassWriter((-36));
classWriter.visitSource("{LGT", "{LGT");
classWriter.toByteArray();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data:
        ClassWriter classWriter = new ClassWriter(20);
        classWriter.visitSource("TestClass", "TestClass");
        classWriter.toByteArray();
    }
}
statement is: // Improved test data:
ClassWriter classWriter = new ClassWriter(20), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: classWriter.visitSource("TestClass", "TestClass"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visitSource("TestClass", "TestClass") target is: classWriter method is: visitSource(java.lang.String,java.lang.String)
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 1
Matched Method is: visitSource(Ljava/lang/String;Ljava/lang/String;)V
statement is: classWriter.toByteArray(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.toByteArray() target is: classWriter method is: toByteArray()
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 1
Matched Method is: toByteArray()[B
TestCase is: int _int = 20;
ClassWriter classWriter = new ClassWriter(_int);
String string = "TestClass";
String string = "TestClass";
((ClassWriter) _int).visitSource(string, string);
((ClassWriter) _int).toByteArray();

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-526))
statement is: org.evosuite.testcase.statements.ArrayStatement@9d1c01f5 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[0]
statement is: visit(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classWriter.visit(13, (-526), "1cug$(C", "1cug$(C", (String) null, arg5)
statement is: toByteArray()[B type is: class org.evosuite.testcase.statements.MethodStatement return type class [B
statement code is: byte[] byteArray = classWriter.toByteArray()
test data is: ClassWriter classWriter = new ClassWriter((-526));
String[] stringArray = new String[0];
classWriter.visit(13, (-526), "1cug$(C", "1cug$(C", (String) null, stringArray);
classWriter.toByteArray();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        String[] stringArray = new String[0];
        classWriter.visit(13, -526, "1cug$(C", "1cug$(C", ((String) (null)), stringArray);
        classWriter.toByteArray();
        // Improved test data:
        ClassWriter classWriter = new ClassWriter(-526);
        String[] stringArray = new String[]{ "Hello World" };// using a more descriptive String value

        classWriter.visit(13, -526, "1cug$(C", "1cug$(C", ((String) (null)), stringArray);
        classWriter.toByteArray();
    }
}
statement is: String[] stringArray = new String[0], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [0] Ct is: String[] stringArray = new String[0] isAssignment: false Array: new String[0] Elements: []
lengths: [0] [0]
Their type are: class [Ljava.lang.String; String[]
statement is: classWriter.visit(13, -526, "1cug$(C", "1cug$(C", ((String) (null)), stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visit(13, -526, "1cug$(C", "1cug$(C", ((String) (null)), stringArray) target is: classWriter method is: visit(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[])
statement is: classWriter.toByteArray(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.toByteArray() target is: classWriter method is: toByteArray()
statement is: // Improved test data:
ClassWriter classWriter = new ClassWriter(-526), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: String[] stringArray = new String[]{ "Hello World" }// using a more descriptive String value
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [] Ct is: String[] stringArray = new String[0] isAssignment: false Array: new String[]{ "Hello World" } Elements: ["Hello World"]
lengths: [0] []
statement is: classWriter.visit(13, -526, "1cug$(C", "1cug$(C", ((String) (null)), stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visit(13, -526, "1cug$(C", "1cug$(C", ((String) (null)), stringArray) target is: classWriter method is: visit(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[])
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 1
Matched Method is: visit(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V
i 4 Parameters size() 4 Num of Method Parameters: 6
i 5 Parameters size() 4 Num of Method Parameters: 6
statement is: classWriter.toByteArray(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.toByteArray() target is: classWriter method is: toByteArray()
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 1
Matched Method is: toByteArray()[B
TestCase is: String[] stringArray = new String[0];
ClassWriter classWriter = new ClassWriter((-526));
int _int = 13;
String string = "1cug$(C";
String string = "1cug$(C";
String string = null;
String[] stringArray = null;
((ClassWriter) stringArray).visit(_int, (int) string, string, (String) stringArray, string, stringArray);
((ClassWriter) stringArray).toByteArray();

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(20)
statement is: visitInnerClass(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classWriter.visitInnerClass((String) null, (String) null, (String) null, 20)
statement is: toByteArray()[B type is: class org.evosuite.testcase.statements.MethodStatement return type class [B
statement code is: byte[] byteArray = classWriter.toByteArray()
test data is: ClassWriter classWriter = new ClassWriter(20);
classWriter.visitInnerClass((String) null, (String) null, (String) null, 20);
classWriter.toByteArray();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        byte[] byteArray = classWriter.toByteArray();
    }
}
statement is: byte[] byteArray = classWriter.toByteArray(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.toByteArray() target is: classWriter method is: toByteArray()
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(689)
statement is: visitAnnotation(Ljava/lang/String;Z)Lwheel/asm/AnnotationVisitor; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.AnnotationWriter
statement code is: AnnotationWriter visitAnnotation = (AnnotationWriter)classWriter.visitAnnotation("Signature", true)
statement is: toByteArray()[B type is: class org.evosuite.testcase.statements.MethodStatement return type class [B
statement code is: byte[] byteArray = classWriter.toByteArray()
test data is: ClassWriter classWriter = new ClassWriter(689);
classWriter.visitAnnotation("Signature", true);
classWriter.toByteArray();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.visitAnnotation("Signature", false);// Add a more representative annotation value

        classWriter.toByteArray();// Add a more representative return value }}

    }
}
statement is: classWriter.visitAnnotation("Signature", false)// Add a more representative annotation value
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visitAnnotation("Signature", false)// Add a more representative annotation value
 target is: classWriter method is: visitAnnotation(java.lang.String,boolean)
statement is: classWriter.toByteArray()// Add a more representative return value }}
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.toByteArray()// Add a more representative return value }}
 target is: classWriter method is: toByteArray()
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-2103))
statement is: visitAnnotation(Ljava/lang/String;Z)Lwheel/asm/AnnotationVisitor; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.AnnotationWriter
statement code is: AnnotationWriter visitAnnotation = (AnnotationWriter)classWriter.visitAnnotation("SourceDebugExtension", false)
statement is: toByteArray()[B type is: class org.evosuite.testcase.statements.MethodStatement return type class [B
statement code is: byte[] byteArray = classWriter.toByteArray()
test data is: ClassWriter classWriter = new ClassWriter((-2103));
classWriter.visitAnnotation("SourceDebugExtension", false);
classWriter.toByteArray();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.visitAnnotation("SourceDebugExtension", false);
        classWriter.toByteArray();
    }
}
statement is: classWriter.visitAnnotation("SourceDebugExtension", false), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visitAnnotation("SourceDebugExtension", false) target is: classWriter method is: visitAnnotation(java.lang.String,boolean)
statement is: classWriter.toByteArray(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.toByteArray() target is: classWriter method is: toByteArray()
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(18)
statement is: wheel.asm.Attribute(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.Attribute
statement code is: Attribute attribute = new Attribute("")
statement is: org.evosuite.testcase.statements.ArrayStatement@21f0ae8 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [B
statement code is: byte[] byteArray = new byte[0]
statement is: org.evosuite.testcase.statements.AssignmentStatement@53d261eb type is: class org.evosuite.testcase.statements.AssignmentStatement return type class [B
statement code is: attribute.value = byteArray
statement is: visitAttribute(Lwheel/asm/Attribute;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classWriter.visitAttribute(arg0)
statement is: toByteArray()[B type is: class org.evosuite.testcase.statements.MethodStatement return type class [B
statement code is: byte[] byteArray = classWriter.toByteArray()
test data is: ClassWriter classWriter = new ClassWriter(18);
Attribute attribute = new Attribute("");
byte[] byteArray = new byte[0];
attribute.value = byteArray;
classWriter.visitAttribute(attribute);
classWriter.toByteArray();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Attribute attribute = new Attribute("custom_attribute");
        byte[] byteArray = new byte[]{ 0x1, 0x2, 0x3 };
        attribute.value = byteArray;
        classWriter.visitAttribute(attribute);
        classWriter.toByteArray();
    }
}
statement is: Attribute attribute = new Attribute("custom_attribute"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: byte[] byteArray = new byte[]{ 0x1, 0x2, 0x3 }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [] Ct is: byte[] byteArray = new byte[0] isAssignment: false Array: new byte[]{ 0x1, 0x2, 0x3 } Elements: [0x1, 0x2, 0x3]
lengths: [0] []
statement is: attribute.value = byteArray, class spoon.support.reflect.code.CtAssignmentImpl
statement is: classWriter.visitAttribute(attribute), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visitAttribute(attribute) target is: classWriter method is: visitAttribute(Attribute)
statement is: classWriter.toByteArray(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.toByteArray() target is: classWriter method is: toByteArray()
TestCase is: String string = "custom_attribute";
Attribute attribute = new Attribute(string);

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(25)
statement is: org.evosuite.testcase.statements.AssignmentStatement@964ff369 type is: class org.evosuite.testcase.statements.AssignmentStatement return type boolean
statement code is: classWriter.invalidFrames = true
statement is: toByteArray()[B type is: class org.evosuite.testcase.statements.MethodStatement return type class [B
statement code is: byte[] byteArray = classWriter.toByteArray()
test data is: ClassWriter classWriter = new ClassWriter(25);
classWriter.invalidFrames = true;
classWriter.toByteArray();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.invalidFrames = true;
        String[] frames = new String[]{ "frame1", "frame2", "frame3" };
        classWriter.toByteArray();
    }
}
statement is: classWriter.invalidFrames = true, class spoon.support.reflect.code.CtAssignmentImpl
statement is: String[] frames = new String[]{ "frame1", "frame2", "frame3" }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
statement is: classWriter.toByteArray(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.toByteArray() target is: classWriter method is: toByteArray()
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-5))
statement is: newConst(Ljava/lang/Object;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int newConst = arg0.newConst(arg0)
test data is: ClassWriter classWriter = new ClassWriter((-5));
classWriter.newConst(classWriter);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        int myInt = 9001;
        double myDouble = 2.71828;
        String myString = "The answer to life, the universe, and everything is 42.";
        char myChar = 'z';
    }
}
statement is: int myInt = 9001, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: double myDouble = 2.71828, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String myString = "The answer to life, the universe, and everything is 42.", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: char myChar = 'z', class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
* this is vulnerable: int _int = 9001
* this is vulnerable: double _double = 2.71828
* this is vulnerable: String string = "The answer to life, the universe, and everything is 42."
* this is vulnerable: char _char = 'z'
TestCase is: int _int = 9001;
double _double = 2.71828;
String string = "The answer to life, the universe, and everything is 42.";
char _char = 'z';

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(59)
statement is: newField(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int newField = classWriter.newField("\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y")
statement is: newField(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int newField = classWriter.newField("\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y")
test data is: ClassWriter classWriter = new ClassWriter(59);
classWriter.newField("\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y");
classWriter.newField("\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.newField("First name: John, Last name: Smith", "First name: John, Last name: Smith", "First name: John, Last name: Smith");
        classWriter.newField("First name: Jane, Last name: Doe", "First name: Jane, Last name: Doe", "First name: Jane, Last name: Doe");
    }
}
statement is: classWriter.newField("First name: John, Last name: Smith", "First name: John, Last name: Smith", "First name: John, Last name: Smith"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newField("First name: John, Last name: Smith", "First name: John, Last name: Smith", "First name: John, Last name: Smith") target is: classWriter method is: newField(java.lang.String,java.lang.String,java.lang.String)
statement is: classWriter.newField("First name: Jane, Last name: Doe", "First name: Jane, Last name: Doe", "First name: Jane, Last name: Doe"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newField("First name: Jane, Last name: Doe", "First name: Jane, Last name: Doe", "First name: Jane, Last name: Doe") target is: classWriter method is: newField(java.lang.String,java.lang.String,java.lang.String)
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(14)
statement is: newFloat(F)Lwheel/asm/Item; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.Item
statement code is: Item newFloat = classWriter.newFloat(14)
statement is: newFloat(F)Lwheel/asm/Item; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.Item
statement code is: Item newFloat = classWriter.newFloat(14)
test data is: ClassWriter classWriter = new ClassWriter(14);
classWriter.newFloat(14);
classWriter.newFloat(14);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data
        ClassWriter classWriter = new ClassWriter(32);
        classWriter.newFloat(25);
        classWriter.newFloat(62.5);
    }
}
statement is: // Improved test data
ClassWriter classWriter = new ClassWriter(32), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: classWriter.newFloat(25), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newFloat(25) target is: classWriter method is: newFloat(int)
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 1
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 1
Matched Method is: newFloat(F)Lwheel/asm/Item;
statement is: classWriter.newFloat(62.5), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newFloat(62.5) target is: classWriter method is: newFloat(double)
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 1
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 1
Matched Method is: newFloat(F)Lwheel/asm/Item;
TestCase is: int _int = 32;
ClassWriter classWriter = new ClassWriter(_int);
int _int = 25;
((ClassWriter) _int).newFloat(_int);
double _double = 62.5;
((ClassWriter) _int).newFloat((float) _double);

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(59)
statement is: newLong(J)Lwheel/asm/Item; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.Item
statement code is: Item newLong = classWriter.newLong(0L)
test data is: ClassWriter classWriter = new ClassWriter(59);
classWriter.newLong(0L);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data
        ClassWriter classWriter = new ClassWriter(23456789L);
        classWriter.newLong(10000000000L);
    }
}
statement is: // Improved test data
ClassWriter classWriter = new ClassWriter(23456789L), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: classWriter.newLong(10000000000L), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newLong(10000000000L) target is: classWriter method is: newLong(long)
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 1
Matched Method is: newLong(J)Lwheel/asm/Item;
TestCase is: long _long = 23456789L;
ClassWriter classWriter = new ClassWriter((int) _long);
long _long = 10000000000L;
((ClassWriter) _long).newLong(_long);

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(54)
statement is: newDouble(D)Lwheel/asm/Item; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.Item
statement code is: Item newDouble = classWriter.newDouble(54)
statement is: newDouble(D)Lwheel/asm/Item; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.Item
statement code is: Item newDouble = classWriter.newDouble(54)
test data is: ClassWriter classWriter = new ClassWriter(54);
classWriter.newDouble(54);
classWriter.newDouble(54);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.newDouble(54);
        classWriter.newDouble(54);
    }
}
statement is: classWriter.newDouble(54), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newDouble(54) target is: classWriter method is: newDouble(int)
statement is: classWriter.newDouble(54), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newDouble(54) target is: classWriter method is: newDouble(int)
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(14)
statement is: newConstItem(Ljava/lang/Object;)Lwheel/asm/Item; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.Item
statement code is: Item newConstItem = classWriter.newConstItem("Z=[")
statement is: newConstItem(Ljava/lang/Object;)Lwheel/asm/Item; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.Item
statement code is: Item newConstItem = classWriter.newConstItem("Z=[")
test data is: ClassWriter classWriter = new ClassWriter(14);
classWriter.newConstItem("Z=[");
classWriter.newConstItem("Z=[");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.newConstItem("Z=[");
        classWriter.newConstItem("Z=[");
    }
}
statement is: classWriter.newConstItem("Z=["), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newConstItem("Z=[") target is: classWriter method is: newConstItem(java.lang.String)
statement is: classWriter.newConstItem("Z=["), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newConstItem("Z=[") target is: classWriter method is: newConstItem(java.lang.String)
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(3182)
statement is: newMethodItem(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Z)Lwheel/asm/Item; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.Item
statement code is: Item newMethodItem = classWriter.newMethodItem("@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(", false)
statement is: newNameType(Ljava/lang/String;Ljava/lang/String;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int newNameType = classWriter.newNameType("@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(")
test data is: ClassWriter classWriter = new ClassWriter(3182);
classWriter.newMethodItem("@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(", false);
classWriter.newNameType("@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.newMethodItem("TestMethod", "TestMethod", "TestMethod", false);
        classWriter.newNameType("TestMethod", "TestMethod");
    }
}
statement is: classWriter.newMethodItem("TestMethod", "TestMethod", "TestMethod", false), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newMethodItem("TestMethod", "TestMethod", "TestMethod", false) target is: classWriter method is: newMethodItem(java.lang.String,java.lang.String,java.lang.String,boolean)
statement is: classWriter.newNameType("TestMethod", "TestMethod"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newNameType("TestMethod", "TestMethod") target is: classWriter method is: newNameType(java.lang.String,java.lang.String)
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(5)
statement is: addType(Ljava/lang/String;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int addType = classWriter.addType("k")
statement is: addType(Ljava/lang/String;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int addType = classWriter.addType("k")
test data is: ClassWriter classWriter = new ClassWriter(5);
classWriter.addType("k");
classWriter.addType("k");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.addType("car");
        classWriter.addType("bike");
    }
}
statement is: classWriter.addType("car"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.addType("car") target is: classWriter method is: addType(java.lang.String)
statement is: classWriter.addType("bike"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.addType("bike") target is: classWriter method is: addType(java.lang.String)
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(11)
statement is: addUninitializedType(Ljava/lang/String;I)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int addUninitializedType = classWriter.addUninitializedType("StackMap", 1394)
statement is: addUninitializedType(Ljava/lang/String;I)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int addUninitializedType = classWriter.addUninitializedType("StackMap", 1394)
test data is: ClassWriter classWriter = new ClassWriter(11);
classWriter.addUninitializedType("StackMap", 1394);
classWriter.addUninitializedType("StackMap", 1394);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.addUninitializedType("StackMap", 1394);
        classWriter.addUninitializedType("StackMap", 1395);// The second instance of "StackMap" is changed to a different value (1395) to demonstrate the difference between two objects with the same class name but different values. }}

    }
}
statement is: classWriter.addUninitializedType("StackMap", 1394), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.addUninitializedType("StackMap", 1394) target is: classWriter method is: addUninitializedType(java.lang.String,int)
statement is: classWriter.addUninitializedType("StackMap", 1395)// The second instance of "StackMap" is changed to a different value (1395) to demonstrate the difference between two objects with the same class name but different values. }}
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.addUninitializedType("StackMap", 1395)// The second instance of "StackMap" is changed to a different value (1395) to demonstrate the difference between two objects with the same class name but different values. }}
 target is: classWriter method is: addUninitializedType(java.lang.String,int)
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(14)
statement is: org.evosuite.testcase.statements.ArrayStatement@a5d90045 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Lwheel.asm.Item;
statement code is: Item[] itemArray = new Item[2]
statement is: org.evosuite.testcase.statements.AssignmentStatement@2bc7e5b6 type is: class org.evosuite.testcase.statements.AssignmentStatement return type class [Lwheel.asm.Item;
statement code is: classWriter.typeTable = itemArray
statement is: addUninitializedType(Ljava/lang/String;I)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int addUninitializedType = classWriter.addUninitializedType("`", 14)
statement is: addType(Ljava/lang/String;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int addType = classWriter.addType(".s.IFJDCS")
test data is: ClassWriter classWriter = new ClassWriter(14);
Item[] itemArray = new Item[2];
classWriter.typeTable = itemArray;
classWriter.addUninitializedType("`", 14);
classWriter.addType(".s.IFJDCS");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Item[] itemArray = new Item[2];
        itemArray[0] = new Item("First item", 1, "This is a description for the first item");
        itemArray[1] = new Item("Second item", 2, "This is a description for the second item");
        classWriter.typeTable = itemArray;
        classWriter.addUninitializedType("`", 14);
        classWriter.addType(".s.IFJDCS");
    }
}
statement is: Item[] itemArray = new Item[2], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [2] Ct is: Item[] itemArray = new Item[2] isAssignment: false Array: new Item[2] Elements: []
lengths: [2] [2]
Their type are: class [Lwheel.asm.Item; Item[]
statement is: itemArray[0] = new Item("First item", 1, "This is a description for the first item"), class spoon.support.reflect.code.CtAssignmentImpl
Assigned : itemArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl null Assignment:new Item("First item", 1, "This is a description for the first item") Ct is: itemArray[0] = new Item("First item", 1, "This is a description for the first item")
target : itemArray class spoon.support.reflect.code.CtLiteralImpl
statement is: itemArray[1] = new Item("Second item", 2, "This is a description for the second item"), class spoon.support.reflect.code.CtAssignmentImpl
Assigned : itemArray[1] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl null Assignment:new Item("Second item", 2, "This is a description for the second item") Ct is: itemArray[1] = new Item("Second item", 2, "This is a description for the second item")
target : itemArray class spoon.support.reflect.code.CtLiteralImpl
statement is: classWriter.typeTable = itemArray, class spoon.support.reflect.code.CtAssignmentImpl
statement is: classWriter.addUninitializedType("`", 14), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.addUninitializedType("`", 14) target is: classWriter method is: addUninitializedType(java.lang.String,int)
statement is: classWriter.addType(".s.IFJDCS"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.addType(".s.IFJDCS") target is: classWriter method is: addType(java.lang.String)
TestCase is: Item[] itemArray = new Item[2];

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-2420))
statement is: getCommonSuperClass(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String commonSuperClass = classWriter.getCommonSuperClass("org.apache.commons.io.filefilter.DirectoryFileFilter", "java/lang/Class")
test data is: ClassWriter classWriter = new ClassWriter((-2420));
classWriter.getCommonSuperClass("org.apache.commons.io.filefilter.DirectoryFileFilter", "java/lang/Class");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data }}
    }
}
statement is: // Improved test data }}, class spoon.support.reflect.code.CtCommentImpl
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(5)
statement is: getCommonSuperClass(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String commonSuperClass = classWriter.getCommonSuperClass("java/lang/Object", "java/lang/Object")
test data is: ClassWriter classWriter = new ClassWriter(5);
classWriter.getCommonSuperClass("java/lang/Object", "java/lang/Object");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        StringBuilder stringBuilder = new StringBuilder();
    }
}
statement is: StringBuilder stringBuilder = new StringBuilder(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-5))
statement is: getCommonSuperClass(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String commonSuperClass = classWriter.getCommonSuperClass("wheel.asm.ClassWriter", "java/lang/Object")
test data is: ClassWriter classWriter = new ClassWriter((-5));
classWriter.getCommonSuperClass("wheel.asm.ClassWriter", "java/lang/Object");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
    }
}
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(2074)
statement is: org.evosuite.testcase.statements.AssignmentStatement@34b87c13 type is: class org.evosuite.testcase.statements.AssignmentStatement return type int
statement code is: classWriter.index = 2074
statement is: java.lang.Character(C)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Character
statement code is: Character character = new Character('i')
statement is: newConst(Ljava/lang/Object;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int newConst = classWriter.newConst(arg0)
test data is: ClassWriter classWriter = new ClassWriter(2074);
classWriter.index = 2074;
Character character = new Character('i');
classWriter.newConst(character);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.index = 2074;
        Character character = new Character('a');
        classWriter.newConst(character);
    }
}
statement is: classWriter.index = 2074, class spoon.support.reflect.code.CtAssignmentImpl
statement is: Character character = new Character('a'), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: classWriter.newConst(character), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newConst(character) target is: classWriter method is: newConst(java.lang.Character)
TestCase is: char _char = 'a';
Character character = new Character(_char);

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(2264)
statement is: newFieldItem(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lwheel/asm/Item; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.Item
statement code is: Item newFieldItem = classWriter.newFieldItem("", "The list of suffixes must not be null", "The list of suffixes must not be null")
statement is: org.evosuite.testcase.statements.AssignmentStatement@34197f01 type is: class org.evosuite.testcase.statements.AssignmentStatement return type int
statement code is: classWriter.threshold = (-317)
statement is: visitSource(Ljava/lang/String;Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classWriter.visitSource("org.apache.commons.io.filefilter.CanWriteFileFilter", "AnnotationDefault")
test data is: ClassWriter classWriter = new ClassWriter(2264);
classWriter.newFieldItem("", "The list of suffixes must not be null", "The list of suffixes must not be null");
classWriter.threshold = (-317);
classWriter.visitSource("org.apache.commons.io.filefilter.CanWriteFileFilter", "AnnotationDefault");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.newFieldItem("ABC", "The list of suffixes must not be null", "The list of suffixes must not be null");
        classWriter.threshold = -317;
        classWriter.visitSource("org.apache.commons.io.filefilter.CanWriteFileFilter", "AnnotationDefault");
    }
}
statement is: classWriter.newFieldItem("ABC", "The list of suffixes must not be null", "The list of suffixes must not be null"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newFieldItem("ABC", "The list of suffixes must not be null", "The list of suffixes must not be null") target is: classWriter method is: newFieldItem(java.lang.String,java.lang.String,java.lang.String)
statement is: classWriter.threshold = -317, class spoon.support.reflect.code.CtAssignmentImpl
statement is: classWriter.visitSource("org.apache.commons.io.filefilter.CanWriteFileFilter", "AnnotationDefault"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visitSource("org.apache.commons.io.filefilter.CanWriteFileFilter", "AnnotationDefault") target is: classWriter method is: visitSource(java.lang.String,java.lang.String)
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-2794))
statement is: newClass(Ljava/lang/String;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int newClass = classWriter.newClass("RuntimeVisibleAnnotations")
test data is: ClassWriter classWriter = new ClassWriter((-2794));
classWriter.newClass("RuntimeVisibleAnnotations");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        int numOfAnnotations = 5;// Number of annotations in the class

        List<Annotation> annotations = new ArrayList<>();// List of annotations for the class

        annotations.add(new Annotation("Ljava/lang/Override;"));// First annotation: @Override

        annotations.add(new Annotation("Ljavax/validation/constraints/NotNull;"));// Second annotation: @NotNull

        annotations.add(new Annotation("Ljavax/validation/constraints/Size;"));// Third annotation: @Size

        annotations.add(new Annotation("Ljavax/validation/constraints/Max;"));// Fourth annotation: @Max

        annotations.add(new Annotation("Ljavax/validation/constraints/Min;"));// Fifth annotation: @Min }}

    }
}
statement is: int numOfAnnotations = 5// Number of annotations in the class
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: List<Annotation> annotations = new ArrayList<>()// List of annotations for the class
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: annotations.add(new Annotation("Ljava/lang/Override;"))// First annotation: @Override
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: annotations.add(new Annotation("Ljava/lang/Override;"))// First annotation: @Override
 target is: annotations method is: add(Annotation)
statement is: annotations.add(new Annotation("Ljavax/validation/constraints/NotNull;"))// Second annotation: @NotNull
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: annotations.add(new Annotation("Ljavax/validation/constraints/NotNull;"))// Second annotation: @NotNull
 target is: annotations method is: add(Annotation)
statement is: annotations.add(new Annotation("Ljavax/validation/constraints/Size;"))// Third annotation: @Size
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: annotations.add(new Annotation("Ljavax/validation/constraints/Size;"))// Third annotation: @Size
 target is: annotations method is: add(Annotation)
statement is: annotations.add(new Annotation("Ljavax/validation/constraints/Max;"))// Fourth annotation: @Max
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: annotations.add(new Annotation("Ljavax/validation/constraints/Max;"))// Fourth annotation: @Max
 target is: annotations method is: add(Annotation)
statement is: annotations.add(new Annotation("Ljavax/validation/constraints/Min;"))// Fifth annotation: @Min }}
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: annotations.add(new Annotation("Ljavax/validation/constraints/Min;"))// Fifth annotation: @Min }}
 target is: annotations method is: add(Annotation)
* this is vulnerable: int _int = 5
TestCase is: int _int = 5;

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(1)
statement is: java.lang.Character(C)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Character
statement code is: Character character = new Character(',')
statement is: newConstItem(Ljava/lang/Object;)Lwheel/asm/Item; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.Item
statement code is: Item newConstItem = classWriter.newConstItem(arg0)
statement is: newConstItem(Ljava/lang/Object;)Lwheel/asm/Item; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.Item
statement code is: Item newConstItem = classWriter.newConstItem(arg0)
test data is: ClassWriter classWriter = new ClassWriter(1);
Character character = new Character(',');
classWriter.newConstItem(character);
classWriter.newConstItem(character);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data for the above code snippet
        ClassWriter classWriter = new ClassWriter(1);
        Character character = new Character('a');// Changed from ',' to 'a' to make it more descriptive and representative of a character.

        classWriter.newConstItem(character);
        classWriter.newConstItem(character);
    }
}
statement is: // Improved test data for the above code snippet
ClassWriter classWriter = new ClassWriter(1), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: Character character = new Character('a')// Changed from ',' to 'a' to make it more descriptive and representative of a character.
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: classWriter.newConstItem(character), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newConstItem(character) target is: classWriter method is: newConstItem(java.lang.Character)
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 1
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 1
Matched Method is: newConstItem(Ljava/lang/Object;)Lwheel/asm/Item;
statement is: classWriter.newConstItem(character), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newConstItem(character) target is: classWriter method is: newConstItem(java.lang.Character)
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 1
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 1
Matched Method is: newConstItem(Ljava/lang/Object;)Lwheel/asm/Item;
TestCase is: int _int = 1;
ClassWriter classWriter = new ClassWriter(_int);
char _char = 'a';
Character character = new Character(_char);
((ClassWriter) _int).newConstItem(character);
((ClassWriter) _int).newConstItem(character);

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(33)
statement is: org.evosuite.testcase.statements.AssignmentStatement@54667d70 type is: class org.evosuite.testcase.statements.AssignmentStatement return type int
statement code is: classWriter.index = (-6)
statement is: newClass(Ljava/lang/String;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int newClass = classWriter.newClass("")
test data is: ClassWriter classWriter = new ClassWriter(33);
classWriter.index = (-6);
classWriter.newClass("");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.index = 12;// Changed to a more descriptive value }}

    }
}
statement is: classWriter.index = 12// Changed to a more descriptive value }}
, class spoon.support.reflect.code.CtAssignmentImpl
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(689)
statement is: newClassItem(Ljava/lang/String;)Lwheel/asm/Item; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.Item
statement code is: Item newClassItem = classWriter.newClassItem("")
test data is: ClassWriter classWriter = new ClassWriter(689);
classWriter.newClassItem("");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        String testString = "classWriterTestString";
    }
}
statement is: String testString = "classWriterTestString", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
* this is vulnerable: String string = "classWriterTestString"
TestCase is: String string = "classWriterTestString";

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-2794))
statement is: org.evosuite.testcase.statements.AssignmentStatement@66751bfe type is: class org.evosuite.testcase.statements.AssignmentStatement return type int
statement code is: classWriter.index = (-2794)
statement is: newConst(Ljava/lang/Object;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int newConst = classWriter.newConst("wheel.asm.ClassWriter")
test data is: ClassWriter classWriter = new ClassWriter((-2794));
classWriter.index = (-2794);
classWriter.newConst("wheel.asm.ClassWriter");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.index = 3019;
    }
}
statement is: classWriter.index = 3019, class spoon.support.reflect.code.CtAssignmentImpl
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-535))
statement is: newInteger(I)Lwheel/asm/Item; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.Item
statement code is: Item newInteger = classWriter.newInteger((-951))
test data is: ClassWriter classWriter = new ClassWriter((-535));
classWriter.newInteger((-951));

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.newInteger(100);// changed to a more descriptive value }}

    }
}
statement is: classWriter.newInteger(100)// changed to a more descriptive value }}
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newInteger(100)// changed to a more descriptive value }}
 target is: classWriter method is: newInteger(int)
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-1086))
statement is: org.evosuite.testcase.statements.AssignmentStatement@70ec7 type is: class org.evosuite.testcase.statements.AssignmentStatement return type int
statement code is: classWriter.index = (-1086)
statement is: newMethod(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Z)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int newMethod = classWriter.newMethod("org.apache.commons.io.filefilter.OrFileFilter", "org.apache.commons.io.filefilter.OrFileFilter", "org.apache.commons.io.filefilter.OrFileFilter", true)
test data is: ClassWriter classWriter = new ClassWriter((-1086));
classWriter.index = (-1086);
classWriter.newMethod("org.apache.commons.io.filefilter.OrFileFilter", "org.apache.commons.io.filefilter.OrFileFilter", "org.apache.commons.io.filefilter.OrFileFilter", true);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.index = Integer.MAX_VALUE;
        classWriter.newMethod("OrFileFilter", "OrFileFilter", "OrFileFilter", true);
    }
}
statement is: classWriter.index = Integer.MAX_VALUE, class spoon.support.reflect.code.CtAssignmentImpl
statement is: classWriter.newMethod("OrFileFilter", "OrFileFilter", "OrFileFilter", true), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newMethod("OrFileFilter", "OrFileFilter", "OrFileFilter", true) target is: classWriter method is: newMethod(java.lang.String,java.lang.String,java.lang.String,boolean)
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-166))
statement is: org.evosuite.testcase.statements.AssignmentStatement@14b1dd56 type is: class org.evosuite.testcase.statements.AssignmentStatement return type int
statement code is: classWriter.index = (-166)
statement is: newNameType(Ljava/lang/String;Ljava/lang/String;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int newNameType = classWriter.newNameType("", "")
test data is: ClassWriter classWriter = new ClassWriter((-166));
classWriter.index = (-166);
classWriter.newNameType("", "");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.index = 0;
        classWriter.newNameType("", "");
    }
}
statement is: classWriter.index = 0, class spoon.support.reflect.code.CtAssignmentImpl
statement is: classWriter.newNameType("", ""), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newNameType("", "") target is: classWriter method is: newNameType(java.lang.String,java.lang.String)
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-6123))
statement is: org.evosuite.testcase.statements.AssignmentStatement@b9d0c3d8 type is: class org.evosuite.testcase.statements.AssignmentStatement return type int
statement code is: classWriter.index = (-6123)
statement is: newUTF8(Ljava/lang/String;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int newUTF8 = classWriter.newUTF8("6Qo")
test data is: ClassWriter classWriter = new ClassWriter((-6123));
classWriter.index = (-6123);
classWriter.newUTF8("6Qo");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.index = 1024;
    }
}
statement is: classWriter.index = 1024, class spoon.support.reflect.code.CtAssignmentImpl
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(66)
statement is: newUTF8(Ljava/lang/String;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int newUTF8 = classWriter.newUTF8("java/lang/Object")
test data is: ClassWriter classWriter = new ClassWriter(66);
classWriter.newUTF8("java/lang/Object");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classWriter.newUTF8("java/util/HashMap");
    }
}
statement is: classWriter.newUTF8("java/util/HashMap"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.newUTF8("java/util/HashMap") target is: classWriter method is: newUTF8(java.lang.String)
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(0)
statement is: org.evosuite.testcase.statements.ArrayStatement@997bd167 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[6]
statement is: org.evosuite.testcase.statements.AssignmentStatement@7efaf455 type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[0] = "|q"
statement is: org.evosuite.testcase.statements.AssignmentStatement@d43ba184 type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[1] = "|q"
statement is: org.evosuite.testcase.statements.AssignmentStatement@a0367a88 type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[2] = "|q"
statement is: org.evosuite.testcase.statements.AssignmentStatement@e3f91b5a type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[3] = "|q"
statement is: org.evosuite.testcase.statements.AssignmentStatement@d659be55 type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[4] = "|q"
statement is: org.evosuite.testcase.statements.AssignmentStatement@dd0023c8 type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[5] = "|q"
statement is: visitMethod(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)Lwheel/asm/MethodVisitor; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.MethodWriter
statement code is: MethodWriter visitMethod = (MethodWriter)classWriter.visitMethod(0, "|q", "|q", "|q", arg4)
test data is: ClassWriter classWriter = new ClassWriter(0);
String[] stringArray = new String[6];
stringArray[0] = "|q";
stringArray[1] = "|q";
stringArray[2] = "|q";
stringArray[3] = "|q";
stringArray[4] = "|q";
stringArray[5] = "|q";
classWriter.visitMethod(0, "|q", "|q", "|q", stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        String[] stringArray = new String[6];
        stringArray[0] = "add";
        stringArray[1] = "subtract";
        stringArray[2] = "multiply";
        stringArray[3] = "divide";
        stringArray[4] = "remainder";
        stringArray[5] = "power";
        classWriter.visitMethod(0, "arithmeticOperation", "calculate", "int", stringArray);
    }
}
statement is: String[] stringArray = new String[6], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [6] Ct is: String[] stringArray = new String[6] isAssignment: false Array: new String[6] Elements: []
lengths: [6] [6]
Their type are: class [Ljava.lang.String; String[]
statement is: stringArray[0] = "add", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"add" Ct is: stringArray[0] = "add"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@179ad8ef
statement is: stringArray[1] = "subtract", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[1] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"subtract" Ct is: stringArray[1] = "subtract"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@561fb2d9
statement is: stringArray[2] = "multiply", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[2] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"multiply" Ct is: stringArray[2] = "multiply"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@2803d92a
statement is: stringArray[3] = "divide", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[3] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"divide" Ct is: stringArray[3] = "divide"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@679e213f
statement is: stringArray[4] = "remainder", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[4] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"remainder" Ct is: stringArray[4] = "remainder"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@b95e1a5c
statement is: stringArray[5] = "power", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[5] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"power" Ct is: stringArray[5] = "power"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@d2bafdf7
statement is: classWriter.visitMethod(0, "arithmeticOperation", "calculate", "int", stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visitMethod(0, "arithmeticOperation", "calculate", "int", stringArray) target is: classWriter method is: visitMethod(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[])
* this is vulnerable: String string = "add"
* this is vulnerable: String string = "subtract"
* this is vulnerable: String string = "multiply"
* this is vulnerable: String string = "divide"
* this is vulnerable: String string = "remainder"
* this is vulnerable: String string = "power"
TestCase is: String[] stringArray = new String[6];
String string = "add";
String string = "subtract";
String string = "multiply";
String string = "divide";
String string = "remainder";
String string = "power";

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-535))
statement is: addUninitializedType(Ljava/lang/String;I)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int addUninitializedType = classWriter.addUninitializedType("wheel.asm.ClassWriter", (-535))
statement is: addUninitializedType(Ljava/lang/String;I)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int addUninitializedType = classWriter.addUninitializedType("", 1307)
statement is: getMergedType(II)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int mergedType = classWriter.getMergedType(2, 2)
test data is: ClassWriter classWriter = new ClassWriter((-535));
classWriter.addUninitializedType("wheel.asm.ClassWriter", (-535));
classWriter.addUninitializedType("", 1307);
classWriter.getMergedType(2, 2);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        int x = -535;// Primitive type int with a negative value

        String s = "wheel.asm.ClassWriter";// String representing a class name

        String t = "HelloWorld";// A string with some descriptive text

        int y = 1307;// Primitive type int with a positive value }}

    }
}
statement is: int x = -535// Primitive type int with a negative value
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtUnaryOperatorImpl
IT HAS NOT BEEN SUPPORTED YET: -535
statement is: String s = "wheel.asm.ClassWriter"// String representing a class name
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String t = "HelloWorld"// A string with some descriptive text
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: int y = 1307// Primitive type int with a positive value }}
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
* this is vulnerable: String string = "wheel.asm.ClassWriter"
* this is vulnerable: String string = "HelloWorld"
* this is vulnerable: int _int = 1307
TestCase is: String string = "wheel.asm.ClassWriter";
String string = "HelloWorld";
int _int = 1307;

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-39))
statement is: org.evosuite.testcase.statements.ArrayStatement@c5b6c9aa type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[1]
statement is: org.evosuite.testcase.statements.AssignmentStatement@f2ed6dfa type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[0] = "=>BI=^LKK?fW4r`y"
statement is: visit(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classWriter.visit((-39), (-39), "=>BI=^LKK?fW4r`y", "=>BI=^LKK?fW4r`y", ",f", arg5)
statement is: org.evosuite.testcase.statements.AssignmentStatement@607d4507 type is: class org.evosuite.testcase.statements.AssignmentStatement return type boolean
statement code is: classWriter.invalidFrames = true
statement is: toByteArray()[B type is: class org.evosuite.testcase.statements.MethodStatement return type class [B
statement code is: byte[] byteArray = classWriter.toByteArray()
test data is: ClassWriter classWriter = new ClassWriter((-39));
String[] stringArray = new String[1];
stringArray[0] = "=>BI=^LKK?fW4r`y";
classWriter.visit((-39), (-39), "=>BI=^LKK?fW4r`y", "=>BI=^LKK?fW4r`y", ",f", stringArray);
classWriter.invalidFrames = true;
classWriter.toByteArray();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        String[] stringArray = new String[1];
        stringArray[0] = "MyTestClass";
        classWriter.visit(39, 39, "MyTestClass", "MyTestClass", ",f", stringArray);
        classWriter.invalidFrames = true;
        classWriter.toByteArray();
    }
}
statement is: String[] stringArray = new String[1], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [1] Ct is: String[] stringArray = new String[1] isAssignment: false Array: new String[1] Elements: []
lengths: [1] [1]
Their type are: class [Ljava.lang.String; String[]
statement is: stringArray[0] = "MyTestClass", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"MyTestClass" Ct is: stringArray[0] = "MyTestClass"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@71a2f52c
statement is: classWriter.visit(39, 39, "MyTestClass", "MyTestClass", ",f", stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visit(39, 39, "MyTestClass", "MyTestClass", ",f", stringArray) target is: classWriter method is: visit(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[])
statement is: classWriter.invalidFrames = true, class spoon.support.reflect.code.CtAssignmentImpl
statement is: classWriter.toByteArray(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.toByteArray() target is: classWriter method is: toByteArray()
* this is vulnerable: String string = "MyTestClass"
TestCase is: String[] stringArray = new String[1];
String string = "MyTestClass";

statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(32)
statement is: visitEnd()V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classWriter.visitEnd()
test data is: ClassWriter classWriter = new ClassWriter(32);
classWriter.visitEnd();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        int x = -1;
        double y = 0.0;
        String z = "";
        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        classWriter.visitEnd();
    }
}
statement is: int x = -1, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtUnaryOperatorImpl
IT HAS NOT BEEN SUPPORTED YET: -1
statement is: double y = 0.0, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String z = "", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: classWriter.visitEnd(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visitEnd() target is: classWriter method is: visitEnd()
source statement: wheel.asm.ClassWriter(I)V callee: VariableReference: Statement 0, type wheel.asm.ClassWriterindex is: 2
Matched Method is: visitEnd()V
* this is vulnerable: String string = ""
TestCase is: double _double = 0.0;
String string = "";
ClassWriter classWriter = new ClassWriter(32);
((ClassWriter) _double).visitEnd();

* test suite isTestSuite: 66
Test 0: 
ClassWriter classWriter = new ClassWriter(59);
classWriter.visitField(59, "", "7$l;2/V[pfu:w", "", "7$l;2/V[pfu:w");
classWriter.toByteArray();
Test 1: 
ClassWriter classWriter = new ClassWriter((-2385));
classWriter.newMethod("", "", "", false);
classWriter.newMethod("", "", "", false);
Test 2: 
ClassReader classReader = new ClassReader("java/lang/String");
ClassWriter classWriter = new ClassWriter(classReader, 4);
classReader.accept((ClassVisitor) classWriter, 21);
Test 3: 
ClassWriter classWriter = new ClassWriter(2620);
String[] stringArray = new String[8];
// Undeclared exception!
try { 
  classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", (String) null, (String) null, stringArray);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 4: 
ClassWriter classWriter = new ClassWriter(14);
classWriter.visit(16777217, 6, "a|4F!Tx}", "", "", (String[]) null);
Test 5: 
ClassWriter classWriter = new ClassWriter((-2420));
classWriter.visitSource((String) null, "");
Test 6: 
ClassWriter classWriter = new ClassWriter(66);
classWriter.visitOuterClass("", (String) null, "");
Test 7: 
ClassWriter classWriter = new ClassWriter((-2420));
classWriter.visitOuterClass("", "wheel.asm.ClassWriter", (String) null);
Test 8: 
ClassWriter classWriter = new ClassWriter(2855);
classWriter.visitOuterClass("}MNV?", "}MNV?", "Deprecated");
classWriter.toByteArray();
Test 9: 
ClassWriter classWriter = new ClassWriter(65);
classWriter.visitInnerClass((String) null, "Sensitive", (String) null, 17);
Test 10: 
ClassWriter classWriter = new ClassWriter(10);
MethodWriter methodWriter = new MethodWriter(classWriter, 0, "wheel.asm.ClassWriter", "wheel.asm.ClassWriter", "tU/M\"wIn!:%F", (String[]) null, false, false);
classWriter.toByteArray();
Test 11: 
ClassWriter classWriter = new ClassWriter((-36));
classWriter.visitSource("{LGT", "{LGT");
classWriter.toByteArray();
Test 12: 
ClassWriter classWriter = new ClassWriter((-526));
String[] stringArray = new String[0];
classWriter.visit(13, (-526), "1cug$(C", "1cug$(C", (String) null, stringArray);
classWriter.toByteArray();
Test 13: 
ClassWriter classWriter = new ClassWriter(20);
classWriter.visitInnerClass((String) null, (String) null, (String) null, 20);
classWriter.toByteArray();
Test 14: 
ClassWriter classWriter = new ClassWriter(689);
classWriter.visitAnnotation("Signature", true);
classWriter.toByteArray();
Test 15: 
ClassWriter classWriter = new ClassWriter((-2103));
classWriter.visitAnnotation("SourceDebugExtension", false);
classWriter.toByteArray();
Test 16: 
ClassWriter classWriter = new ClassWriter(18);
Attribute attribute = new Attribute("");
byte[] byteArray = new byte[0];
attribute.value = byteArray;
classWriter.visitAttribute(attribute);
classWriter.toByteArray();
Test 17: 
ClassWriter classWriter = new ClassWriter(25);
classWriter.invalidFrames = true;
// Undeclared exception!
try { 
  classWriter.toByteArray();
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 18: 
ClassWriter classWriter = new ClassWriter((-5));
// Undeclared exception!
try { 
  classWriter.newConst(classWriter);
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // value wheel.asm.ClassWriter@5
   //
   verifyException("wheel.asm.ClassWriter", e);
}

Test 19: 
ClassWriter classWriter = new ClassWriter(59);
classWriter.newField("\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y");
classWriter.newField("\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y");
Test 20: 
ClassWriter classWriter = new ClassWriter(14);
classWriter.newFloat(14);
classWriter.newFloat(14);
Test 21: 
ClassWriter classWriter = new ClassWriter(59);
classWriter.newLong(0L);
Test 22: 
ClassWriter classWriter = new ClassWriter(54);
classWriter.newDouble(54);
classWriter.newDouble(54);
Test 23: 
ClassWriter classWriter = new ClassWriter(14);
classWriter.newConstItem("Z=[");
classWriter.newConstItem("Z=[");
Test 24: 
ClassWriter classWriter = new ClassWriter(3182);
classWriter.newMethodItem("@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(", false);
classWriter.newNameType("@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(");
Test 25: 
ClassWriter classWriter = new ClassWriter(5);
classWriter.addType("k");
classWriter.addType("k");
Test 26: 
ClassWriter classWriter = new ClassWriter(11);
classWriter.addUninitializedType("StackMap", 1394);
classWriter.addUninitializedType("StackMap", 1394);
Test 27: 
ClassWriter classWriter = new ClassWriter(14);
Item[] itemArray = new Item[2];
classWriter.typeTable = itemArray;
classWriter.addUninitializedType("`", 14);
classWriter.addType(".s.IFJDCS");
Test 28: 
ClassWriter classWriter = new ClassWriter((-2420));
classWriter.getCommonSuperClass("org.apache.commons.io.filefilter.DirectoryFileFilter", "java/lang/Class");
Test 29: 
ClassWriter classWriter = new ClassWriter(5);
classWriter.getCommonSuperClass("java/lang/Object", "java/lang/Object");
Test 30: 
ClassWriter classWriter = new ClassWriter((-5));
classWriter.getCommonSuperClass("wheel.asm.ClassWriter", "java/lang/Object");
Test 31: 
ClassWriter classWriter = new ClassWriter(2074);
classWriter.index = 2074;
Character character = new Character('i');
classWriter.newConst(character);
Test 32: 
ClassWriter classWriter = new ClassWriter(2264);
classWriter.newFieldItem("", "The list of suffixes must not be null", "The list of suffixes must not be null");
classWriter.threshold = (-317);
classWriter.visitSource("org.apache.commons.io.filefilter.CanWriteFileFilter", "AnnotationDefault");
Test 33: 
ClassWriter classWriter = new ClassWriter((-2794));
classWriter.newClass("RuntimeVisibleAnnotations");
Test 34: 
ClassWriter classWriter = new ClassWriter(1);
Character character = new Character(',');
classWriter.newConstItem(character);
classWriter.newConstItem(character);
Test 35: 
ClassWriter classWriter = new ClassWriter(33);
classWriter.index = (-6);
classWriter.newClass("");
Test 36: 
ClassWriter classWriter = new ClassWriter(689);
classWriter.newClassItem("");
Test 37: 
ClassWriter classWriter = new ClassWriter((-2794));
classWriter.index = (-2794);
classWriter.newConst("wheel.asm.ClassWriter");
Test 38: 
ClassWriter classWriter = new ClassWriter((-535));
classWriter.newInteger((-951));
Test 39: 
ClassWriter classWriter = new ClassWriter((-1086));
classWriter.index = (-1086);
classWriter.newMethod("org.apache.commons.io.filefilter.OrFileFilter", "org.apache.commons.io.filefilter.OrFileFilter", "org.apache.commons.io.filefilter.OrFileFilter", true);
Test 40: 
ClassWriter classWriter = new ClassWriter((-166));
classWriter.index = (-166);
classWriter.newNameType("", "");
Test 41: 
ClassWriter classWriter = new ClassWriter((-6123));
classWriter.index = (-6123);
classWriter.newUTF8("6Qo");
Test 42: 
ClassWriter classWriter = new ClassWriter(66);
classWriter.newUTF8("java/lang/Object");
Test 43: 
ClassWriter classWriter = new ClassWriter(0);
String[] stringArray = new String[6];
stringArray[0] = "|q";
stringArray[1] = "|q";
stringArray[2] = "|q";
stringArray[3] = "|q";
stringArray[4] = "|q";
stringArray[5] = "|q";
classWriter.visitMethod(0, "|q", "|q", "|q", stringArray);
Test 44: 
ClassWriter classWriter = new ClassWriter((-535));
classWriter.addUninitializedType("wheel.asm.ClassWriter", (-535));
classWriter.addUninitializedType("", 1307);
// Undeclared exception!
try { 
  classWriter.getMergedType(2, 2);
  fail("Expecting exception: RuntimeException");

} catch(RuntimeException e) {
   //
   // java.lang.ClassNotFoundException: 
   //
   verifyException("wheel.asm.ClassWriter", e);
}

Test 45: 
ClassWriter classWriter = new ClassWriter((-39));
String[] stringArray = new String[1];
stringArray[0] = "=>BI=^LKK?fW4r`y";
classWriter.visit((-39), (-39), "=>BI=^LKK?fW4r`y", "=>BI=^LKK?fW4r`y", ",f", stringArray);
classWriter.invalidFrames = true;
classWriter.toByteArray();
Test 46: 
ClassWriter classWriter = new ClassWriter(32);
classWriter.visitEnd();
Test 47: 

Test 48: 
String[] stringArray = new String[8];
ClassWriter classWriter = new ClassWriter(2620);
String[] stringArray = new String[8];
((ClassWriter) stringArray).visit(14, 16777215, "RuntimeVisibleAnnotations", (String) stringArray, (String) null, (String[]) null);
int _int = 30;
ClassWriter classWriter = new ClassWriter(_int);
String[] stringArray = new String[8];
int _int = 14;
int _int = 16777215;
String string = "RuntimeVisibleAnnotations";
String string = null;
String[] stringArray = null;
((ClassWriter) stringArray).visit(_int, _int, string, (String) stringArray, string, stringArray);

Test 49: 
ClassWriter classWriter = new ClassWriter(14);
((ClassWriter)14).visit(16777217, 6, "a|4F!Tx}", "", "", (String[]) null);

Test 50: 
MethodWriter methodWriter = new MethodWriter((ClassWriter) 0, (int) "wheel.asm.ClassWriter", "wheel.asm.ClassWriter", "tU/M\"wIn!:%F", (String) false, (String[]) false, false, false);

Test 51: 
int _int = 20;
ClassWriter classWriter = new ClassWriter(20);
((ClassWriter)20).visitSource("TestClass", "TestClass");
((ClassWriter) _int).toByteArray();

Test 52: 
String[] stringArray = new String[0];
ClassWriter classWriter = new ClassWriter((-526));
((ClassWriter) stringArray).visit(13, (int) "1cug$(C", "1cug$(C", (String) stringArray, (String) null, (String[]) null);
((ClassWriter) stringArray).toByteArray();

Test 53: 
Attribute attribute = new Attribute("custom_attribute");

Test 54: 

Test 55: 
int _int = 32;
ClassWriter classWriter = new ClassWriter(32);
((ClassWriter)32).newFloat(25);
double _double = 62.5;
((ClassWriter) _int).newFloat((float) _double);

Test 56: 
long _long = 23456789L;
ClassWriter classWriter = new ClassWriter((int) 23456789L);
long _long = 10000000000L;
((ClassWriter) _long).newLong(_long);

Test 57: 
Item[] itemArray = new Item[2];

Test 58: 
Character character = new Character('a');

Test 59: 

Test 60: 
int _int = 1;
ClassWriter classWriter = new ClassWriter(1);
Character character = new Character('a');
((ClassWriter)1).newConstItem(character);
((ClassWriter) _int).newConstItem(character);

Test 61: 

Test 62: 
String[] stringArray = new String[6];

Test 63: 

Test 64: 
String[] stringArray = new String[1];

Test 65: 
ClassWriter classWriter = new ClassWriter(32);
((ClassWriter)0.0).visitEnd();


* Generated after the refinement and before minimization 66 tests with total length 190
* test suite isTestSuite: 66
Test 0: 
ClassWriter classWriter = new ClassWriter(59);
classWriter.visitField(59, "", "7$l;2/V[pfu:w", "", "7$l;2/V[pfu:w");
classWriter.toByteArray();
Test 1: 
ClassWriter classWriter = new ClassWriter((-2385));
classWriter.newMethod("", "", "", false);
classWriter.newMethod("", "", "", false);
Test 2: 
ClassReader classReader = new ClassReader("java/lang/String");
ClassWriter classWriter = new ClassWriter(classReader, 4);
classReader.accept((ClassVisitor) classWriter, 21);
Test 3: 
ClassWriter classWriter = new ClassWriter(2620);
String[] stringArray = new String[8];
// Undeclared exception!
try { 
  classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", (String) null, (String) null, stringArray);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 4: 
ClassWriter classWriter = new ClassWriter(14);
classWriter.visit(16777217, 6, "a|4F!Tx}", "", "", (String[]) null);
Test 5: 
ClassWriter classWriter = new ClassWriter((-2420));
classWriter.visitSource((String) null, "");
Test 6: 
ClassWriter classWriter = new ClassWriter(66);
classWriter.visitOuterClass("", (String) null, "");
Test 7: 
ClassWriter classWriter = new ClassWriter((-2420));
classWriter.visitOuterClass("", "wheel.asm.ClassWriter", (String) null);
Test 8: 
ClassWriter classWriter = new ClassWriter(2855);
classWriter.visitOuterClass("}MNV?", "}MNV?", "Deprecated");
classWriter.toByteArray();
Test 9: 
ClassWriter classWriter = new ClassWriter(65);
classWriter.visitInnerClass((String) null, "Sensitive", (String) null, 17);
Test 10: 
ClassWriter classWriter = new ClassWriter(10);
MethodWriter methodWriter = new MethodWriter(classWriter, 0, "wheel.asm.ClassWriter", "wheel.asm.ClassWriter", "tU/M\"wIn!:%F", (String[]) null, false, false);
classWriter.toByteArray();
Test 11: 
ClassWriter classWriter = new ClassWriter((-36));
classWriter.visitSource("{LGT", "{LGT");
classWriter.toByteArray();
Test 12: 
ClassWriter classWriter = new ClassWriter((-526));
String[] stringArray = new String[0];
classWriter.visit(13, (-526), "1cug$(C", "1cug$(C", (String) null, stringArray);
classWriter.toByteArray();
Test 13: 
ClassWriter classWriter = new ClassWriter(20);
classWriter.visitInnerClass((String) null, (String) null, (String) null, 20);
classWriter.toByteArray();
Test 14: 
ClassWriter classWriter = new ClassWriter(689);
classWriter.visitAnnotation("Signature", true);
classWriter.toByteArray();
Test 15: 
ClassWriter classWriter = new ClassWriter((-2103));
classWriter.visitAnnotation("SourceDebugExtension", false);
classWriter.toByteArray();
Test 16: 
ClassWriter classWriter = new ClassWriter(18);
Attribute attribute = new Attribute("");
byte[] byteArray = new byte[0];
attribute.value = byteArray;
classWriter.visitAttribute(attribute);
classWriter.toByteArray();
Test 17: 
ClassWriter classWriter = new ClassWriter(25);
classWriter.invalidFrames = true;
// Undeclared exception!
try { 
  classWriter.toByteArray();
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 18: 
ClassWriter classWriter = new ClassWriter((-5));
// Undeclared exception!
try { 
  classWriter.newConst(classWriter);
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // value wheel.asm.ClassWriter@5
   //
   verifyException("wheel.asm.ClassWriter", e);
}

Test 19: 
ClassWriter classWriter = new ClassWriter(59);
classWriter.newField("\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y");
classWriter.newField("\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y");
Test 20: 
ClassWriter classWriter = new ClassWriter(14);
classWriter.newFloat(14);
classWriter.newFloat(14);
Test 21: 
ClassWriter classWriter = new ClassWriter(59);
classWriter.newLong(0L);
Test 22: 
ClassWriter classWriter = new ClassWriter(54);
classWriter.newDouble(54);
classWriter.newDouble(54);
Test 23: 
ClassWriter classWriter = new ClassWriter(14);
classWriter.newConstItem("Z=[");
classWriter.newConstItem("Z=[");
Test 24: 
ClassWriter classWriter = new ClassWriter(3182);
classWriter.newMethodItem("@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(", false);
classWriter.newNameType("@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(");
Test 25: 
ClassWriter classWriter = new ClassWriter(5);
classWriter.addType("k");
classWriter.addType("k");
Test 26: 
ClassWriter classWriter = new ClassWriter(11);
classWriter.addUninitializedType("StackMap", 1394);
classWriter.addUninitializedType("StackMap", 1394);
Test 27: 
ClassWriter classWriter = new ClassWriter(14);
Item[] itemArray = new Item[2];
classWriter.typeTable = itemArray;
classWriter.addUninitializedType("`", 14);
classWriter.addType(".s.IFJDCS");
Test 28: 
ClassWriter classWriter = new ClassWriter((-2420));
classWriter.getCommonSuperClass("org.apache.commons.io.filefilter.DirectoryFileFilter", "java/lang/Class");
Test 29: 
ClassWriter classWriter = new ClassWriter(5);
classWriter.getCommonSuperClass("java/lang/Object", "java/lang/Object");
Test 30: 
ClassWriter classWriter = new ClassWriter((-5));
classWriter.getCommonSuperClass("wheel.asm.ClassWriter", "java/lang/Object");
Test 31: 
ClassWriter classWriter = new ClassWriter(2074);
classWriter.index = 2074;
Character character = new Character('i');
classWriter.newConst(character);
Test 32: 
ClassWriter classWriter = new ClassWriter(2264);
classWriter.newFieldItem("", "The list of suffixes must not be null", "The list of suffixes must not be null");
classWriter.threshold = (-317);
classWriter.visitSource("org.apache.commons.io.filefilter.CanWriteFileFilter", "AnnotationDefault");
Test 33: 
ClassWriter classWriter = new ClassWriter((-2794));
classWriter.newClass("RuntimeVisibleAnnotations");
Test 34: 
ClassWriter classWriter = new ClassWriter(1);
Character character = new Character(',');
classWriter.newConstItem(character);
classWriter.newConstItem(character);
Test 35: 
ClassWriter classWriter = new ClassWriter(33);
classWriter.index = (-6);
classWriter.newClass("");
Test 36: 
ClassWriter classWriter = new ClassWriter(689);
classWriter.newClassItem("");
Test 37: 
ClassWriter classWriter = new ClassWriter((-2794));
classWriter.index = (-2794);
classWriter.newConst("wheel.asm.ClassWriter");
Test 38: 
ClassWriter classWriter = new ClassWriter((-535));
classWriter.newInteger((-951));
Test 39: 
ClassWriter classWriter = new ClassWriter((-1086));
classWriter.index = (-1086);
classWriter.newMethod("org.apache.commons.io.filefilter.OrFileFilter", "org.apache.commons.io.filefilter.OrFileFilter", "org.apache.commons.io.filefilter.OrFileFilter", true);
Test 40: 
ClassWriter classWriter = new ClassWriter((-166));
classWriter.index = (-166);
classWriter.newNameType("", "");
Test 41: 
ClassWriter classWriter = new ClassWriter((-6123));
classWriter.index = (-6123);
classWriter.newUTF8("6Qo");
Test 42: 
ClassWriter classWriter = new ClassWriter(66);
classWriter.newUTF8("java/lang/Object");
Test 43: 
ClassWriter classWriter = new ClassWriter(0);
String[] stringArray = new String[6];
stringArray[0] = "|q";
stringArray[1] = "|q";
stringArray[2] = "|q";
stringArray[3] = "|q";
stringArray[4] = "|q";
stringArray[5] = "|q";
classWriter.visitMethod(0, "|q", "|q", "|q", stringArray);
Test 44: 
ClassWriter classWriter = new ClassWriter((-535));
classWriter.addUninitializedType("wheel.asm.ClassWriter", (-535));
classWriter.addUninitializedType("", 1307);
// Undeclared exception!
try { 
  classWriter.getMergedType(2, 2);
  fail("Expecting exception: RuntimeException");

} catch(RuntimeException e) {
   //
   // java.lang.ClassNotFoundException: 
   //
   verifyException("wheel.asm.ClassWriter", e);
}

Test 45: 
ClassWriter classWriter = new ClassWriter((-39));
String[] stringArray = new String[1];
stringArray[0] = "=>BI=^LKK?fW4r`y";
classWriter.visit((-39), (-39), "=>BI=^LKK?fW4r`y", "=>BI=^LKK?fW4r`y", ",f", stringArray);
classWriter.invalidFrames = true;
classWriter.toByteArray();
Test 46: 
ClassWriter classWriter = new ClassWriter(32);
classWriter.visitEnd();
Test 47: 

Test 48: 
String[] stringArray = new String[8];
ClassWriter classWriter = new ClassWriter(2620);
String[] stringArray = new String[8];
((ClassWriter) stringArray).visit(14, 16777215, "RuntimeVisibleAnnotations", (String) stringArray, (String) null, (String[]) null);
int _int = 30;
ClassWriter classWriter = new ClassWriter(_int);
String[] stringArray = new String[8];
int _int = 14;
int _int = 16777215;
String string = "RuntimeVisibleAnnotations";
String string = null;
String[] stringArray = null;
((ClassWriter) stringArray).visit(_int, _int, string, (String) stringArray, string, stringArray);

Test 49: 
ClassWriter classWriter = new ClassWriter(14);
((ClassWriter)14).visit(16777217, 6, "a|4F!Tx}", "", "", (String[]) null);

Test 50: 
MethodWriter methodWriter = new MethodWriter((ClassWriter) 0, (int) "wheel.asm.ClassWriter", "wheel.asm.ClassWriter", "tU/M\"wIn!:%F", (String) false, (String[]) false, false, false);

Test 51: 
int _int = 20;
ClassWriter classWriter = new ClassWriter(20);
((ClassWriter)20).visitSource("TestClass", "TestClass");
((ClassWriter) _int).toByteArray();

Test 52: 
String[] stringArray = new String[0];
ClassWriter classWriter = new ClassWriter((-526));
((ClassWriter) stringArray).visit(13, (int) "1cug$(C", "1cug$(C", (String) stringArray, (String) null, (String[]) null);
((ClassWriter) stringArray).toByteArray();

Test 53: 
Attribute attribute = new Attribute("custom_attribute");

Test 54: 

Test 55: 
int _int = 32;
ClassWriter classWriter = new ClassWriter(32);
((ClassWriter)32).newFloat(25);
double _double = 62.5;
((ClassWriter) _int).newFloat((float) _double);

Test 56: 
long _long = 23456789L;
ClassWriter classWriter = new ClassWriter((int) 23456789L);
long _long = 10000000000L;
((ClassWriter) _long).newLong(_long);

Test 57: 
Item[] itemArray = new Item[2];

Test 58: 
Character character = new Character('a');

Test 59: 

Test 60: 
int _int = 1;
ClassWriter classWriter = new ClassWriter(1);
Character character = new Character('a');
((ClassWriter)1).newConstItem(character);
((ClassWriter) _int).newConstItem(character);

Test 61: 

Test 62: 
String[] stringArray = new String[6];

Test 63: 

Test 64: 
String[] stringArray = new String[1];

Test 65: 
ClassWriter classWriter = new ClassWriter(32);
((ClassWriter)0.0).visitEnd();


* Minimizing test suite
* test suite isTestSuite: 49
Test 0: 
ClassWriter classWriter = new ClassWriter(59);
classWriter.newField("\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y");
classWriter.newField("\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y");
Test 1: 
ClassReader classReader = new ClassReader("java/lang/String");
ClassWriter classWriter = new ClassWriter(classReader, 4);
classReader.accept((ClassVisitor) classWriter, 21);
Test 2: 
ClassWriter classWriter = new ClassWriter((-5));
// Undeclared exception!
try { 
  classWriter.newConst(classWriter);
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // value wheel.asm.ClassWriter@5
   //
   verifyException("wheel.asm.ClassWriter", e);
}

Test 3: 
ClassWriter classWriter = new ClassWriter(2620);
String[] stringArray = new String[8];
// Undeclared exception!
try { 
  classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", (String) null, (String) null, stringArray);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 4: 
ClassWriter classWriter = new ClassWriter(14);
classWriter.visit(16777217, 6, "a|4F!Tx}", "", "", (String[]) null);
Test 5: 
ClassWriter classWriter = new ClassWriter((-526));
String[] stringArray = new String[0];
classWriter.visit(13, (-526), "1cug$(C", "1cug$(C", (String) null, stringArray);
classWriter.toByteArray();
Test 6: 
ClassWriter classWriter = new ClassWriter((-2420));
classWriter.visitSource((String) null, "");
Test 7: 
ClassWriter classWriter = new ClassWriter(66);
classWriter.visitOuterClass("", (String) null, "");
Test 8: 
ClassWriter classWriter = new ClassWriter((-2420));
classWriter.visitOuterClass("", "wheel.asm.ClassWriter", (String) null);
Test 9: 
ClassWriter classWriter = new ClassWriter(2855);
classWriter.visitOuterClass("}MNV?", "}MNV?", "Deprecated");
classWriter.toByteArray();
Test 10: 
ClassWriter classWriter = new ClassWriter((-2103));
classWriter.visitAnnotation("SourceDebugExtension", false);
classWriter.toByteArray();
Test 11: 
ClassWriter classWriter = new ClassWriter(689);
classWriter.visitAnnotation("Signature", true);
classWriter.toByteArray();
Test 12: 
ClassWriter classWriter = new ClassWriter(65);
classWriter.visitInnerClass((String) null, "Sensitive", (String) null, 17);
Test 13: 
ClassWriter classWriter = new ClassWriter(59);
classWriter.visitField(59, "", "7$l;2/V[pfu:w", "", "7$l;2/V[pfu:w");
classWriter.toByteArray();
Test 14: 
ClassWriter classWriter = new ClassWriter(10);
MethodWriter methodWriter = new MethodWriter(classWriter, 0, "wheel.asm.ClassWriter", "wheel.asm.ClassWriter", "tU/M\"wIn!:%F", (String[]) null, false, false);
classWriter.toByteArray();
Test 15: 
ClassWriter classWriter = new ClassWriter((-36));
classWriter.visitSource("{LGT", "{LGT");
classWriter.toByteArray();
Test 16: 
ClassWriter classWriter = new ClassWriter(20);
classWriter.visitInnerClass((String) null, (String) null, (String) null, 20);
classWriter.toByteArray();
Test 17: 
ClassWriter classWriter = new ClassWriter(18);
Attribute attribute = new Attribute("");
byte[] byteArray = new byte[0];
attribute.value = byteArray;
classWriter.visitAttribute(attribute);
classWriter.toByteArray();
Test 18: 
ClassWriter classWriter = new ClassWriter(25);
classWriter.invalidFrames = true;
// Undeclared exception!
try { 
  classWriter.toByteArray();
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 19: 
ClassWriter classWriter = new ClassWriter(1);
Character character = new Character(',');
classWriter.newConstItem(character);
classWriter.newConstItem(character);
Test 20: 
ClassWriter classWriter = new ClassWriter((-2385));
classWriter.newMethod("", "", "", false);
classWriter.newMethod("", "", "", false);
Test 21: 
ClassWriter classWriter = new ClassWriter(14);
classWriter.newFloat(14);
classWriter.newFloat(14);
Test 22: 
ClassWriter classWriter = new ClassWriter(59);
classWriter.newLong(0L);
Test 23: 
ClassWriter classWriter = new ClassWriter(54);
classWriter.newDouble(54);
classWriter.newDouble(54);
Test 24: 
ClassWriter classWriter = new ClassWriter(14);
classWriter.newConstItem("Z=[");
classWriter.newConstItem("Z=[");
Test 25: 
ClassWriter classWriter = new ClassWriter(3182);
classWriter.newMethodItem("@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(", false);
classWriter.newNameType("@V}C^;!7[Jthpc[(", "@V}C^;!7[Jthpc[(");
Test 26: 
ClassWriter classWriter = new ClassWriter(5);
classWriter.addType("k");
classWriter.addType("k");
Test 27: 
ClassWriter classWriter = new ClassWriter(11);
classWriter.addUninitializedType("StackMap", 1394);
classWriter.addUninitializedType("StackMap", 1394);
Test 28: 
ClassWriter classWriter = new ClassWriter((-535));
classWriter.addUninitializedType("wheel.asm.ClassWriter", (-535));
classWriter.addUninitializedType("", 1307);
// Undeclared exception!
try { 
  classWriter.getMergedType(2, 2);
  fail("Expecting exception: RuntimeException");

} catch(RuntimeException e) {
   //
   // java.lang.ClassNotFoundException: 
   //
   verifyException("wheel.asm.ClassWriter", e);
}

Test 29: 
ClassWriter classWriter = new ClassWriter(14);
Item[] itemArray = new Item[2];
classWriter.typeTable = itemArray;
classWriter.addUninitializedType("`", 14);
classWriter.addType(".s.IFJDCS");
Test 30: 
ClassWriter classWriter = new ClassWriter((-535));
// Undeclared exception!
try { 
  classWriter.getMergedType(2, 2);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("wheel.asm.ClassWriter", e);
}

Test 31: 
ClassWriter classWriter = new ClassWriter((-2420));
classWriter.getCommonSuperClass("org.apache.commons.io.filefilter.DirectoryFileFilter", "java/lang/Class");
Test 32: 
ClassWriter classWriter = new ClassWriter(5);
classWriter.getCommonSuperClass("java/lang/Object", "java/lang/Object");
Test 33: 
ClassWriter classWriter = new ClassWriter((-5));
classWriter.getCommonSuperClass("wheel.asm.ClassWriter", "java/lang/Object");
Test 34: 
ClassWriter classWriter = new ClassWriter(2074);
classWriter.index = 2074;
Character character = new Character('i');
classWriter.newConst(character);
Test 35: 
ClassWriter classWriter = new ClassWriter(2264);
classWriter.newFieldItem("", "The list of suffixes must not be null", "The list of suffixes must not be null");
classWriter.threshold = (-317);
classWriter.visitSource("org.apache.commons.io.filefilter.CanWriteFileFilter", "AnnotationDefault");
Test 36: 
ClassWriter classWriter = new ClassWriter((-2794));
classWriter.newClass("RuntimeVisibleAnnotations");
Test 37: 
ClassWriter classWriter = new ClassWriter((-166));
classWriter.newNameType("", "");
Test 38: 
ClassWriter classWriter = new ClassWriter(33);
classWriter.index = (-6);
classWriter.newClass("");
Test 39: 
ClassWriter classWriter = new ClassWriter(689);
classWriter.newClassItem("");
Test 40: 
ClassWriter classWriter = new ClassWriter((-2794));
classWriter.index = (-2794);
classWriter.newConst("wheel.asm.ClassWriter");
Test 41: 
ClassWriter classWriter = new ClassWriter((-535));
classWriter.newInteger((-951));
Test 42: 
ClassWriter classWriter = new ClassWriter((-1086));
classWriter.index = (-1086);
classWriter.newMethod("org.apache.commons.io.filefilter.OrFileFilter", "org.apache.commons.io.filefilter.OrFileFilter", "org.apache.commons.io.filefilter.OrFileFilter", true);
Test 43: 
ClassWriter classWriter = new ClassWriter((-166));
classWriter.index = (-166);
classWriter.newNameType("", "");
Test 44: 
ClassWriter classWriter = new ClassWriter((-6123));
classWriter.index = (-6123);
classWriter.newUTF8("6Qo");
Test 45: 
ClassWriter classWriter = new ClassWriter(66);
classWriter.newUTF8("java/lang/Object");
Test 46: 
ClassWriter classWriter = new ClassWriter(0);
String[] stringArray = new String[6];
stringArray[0] = "|q";
stringArray[1] = "|q";
stringArray[2] = "|q";
stringArray[3] = "|q";
stringArray[4] = "|q";
stringArray[5] = "|q";
classWriter.visitMethod(0, "|q", "|q", "|q", stringArray);
Test 47: 
ClassWriter classWriter = new ClassWriter((-39));
String[] stringArray = new String[1];
stringArray[0] = "=>BI=^LKK?fW4r`y";
classWriter.visit((-39), (-39), "=>BI=^LKK?fW4r`y", "=>BI=^LKK?fW4r`y", ",f", stringArray);
classWriter.invalidFrames = true;
classWriter.toByteArray();
Test 48: 
// Undeclared exception!
try { 
  ((ClassWriter)0.0).visitEnd();
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
}


* Going to analyze the coverage criteria
* Coverage analysis for criterion BRANCH
* Coverage of criterion BRANCH: 92%
* Total number of goals: 174
* Number of covered goals: 160
* Coverage analysis for criterion LINE
* Coverage of criterion LINE: 95%
* Total number of goals: 345
* Number of covered goals: 327
* Coverage analysis for criterion OUTPUT
* Coverage of criterion OUTPUT: 47%
* Total number of goals: 55
* Number of covered goals: 26
* Coverage analysis for criterion METHOD
* Coverage of criterion METHOD: 100%
* Total number of goals: 30
* Number of covered goals: 30
* Coverage analysis for criterion CBRANCH
* Coverage of criterion CBRANCH: 92%
* Total number of goals: 174
* Number of covered goals: 160
* Generated 49 tests with total length 148
* Resulting test suite's coverage: 85% (average coverage for all fitness functions)
* Generating assertions
* Resulting test suite's mutation score: 16%
* Compiling and checking tests
Going to execute: removeTestsThatDoNotCompile
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter(59);
classWriter.newField("\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y");
int newField = classWriter.newField("\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y", "\"uMQ=$B?KU={Y");
assertEquals(4, newField);


** It was a parseable test case! 
refined test name is: testClassWriterNewFieldCreation
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter arg0 = new ClassWriter((-5));
// Undeclared exception!
try { 
  arg0.newConst(arg0);
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // value wheel.asm.ClassWriter@5
   //
   verifyException("wheel.asm.ClassWriter", e);
}


** It was a parseable test case! 
refined test name is: testNewConstIllegalArgumentException
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter(2620);
String[] arg5 = new String[8];
// Undeclared exception!
try { 
  classWriter.visit(14, 16777215, "RuntimeVisibleAnnotations", (String) null, (String) null, arg5);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}


** It was a parseable test case! 
refined test name is: testVisitWithInvalidAnnotationNameThrowsException
* Compiling Tests
refined test name is: testVisitMethodWithNullAnnotationName
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter(14);
classWriter.visit(16777217, 6, "a|4F!Tx}", "", "", (String[]) null);
assertEquals(1, ClassWriter.COMPUTE_MAXS);


** It was a parseable test case! 
refined test name is: testClassWriterVisit
* Compiling Tests
refined test name is: testVisitMethodReturnsExpectedValue
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter((-526));
String[] arg5 = new String[0];
classWriter.visit(13, (-526), "1cug$(C", "1cug$(C", (String) null, arg5);
byte[] byteArray = classWriter.toByteArray();
assertEquals(94, byteArray.length);


** It was a parseable test case! 
refined test name is: testCreateClassWithNameAndSuperclass
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter((-2420));
classWriter.visitSource((String) null, "");
assertEquals(2, ClassWriter.COMPUTE_FRAMES);


** It was a parseable test case! 
refined test name is: testVisitSourceMethod
* Compiling Tests
refined test name is: testVisitSource
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter(66);
classWriter.visitOuterClass("", (String) null, "");
assertEquals(1, ClassWriter.COMPUTE_MAXS);


** It was a parseable test case! 
refined test name is: testVisitingOuterClassSetsComputeMaxsToTrue
* Compiling Tests
refined test name is: testVisitingAnOuterClassSetsComputeMaxsFlagToTrue
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter((-2420));
classWriter.visitOuterClass("", "wheel.asm.ClassWriter", (String) null);
assertEquals(2, ClassWriter.COMPUTE_FRAMES);


** It was a parseable test case! 
refined test name is: testComputeFramesFlagIsSetCorrectly
* Compiling Tests
refined test name is: testComputeFramesFlagIsSetToTwo
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter(2855);
classWriter.visitOuterClass("}MNV?", "}MNV?", "Deprecated");
byte[] byteArray = classWriter.toByteArray();
assertEquals(81, byteArray.length);


** It was a parseable test case! 
refined test name is: testVisitOuterClass
* Compiling Tests
refined test name is: testVisitOuterClass
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter((-2103));
classWriter.visitAnnotation("SourceDebugExtension", false);
byte[] byteArray = classWriter.toByteArray();
assertEquals(89, byteArray.length);


** It was a parseable test case! 
refined test name is: testToByteArrayReturnsCorrectLengthOfArray
* Compiling Tests
refined test name is: testClassWriterToByteArrayLength
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter(689);
classWriter.visitAnnotation("Signature", true);
byte[] byteArray = classWriter.toByteArray();
assertEquals(76, byteArray.length);


** It was a parseable test case! 
refined test name is: testVisitAnnotationWithSignatureAndTrue
* Compiling Tests
refined test name is: testVisitAnnotationWithSignatureAndTrueParameters
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter(65);
classWriter.visitInnerClass((String) null, "Sensitive", (String) null, 17);
assertEquals(2, ClassWriter.COMPUTE_FRAMES);


** It was a parseable test case! 
refined test name is: testComputeFramesFlagSetToTwo
* Compiling Tests
refined test name is: testSetInnerClassFlagsForSensitive
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter(59);
classWriter.visitField(59, "", "7$l;2/V[pfu:w", "", "7$l;2/V[pfu:w");
byte[] byteArray = classWriter.toByteArray();
assertEquals(98, byteArray.length);


** It was a parseable test case! 
refined test name is: testVisitFieldWithType
* Compiling Tests
refined test name is: testLengthOfByteArrayAfterVisitingField
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter arg0 = new ClassWriter(10);
MethodWriter methodWriter = new MethodWriter(arg0, 0, "wheel.asm.ClassWriter", "wheel.asm.ClassWriter", "tU/M\"wIn!:%F", (String[]) null, false, false);
byte[] byteArray = arg0.toByteArray();
assertEquals(91, byteArray.length);


** It was a parseable test case! 
refined test name is: testGenerateClassFile
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter((-36));
classWriter.visitSource("{LGT", "{LGT");
byte[] byteArray = classWriter.toByteArray();
assertEquals(85, byteArray.length);


** It was a parseable test case! 
refined test name is: testClassWriterWithNegativeMaxStackSize
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter(20);
classWriter.visitInnerClass((String) null, (String) null, (String) null, 20);
byte[] byteArray = classWriter.toByteArray();
assertEquals(55, byteArray.length);


** It was a parseable test case! 
refined test name is: testVisitInnerClassWithNameOuterNameAndAccessFlags
* Compiling Tests
refined test name is: testVisitInnerClassWithNameAndAccessFlags
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassWriter classWriter = new ClassWriter(25);
classWriter.invalidFrames = true;
// Undeclared exception!
try { 
  classWriter.toByteArray();
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}


** It was a parseable test case! 
* Computation finished
