* EvoSuite 1.0.0-SNAPSHOT
* Going to generate test cases for class: wheel.asm.ClassReader
* Starting Client-0
* Properties loaded from /home/roham/Results-Utestgen/dataset/SF110-new-res/80_wheelwebtool/evosuite-files/evosuite.properties
* Connecting to master process on port 11918
* Analyzing classpath: 
* Inheritance tree loaded from evosuite-files/inheritance.xml.gz
[MASTER] 05:15:29.010 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.Consumer
[MASTER] 05:15:29.016 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.Predicate
[MASTER] 05:15:29.017 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.UnaryOperator
[MASTER] 05:15:29.034 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.Temporal
[MASTER] 05:15:29.034 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.ZoneId
[MASTER] 05:15:29.035 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalAccessor
[MASTER] 05:15:29.036 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalField
[MASTER] 05:15:29.037 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalUnit
[MASTER] 05:15:29.037 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalAmount
[MASTER] 05:15:29.038 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.Clock
[MASTER] 05:15:29.040 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalQuery
[MASTER] 05:15:29.042 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.time.temporal.TemporalAdjuster
[MASTER] 05:15:29.045 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.Function
[MASTER] 05:15:29.073 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.BiFunction
[MASTER] 05:15:29.075 [logback-1] WARN  InheritanceTree - Class not in inheritance graph: java.util.function.BiConsumer
* Finished analyzing classpath
* Generating tests for class wheel.asm.ClassReader
* Test criteria:
  - Branch Coverage
  - Line Coverage
  - Method-Output Coverage
  - Top-Level Method Coverage
  - Context Branch Coverage
* Total number of test goals for DYNAMOSA: 2563
* Using seed 1710306922012
* Starting evolution
[Progress:>                             0%] [Cov:>                                  0%]* Initial Number of Goals in DynaMOSA = 240 / 2563
[Progress:>                             0%] [Cov:====>                              13%][Progress:>                             1%] [Cov:====>                              13%][Progress:>                             2%] [Cov:=======>                           22%][Progress:>                             3%] [Cov:=========>                         27%][Progress:=>                            4%] [Cov:============>                      37%][Progress:=>                            5%] [Cov:===============>                   43%][Progress:=>                            6%] [Cov:================>                  47%][Progress:==>                           7%] [Cov:================>                  48%][Progress:==>                           8%] [Cov:=================>                 49%][Progress:==>                           9%] [Cov:=================>                 51%][Progress:===>                          13%] [Cov:=================>                 51%][Progress:====>                         16%] [Cov:==================>                52%][Progress:======>                       20%] [Cov:===================>               55%][Progress:======>                       22%] [Cov:===================>               55%][Progress:======>                       23%] [Cov:===================>               55%][Progress:=======>                      25%] [Cov:===================>               55%][Progress:========>                     27%] [Cov:===================>               56%][Progress:========>                     29%] [Cov:===================>               56%][Progress:=========>                    31%] [Cov:===================>               56%][Progress:==========>                   36%] [Cov:====================>              58%][Progress:===========>                  39%] [Cov:====================>              58%][Progress:============>                 43%] [Cov:====================>              58%][Progress:==============>               48%] [Cov:====================>              58%][Progress:================>             54%] [Cov:====================>              59%][Progress:=================>            59%] [Cov:====================>              59%][Progress:==================>           63%] [Cov:====================>              59%][Progress:====================>         69%] [Cov:=====================>             60%][Progress:=====================>        73%] [Cov:=====================>             60%][Progress:======================>       75%] [Cov:=====================>             60%][Progress:=======================>      77%] [Cov:=====================>             60%][Progress:========================>     80%] [Cov:=====================>             60%][Progress:========================>     82%] [Cov:=====================>             60%][Progress:=========================>    85%] [Cov:=====================>             60%][Progress:==========================>   87%] [Cov:=====================>             60%][Progress:==========================>   88%] [Cov:=====================>             60%][Progress:===========================>  91%] [Cov:=====================>             60%][Progress:============================> 94%] [Cov:=====================>             60%][Progress:=============================>98%] [Cov:=====================>             60%][Progress:==============================100%] [Cov:=====================>             60%]
* Search finished after 202s and 38 generations, 17880 statements, best individual has fitness: 1213.0
* Generated before the refinement 44 tests with total length 109
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: readShort(I)S type is: class org.evosuite.testcase.statements.MethodStatement return type short
statement code is: short readShort = classReader.readShort(4)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readShort(4);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data
        classReader.readShort(4);// This value is not representative of the situation being tested. A more descriptive and representative value would be a specific number that reflects the actual file size. }}

    }
}
statement is: // Improved test data
classReader.readShort(4)// This value is not representative of the situation being tested. A more descriptive and representative value would be a specific number that reflects the actual file size. }}
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: // Improved test data
classReader.readShort(4)// This value is not representative of the situation being tested. A more descriptive and representative value would be a specific number that reflects the actual file size. }}
 target is: classReader method is: readShort(int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: getAccess()I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int access = classReader.getAccess()
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.getAccess();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Changed primitive value from 0 to -1 to demonstrate that it can be any negative number.
        classReader.setAccess(-1);
    }
}
statement is: // Changed primitive value from 0 to -1 to demonstrate that it can be any negative number.
classReader.setAccess(-1), class spoon.support.reflect.code.CtInvocationImpl
invocation is: // Changed primitive value from 0 to -1 to demonstrate that it can be any negative number.
classReader.setAccess(-1) target is: classReader method is: setAccess(int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter")
statement is: getItem(I)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int item = classReader.getItem(1)
test data is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
classReader.getItem(1);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.getItem(5);
    }
}
statement is: classReader.getItem(5), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.getItem(5) target is: classReader method is: getItem(int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: readByte(I)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int readByte = classReader.readByte(376)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readByte(376);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.readByte(((int) (Math.random() * 1024)));
    }
}
statement is: classReader.readByte(((int) (Math.random() * 1024))), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readByte(((int) (Math.random() * 1024))) target is: classReader method is: readByte(int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter")
statement is: wheel.asm.ClassWriter(Lwheel/asm/ClassReader;I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(arg0, 7316)
test data is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter(classReader, 7316);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // The value of 7316 is a random number that was chosen as an example. In reality, the value should be based on the specific requirements of the test case and the data being tested. }}
    }
}
statement is: // The value of 7316 is a random number that was chosen as an example. In reality, the value should be based on the specific requirements of the test case and the data being tested. }}, class spoon.support.reflect.code.CtCommentImpl
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter")
statement is: getClassName()Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String className = classReader.getClassName()
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter");
classReader.getClassName();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data:
        ClassReader classReader = new ClassReader("com.example.mypackage.MyClass");
        classReader.getClassName();
        // Explanation:
        // The original code snippet uses the hardcoded String "org.apache.commons.io.filefilter.HiddenFileFilter" which is not descriptive enough for a test suite. }}
    }
}
statement is: // Improved test data:
ClassReader classReader = new ClassReader("com.example.mypackage.MyClass"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: classReader.getClassName(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.getClassName() target is: classReader method is: getClassName()
source statement: wheel.asm.ClassReader(Ljava/lang/String;)V callee: VariableReference: Statement 0, type wheel.asm.ClassReaderindex is: 1
Matched Method is: getClassName()Ljava/lang/String;
statement is: // Explanation:, class spoon.support.reflect.code.CtCommentImpl
statement is: // The original code snippet uses the hardcoded String "org.apache.commons.io.filefilter.HiddenFileFilter" which is not descriptive enough for a test suite. }}, class spoon.support.reflect.code.CtCommentImpl
TestCase is: String string = "com.example.mypackage.MyClass";
ClassReader classReader = new ClassReader(string);
((ClassReader) string).getClassName();

statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: wheel.asm.ClassReader([BII)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader(classReader.b, 2, 2)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassReader classReader = new ClassReader(classReader.b, 2, 2);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data
        int fileSize = 1024;// The size of the file to be read

        String fileName = "testFile.txt";// The name of the file to be read

        char[] contents = new char[]{ 't', 'e', 's', 't' };// The contents of the file to be read

        // Improved test data with more descriptive names
        int largeFileSize = 1024 * 1024;// The size of a large file to be read

        String largeFileName = "largeTestFile.txt";// The name of a large file to be read

        char[] largeContents = new char[]{ 'l', 'a', 'r', 'g', 'e' };// The contents of a large file to be read }}

    }
}
statement is: // Improved test data
int fileSize = 1024// The size of the file to be read
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String fileName = "testFile.txt"// The name of the file to be read
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: char[] contents = new char[]{ 't', 'e', 's', 't' }// The contents of the file to be read
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
statement is: // Improved test data with more descriptive names
int largeFileSize = 1024 * 1024// The size of a large file to be read
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtBinaryOperatorImpl
IT HAS NOT BEEN SUPPORTED YET: 1024 * 1024
statement is: String largeFileName = "largeTestFile.txt"// The name of a large file to be read
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: char[] largeContents = new char[]{ 'l', 'a', 'r', 'g', 'e' }// The contents of a large file to be read }}
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
* this is vulnerable: int _int = 1024
* this is vulnerable: String string = "testFile.txt"
* this is vulnerable: String string = "largeTestFile.txt"
TestCase is: int _int = 1024;
String string = "testFile.txt";
String string = "largeTestFile.txt";

statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.NameFileFilter")
statement is: wheel.asm.ClassWriter(Lwheel/asm/ClassReader;I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(arg0, 1274)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.NameFileFilter");
ClassWriter classWriter = new ClassWriter(classReader, 1274);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data
        int[] numbers = new int[]{ 1, 2, 3, 4, 5 };
        String[] strings = new String[]{ "apple", "banana", "cherry" };
        char[] characters = new char[]{ 'a', 'b', 'c' };
        // Using improved test data in the code
        classReader.accept(new MyVisitor(), numbers);
        classWriter.visit(numbers[0], null);
        classWriter.visitStringConstant("This is a string", strings[0], characters[0]);
    }
}
statement is: // Improved test data
int[] numbers = new int[]{ 1, 2, 3, 4, 5 }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
statement is: String[] strings = new String[]{ "apple", "banana", "cherry" }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
statement is: char[] characters = new char[]{ 'a', 'b', 'c' }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
statement is: // Using improved test data in the code
classReader.accept(new MyVisitor(), numbers), class spoon.support.reflect.code.CtInvocationImpl
invocation is: // Using improved test data in the code
classReader.accept(new MyVisitor(), numbers) target is: classReader method is: accept(MyVisitor,int[])
statement is: classWriter.visit(numbers[0], null), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visit(numbers[0], null) target is: classWriter method is: visit(int,<unknown>)
statement is: classWriter.visitStringConstant("This is a string", strings[0], characters[0]), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classWriter.visitStringConstant("This is a string", strings[0], characters[0]) target is: classWriter method is: visitStringConstant(java.lang.String,java.lang.String,char)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter")
statement is: getSuperName()Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String superName = classReader.getSuperName()
test data is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
classReader.getSuperName();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.getSuperName();
    }
}
statement is: classReader.getSuperName(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.getSuperName() target is: classReader method is: getSuperName()
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("java/lang/Object")
statement is: getSuperName()Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String superName = classReader.getSuperName()
test data is: ClassReader classReader = new ClassReader("java/lang/Object");
classReader.getSuperName();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.getSuperName();
    }
}
statement is: classReader.getSuperName(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.getSuperName() target is: classReader method is: getSuperName()
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: getInterfaces()[Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class [Ljava.lang.String;
statement code is: String[] interfaces = classReader.getInterfaces()
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.getInterfaces();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        List<String> interfaces = classReader.getInterfaces();
        assertTrue(interfaces.contains("java.io.Serializable"));
        assertTrue(interfaces.contains("java.lang.Comparable"));
    }
}
statement is: List<String> interfaces = classReader.getInterfaces(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.getInterfaces() target is: classReader method is: getInterfaces()
statement is: assertTrue(interfaces.contains("java.io.Serializable")), class spoon.support.reflect.code.CtInvocationImpl
invocation is: assertTrue(interfaces.contains("java.io.Serializable")) target is:  method is: assertTrue(<unknown>)
statement is: assertTrue(interfaces.contains("java.lang.Comparable")), class spoon.support.reflect.code.CtInvocationImpl
invocation is: assertTrue(interfaces.contains("java.lang.Comparable")) target is:  method is: assertTrue(<unknown>)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter")
statement is: getInterfaces()[Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class [Ljava.lang.String;
statement code is: String[] interfaces = classReader.getInterfaces()
test data is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
classReader.getInterfaces();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.getInterfaces();
    }
}
statement is: classReader.getInterfaces(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.getInterfaces() target is: classReader method is: getInterfaces()
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: wheel.asm.ClassReader([BII)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader(classReader.b, 8, 0)
statement is: wheel.asm.ClassWriter(Lwheel/asm/ClassReader;I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(arg0, 189)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassReader classReader = new ClassReader(classReader.b, 8, 0);
ClassWriter classWriter = new ClassWriter(classReader, 189);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data }}
    }
}
statement is: // Improved test data }}, class spoon.support.reflect.code.CtCommentImpl
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("")
test data is: ClassReader classReader = new ClassReader("");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.setSuperclassName(new String("java.lang.Object"));// super class name

        classReader.addInterfaceName(new String("com.example.MyInterface"));// interface names

        classReader.setSourceFile(new String("/path/to/MyClass.java"));// source file path

        classReader.addMethodInfo(new MethodInfo("myMethod", "()V"));// method signature

        classReader.addFieldInfo(new FieldInfo("myField", "I"));// field name and type }}

    }
}
statement is: classReader.setSuperclassName(new String("java.lang.Object"))// super class name
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.setSuperclassName(new String("java.lang.Object"))// super class name
 target is: classReader method is: setSuperclassName(java.lang.String)
statement is: classReader.addInterfaceName(new String("com.example.MyInterface"))// interface names
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.addInterfaceName(new String("com.example.MyInterface"))// interface names
 target is: classReader method is: addInterfaceName(java.lang.String)
statement is: classReader.setSourceFile(new String("/path/to/MyClass.java"))// source file path
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.setSourceFile(new String("/path/to/MyClass.java"))// source file path
 target is: classReader method is: setSourceFile(java.lang.String)
statement is: classReader.addMethodInfo(new MethodInfo("myMethod", "()V"))// method signature
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.addMethodInfo(new MethodInfo("myMethod", "()V"))// method signature
 target is: classReader method is: addMethodInfo(MethodInfo)
statement is: classReader.addFieldInfo(new FieldInfo("myField", "I"))// field name and type }}
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.addFieldInfo(new FieldInfo("myField", "I"))// field name and type }}
 target is: classReader method is: addFieldInfo(FieldInfo)
statement is: mock(java.util.Enumeration<java.io.BufferedInputStream>) type is: class org.evosuite.testcase.statements.FunctionalMockStatement return type java.util.Enumeration<java.io.BufferedInputStream>
statement code is: Enumeration<BufferedInputStream> enumeration = (Enumeration<BufferedInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
doReturn(false).when(enumeration).hasMoreElements()
statement is: java.io.SequenceInputStream(Ljava/util/Enumeration;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.io.SequenceInputStream
statement code is: SequenceInputStream sequenceInputStream = new SequenceInputStream(arg0)
statement is: wheel.asm.ClassReader(Ljava/io/InputStream;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader(arg0)
test data is: Enumeration<BufferedInputStream> enumeration = (Enumeration<BufferedInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
doReturn(false).when(enumeration).hasMoreElements();
SequenceInputStream sequenceInputStream = new SequenceInputStream(enumeration);
ClassReader classReader = new ClassReader(sequenceInputStream);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Arrange
        List<BufferedInputStream> inputStreams = new ArrayList<>();
        BufferedInputStream inputStream1 = new BufferedInputStream(new FileInputStream("path/to/class1.class"));
        BufferedInputStream inputStream2 = new BufferedInputStream(new FileInputStream("path/to/class2.class"));
        inputStreams.add(inputStream1);
        inputStreams.add(inputStream2);
        SequenceInputStream sequenceInputStream = new SequenceInputStream(inputStreams.iterator());
        ClassReader classReader = new ClassReader(sequenceInputStream, 0);
        // Act
        classReader.accept(mock(ClassVisitor.class), 0);
        // Assert
        verify(classReader).accept(any(), any());
    }
}
statement is: // Arrange
List<BufferedInputStream> inputStreams = new ArrayList<>(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: BufferedInputStream inputStream1 = new BufferedInputStream(new FileInputStream("path/to/class1.class")), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: BufferedInputStream inputStream2 = new BufferedInputStream(new FileInputStream("path/to/class2.class")), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: inputStreams.add(inputStream1), class spoon.support.reflect.code.CtInvocationImpl
invocation is: inputStreams.add(inputStream1) target is: inputStreams method is: add(BufferedInputStream)
statement is: inputStreams.add(inputStream2), class spoon.support.reflect.code.CtInvocationImpl
invocation is: inputStreams.add(inputStream2) target is: inputStreams method is: add(BufferedInputStream)
statement is: SequenceInputStream sequenceInputStream = new SequenceInputStream(inputStreams.iterator()), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
TestCase Could not be added: java.io.SequenceInputStream(Ljava/util/Enumeration;)V
statement is: ClassReader classReader = new ClassReader(sequenceInputStream, 0), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: // Act
classReader.accept(mock(ClassVisitor.class), 0), class spoon.support.reflect.code.CtInvocationImpl
invocation is: // Act
classReader.accept(mock(ClassVisitor.class), 0) target is: classReader method is: accept(int)
statement is: // Assert
verify(classReader).accept(any(), any()), class spoon.support.reflect.code.CtInvocationImpl
invocation is: // Assert
verify(classReader).accept(any(), any()) target is: verify(classReader) method is: accept()
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("wheel.asm.MethodWriter")
test data is: ClassReader classReader = new ClassReader("wheel.asm.MethodWriter");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data:
        int methodAccessFlags = 0x10;// ACC_PUBLIC

        String methodName = "main";
        String[] parameterTypes = new String[]{ "java/lang/String" };
        String returnType = "V";
    }
}
statement is: // Improved test data:
int methodAccessFlags = 0x10// ACC_PUBLIC
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String methodName = "main", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String[] parameterTypes = new String[]{ "java/lang/String" }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
statement is: String returnType = "V", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
* this is vulnerable: int _int = 16
* this is vulnerable: String string = "main"
* this is vulnerable: String string = "V"
TestCase is: int _int = 16;
String string = "main";
String string = "V";

statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: org.evosuite.testcase.statements.ArrayStatement@addceb9c type is: class org.evosuite.testcase.statements.ArrayStatement return type class [C
statement code is: char[] charArray = new char[6]
statement is: readUTF8(I[C)Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String readUTF8 = classReader.readUTF8(4, arg1)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
char[] charArray = new char[6];
classReader.readUTF8(4, charArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        char[] charArray = new char[7];
        classReader.readUTF8(5, charArray);
    }
}
statement is: char[] charArray = new char[7], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [7] Ct is: char[] charArray = new char[6] isAssignment: false Array: new char[7] Elements: []
lengths: [6] [7]
Their type are: class [C char[]
statement is: classReader.readUTF8(5, charArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readUTF8(5, charArray) target is: classReader method is: readUTF8(int,char[])
TestCase is: char[] charArray = new char[6];

statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter")
statement is: org.evosuite.testcase.statements.ArrayStatement@d6d2ed1f type is: class org.evosuite.testcase.statements.ArrayStatement return type class [C
statement code is: char[] charArray = new char[6]
statement is: readConst(I[C)Ljava/lang/Object; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String readConst = (String)classReader.readConst(15, arg1)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter");
char[] charArray = new char[6];
classReader.readConst(15, charArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        char[] charArray = new char[6];
        classReader.readConst(15, charArray);
        // Improved test data
        char[] moreDescriptiveCharArray = new char[]{ 'H', 'i', 'd', 'e', 'n' };
    }
}
statement is: char[] charArray = new char[6], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [6] Ct is: char[] charArray = new char[6] isAssignment: false Array: new char[6] Elements: []
lengths: [6] [6]
Their type are: class [C char[]
statement is: classReader.readConst(15, charArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readConst(15, charArray) target is: classReader method is: readConst(int,char[])
statement is: // Improved test data
char[] moreDescriptiveCharArray = new char[]{ 'H', 'i', 'd', 'e', 'n' }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [] Ct is: char[] charArray = new char[6] isAssignment: false Array: new char[]{ 'H', 'i', 'd', 'e', 'n' } Elements: ['H', 'i', 'd', 'e', 'n']
lengths: [6] []
TestCase is: char[] charArray = new char[6];

statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter")
statement is: org.evosuite.testcase.statements.ArrayStatement@9ac6ee02 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [C
statement code is: char[] charArray = new char[5]
statement is: readConst(I[C)Ljava/lang/Object; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.Object
statement code is: Object readConst = classReader.readConst(4, arg1)
test data is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[5];
classReader.readConst(4, charArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        char[] charArray = new char[5];
        classReader.readConst(4, charArray);
        // Improved test data:
        ClassReader classReader = new ClassReader("com.example.MyClass");
        char[] charArray = new char[]{ 'h', 'e', 'l', 'l', 'o' };
        classReader.readConst(5, charArray);
    }
}
statement is: char[] charArray = new char[5], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [5] Ct is: char[] charArray = new char[5] isAssignment: false Array: new char[5] Elements: []
lengths: [5] [5]
Their type are: class [C char[]
statement is: classReader.readConst(4, charArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readConst(4, charArray) target is: classReader method is: readConst(int,char[])
statement is: // Improved test data:
ClassReader classReader = new ClassReader("com.example.MyClass"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: char[] charArray = new char[]{ 'h', 'e', 'l', 'l', 'o' }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [] Ct is: char[] charArray = new char[5] isAssignment: false Array: new char[]{ 'h', 'e', 'l', 'l', 'o' } Elements: ['h', 'e', 'l', 'l', 'o']
lengths: [5] []
statement is: classReader.readConst(5, charArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readConst(5, charArray) target is: classReader method is: readConst(int,char[])
source statement: wheel.asm.ClassReader(Ljava/lang/String;)V callee: VariableReference: Statement 0, type wheel.asm.ClassReaderindex is: 2
Matched Method is: readConst(I[C)Ljava/lang/Object;
TestCase is: char[] charArray = new char[5];
String string = "com.example.MyClass";
ClassReader classReader = new ClassReader(string);
int _int = 5;
((ClassReader) charArray).readConst(_int, charArray);

statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter")
statement is: org.evosuite.testcase.statements.ArrayStatement@35097fd7 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [C
statement code is: char[] charArray = new char[2]
statement is: readConst(I[C)Ljava/lang/Object; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.Object
statement code is: Object readConst = classReader.readConst(637, arg1)
test data is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[2];
classReader.readConst(637, charArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        char[] charArray = new char[2];
        classReader.readConst(0x385, charArray);
    }
}
statement is: char[] charArray = new char[2], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [2] Ct is: char[] charArray = new char[2] isAssignment: false Array: new char[2] Elements: []
lengths: [2] [2]
Their type are: class [C char[]
statement is: classReader.readConst(0x385, charArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readConst(0x385, charArray) target is: classReader method is: readConst(int,char[])
TestCase is: char[] charArray = new char[2];

statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter")
statement is: org.evosuite.testcase.statements.ArrayStatement@42d56076 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [C
statement code is: char[] charArray = new char[6]
statement is: readConst(I[C)Ljava/lang/Object; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.Object
statement code is: Object readConst = classReader.readConst(52, arg1)
test data is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[6];
classReader.readConst(52, charArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        char[] charArray = new char[6];
        classReader.readConst(52, "The Quick Brown Fox Jumps Over The Lazy Dog".toCharArray());
    }
}
statement is: char[] charArray = new char[6], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [6] Ct is: char[] charArray = new char[6] isAssignment: false Array: new char[6] Elements: []
lengths: [6] [6]
Their type are: class [C char[]
statement is: classReader.readConst(52, "The Quick Brown Fox Jumps Over The Lazy Dog".toCharArray()), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readConst(52, "The Quick Brown Fox Jumps Over The Lazy Dog".toCharArray()) target is: classReader method is: readConst(int,char[])
TestCase is: char[] charArray = new char[6];

statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter")
statement is: org.evosuite.testcase.statements.ArrayStatement@a3f5e184 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [C
statement code is: char[] charArray = new char[2]
statement is: readConst(I[C)Ljava/lang/Object; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.Object
statement code is: Object readConst = classReader.readConst(2, arg1)
test data is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[2];
classReader.readConst(2, charArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        char[] charArray = new char[]{ 'a', 'b' };
        classReader.readConst(2, charArray);
    }
}
statement is: char[] charArray = new char[]{ 'a', 'b' }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [] Ct is: char[] charArray = new char[2] isAssignment: false Array: new char[]{ 'a', 'b' } Elements: ['a', 'b']
lengths: [2] []
statement is: classReader.readConst(2, charArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readConst(2, charArray) target is: classReader method is: readConst(int,char[])
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.IOCase")
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(8)
statement is: accept(Lwheel/asm/ClassVisitor;I)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classReader.accept((ClassVisitor) arg0, 41)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.IOCase");
ClassWriter classWriter = new ClassWriter(8);
classReader.accept((ClassVisitor) classWriter, 41);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data: }}
    }
}
statement is: // Improved test data: }}, class spoon.support.reflect.code.CtCommentImpl
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: org.evosuite.testcase.statements.ArrayStatement@2a4e9606 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [C
statement code is: char[] charArray = new char[1]
statement is: readConst(I[C)Ljava/lang/Object; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.Object
statement code is: Object readConst = classReader.readConst(33, arg1)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
char[] charArray = new char[1];
classReader.readConst(33, charArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        char[] charArray = new char[1];
        classReader.readConst(33, "This is a string value used for testing.");
    }
}
statement is: char[] charArray = new char[1], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [1] Ct is: char[] charArray = new char[1] isAssignment: false Array: new char[1] Elements: []
lengths: [1] [1]
Their type are: class [C char[]
statement is: classReader.readConst(33, "This is a string value used for testing."), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readConst(33, "This is a string value used for testing.") target is: classReader method is: readConst(int,java.lang.String)
TestCase is: char[] charArray = new char[1];

statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: readLong(I)J type is: class org.evosuite.testcase.statements.MethodStatement return type long
statement code is: long readLong = classReader.readLong(1)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readLong(1);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.readLong(1000000000);
    }
}
statement is: classReader.readLong(1000000000), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readLong(1000000000) target is: classReader method is: readLong(int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: readInt(I)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int readInt = classReader.readInt(76)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readInt(76);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.readInt(8192);
    }
}
statement is: classReader.readInt(8192), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readInt(8192) target is: classReader method is: readInt(int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.IOCase")
statement is: readClass(I[C)Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String readClass = classReader.readClass(2, (char[]) null)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.IOCase");
classReader.readClass(2, (char[]) null);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.readClass(2, new char[]{  });
    }
}
statement is: classReader.readClass(2, new char[]{  }), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readClass(2, new char[]{  }) target is: classReader method is: readClass(int,char[])
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: readUnsignedShort(I)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int readUnsignedShort = classReader.readUnsignedShort(5)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readUnsignedShort(5);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.readUnsignedShort(0xbeef);
    }
}
statement is: classReader.readUnsignedShort(0xbeef), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readUnsignedShort(0xbeef) target is: classReader method is: readUnsignedShort(int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter")
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter((-164))
statement is: accept(Lwheel/asm/ClassVisitor;[Lwheel/asm/Attribute;I)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classReader.accept((ClassVisitor) arg0, (Attribute[]) null, 262144)
test data is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter((-164));
classReader.accept((ClassVisitor) classWriter, (Attribute[]) null, 262144);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        int intValue = 5;// Improved test data: Changed the primitive value from 5 to a more descriptive and representative value such as 10.

        String stringValue = "Hello World";// Improved test data: Changed the String value from "Hello World" to a more descriptive and representative value such as "Goodbye World".

        double doubleValue = 3.14;// Improved test data: Changed the double value from 3.14 to a more descriptive and representative value such as 2.78.

        char charValue = 'a';// Improved test data: Changed the char value from 'a' to a more descriptive and representative value such as 'b'. }}

    }
}
statement is: int intValue = 5// Improved test data: Changed the primitive value from 5 to a more descriptive and representative value such as 10.
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String stringValue = "Hello World"// Improved test data: Changed the String value from "Hello World" to a more descriptive and representative value such as "Goodbye World".
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: double doubleValue = 3.14// Improved test data: Changed the double value from 3.14 to a more descriptive and representative value such as 2.78.
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: char charValue = 'a'// Improved test data: Changed the char value from 'a' to a more descriptive and representative value such as 'b'. }}
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
* this is vulnerable: int _int = 5
* this is vulnerable: String string = "Hello World"
* this is vulnerable: double _double = 3.14
* this is vulnerable: char _char = 'a'
TestCase is: int _int = 5;
String string = "Hello World";
double _double = 3.14;
char _char = 'a';

statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(2656)
statement is: wheel.asm.ClassAdapter(Lwheel/asm/ClassVisitor;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassAdapter
statement code is: ClassAdapter classAdapter = new ClassAdapter(arg0)
statement is: accept(Lwheel/asm/ClassVisitor;[Lwheel/asm/Attribute;I)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classReader.accept((ClassVisitor) arg0, (Attribute[]) null, (-679))
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(2656);
ClassAdapter classAdapter = new ClassAdapter(classWriter);
classReader.accept((ClassVisitor) classAdapter, (Attribute[]) null, (-679));

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.accept(((ClassVisitor) (classAdapter)), ((Attribute[]) (null)), -679);
    }
}
statement is: classReader.accept(((ClassVisitor) (classAdapter)), ((Attribute[]) (null)), -679), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.accept(((ClassVisitor) (classAdapter)), ((Attribute[]) (null)), -679) target is: classReader method is: accept(ClassVisitor,Attribute[],int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: wheel.asm.ClassWriter(Lwheel/asm/ClassReader;I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(arg0, (-1843))
statement is: wheel.asm.ClassAdapter(Lwheel/asm/ClassVisitor;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassAdapter
statement code is: ClassAdapter classAdapter = new ClassAdapter(arg0)
statement is: accept(Lwheel/asm/ClassVisitor;[Lwheel/asm/Attribute;I)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classReader.accept((ClassVisitor) arg0, (Attribute[]) null, 2285)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(classReader, (-1843));
ClassAdapter classAdapter = new ClassAdapter(classWriter);
classReader.accept((ClassVisitor) classAdapter, (Attribute[]) null, 2285);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.accept(((ClassVisitor) (classAdapter)), ((Attribute[]) (null)), 2285);
    }
}
statement is: classReader.accept(((ClassVisitor) (classAdapter)), ((Attribute[]) (null)), 2285), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.accept(((ClassVisitor) (classAdapter)), ((Attribute[]) (null)), 2285) target is: classReader method is: accept(ClassVisitor,Attribute[],int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter")
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(2)
statement is: org.evosuite.testcase.statements.ArrayStatement@48e264f7 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Lwheel.asm.Attribute;
statement code is: Attribute[] attributeArray = new Attribute[5]
statement is: accept(Lwheel/asm/ClassVisitor;[Lwheel/asm/Attribute;I)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classReader.accept((ClassVisitor) arg0, arg1, 8)
test data is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter(2);
Attribute[] attributeArray = new Attribute[5];
classReader.accept((ClassVisitor) classWriter, attributeArray, 8);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Attribute[] attributeArray = new Attribute[5];
        classReader.accept(((ClassVisitor) (classWriter)), attributeArray, 8);
        // Improved test data
        int classVersion = 52;// Java SE 8 version

        String className = "com.example.MyClass";
        Class<?>[] interfaces = new Class<?>[]{ Runnable.class, Serializable.class };
        Method[] methods = new Method[3];
        methods[0] = new Method("run", Void.TYPE, new Class[0], false);
        methods[1] = new Method("getClass", Class.class, new Class[0], true);
        methods[2] = new Method("hashCode", Integer.TYPE, new Class[0], true);
        // Improved test data for attributes array
        Attribute[] attributeArray = new Attribute[5];
        attributeArray[0] = new Attribute("ConstantValue", new Integer(42));
        attributeArray[1] = new Attribute("Code", new byte[]{ 0xa, 0xb });
        attributeArray[2] = new Attribute("LocalVariableTable", "com.example.MyClass");
        attributeArray[3] = new Attribute("LineNumberTable", new Integer(42));
    }
}
statement is: Attribute[] attributeArray = new Attribute[5], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [5] Ct is: Attribute[] attributeArray = new Attribute[5] isAssignment: false Array: new Attribute[5] Elements: []
lengths: [5] [5]
Their type are: class [Lwheel.asm.Attribute; Attribute[]
statement is: classReader.accept(((ClassVisitor) (classWriter)), attributeArray, 8), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.accept(((ClassVisitor) (classWriter)), attributeArray, 8) target is: classReader method is: accept(ClassVisitor,Attribute[],int)
statement is: // Improved test data
int classVersion = 52// Java SE 8 version
, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String className = "com.example.MyClass", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: Class<?>[] interfaces = new Class<?>[]{ Runnable.class, Serializable.class }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [] Ct is: Attribute[] attributeArray = new Attribute[5] isAssignment: false Array: new Class<?>[]{ Runnable.class, Serializable.class } Elements: [Runnable.class, Serializable.class]
lengths: [5] []
statement is: Method[] methods = new Method[3], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [3] Ct is: Attribute[] attributeArray = new Attribute[5] isAssignment: false Array: new Method[3] Elements: []
lengths: [5] [3]
Their type are: class [Lwheel.asm.Attribute; Method[]
statement is: methods[0] = new Method("run", Void.TYPE, new Class[0], false), class spoon.support.reflect.code.CtAssignmentImpl
Assigned : methods[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl null Assignment:new Method("run", Void.TYPE, new Class[0], false) Ct is: methods[0] = new Method("run", Void.TYPE, new Class[0], false)
target : methods class spoon.support.reflect.code.CtLiteralImpl
statement is: methods[1] = new Method("getClass", Class.class, new Class[0], true), class spoon.support.reflect.code.CtAssignmentImpl
Assigned : methods[1] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl null Assignment:new Method("getClass", Class.class, new Class[0], true) Ct is: methods[1] = new Method("getClass", Class.class, new Class[0], true)
target : methods class spoon.support.reflect.code.CtLiteralImpl
statement is: methods[2] = new Method("hashCode", Integer.TYPE, new Class[0], true), class spoon.support.reflect.code.CtAssignmentImpl
Assigned : methods[2] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl null Assignment:new Method("hashCode", Integer.TYPE, new Class[0], true) Ct is: methods[2] = new Method("hashCode", Integer.TYPE, new Class[0], true)
target : methods class spoon.support.reflect.code.CtLiteralImpl
statement is: // Improved test data for attributes array
Attribute[] attributeArray = new Attribute[5], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [5] Ct is: Attribute[] attributeArray = new Attribute[5] isAssignment: false Array: new Attribute[5] Elements: []
lengths: [5] [5]
Their type are: class [Lwheel.asm.Attribute; Attribute[]
statement is: attributeArray[0] = new Attribute("ConstantValue", new Integer(42)), class spoon.support.reflect.code.CtAssignmentImpl
Assigned : attributeArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl null Assignment:new Attribute("ConstantValue", new Integer(42)) Ct is: attributeArray[0] = new Attribute("ConstantValue", new Integer(42))
target : attributeArray class spoon.support.reflect.code.CtLiteralImpl
statement is: attributeArray[1] = new Attribute("Code", new byte[]{ 0xa, 0xb }), class spoon.support.reflect.code.CtAssignmentImpl
Assigned : attributeArray[1] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl null Assignment:new Attribute("Code", new byte[]{ 0xa, 0xb }) Ct is: attributeArray[1] = new Attribute("Code", new byte[]{ 0xa, 0xb })
target : attributeArray class spoon.support.reflect.code.CtLiteralImpl
statement is: attributeArray[2] = new Attribute("LocalVariableTable", "com.example.MyClass"), class spoon.support.reflect.code.CtAssignmentImpl
Assigned : attributeArray[2] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl null Assignment:new Attribute("LocalVariableTable", "com.example.MyClass") Ct is: attributeArray[2] = new Attribute("LocalVariableTable", "com.example.MyClass")
target : attributeArray class spoon.support.reflect.code.CtLiteralImpl
statement is: attributeArray[3] = new Attribute("LineNumberTable", new Integer(42)), class spoon.support.reflect.code.CtAssignmentImpl
Assigned : attributeArray[3] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl null Assignment:new Attribute("LineNumberTable", new Integer(42)) Ct is: attributeArray[3] = new Attribute("LineNumberTable", new Integer(42))
target : attributeArray class spoon.support.reflect.code.CtLiteralImpl
* this is vulnerable: int _int = 52
* this is vulnerable: String string = "com.example.MyClass"
TestCase is: Attribute[] attributeArray = new Attribute[5];
int _int = 52;
String string = "com.example.MyClass";
Attribute[] attributeArray = new Attribute[5];

statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter")
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(4)
statement is: accept(Lwheel/asm/ClassVisitor;[Lwheel/asm/Attribute;I)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classReader.accept((ClassVisitor) arg0, (Attribute[]) null, 2238)
test data is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter(4);
classReader.accept((ClassVisitor) classWriter, (Attribute[]) null, 2238);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.accept(((ClassVisitor) (classWriter)), ((Attribute[]) (null)), 2238);
    }
}
statement is: classReader.accept(((ClassVisitor) (classWriter)), ((Attribute[]) (null)), 2238), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.accept(((ClassVisitor) (classWriter)), ((Attribute[]) (null)), 2238) target is: classReader method is: accept(ClassVisitor,Attribute[],int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: wheel.asm.ClassWriter(I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(42)
statement is: wheel.asm.ClassAdapter(Lwheel/asm/ClassVisitor;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassAdapter
statement code is: ClassAdapter classAdapter = new ClassAdapter(arg0)
statement is: accept(Lwheel/asm/ClassVisitor;[Lwheel/asm/Attribute;I)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classReader.accept((ClassVisitor) arg0, (Attribute[]) null, (-1856))
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(42);
ClassAdapter classAdapter = new ClassAdapter(classWriter);
classReader.accept((ClassVisitor) classAdapter, (Attribute[]) null, (-1856));

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.accept(((ClassVisitor) (classAdapter)), ((Attribute[]) (null)), -1856);
    }
}
statement is: classReader.accept(((ClassVisitor) (classAdapter)), ((Attribute[]) (null)), -1856), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.accept(((ClassVisitor) (classAdapter)), ((Attribute[]) (null)), -1856) target is: classReader method is: accept(ClassVisitor,Attribute[],int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter")
statement is: org.evosuite.testcase.statements.ArrayStatement@e20d54bc type is: class org.evosuite.testcase.statements.ArrayStatement return type class [C
statement code is: char[] charArray = new char[4]
statement is: readConst(I[C)Ljava/lang/Object; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.Double
statement code is: Double readConst = (Double)classReader.readConst(8, arg1)
test data is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[4];
classReader.readConst(8, charArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        char[] charArray = new char[4];
        classReader.readConst(8, charArray);
        // Improved test data:
        ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
        char[] charArray = new char[]{ 'H', 'e', 'l', 'l', 'o' };
        classReader.readConst(8, charArray);
    }
}
statement is: char[] charArray = new char[4], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [4] Ct is: char[] charArray = new char[4] isAssignment: false Array: new char[4] Elements: []
lengths: [4] [4]
Their type are: class [C char[]
statement is: classReader.readConst(8, charArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readConst(8, charArray) target is: classReader method is: readConst(int,char[])
statement is: // Improved test data:
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: char[] charArray = new char[]{ 'H', 'e', 'l', 'l', 'o' }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [] Ct is: char[] charArray = new char[4] isAssignment: false Array: new char[]{ 'H', 'e', 'l', 'l', 'o' } Elements: ['H', 'e', 'l', 'l', 'o']
lengths: [4] []
statement is: classReader.readConst(8, charArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readConst(8, charArray) target is: classReader method is: readConst(int,char[])
source statement: wheel.asm.ClassReader(Ljava/lang/String;)V callee: VariableReference: Statement 0, type wheel.asm.ClassReaderindex is: 2
Matched Method is: readConst(I[C)Ljava/lang/Object;
TestCase is: char[] charArray = new char[4];
String string = "wheel.asm.ClassWriter";
ClassReader classReader = new ClassReader(string);
int _int = 8;
((ClassReader) charArray).readConst(_int, charArray);

statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: readByte(I)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int readByte = classReader.readByte(6)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readByte(6);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.readByte(25);// Improved test data: using a more descriptive value for the byte read }}

    }
}
statement is: classReader.readByte(25)// Improved test data: using a more descriptive value for the byte read }}
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readByte(25)// Improved test data: using a more descriptive value for the byte read }}
 target is: classReader method is: readByte(int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: readInt(I)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int readInt = classReader.readInt(2)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readInt(2);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.readInt(100);
    }
}
statement is: classReader.readInt(100), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readInt(100) target is: classReader method is: readInt(int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: readLong(I)J type is: class org.evosuite.testcase.statements.MethodStatement return type long
statement code is: long readLong = classReader.readLong(52)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readLong(52);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.readLong(10000);// Changed the value from 52 to a more representative value of 10,000 for testing purposes. }}

    }
}
statement is: classReader.readLong(10000)// Changed the value from 52 to a more representative value of 10,000 for testing purposes. }}
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readLong(10000)// Changed the value from 52 to a more representative value of 10,000 for testing purposes. }}
 target is: classReader method is: readLong(int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter")
statement is: readShort(I)S type is: class org.evosuite.testcase.statements.MethodStatement return type short
statement code is: short readShort = classReader.readShort(2)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter");
classReader.readShort(2);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.readShort(2);// Read a short value from position 2 in the class file, which is likely to represent a flag indicating whether the file is hidden or not }}

    }
}
statement is: classReader.readShort(2)// Read a short value from position 2 in the class file, which is likely to represent a flag indicating whether the file is hidden or not }}
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readShort(2)// Read a short value from position 2 in the class file, which is likely to represent a flag indicating whether the file is hidden or not }}
 target is: classReader method is: readShort(int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: readShort(I)S type is: class org.evosuite.testcase.statements.MethodStatement return type short
statement code is: short readShort = classReader.readShort(23)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readShort(23);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.readShort(51);
    }
}
statement is: classReader.readShort(51), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readShort(51) target is: classReader method is: readShort(int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: readUnsignedShort(I)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int readUnsignedShort = classReader.readUnsignedShort(2)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readUnsignedShort(2);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        classReader.readUnsignedShort(2);
    }
}
statement is: classReader.readUnsignedShort(2), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readUnsignedShort(2) target is: classReader method is: readUnsignedShort(int)
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: wheel.asm.ClassReader([B)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader(classReader.b)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassReader classReader = new ClassReader(classReader.b);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data }}
    }
}
statement is: // Improved test data }}, class spoon.support.reflect.code.CtCommentImpl
statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter")
statement is: wheel.asm.ClassWriter(Lwheel/asm/ClassReader;I)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassWriter
statement code is: ClassWriter classWriter = new ClassWriter(arg0, 8)
statement is: copyPool(Lwheel/asm/ClassWriter;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: classReader.copyPool(arg0)
test data is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(classReader, 8);
classReader.copyPool(classWriter);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        String inputFilePath = "path/to/input/file";
        String outputFilePath = "path/to/output/file";
        ClassReader classReader = new ClassReader(inputFilePath);
        ClassWriter classWriter = new ClassWriter(classReader, 8);
        classReader.copyPool(classWriter);
    }
}
statement is: String inputFilePath = "path/to/input/file", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String outputFilePath = "path/to/output/file", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: ClassReader classReader = new ClassReader(inputFilePath), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: ClassWriter classWriter = new ClassWriter(classReader, 8), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: classReader.copyPool(classWriter), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.copyPool(classWriter) target is: classReader method is: copyPool(ClassWriter)
source statement: wheel.asm.ClassReader(Ljava/lang/String;)V callee: VariableReference: Statement 0, type wheel.asm.ClassReaderindex is: 2
Matched Method is: copyPool(Lwheel/asm/ClassWriter;)V
* this is vulnerable: String string = "path/to/output/file"
TestCase is: String string = "path/to/input/file";
String string = "path/to/output/file";
ClassReader classReader = new ClassReader(string);
int _int = 8;
ClassWriter classWriter = new ClassWriter(classReader, _int);
((ClassReader) string).copyPool(classWriter);

statement is: wheel.asm.ClassReader(Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class wheel.asm.ClassReader
statement code is: ClassReader classReader = new ClassReader("wheel.asm.AnnotationWriter")
statement is: org.evosuite.testcase.statements.ArrayStatement@68676ab9 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Lwheel.asm.Label;
statement code is: Label[] labelArray = new Label[2]
statement is: readLabel(I[Lwheel/asm/Label;)Lwheel/asm/Label; type is: class org.evosuite.testcase.statements.MethodStatement return type class wheel.asm.Label
statement code is: Label readLabel = classReader.readLabel(217, arg1)
test data is: ClassReader classReader = new ClassReader("wheel.asm.AnnotationWriter");
Label[] labelArray = new Label[2];
classReader.readLabel(217, labelArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Label[] labelArray = new Label[]{ new Label(1), new Label(2) };
        classReader.readLabel(217, labelArray);
    }
}
statement is: Label[] labelArray = new Label[]{ new Label(1), new Label(2) }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [] Ct is: Label[] labelArray = new Label[2] isAssignment: false Array: new Label[]{ new Label(1), new Label(2) } Elements: [new Label(1), new Label(2)]
lengths: [2] []
statement is: classReader.readLabel(217, labelArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: classReader.readLabel(217, labelArray) target is: classReader method is: readLabel(int,Label[])
* test suite isTestSuite: 57
Test 0: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readShort(4);
Test 1: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.getAccess();
Test 2: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
classReader.getItem(1);
Test 3: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readByte(376);
Test 4: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter(classReader, 7316);
Test 5: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter");
classReader.getClassName();
Test 6: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassReader classReader = null;
try {
  classReader = new ClassReader(classReader.b, 2, 2);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 7: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.NameFileFilter");
ClassWriter classWriter = new ClassWriter(classReader, 1274);
Test 8: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
classReader.getSuperName();
Test 9: 
ClassReader classReader = new ClassReader("java/lang/Object");
classReader.getSuperName();
Test 10: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.getInterfaces();
Test 11: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
classReader.getInterfaces();
Test 12: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassReader classReader = new ClassReader(classReader.b, 8, 0);
ClassWriter classWriter = null;
try {
  classWriter = new ClassWriter(classReader, 189);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 13: 
ClassReader classReader = null;
try {
  classReader = new ClassReader("");
  fail("Expecting exception: IOException");

} catch(Throwable e) {
   //
   // Class not found
   //
   verifyException("wheel.asm.ClassReader", e);
}

Test 14: 
Enumeration<BufferedInputStream> enumeration = (Enumeration<BufferedInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
doReturn(false).when(enumeration).hasMoreElements();
SequenceInputStream sequenceInputStream = new SequenceInputStream(enumeration);
ClassReader classReader = null;
try {
  classReader = new ClassReader(sequenceInputStream);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 15: 
ClassReader classReader = new ClassReader("wheel.asm.MethodWriter");
Test 16: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
char[] charArray = new char[6];
// Undeclared exception!
try { 
  classReader.readUTF8(4, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 17: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter");
char[] charArray = new char[6];
classReader.readConst(15, charArray);
Test 18: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[5];
// Undeclared exception!
try { 
  classReader.readConst(4, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 19: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[2];
// Undeclared exception!
try { 
  classReader.readConst(637, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 20: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[6];
// Undeclared exception!
try { 
  classReader.readConst(52, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 21: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[2];
// Undeclared exception!
try { 
  classReader.readConst(2, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 22: 
ClassReader classReader = new ClassReader("org.apache.commons.io.IOCase");
ClassWriter classWriter = new ClassWriter(8);
classReader.accept((ClassVisitor) classWriter, 41);
Test 23: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
char[] charArray = new char[1];
// Undeclared exception!
try { 
  classReader.readConst(33, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 24: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readLong(1);
Test 25: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readInt(76);
Test 26: 
ClassReader classReader = new ClassReader("org.apache.commons.io.IOCase");
// Undeclared exception!
try { 
  classReader.readClass(2, (char[]) null);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 27: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readUnsignedShort(5);
Test 28: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter((-164));
classReader.accept((ClassVisitor) classWriter, (Attribute[]) null, 262144);
Test 29: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(2656);
ClassAdapter classAdapter = new ClassAdapter(classWriter);
classReader.accept((ClassVisitor) classAdapter, (Attribute[]) null, (-679));
Test 30: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(classReader, (-1843));
ClassAdapter classAdapter = new ClassAdapter(classWriter);
classReader.accept((ClassVisitor) classAdapter, (Attribute[]) null, 2285);
Test 31: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter(2);
Attribute[] attributeArray = new Attribute[5];
classReader.accept((ClassVisitor) classWriter, attributeArray, 8);
Test 32: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter(4);
classReader.accept((ClassVisitor) classWriter, (Attribute[]) null, 2238);
Test 33: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(42);
ClassAdapter classAdapter = new ClassAdapter(classWriter);
classReader.accept((ClassVisitor) classAdapter, (Attribute[]) null, (-1856));
Test 34: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[4];
classReader.readConst(8, charArray);
Test 35: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readByte(6);
Test 36: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readInt(2);
Test 37: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readLong(52);
Test 38: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter");
classReader.readShort(2);
Test 39: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readShort(23);
Test 40: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readUnsignedShort(2);
Test 41: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassReader classReader = new ClassReader(classReader.b);
Test 42: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(classReader, 8);
classReader.copyPool(classWriter);
Test 43: 
ClassReader classReader = new ClassReader("wheel.asm.AnnotationWriter");
Label[] labelArray = new Label[2];
// Undeclared exception!
try { 
  classReader.readLabel(217, labelArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 44: 
String string = "com.example.mypackage.MyClass";
ClassReader classReader = new ClassReader("com.example.mypackage.MyClass");
((ClassReader) string).getClassName();

Test 45: 

Test 46: 

Test 47: 
char[] charArray = new char[6];

Test 48: 
char[] charArray = new char[6];

Test 49: 
char[] charArray = new char[5];
ClassReader classReader = new ClassReader("com.example.MyClass");
int _int = 5;
((ClassReader) charArray).readConst(_int, charArray);

Test 50: 
char[] charArray = new char[2];

Test 51: 
char[] charArray = new char[6];

Test 52: 
char[] charArray = new char[1];

Test 53: 

Test 54: 
Attribute[] attributeArray = new Attribute[5];
Attribute[] attributeArray = new Attribute[5];

Test 55: 
char[] charArray = new char[4];
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
((ClassReader) charArray).readConst(8, charArray);

Test 56: 
String string = "path/to/input/file";
ClassReader classReader = new ClassReader("path/to/input/file");
int _int = 8;
ClassWriter classWriter = new ClassWriter(classReader, _int);
((ClassReader) string).copyPool(classWriter);


* Generated after the refinement and before minimization 57 tests with total length 131
* test suite isTestSuite: 57
Test 0: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readShort(4);
Test 1: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.getAccess();
Test 2: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
classReader.getItem(1);
Test 3: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readByte(376);
Test 4: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter(classReader, 7316);
Test 5: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter");
classReader.getClassName();
Test 6: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassReader classReader = null;
try {
  classReader = new ClassReader(classReader.b, 2, 2);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 7: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.NameFileFilter");
ClassWriter classWriter = new ClassWriter(classReader, 1274);
Test 8: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
classReader.getSuperName();
Test 9: 
ClassReader classReader = new ClassReader("java/lang/Object");
classReader.getSuperName();
Test 10: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.getInterfaces();
Test 11: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
classReader.getInterfaces();
Test 12: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassReader classReader = new ClassReader(classReader.b, 8, 0);
ClassWriter classWriter = null;
try {
  classWriter = new ClassWriter(classReader, 189);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 13: 
ClassReader classReader = null;
try {
  classReader = new ClassReader("");
  fail("Expecting exception: IOException");

} catch(Throwable e) {
   //
   // Class not found
   //
   verifyException("wheel.asm.ClassReader", e);
}

Test 14: 
Enumeration<BufferedInputStream> enumeration = (Enumeration<BufferedInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
doReturn(false).when(enumeration).hasMoreElements();
SequenceInputStream sequenceInputStream = new SequenceInputStream(enumeration);
ClassReader classReader = null;
try {
  classReader = new ClassReader(sequenceInputStream);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 15: 
ClassReader classReader = new ClassReader("wheel.asm.MethodWriter");
Test 16: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
char[] charArray = new char[6];
// Undeclared exception!
try { 
  classReader.readUTF8(4, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 17: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter");
char[] charArray = new char[6];
classReader.readConst(15, charArray);
Test 18: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[5];
// Undeclared exception!
try { 
  classReader.readConst(4, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 19: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[2];
// Undeclared exception!
try { 
  classReader.readConst(637, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 20: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[6];
// Undeclared exception!
try { 
  classReader.readConst(52, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 21: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[2];
// Undeclared exception!
try { 
  classReader.readConst(2, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 22: 
ClassReader classReader = new ClassReader("org.apache.commons.io.IOCase");
ClassWriter classWriter = new ClassWriter(8);
classReader.accept((ClassVisitor) classWriter, 41);
Test 23: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
char[] charArray = new char[1];
// Undeclared exception!
try { 
  classReader.readConst(33, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 24: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readLong(1);
Test 25: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readInt(76);
Test 26: 
ClassReader classReader = new ClassReader("org.apache.commons.io.IOCase");
// Undeclared exception!
try { 
  classReader.readClass(2, (char[]) null);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 27: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readUnsignedShort(5);
Test 28: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter((-164));
classReader.accept((ClassVisitor) classWriter, (Attribute[]) null, 262144);
Test 29: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(2656);
ClassAdapter classAdapter = new ClassAdapter(classWriter);
classReader.accept((ClassVisitor) classAdapter, (Attribute[]) null, (-679));
Test 30: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(classReader, (-1843));
ClassAdapter classAdapter = new ClassAdapter(classWriter);
classReader.accept((ClassVisitor) classAdapter, (Attribute[]) null, 2285);
Test 31: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter(2);
Attribute[] attributeArray = new Attribute[5];
classReader.accept((ClassVisitor) classWriter, attributeArray, 8);
Test 32: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter(4);
classReader.accept((ClassVisitor) classWriter, (Attribute[]) null, 2238);
Test 33: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(42);
ClassAdapter classAdapter = new ClassAdapter(classWriter);
classReader.accept((ClassVisitor) classAdapter, (Attribute[]) null, (-1856));
Test 34: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[4];
classReader.readConst(8, charArray);
Test 35: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readByte(6);
Test 36: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readInt(2);
Test 37: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readLong(52);
Test 38: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter");
classReader.readShort(2);
Test 39: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readShort(23);
Test 40: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readUnsignedShort(2);
Test 41: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassReader classReader = new ClassReader(classReader.b);
Test 42: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(classReader, 8);
classReader.copyPool(classWriter);
Test 43: 
ClassReader classReader = new ClassReader("wheel.asm.AnnotationWriter");
Label[] labelArray = new Label[2];
// Undeclared exception!
try { 
  classReader.readLabel(217, labelArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 44: 
String string = "com.example.mypackage.MyClass";
ClassReader classReader = new ClassReader("com.example.mypackage.MyClass");
((ClassReader) string).getClassName();

Test 45: 

Test 46: 

Test 47: 
char[] charArray = new char[6];

Test 48: 
char[] charArray = new char[6];

Test 49: 
char[] charArray = new char[5];
ClassReader classReader = new ClassReader("com.example.MyClass");
int _int = 5;
((ClassReader) charArray).readConst(_int, charArray);

Test 50: 
char[] charArray = new char[2];

Test 51: 
char[] charArray = new char[6];

Test 52: 
char[] charArray = new char[1];

Test 53: 

Test 54: 
Attribute[] attributeArray = new Attribute[5];
Attribute[] attributeArray = new Attribute[5];

Test 55: 
char[] charArray = new char[4];
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
((ClassReader) charArray).readConst(8, charArray);

Test 56: 
String string = "path/to/input/file";
ClassReader classReader = new ClassReader("path/to/input/file");
int _int = 8;
ClassWriter classWriter = new ClassWriter(classReader, _int);
((ClassReader) string).copyPool(classWriter);


* Minimizing test suite
* test suite isTestSuite: 44
Test 0: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readShort(23);
Test 1: 
ClassReader classReader = new ClassReader("org.apache.commons.io.IOCase");
ClassWriter classWriter = new ClassWriter(8);
classReader.accept((ClassVisitor) classWriter, 41);
Test 2: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.getAccess();
Test 3: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
classReader.getItem(1);
Test 4: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readByte(376);
Test 5: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter");
classReader.getClassName();
Test 6: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassReader classReader = null;
try {
  classReader = new ClassReader(classReader.b, 2, 2);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 7: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.NameFileFilter");
ClassWriter classWriter = new ClassWriter(classReader, 1274);
Test 8: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
classReader.getSuperName();
Test 9: 
ClassReader classReader = new ClassReader("java/lang/Object");
classReader.getSuperName();
Test 10: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.getInterfaces();
Test 11: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
classReader.getInterfaces();
Test 12: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter(classReader, 7316);
Test 13: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassReader classReader = new ClassReader(classReader.b, 8, 0);
ClassWriter classWriter = null;
try {
  classWriter = new ClassWriter(classReader, 189);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 14: 
ClassReader classReader = null;
try {
  classReader = new ClassReader("com.example.mypackage.MyClass");
  fail("Expecting exception: IOException");

} catch(Throwable e) {
   //
   // Class not found
   //
   verifyException("wheel.asm.ClassReader", e);
}

Test 15: 
Enumeration<BufferedInputStream> enumeration = (Enumeration<BufferedInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
doReturn(false).when(enumeration).hasMoreElements();
SequenceInputStream sequenceInputStream = new SequenceInputStream(enumeration);
ClassReader classReader = null;
try {
  classReader = new ClassReader(sequenceInputStream);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 16: 
ClassReader classReader = new ClassReader("wheel.asm.MethodWriter");
Test 17: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter((-164));
classReader.accept((ClassVisitor) classWriter, (Attribute[]) null, 262144);
Test 18: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter(4);
classReader.accept((ClassVisitor) classWriter, (Attribute[]) null, 2238);
Test 19: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(classReader, (-1843));
ClassAdapter classAdapter = new ClassAdapter(classWriter);
classReader.accept((ClassVisitor) classAdapter, (Attribute[]) null, 2285);
Test 20: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter(2);
Attribute[] attributeArray = new Attribute[5];
classReader.accept((ClassVisitor) classWriter, attributeArray, 8);
Test 21: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(42);
ClassAdapter classAdapter = new ClassAdapter(classWriter);
classReader.accept((ClassVisitor) classAdapter, (Attribute[]) null, (-1856));
Test 22: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
char[] charArray = new char[6];
// Undeclared exception!
try { 
  classReader.readUTF8(4, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 23: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter");
char[] charArray = new char[6];
classReader.readConst(15, charArray);
Test 24: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[5];
// Undeclared exception!
try { 
  classReader.readConst(4, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 25: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[2];
// Undeclared exception!
try { 
  classReader.readConst(637, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 26: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[6];
// Undeclared exception!
try { 
  classReader.readConst(52, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 27: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[2];
// Undeclared exception!
try { 
  classReader.readConst(2, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 28: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
char[] charArray = new char[1];
// Undeclared exception!
try { 
  classReader.readConst(33, charArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 29: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readLong(1);
Test 30: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readInt(2);
Test 31: 
ClassReader classReader = new ClassReader("org.apache.commons.io.IOCase");
// Undeclared exception!
try { 
  classReader.readClass(2, (char[]) null);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}

Test 32: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readUnsignedShort(2);
Test 33: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(2656);
ClassAdapter classAdapter = new ClassAdapter(classWriter);
classReader.accept((ClassVisitor) classAdapter, (Attribute[]) null, (-679));
Test 34: 
ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] charArray = new char[4];
classReader.readConst(8, charArray);
Test 35: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readByte(6);
Test 36: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readInt(76);
Test 37: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readLong(52);
Test 38: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter");
classReader.readShort(2);
Test 39: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readShort(4);
Test 40: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
classReader.readUnsignedShort(5);
Test 41: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassReader classReader = new ClassReader(classReader.b);
Test 42: 
ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassWriter classWriter = new ClassWriter(classReader, 8);
classReader.copyPool(classWriter);
Test 43: 
ClassReader classReader = new ClassReader("wheel.asm.AnnotationWriter");
Label[] labelArray = new Label[2];
// Undeclared exception!
try { 
  classReader.readLabel(217, labelArray);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}


* Going to analyze the coverage criteria
* Coverage analysis for criterion BRANCH
* Coverage of criterion BRANCH: 50%
* Total number of goals: 817
* Number of covered goals: 406
* Coverage analysis for criterion LINE
* Coverage of criterion LINE: 59%
* Total number of goals: 868
* Number of covered goals: 516
* Coverage analysis for criterion OUTPUT
* Coverage of criterion OUTPUT: 48%
* Total number of goals: 40
* Number of covered goals: 19
* Coverage analysis for criterion METHOD
* Coverage of criterion METHOD: 100%
* Total number of goals: 21
* Number of covered goals: 21
* Coverage analysis for criterion CBRANCH
* Coverage of criterion CBRANCH: 49%
* Total number of goals: 817
* Number of covered goals: 403
* Generated 44 tests with total length 109
* Resulting test suite's coverage: 61% (average coverage for all fitness functions)
* Generating assertions
* Resulting test suite's mutation score: 32%
* Compiling and checking tests
Going to execute: removeTestsThatDoNotCompile
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
short readShort = classReader.readShort(23);
assertEquals((short)2560, readShort);
assertEquals(883, classReader.header);


** It was a parseable test case! 
refined test name is: testReadShort
* Compiling Tests
refined test name is: testReadShortAtOffset23
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("org.apache.commons.io.IOCase");
ClassWriter arg0 = new ClassWriter(8);
classReader.accept((ClassVisitor) arg0, 41);
assertEquals(2, ClassReader.SKIP_DEBUG);


** It was a parseable test case! 
refined test name is: testAcceptMethodSetsSkipDebugFlag
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
int access = classReader.getAccess();
assertEquals(33, access);


** It was a parseable test case! 
refined test name is: testGetAccessFlagShouldReturnExpectedValue
* Compiling Tests
refined test name is: testGetAccessFlagOfClassshouldReturnCorrectValue
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
int item = classReader.getItem(1);
assertEquals(11, item);
assertEquals(7316, classReader.header);


** It was a parseable test case! 
refined test name is: testGetItemShouldReturnCorrectValue
* Compiling Tests
refined test name is: testGetItemAndHeader
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
int readByte = classReader.readByte(376);
assertEquals(883, classReader.header);
assertEquals(97, readByte);


** It was a parseable test case! 
refined test name is: testReadByteFromClassFile
* Compiling Tests
refined test name is: testReadHeaderFromClassFileWithValidIndex
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter");
assertEquals(609, classReader.header);

String className = classReader.getClassName();
assertEquals("org/apache/commons/io/filefilter/HiddenFileFilter", className);


** It was a parseable test case! 
refined test name is: testReadHeaderAndClassName
* Compiling Tests
refined test name is: testClassReaderHeaderAndClassName
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader arg0 = new ClassReader("org.apache.commons.io.filefilter.NameFileFilter");
ClassWriter classWriter = new ClassWriter(arg0, 1274);
assertEquals(2, ClassWriter.COMPUTE_FRAMES);


** It was a parseable test case! 
refined test name is: testComputeFrames
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
String superName = classReader.getSuperName();
assertNotNull(superName);
assertEquals(7316, classReader.header);
assertEquals("java/lang/Object", superName);


** It was a parseable test case! 
refined test name is: testClassReaderHeaderAndSuperclass
* Compiling Tests
refined test name is: testReadClassHeadervalidInput
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("java/lang/Object");
String superName = classReader.getSuperName();
assertNull(superName);
assertEquals(927, classReader.header);


** It was a parseable test case! 
refined test name is: testNullSuperName
* Compiling Tests
refined test name is: testSuperNameIsNull
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
String[] interfaces = classReader.getInterfaces();
assertEquals(883, classReader.header);
assertEquals(0, interfaces.length);


** It was a parseable test case! 
refined test name is: testGetInterfacesEmpty
* Compiling Tests
refined test name is: testGetInterfacesReturnsEmptyArray
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
String[] interfaces = classReader.getInterfaces();
assertEquals(7316, classReader.header);
assertEquals(1, interfaces.length);


** It was a parseable test case! 
refined test name is: testGetInterfaces
* Compiling Tests
refined test name is: getInterfacesTest
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader arg0 = new ClassReader("wheel.asm.ClassWriter");
ClassWriter classWriter = new ClassWriter(arg0, 7316);
assertEquals(1, ClassWriter.COMPUTE_MAXS);


** It was a parseable test case! 
refined test name is: testComputeMaxsWithComputeMaxsEnabled
* Compiling Tests
refined test name is: testComputeMaxsEnabled
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
ClassReader arg0 = new ClassReader(classReader.b, 8, 0);
ClassWriter classWriter = null;
try {
  classWriter = new ClassWriter(arg0, 189);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // no message in exception (getMessage() returned null)
   //
}


** It was a parseable test case! 
refined test name is: testCtorThrowsExceptionOnInvalidArgument
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = null;
try {
  classReader = new ClassReader("com.example.mypackage.MyClass");
  fail("Expecting exception: IOException");

} catch(Throwable e) {
   //
   // Class not found
   //
   verifyException("wheel.asm.ClassReader", e);
}


** It was a parseable test case! 
refined test name is: testLoadingClassUsingClassReader
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("wheel.asm.MethodWriter");
assertEquals(7802, classReader.header);


** It was a parseable test case! 
refined test name is: testReadHeaderMethod
* Compiling Tests
refined test name is: testReadHeaderWithValidFile
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter arg0 = new ClassWriter((-164));
classReader.accept((ClassVisitor) arg0, (Attribute[]) null, 262144);
assertEquals(2, ClassReader.SKIP_DEBUG);


** It was a parseable test case! 
refined test name is: testSkipDebugInfo
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter arg0 = new ClassWriter(4);
classReader.accept((ClassVisitor) arg0, (Attribute[]) null, 2238);
assertEquals(1, ClassReader.SKIP_CODE);


** It was a parseable test case! 
refined test name is: testAcceptMethodWithSpecificFlagValue
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
ClassWriter arg0 = new ClassWriter(2);
Attribute[] arg1 = new Attribute[5];
classReader.accept((ClassVisitor) arg0, arg1, 8);
assertEquals(1, ClassWriter.COMPUTE_MAXS);


** It was a parseable test case! 
refined test name is: testAcceptMethodCallsCorrectly
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.CanReadFileFilter");
char[] arg1 = new char[6];
// Undeclared exception!
try { 
  classReader.readUTF8(4, arg1);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // 6
   //
   verifyException("wheel.asm.ClassReader", e);
}


** It was a parseable test case! 
refined test name is: testReadUTF8ThrowsArrayIndexOutOfBoundsException
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("org.apache.commons.io.filefilter.HiddenFileFilter");
assertEquals(609, classReader.header);

char[] arg1 = new char[6];
Object readConst = classReader.readConst(15, arg1);
assertEquals("\u0000\u001B\t", readConst);


** It was a parseable test case! 
refined test name is: testReadConstWithValidIndex
* Compiling Tests
refined test name is: testReadConstantPool
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] arg1 = new char[5];
// Undeclared exception!
try { 
  classReader.readConst(4, arg1);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // 5
   //
   verifyException("wheel.asm.ClassReader", e);
}


** It was a parseable test case! 
refined test name is: testReadConstValidIndexReturnsCorrectValue
* Compiling Tests
refined test name is: testReadConstantWithValidIndexReturnsExpectedValue
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] arg1 = new char[2];
// Undeclared exception!
try { 
  classReader.readConst(637, arg1);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // 2
   //
   verifyException("wheel.asm.ClassReader", e);
}


** It was a parseable test case! 
refined test name is: testReadConstOutOfBounds
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] arg1 = new char[6];
// Undeclared exception!
try { 
  classReader.readConst(52, arg1);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // 6
   //
   verifyException("wheel.asm.ClassReader", e);
}


** It was a parseable test case! 
refined test name is: testReadConstthrowsExceptionWhenIndexOutOfBounds
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: ClassReader classReader = new ClassReader("wheel.asm.ClassWriter");
char[] arg1 = new char[2];
// Undeclared exception!
try { 
  classReader.readConst(2, arg1);
  fail("Expecting exception: ArrayIndexOutOfBoundsException");

} catch(ArrayIndexOutOfBoundsException e) {
   //
   // 2
   //
   verifyException("wheel.asm.ClassReader", e);
}


** It was a parseable test case! 
* Computation finished
