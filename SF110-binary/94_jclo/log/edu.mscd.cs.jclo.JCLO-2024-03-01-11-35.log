* EvoSuite 1.2.1-SNAPSHOT
* Going to generate test cases for class: edu.mscd.cs.jclo.JCLO
* Starting Client-0
* Properties loaded from /home/ubuntu/UTestGen/Evaluation/getting_results/dataset/SF110/94_jclo/evosuite-files/evosuite.properties
* Connecting to master process on port 4853
* Analyzing classpath: 
* Inheritance tree loaded from evosuite-files/inheritance.xml.gz
* Finished analyzing classpath
* Generating tests for class edu.mscd.cs.jclo.JCLO
* Test criteria:
  - Branch Coverage
  - Line Coverage
  - Method-Output Coverage
  - Top-Level Method Coverage
  - Context Branch Coverage
* Total number of test goals for DYNAMOSA: 533
* Using seed 1709292915461
* Starting evolution
[Progress:>                             0%] [Cov:>                                  0%]* Initial Number of Goals in DynaMOSA = 198 / 533
[Progress:>                             0%] [Cov:================>                  48%][Progress:>                             1%] [Cov:=================>                 50%][Progress:>                             1%] [Cov:=================>                 50%][Progress:>                             2%] [Cov:=================>                 50%][Progress:>                             2%] [Cov:=================>                 50%][Progress:>                             3%] [Cov:==================>                52%][Progress:>                             3%] [Cov:===================>               56%][Progress:=>                            4%] [Cov:===================>               56%][Progress:=>                            4%] [Cov:===================>               56%][Progress:=>                            5%] [Cov:===================>               56%][Progress:=>                            5%] [Cov:===================>               56%][Progress:=>                            6%] [Cov:===================>               56%][Progress:==>                           7%] [Cov:===================>               56%][Progress:==>                           7%] [Cov:===================>               56%][Progress:==>                           8%] [Cov:===================>               56%][Progress:==>                           8%] [Cov:===================>               56%][Progress:==>                           9%] [Cov:===================>               56%][Progress:==>                           9%] [Cov:===================>               56%][Progress:===>                          10%] [Cov:===================>               57%][Progress:===>                          10%] [Cov:===================>               57%][Progress:===>                          11%] [Cov:=====================>             60%][Progress:===>                          12%] [Cov:=====================>             60%][Progress:===>                          12%] [Cov:=====================>             61%][Progress:===>                          13%] [Cov:=====================>             61%][Progress:===>                          13%] [Cov:=====================>             61%][Progress:====>                         14%] [Cov:=====================>             61%][Progress:====>                         14%] [Cov:=====================>             61%][Progress:====>                         15%] [Cov:=====================>             61%][Progress:====>                         15%] [Cov:=====================>             61%][Progress:====>                         16%] [Cov:=====================>             61%][Progress:====>                         16%] [Cov:=====================>             61%][Progress:=====>                        17%] [Cov:=====================>             62%][Progress:=====>                        18%] [Cov:=====================>             62%][Progress:=====>                        18%] [Cov:=====================>             62%][Progress:=====>                        19%] [Cov:=====================>             62%][Progress:=====>                        19%] [Cov:=====================>             62%][Progress:======>                       20%] [Cov:=====================>             62%][Progress:======>                       20%] [Cov:=====================>             62%][Progress:======>                       21%] [Cov:=====================>             62%][Progress:======>                       22%] [Cov:=====================>             62%][Progress:======>                       22%] [Cov:=====================>             62%][Progress:======>                       23%] [Cov:=====================>             62%][Progress:======>                       23%] [Cov:=====================>             62%][Progress:=======>                      24%] [Cov:=====================>             62%][Progress:=======>                      24%] [Cov:=====================>             62%][Progress:=======>                      24%] [Cov:=====================>             62%][Progress:=======>                      24%] [Cov:=====================>             62%][Progress:=======>                      25%] [Cov:=====================>             62%][Progress:=======>                      25%] [Cov:=====================>             62%][Progress:=======>                      25%] [Cov:=====================>             62%][Progress:=======>                      25%] [Cov:=====================>             62%][Progress:=======>                      25%] [Cov:=====================>             62%][Progress:=======>                      25%] [Cov:=====================>             62%][Progress:=======>                      25%] [Cov:=====================>             62%][Progress:=======>                      26%] [Cov:=====================>             62%][Progress:=======>                      26%] [Cov:=====================>             62%][Progress:=======>                      26%] [Cov:=====================>             62%][Progress:=======>                      26%] [Cov:=====================>             62%][Progress:=======>                      26%] [Cov:=====================>             62%][Progress:=======>                      26%] [Cov:=====================>             62%][Progress:=======>                      26%] [Cov:=====================>             62%][Progress:=======>                      26%] [Cov:=====================>             62%][Progress:========>                     27%] [Cov:=====================>             62%][Progress:========>                     27%] [Cov:=====================>             62%][Progress:========>                     27%] [Cov:=====================>             62%][Progress:========>                     27%] [Cov:=====================>             62%][Progress:========>                     27%] [Cov:=====================>             62%][Progress:========>                     27%] [Cov:=====================>             62%][Progress:========>                     28%] [Cov:=====================>             62%][Progress:========>                     28%] [Cov:=====================>             62%][Progress:========>                     28%] [Cov:=====================>             62%][Progress:========>                     28%] [Cov:=====================>             62%][Progress:========>                     29%] [Cov:=====================>             62%][Progress:========>                     29%] [Cov:=====================>             62%][Progress:========>                     29%] [Cov:=====================>             62%][Progress:=========>                    30%] [Cov:=====================>             62%][Progress:=========>                    30%] [Cov:=====================>             62%][Progress:=========>                    30%] [Cov:=====================>             62%][Progress:=========>                    30%] [Cov:=====================>             62%][Progress:=========>                    31%] [Cov:=====================>             62%][Progress:=========>                    31%] [Cov:=====================>             62%][Progress:=========>                    31%] [Cov:=====================>             62%][Progress:=========>                    32%] [Cov:=====================>             62%][Progress:=========>                    32%] [Cov:=====================>             62%][Progress:=========>                    32%] [Cov:=====================>             62%][Progress:=========>                    32%] [Cov:=====================>             62%][Progress:=========>                    33%] [Cov:=====================>             62%][Progress:=========>                    33%] [Cov:=====================>             62%][Progress:=========>                    33%] [Cov:=====================>             62%][Progress:==========>                   34%] [Cov:=====================>             62%][Progress:==========>                   34%] [Cov:=====================>             62%][Progress:==========>                   34%] [Cov:=====================>             62%][Progress:==========>                   35%] [Cov:=====================>             62%][Progress:==========>                   35%] [Cov:=====================>             62%][Progress:==========>                   35%] [Cov:=====================>             62%][Progress:==========>                   35%] [Cov:=====================>             62%][Progress:==========>                   36%] [Cov:=====================>             62%][Progress:==========>                   36%] [Cov:=====================>             62%][Progress:==========>                   36%] [Cov:=====================>             62%][Progress:===========>                  37%] [Cov:=====================>             62%][Progress:===========>                  37%] [Cov:=====================>             62%][Progress:===========>                  37%] [Cov:=====================>             62%][Progress:===========>                  38%] [Cov:=====================>             62%][Progress:===========>                  38%] [Cov:=====================>             62%][Progress:===========>                  38%] [Cov:=====================>             62%][Progress:===========>                  39%] [Cov:=====================>             62%][Progress:===========>                  39%] [Cov:=====================>             62%][Progress:===========>                  39%] [Cov:=====================>             62%][Progress:============>                 40%] [Cov:=====================>             62%][Progress:============>                 40%] [Cov:=====================>             62%][Progress:============>                 40%] [Cov:=====================>             62%][Progress:============>                 41%] [Cov:=====================>             62%][Progress:============>                 41%] [Cov:=====================>             62%][Progress:============>                 41%] [Cov:=====================>             62%][Progress:============>                 41%] [Cov:=====================>             62%][Progress:============>                 42%] [Cov:=====================>             62%][Progress:============>                 42%] [Cov:=====================>             62%][Progress:============>                 42%] [Cov:=====================>             62%][Progress:============>                 43%] [Cov:=====================>             62%][Progress:============>                 43%] [Cov:=====================>             62%][Progress:============>                 43%] [Cov:=====================>             62%][Progress:============>                 43%] [Cov:=====================>             62%][Progress:=============>                44%] [Cov:=====================>             62%][Progress:=============>                44%] [Cov:=====================>             62%][Progress:=============>                44%] [Cov:=======================>           66%][Progress:=============>                44%] [Cov:=======================>           66%][Progress:=============>                45%] [Cov:=======================>           66%][Progress:=============>                45%] [Cov:=======================>           66%][Progress:=============>                45%] [Cov:=======================>           66%][Progress:=============>                45%] [Cov:=======================>           66%][Progress:=============>                46%] [Cov:=======================>           66%][Progress:=============>                46%] [Cov:=======================>           66%][Progress:=============>                46%] [Cov:=========================>         73%][Progress:=============>                46%] [Cov:=========================>         73%][Progress:=============>                46%] [Cov:=========================>         73%][Progress:==============>               47%] [Cov:=========================>         73%][Progress:==============>               47%] [Cov:=========================>         73%][Progress:==============>               47%] [Cov:=========================>         73%][Progress:==============>               47%] [Cov:=========================>         73%][Progress:==============>               48%] [Cov:=========================>         73%][Progress:==============>               48%] [Cov:=========================>         73%][Progress:==============>               48%] [Cov:=========================>         73%][Progress:==============>               48%] [Cov:=========================>         73%][Progress:==============>               49%] [Cov:=========================>         73%][Progress:==============>               49%] [Cov:=========================>         73%][Progress:==============>               49%] [Cov:=========================>         73%][Progress:==============>               49%] [Cov:=========================>         73%][Progress:===============>              50%] [Cov:=========================>         73%][Progress:===============>              50%] [Cov:=========================>         73%][Progress:===============>              50%] [Cov:=========================>         73%][Progress:===============>              51%] [Cov:=========================>         73%][Progress:===============>              51%] [Cov:=========================>         74%][Progress:===============>              51%] [Cov:=========================>         74%][Progress:===============>              51%] [Cov:=========================>         74%][Progress:===============>              51%] [Cov:=========================>         74%][Progress:===============>              51%] [Cov:=========================>         74%][Progress:===============>              52%] [Cov:=========================>         74%][Progress:===============>              52%] [Cov:=========================>         74%][Progress:===============>              52%] [Cov:=========================>         74%][Progress:===============>              52%] [Cov:=========================>         74%][Progress:===============>              52%] [Cov:=========================>         74%][Progress:===============>              52%] [Cov:=========================>         74%][Progress:===============>              52%] [Cov:=========================>         74%][Progress:===============>              53%] [Cov:=========================>         74%][Progress:===============>              53%] [Cov:=========================>         74%][Progress:===============>              53%] [Cov:=========================>         74%][Progress:===============>              53%] [Cov:=========================>         74%][Progress:===============>              53%] [Cov:=========================>         74%][Progress:===============>              53%] [Cov:=========================>         74%][Progress:===============>              53%] [Cov:=========================>         74%][Progress:===============>              53%] [Cov:=========================>         74%][Progress:===============>              53%] [Cov:=========================>         74%][Progress:================>             54%] [Cov:=========================>         74%][Progress:================>             54%] [Cov:=========================>         74%][Progress:================>             54%] [Cov:=========================>         74%][Progress:================>             54%] [Cov:=========================>         74%][Progress:================>             54%] [Cov:=========================>         74%][Progress:================>             54%] [Cov:=========================>         74%][Progress:================>             54%] [Cov:=========================>         74%][Progress:================>             55%] [Cov:=========================>         74%][Progress:================>             55%] [Cov:=========================>         74%][Progress:================>             55%] [Cov:=========================>         74%][Progress:================>             56%] [Cov:=========================>         74%][Progress:================>             56%] [Cov:=========================>         74%][Progress:=================>            57%] [Cov:=========================>         74%][Progress:=================>            57%] [Cov:=========================>         74%][Progress:=================>            57%] [Cov:=========================>         74%][Progress:=================>            58%] [Cov:=========================>         74%][Progress:=================>            59%] [Cov:=========================>         74%][Progress:=================>            59%] [Cov:=========================>         74%][Progress:=================>            59%] [Cov:=========================>         74%][Progress:==================>           60%] [Cov:=========================>         74%][Progress:==================>           60%] [Cov:=========================>         74%][Progress:==================>           61%] [Cov:=========================>         74%][Progress:==================>           61%] [Cov:=========================>         74%][Progress:==================>           61%] [Cov:=========================>         74%][Progress:==================>           62%] [Cov:=========================>         74%][Progress:==================>           63%] [Cov:=========================>         74%][Progress:==================>           63%] [Cov:=========================>         74%][Progress:===================>          64%] [Cov:=========================>         74%][Progress:===================>          64%] [Cov:=========================>         74%][Progress:===================>          64%] [Cov:=========================>         74%][Progress:===================>          65%] [Cov:=========================>         74%][Progress:===================>          65%] [Cov:=========================>         74%][Progress:===================>          66%] [Cov:=========================>         74%][Progress:===================>          66%] [Cov:=========================>         74%][Progress:===================>          66%] [Cov:=========================>         74%][Progress:===================>          66%] [Cov:=========================>         74%][Progress:====================>         67%] [Cov:=========================>         74%][Progress:====================>         67%] [Cov:=========================>         74%][Progress:====================>         68%] [Cov:=========================>         74%][Progress:====================>         68%] [Cov:=========================>         74%][Progress:====================>         68%] [Cov:=========================>         74%][Progress:====================>         69%] [Cov:=========================>         74%][Progress:====================>         69%] [Cov:=========================>         74%][Progress:====================>         69%] [Cov:=========================>         74%][Progress:=====================>        70%] [Cov:=========================>         74%][Progress:=====================>        70%] [Cov:=========================>         74%][Progress:=====================>        70%] [Cov:=========================>         74%][Progress:=====================>        70%] [Cov:=========================>         74%][Progress:=====================>        71%] [Cov:=========================>         74%][Progress:=====================>        71%] [Cov:=========================>         74%][Progress:=====================>        71%] [Cov:=========================>         74%][Progress:=====================>        72%] [Cov:=========================>         74%][Progress:=====================>        72%] [Cov:=========================>         74%][Progress:=====================>        73%] [Cov:=========================>         74%][Progress:=====================>        73%] [Cov:=========================>         74%][Progress:=====================>        73%] [Cov:=========================>         74%][Progress:======================>       74%] [Cov:=========================>         74%][Progress:======================>       74%] [Cov:=========================>         74%][Progress:======================>       74%] [Cov:=========================>         74%][Progress:======================>       75%] [Cov:=========================>         74%][Progress:======================>       75%] [Cov:=========================>         74%][Progress:======================>       76%] [Cov:=========================>         74%][Progress:======================>       76%] [Cov:=========================>         74%][Progress:======================>       76%] [Cov:=========================>         74%][Progress:======================>       76%] [Cov:=========================>         74%][Progress:======================>       76%] [Cov:=========================>         74%][Progress:=======================>      77%] [Cov:=========================>         74%][Progress:=======================>      77%] [Cov:=========================>         74%][Progress:=======================>      77%] [Cov:=========================>         74%][Progress:=======================>      78%] [Cov:=========================>         74%][Progress:=======================>      78%] [Cov:=========================>         74%][Progress:=======================>      78%] [Cov:=========================>         74%][Progress:=======================>      79%] [Cov:=========================>         74%][Progress:=======================>      79%] [Cov:=========================>         74%][Progress:========================>     80%] [Cov:=========================>         74%][Progress:========================>     80%] [Cov:=========================>         74%][Progress:========================>     80%] [Cov:=========================>         74%][Progress:========================>     81%] [Cov:=========================>         74%][Progress:========================>     81%] [Cov:=========================>         74%][Progress:========================>     82%] [Cov:=========================>         74%][Progress:========================>     82%] [Cov:=========================>         74%][Progress:========================>     82%] [Cov:=========================>         74%][Progress:========================>     83%] [Cov:=========================>         74%][Progress:========================>     83%] [Cov:=========================>         74%][Progress:========================>     83%] [Cov:=========================>         74%][Progress:========================>     83%] [Cov:=========================>         74%][Progress:========================>     83%] [Cov:=========================>         74%][Progress:========================>     83%] [Cov:=========================>         74%][Progress:========================>     83%] [Cov:=========================>         74%][Progress:========================>     83%] [Cov:=========================>         74%][Progress:========================>     83%] [Cov:=========================>         74%][Progress:========================>     83%] [Cov:=========================>         74%][Progress:=========================>    84%] [Cov:=========================>         74%][Progress:=========================>    84%] [Cov:=========================>         74%][Progress:=========================>    84%] [Cov:=========================>         74%][Progress:=========================>    84%] [Cov:=========================>         74%][Progress:=========================>    84%] [Cov:=========================>         74%][Progress:=========================>    85%] [Cov:=========================>         74%][Progress:=========================>    85%] [Cov:=========================>         74%][Progress:=========================>    86%] [Cov:=========================>         74%][Progress:==========================>   87%] [Cov:=========================>         74%][Progress:==========================>   87%] [Cov:=========================>         74%][Progress:==========================>   88%] [Cov:=========================>         74%][Progress:==========================>   88%] [Cov:=========================>         74%][Progress:==========================>   88%] [Cov:=========================>         74%][Progress:==========================>   88%] [Cov:=========================>         74%][Progress:==========================>   89%] [Cov:=========================>         74%][Progress:==========================>   89%] [Cov:=========================>         74%][Progress:==========================>   89%] [Cov:=========================>         74%][Progress:==========================>   89%] [Cov:=========================>         74%][Progress:===========================>  90%] [Cov:=========================>         74%][Progress:===========================>  90%] [Cov:==========================>        75%][Progress:===========================>  91%] [Cov:==========================>        75%][Progress:===========================>  91%] [Cov:==========================>        75%][Progress:===========================>  91%] [Cov:==========================>        75%][Progress:===========================>  92%] [Cov:==========================>        75%][Progress:===========================>  92%] [Cov:==========================>        75%][Progress:===========================>  92%] [Cov:==========================>        75%][Progress:===========================>  93%] [Cov:==========================>        75%][Progress:===========================>  93%] [Cov:==========================>        75%][Progress:===========================>  93%] [Cov:==========================>        75%][Progress:============================> 94%] [Cov:==========================>        75%][Progress:============================> 94%] [Cov:==========================>        75%][Progress:============================> 94%] [Cov:==========================>        75%][Progress:============================> 95%] [Cov:==========================>        75%][Progress:============================> 95%] [Cov:==========================>        75%][Progress:============================> 95%] [Cov:==========================>        75%][Progress:============================> 96%] [Cov:==========================>        75%][Progress:============================> 96%] [Cov:==========================>        75%][Progress:============================> 96%] [Cov:==========================>        75%][Progress:=============================>97%] [Cov:==========================>        75%][Progress:=============================>97%] [Cov:==========================>        75%][Progress:=============================>97%] [Cov:==========================>        75%][Progress:=============================>98%] [Cov:==========================>        75%][Progress:=============================>98%] [Cov:==========================>        75%][Progress:=============================>98%] [Cov:==========================>        75%][Progress:=============================>99%] [Cov:==========================>        75%][Progress:=============================>99%] [Cov:==========================>        75%][Progress:=============================>99%] [Cov:==========================>        75%][Progress:=============================>99%] [Cov:==========================>        75%][Progress:=============================>99%] [Cov:==========================>        75%][Progress:==============================100%] [Cov:==========================>        75%][Progress:==============================100%] [Cov:==========================>        75%][Progress:==============================100%] [Cov:==========================>        75%][Progress:==============================100%] [Cov:==========================>        75%][Progress:==============================100%] [Cov:==========================>        75%][Progress:==============================100%] [Cov:==========================>        75%]
* Search finished after 101s and 318 generations, 154404 statements, best individual has fitness: 117.0
* Generated before the refinement 36 tests with total length 107
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("_")
statement is: getLong(Ljava/lang/String;)J type is: class org.evosuite.testcase.statements.MethodStatement return type long
statement code is: long _long = jCLO.getLong("serialVersionUID")
test data is: JCLO jCLO = new JCLO("_");
jCLO.getLong("serialVersionUID");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JCLO jCLO = new JCLO("_");
        jCLO.getLong(0);
    }
}
statement is: JCLO jCLO = new JCLO("_"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.getLong(0), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getLong(0) target is: jCLO method is: getLong(int)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: getLong(Ljava/lang/String;)J
TestCase is: String string = "_";
JCLO jCLO = new JCLO(string);
int _int = 0;
((JCLO) string).getLong((String) _int);

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("MINYVrLUE")
statement is: getInts(Ljava/lang/String;)[I type is: class org.evosuite.testcase.statements.MethodStatement return type class [I
statement code is: int[] ints = jCLO.getInts("MINYVrLUE")
test data is: JCLO jCLO = new JCLO("MINYVrLUE");
jCLO.getInts("MINYVrLUE");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data for the JCLO class
        JCLO jCLO = new JCLO("A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION");
        jCLO.getInts("A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION");// Changed the input value from "MINYVrLUE" to a more descriptive string, such as "A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION" }}

    }
}
statement is: // Improved test data for the JCLO class
JCLO jCLO = new JCLO("A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.getInts("A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION")// Changed the input value from "MINYVrLUE" to a more descriptive string, such as "A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION" }}
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getInts("A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION")// Changed the input value from "MINYVrLUE" to a more descriptive string, such as "A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION" }}
 target is: jCLO method is: getInts(java.lang.String)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: getInts(Ljava/lang/String;)[I
TestCase is: String string = "A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION";
JCLO jCLO = new JCLO(string);
String string = "A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION";
((JCLO) string).getInts(string);

statement is: java.lang.Byte(B)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Byte
statement code is: Byte byte = new Byte((byte)0)
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO(arg0)
statement is: getChar(Ljava/lang/String;)C type is: class org.evosuite.testcase.statements.MethodStatement return type char
statement code is: char _char = jCLO.getChar("")
test data is: Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO(byte);
jCLO.getChar("");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Byte = new Byte(((byte) (127)));// byte value can range from -128 to 127, so using a value of 127 is more representative of the maximum value that can be stored in a byte.

        JCLO jCLO = new JCLO(byte.class);
        jCLO.getChar("A");// getChar() method takes a String argument and returns a Character object, so passing in "A" as an argument would make more sense than an empty string. }}

    }
}
statement is: Byte = new Byte(((byte) (127)))// byte value can range from -128 to 127, so using a value of 127 is more representative of the maximum value that can be stored in a byte.
, class spoon.support.reflect.code.CtAssignmentImpl
statement is: JCLO jCLO = new JCLO(byte.class), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
TestCase Could not be added: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V
statement is: jCLO.getChar("A")// getChar() method takes a String argument and returns a Character object, so passing in "A" as an argument would make more sense than an empty string. }}
, class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getChar("A")// getChar() method takes a String argument and returns a Character object, so passing in "A" as an argument would make more sense than an empty string. }}
 target is: jCLO method is: getChar(java.lang.String)
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("&s9oMg&7.")
statement is: getString(Ljava/lang/String;)Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String string = jCLO.getString("&s9oMg&7.")
test data is: JCLO jCLO = new JCLO("&s9oMg&7.");
jCLO.getString("&s9oMg&7.");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data
        JCLO jCLO = new JCLO("A long string with special characters &^%$#@!");
        jCLO.getString("A long string with special characters &^%$#@!");
    }
}
statement is: // Improved test data
JCLO jCLO = new JCLO("A long string with special characters &^%$#@!"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.getString("A long string with special characters &^%$#@!"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getString("A long string with special characters &^%$#@!") target is: jCLO method is: getString(java.lang.String)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: getString(Ljava/lang/String;)Ljava/lang/String;
TestCase is: String string = "A long string with special characters &^%$#@!";
JCLO jCLO = new JCLO(string);
String string = "A long string with special characters &^%$#@!";
((JCLO) string).getString(string);

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("R|SH=lbH}G^z`SIZE")
statement is: getInt(Ljava/lang/String;)I type is: class org.evosuite.testcase.statements.MethodStatement return type int
statement code is: int _int = jCLO.getInt("R|SH=lbH}G^z`SIZE")
test data is: JCLO jCLO = new JCLO("R|SH=lbH}G^z`SIZE");
jCLO.getInt("R|SH=lbH}G^z`SIZE");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JCLO jCLO = new JCLO("Inventory size");
        jCLO.getInt("Inventory size");
    }
}
statement is: JCLO jCLO = new JCLO("Inventory size"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.getInt("Inventory size"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getInt("Inventory size") target is: jCLO method is: getInt(java.lang.String)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: getInt(Ljava/lang/String;)I
TestCase is: String string = "Inventory size";
JCLO jCLO = new JCLO(string);
String string = "Inventory size";
((JCLO) string).getInt(string);

statement is: java.lang.Byte(B)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Byte
statement code is: Byte byte = new Byte((byte)0)
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO((String) null, arg1)
statement is: getShorts(Ljava/lang/String;)[S type is: class org.evosuite.testcase.statements.MethodStatement return type class [S
statement code is: short[] shorts = jCLO.getShorts("")
test data is: Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.getShorts("");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Byte = new Byte(((byte) (127)));
        JCLO jCLO = new JCLO("Test", byte.class);
        jCLO.getShorts(new String[]{ "This", "is", "a", "test" });
    }
}
statement is: Byte = new Byte(((byte) (127))), class spoon.support.reflect.code.CtAssignmentImpl
statement is: JCLO jCLO = new JCLO("Test", byte.class), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.getShorts(new String[]{ "This", "is", "a", "test" }), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getShorts(new String[]{ "This", "is", "a", "test" }) target is: jCLO method is: getShorts(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V callee: VariableReference: Statement 1, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: getShorts(Ljava/lang/String;)[S
i 0 Parameters size() 0 Num of Method Parameters: 1
TestCase is: String string = "Test";
JCLO jCLO = new JCLO(string, string);
String string = null;
jCLO.getShorts(string);

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("k.8Sq%VkKnaV4D`AGwSIZE")
statement is: getChars(Ljava/lang/String;)[C type is: class org.evosuite.testcase.statements.MethodStatement return type class [C
statement code is: char[] chars = jCLO.getChars("value")
test data is: JCLO jCLO = new JCLO("k.8Sq%VkKnaV4D`AGwSIZE");
jCLO.getChars("value");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JCLO jCLO = new JCLO("k.8Sq%VkKnaV4D`AGwSIZE");
        jCLO.getChars("value");
    }
}
statement is: JCLO jCLO = new JCLO("k.8Sq%VkKnaV4D`AGwSIZE"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.getChars("value"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getChars("value") target is: jCLO method is: getChars(java.lang.String)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: getChars(Ljava/lang/String;)[C
TestCase is: String string = "k.8Sq%VkKnaV4D`AGwSIZE";
JCLO jCLO = new JCLO(string);
String string = "value";
((JCLO) string).getChars(string);

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("/")
statement is: getBoolean(Ljava/lang/String;)Z type is: class org.evosuite.testcase.statements.MethodStatement return type boolean
statement code is: boolean _boolean = jCLO.getBoolean("/")
test data is: JCLO jCLO = new JCLO("/");
jCLO.getBoolean("/");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JCLO jCLO = new JCLO("//root/child");
        jCLO.getBoolean("//root/child");
    }
}
statement is: JCLO jCLO = new JCLO("//root/child"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.getBoolean("//root/child"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getBoolean("//root/child") target is: jCLO method is: getBoolean(java.lang.String)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: getBoolean(Ljava/lang/String;)Z
TestCase is: String string = "//root/child";
JCLO jCLO = new JCLO(string);
String string = "//root/child";
((JCLO) string).getBoolean(string);

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO(" ")
statement is: getDoubles(Ljava/lang/String;)[D type is: class org.evosuite.testcase.statements.MethodStatement return type class [D
statement code is: double[] doubles = jCLO.getDoubles(" ")
test data is: JCLO jCLO = new JCLO(" ");
jCLO.getDoubles(" ");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JCLO jCLO = new JCLO(10);
        jCLO.getDoubles(-1.0, 2.0, -3.0, 4.0);
    }
}
statement is: JCLO jCLO = new JCLO(10), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.getDoubles(-1.0, 2.0, -3.0, 4.0), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getDoubles(-1.0, 2.0, -3.0, 4.0) target is: jCLO method is: getDoubles(double,double,double,double)
TestCase is: int _int = 10;
JCLO jCLO = new JCLO(_int);

statement is: java.lang.Object()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Object
statement code is: Object object = new Object()
statement is: org.evosuite.testcase.statements.ArrayStatement@1840c3fa type is: class org.evosuite.testcase.statements.ArrayStatement return type class [[Ljava.lang.String;
statement code is: String[][] stringArray = new String[4][1]
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;[[Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO(arg0, arg1)
statement is: org.evosuite.testcase.statements.ArrayStatement@cb001ed5 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[9]
statement is: org.evosuite.testcase.statements.AssignmentStatement@3085ba7 type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[0] = "-' requires '=VALUE'"
statement is: parse([Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: jCLO.parse(arg0)
test data is: Object object = new Object();
String[][] stringArray = new String[4][1];
JCLO jCLO = new JCLO(object, stringArray);
String[] stringArray = new String[9];
stringArray[0] = "-' requires '=VALUE'";
jCLO.parse(stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Object object = new Object();
        String[][] stringArray = new String[4][1];
        JCLO jCLO = new JCLO(object, stringArray);
        String[] stringArray = new String[9];
        stringArray[0] = "Invalid syntax: '=' requires a value";
        jCLO.parse(stringArray);
    }
}
statement is: Object object = new Object(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: String[][] stringArray = new String[4][1], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [4, 1] Ct is: String[][] stringArray = new String[4][1] isAssignment: false Array: new String[4][1] Elements: []
lengths: [4, 1] [4, 1]
Their type are: class [[Ljava.lang.String; String[][]
statement is: JCLO jCLO = new JCLO(object, stringArray), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: String[] stringArray = new String[9], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [9] Ct is: String[][] stringArray = new String[4][1] isAssignment: false Array: new String[9] Elements: []
lengths: [4, 1] [9]
Dimension: [9] Ct is: String[] stringArray = new String[9] isAssignment: false Array: new String[9] Elements: []
lengths: [9] [9]
Their type are: class [Ljava.lang.String; String[]
statement is: stringArray[0] = "Invalid syntax: '=' requires a value", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"Invalid syntax: '=' requires a value" Ct is: stringArray[0] = "Invalid syntax: '=' requires a value"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;[[Ljava/lang/String;)V callee: VariableReference: Statement 2, type edu.mscd.cs.jclo.JCLOindex is: 2
Matched Method is: parse([Ljava/lang/String;)V
TestCase is: Object object = new Object();
String[][] stringArray = new String[4][1];
JCLO jCLO = new JCLO(object, stringArray);
String[] stringArray = new String[9];
String string = "Invalid syntax: '=' requires a value";
stringArray[0] = string;
jCLO.parse(stringArray);

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("")
statement is: getDouble(Ljava/lang/String;)D type is: class org.evosuite.testcase.statements.MethodStatement return type double
statement code is: double _double = jCLO.getDouble("")
test data is: JCLO jCLO = new JCLO("");
jCLO.getDouble("");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data for the JCLO class
        JCLO jCLO1 = new JCLO("hello");
        jCLO1.getDouble("9876543210.12345");
        JCLO jCLO2 = new JCLO("world");
        jCLO2.getDouble("-1234567890.12345");
        JCLO jCLO3 = new JCLO("test");
        jCLO3.getDouble("1234567890.12345");
        JCLO jCLO4 = new JCLO("foo");
        jCLO4.getDouble("-9876543210.12345");
    }
}
statement is: // Improved test data for the JCLO class
JCLO jCLO1 = new JCLO("hello"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO1.getDouble("9876543210.12345"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO1.getDouble("9876543210.12345") target is: jCLO1 method is: getDouble(java.lang.String)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: getDouble(Ljava/lang/String;)D
statement is: JCLO jCLO2 = new JCLO("world"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO2.getDouble("-1234567890.12345"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO2.getDouble("-1234567890.12345") target is: jCLO2 method is: getDouble(java.lang.String)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 5
Matched Method is: getDouble(Ljava/lang/String;)D
statement is: JCLO jCLO3 = new JCLO("test"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO3.getDouble("1234567890.12345"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO3.getDouble("1234567890.12345") target is: jCLO3 method is: getDouble(java.lang.String)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 9
Matched Method is: getDouble(Ljava/lang/String;)D
statement is: JCLO jCLO4 = new JCLO("foo"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO4.getDouble("-9876543210.12345"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO4.getDouble("-9876543210.12345") target is: jCLO4 method is: getDouble(java.lang.String)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 13
Matched Method is: getDouble(Ljava/lang/String;)D
TestCase is: String string = "hello";
JCLO jCLO = new JCLO(string);
String string = "9876543210.12345";
((JCLO) string).getDouble(string);
String string = "world";
JCLO jCLO = new JCLO(string);
String string = "-1234567890.12345";
((JCLO) string).getDouble(string);
String string = "test";
JCLO jCLO = new JCLO(string);
String string = "1234567890.12345";
((JCLO) string).getDouble(string);
String string = "foo";
JCLO jCLO = new JCLO(string);
String string = "-9876543210.12345";
((JCLO) string).getDouble(string);

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO(" ")
statement is: getFloat(Ljava/lang/String;)F type is: class org.evosuite.testcase.statements.MethodStatement return type float
statement code is: float _float = jCLO.getFloat(" ")
test data is: JCLO jCLO = new JCLO(" ");
jCLO.getFloat(" ");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JCLO jCLO = new JCLO(" ");
        jCLO.getFloat(" ");
    }
}
statement is: JCLO jCLO = new JCLO(" "), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.getFloat(" "), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getFloat(" ") target is: jCLO method is: getFloat(java.lang.String)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: getFloat(Ljava/lang/String;)F
TestCase is: String string = " ";
JCLO jCLO = new JCLO(string);
String string = " ";
((JCLO) string).getFloat(string);

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("Yp7!}i{T1K[Z=Yz;dQ")
statement is: getStrings(Ljava/lang/String;)[Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class [Ljava.lang.String;
statement code is: String[] strings = jCLO.getStrings("Yp7!}i{T1K[Z=Yz;dQ")
test data is: JCLO jCLO = new JCLO("Yp7!}i{T1K[Z=Yz;dQ");
jCLO.getStrings("Yp7!}i{T1K[Z=Yz;dQ");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        jCLO.getStrings("A long string of characters that describes a real-world scenario.");
    }
}
statement is: jCLO.getStrings("A long string of characters that describes a real-world scenario."), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getStrings("A long string of characters that describes a real-world scenario.") target is: jCLO method is: getStrings(java.lang.String)
statement is: java.lang.Byte(B)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Byte
statement code is: Byte byte = new Byte((byte)0)
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO((String) null, arg1)
statement is: getFloats(Ljava/lang/String;)[F type is: class org.evosuite.testcase.statements.MethodStatement return type class [F
statement code is: float[] floats = jCLO.getFloats("")
test data is: Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.getFloats("");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Byte = new Byte(((byte) (127)));
        JCLO jCLO = new JCLO("string", byte.class);
        jCLO.getFloats(3.14F);
    }
}
statement is: Byte = new Byte(((byte) (127))), class spoon.support.reflect.code.CtAssignmentImpl
statement is: JCLO jCLO = new JCLO("string", byte.class), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.getFloats(3.14F), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getFloats(3.14F) target is: jCLO method is: getFloats(float)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V callee: VariableReference: Statement 1, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: getFloats(Ljava/lang/String;)[F
TestCase is: String string = "string";
JCLO jCLO = new JCLO(string, string);
float _float = 3.14F;
jCLO.getFloats((String) _float);

statement is: java.lang.Object()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Object
statement code is: Object object = new Object()
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO(arg0)
statement is: getShort(Ljava/lang/String;)S type is: class org.evosuite.testcase.statements.MethodStatement return type short
statement code is: short _short = jCLO.getShort("YcZ:)OB^")
test data is: Object object = new Object();
JCLO jCLO = new JCLO(object);
jCLO.getShort("YcZ:)OB^");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Object object = new Object();
        JCLO jCLO = new JCLO(object);
        jCLO.getShort("123456789");
    }
}
statement is: Object object = new Object(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: JCLO jCLO = new JCLO(object), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.getShort("123456789"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getShort("123456789") target is: jCLO method is: getShort(java.lang.String)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 1, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: getShort(Ljava/lang/String;)S
TestCase is: Object object = new Object();
JCLO jCLO = new JCLO(object);
String string = "123456789";
jCLO.getShort(string);

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("")
statement is: getLongs(Ljava/lang/String;)[J type is: class org.evosuite.testcase.statements.MethodStatement return type class [J
statement code is: long[] longs = jCLO.getLongs("")
test data is: JCLO jCLO = new JCLO("");
jCLO.getLongs("");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data for the JCLO class
        // Setup:
        JCLO jCLO = new JCLO(10, 20);
        // Test case 1: Get longs from empty list
        assertEquals("Empty list should return an empty list", Collections.emptyList(), jCLO.getLongs(Collections.emptyList()));
        // Test case 2: Get longs from list of integers
        List<Integer> intList = Arrays.asList(1, 2, 3, 4, 5);
        assertEquals("Should return a list of longs", Arrays.asList(1L, 2L, 3L, 4L, 5L), jCLO.getLongs(intList));
        // Test case 3: Get longs from list of strings
        List<String> strList = Arrays.asList("apple", "banana", "orange");
        assertEquals("Should return a list of longs", Arrays.asList(0L, 1L, 2L), jCLO.getLongs(strList));
    }
}
statement is: // Improved test data for the JCLO class
// Setup:
JCLO jCLO = new JCLO(10, 20), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: // Test case 1: Get longs from empty list
assertEquals("Empty list should return an empty list", Collections.emptyList(), jCLO.getLongs(Collections.emptyList())), class spoon.support.reflect.code.CtInvocationImpl
invocation is: // Test case 1: Get longs from empty list
assertEquals("Empty list should return an empty list", Collections.emptyList(), jCLO.getLongs(Collections.emptyList())) target is:  method is: assertEquals(java.lang.String,<unknown>,<unknown>)
statement is: // Test case 2: Get longs from list of integers
List<Integer> intList = Arrays.asList(1, 2, 3, 4, 5), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtInvocationImpl
invocation is: Arrays.asList(1, 2, 3, 4, 5) target is: Arrays method is: asList(int,int,int,int,int)
statement is: assertEquals("Should return a list of longs", Arrays.asList(1L, 2L, 3L, 4L, 5L), jCLO.getLongs(intList)), class spoon.support.reflect.code.CtInvocationImpl
invocation is: assertEquals("Should return a list of longs", Arrays.asList(1L, 2L, 3L, 4L, 5L), jCLO.getLongs(intList)) target is:  method is: assertEquals(java.lang.String,<unknown>,<unknown>)
statement is: // Test case 3: Get longs from list of strings
List<String> strList = Arrays.asList("apple", "banana", "orange"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtInvocationImpl
invocation is: Arrays.asList("apple", "banana", "orange") target is: Arrays method is: asList(java.lang.String,java.lang.String,java.lang.String)
statement is: assertEquals("Should return a list of longs", Arrays.asList(0L, 1L, 2L), jCLO.getLongs(strList)), class spoon.support.reflect.code.CtInvocationImpl
invocation is: assertEquals("Should return a list of longs", Arrays.asList(0L, 1L, 2L), jCLO.getLongs(strList)) target is:  method is: assertEquals(java.lang.String,<unknown>,<unknown>)
statement is: java.lang.Byte(B)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Byte
statement code is: Byte byte = new Byte((byte)0)
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO(arg0)
statement is: getBytes(Ljava/lang/String;)[B type is: class org.evosuite.testcase.statements.MethodStatement return type class [B
statement code is: byte[] bytes = jCLO.getBytes("*:7OM!WAG[x378")
test data is: Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO(byte);
jCLO.getBytes("*:7OM!WAG[x378");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Byte = new Byte(((byte) (255)));
        JCLO jCLO = new JCLO(byte.class);
        jCLO.getBytes("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    }
}
statement is: Byte = new Byte(((byte) (255))), class spoon.support.reflect.code.CtAssignmentImpl
statement is: JCLO jCLO = new JCLO(byte.class), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
TestCase Could not be added: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V
statement is: jCLO.getBytes("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getBytes("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789") target is: jCLO method is: getBytes(java.lang.String)
statement is: java.lang.Byte(B)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Byte
statement code is: Byte byte = new Byte((byte)0)
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO((String) null, arg1)
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("", arg1)
statement is: usage()Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String usage = jCLO.usage()
test data is: Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
JCLO jCLO = new JCLO("", jCLO);
jCLO.usage();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Byte = new Byte(((byte) (127)));
        JCLO jCLO = new JCLO("Hello, World!", byte.class);
        JCLO jCLO = new JCLO("Goodbye, World!", jCLO);
        jCLO.usage();
    }
}
statement is: Byte = new Byte(((byte) (127))), class spoon.support.reflect.code.CtAssignmentImpl
statement is: JCLO jCLO = new JCLO("Hello, World!", byte.class), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: JCLO jCLO = new JCLO("Goodbye, World!", jCLO), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.usage(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.usage() target is: jCLO method is: usage()
TestCase is: String string = "Hello, World!";
JCLO jCLO = new JCLO(string, string);
String string = "Goodbye, World!";
JCLO jCLO = new JCLO(string, jCLO);

statement is: java.lang.Byte(B)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Byte
statement code is: Byte byte = new Byte((byte) (-1))
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("-{,vPwuV3ODk", arg1)
statement is: org.evosuite.testcase.statements.ArrayStatement@6698f666 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[5]
statement is: org.evosuite.testcase.statements.AssignmentStatement@1c9567a type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[0] = "-{,vPwuV3ODk"
statement is: parse([Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: jCLO.parse(arg0)
test data is: Byte byte = new Byte((byte) (-1));
JCLO jCLO = new JCLO("-{,vPwuV3ODk", byte);
String[] stringArray = new String[5];
stringArray[0] = "-{,vPwuV3ODk";
jCLO.parse(stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Byte = new Byte(((byte) (-1)));
        JCLO jCLO = new JCLO("-{,vPwuV3ODk", byte.class);
        String[] stringArray = new String[5];
        stringArray[0] = "This is a test string";
        jCLO.parse(stringArray);
    }
}
statement is: Byte = new Byte(((byte) (-1))), class spoon.support.reflect.code.CtAssignmentImpl
statement is: JCLO jCLO = new JCLO("-{,vPwuV3ODk", byte.class), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: String[] stringArray = new String[5], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [5] Ct is: String[] stringArray = new String[5] isAssignment: false Array: new String[5] Elements: []
lengths: [5] [5]
Their type are: class [Ljava.lang.String; String[]
statement is: stringArray[0] = "This is a test string", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"This is a test string" Ct is: stringArray[0] = "This is a test string"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V callee: VariableReference: Statement 1, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
TestCase is: String string = "-{,vPwuV3ODk";
JCLO jCLO = new JCLO(string, string);
String[] stringArray = new String[5];
String string = "This is a test string";
stringArray[0] = string;
jCLO.parse(stringArray);

statement is: java.lang.Byte(B)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Byte
statement code is: Byte byte = new Byte((byte)0)
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO((String) null, arg1)
statement is: toString()Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String string = jCLO.toString()
test data is: Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.toString();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Byte = new Byte(((byte) (127)));
        JCLO jCLO = new JCLO("Another Test String", byte.class);
        jCLO.toString();
    }
}
statement is: Byte = new Byte(((byte) (127))), class spoon.support.reflect.code.CtAssignmentImpl
statement is: JCLO jCLO = new JCLO("Another Test String", byte.class), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.toString(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.toString() target is: jCLO method is: toString()
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V callee: VariableReference: Statement 1, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: toString()Ljava/lang/String;
TestCase is: String string = "Another Test String";
JCLO jCLO = new JCLO(string, string);
jCLO.toString();

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("\"")
statement is: toString()Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String string = jCLO.toString()
test data is: JCLO jCLO = new JCLO("\"");
jCLO.toString();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        int a = 5;
        double b = 3.14;
        String c = "Hello World!";
        char d = 'a';
    }
}
statement is: int a = 5, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: double b = 3.14, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: String c = "Hello World!", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: char d = 'a', class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
* this is vulnerable: int _int = 5
* this is vulnerable: double _double = 3.14
* this is vulnerable: String string = "Hello World!"
* this is vulnerable: char _char = 'a'
TestCase is: int _int = 5;
double _double = 3.14;
String string = "Hello World!";
char _char = 'a';

statement is: java.lang.Byte(B)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Byte
statement code is: Byte byte = new Byte((byte)0)
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO((String) null, arg1)
statement is: usage()Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String usage = jCLO.usage()
test data is: Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.usage();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Byte = new Byte(((byte) (127)));
        JCLO jCLO = new JCLO("JCLO Test", byte.class);
        jCLO.usage();
    }
}
statement is: Byte = new Byte(((byte) (127))), class spoon.support.reflect.code.CtAssignmentImpl
statement is: JCLO jCLO = new JCLO("JCLO Test", byte.class), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.usage(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.usage() target is: jCLO method is: usage()
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V callee: VariableReference: Statement 1, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: usage()Ljava/lang/String;
TestCase is: String string = "JCLO Test";
JCLO jCLO = new JCLO(string, string);
jCLO.usage();

statement is: java.lang.Byte(B)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Byte
statement code is: Byte byte = new Byte((byte)3)
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("MIN_VALUE", arg1)
statement is: usage()Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String usage = jCLO.usage()
test data is: Byte byte = new Byte((byte)3);
JCLO jCLO = new JCLO("MIN_VALUE", byte);
jCLO.usage();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Byte = new Byte(Byte.MIN_VALUE);
        JCLO jCLO = new JCLO("MIN_VALUE", byte.class);
        jCLO.usage();
    }
}
statement is: Byte = new Byte(Byte.MIN_VALUE), class spoon.support.reflect.code.CtAssignmentImpl
statement is: JCLO jCLO = new JCLO("MIN_VALUE", byte.class), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.usage(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.usage() target is: jCLO method is: usage()
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V callee: VariableReference: Statement 1, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: usage()Ljava/lang/String;
TestCase is: String string = "MIN_VALUE";
JCLO jCLO = new JCLO(string, string);
jCLO.usage();

statement is: java.lang.Object()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Object
statement code is: Object object = new Object()
statement is: org.evosuite.testcase.statements.ArrayStatement@702fee74 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [[Ljava.lang.String;
statement code is: String[][] stringArray = new String[4][1]
statement is: org.evosuite.testcase.statements.ArrayStatement@2c4d3198 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[5]
statement is: org.evosuite.testcase.statements.AssignmentStatement@4b37e156 type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[0] = "-"
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;[[Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO(arg0, arg1)
statement is: parse([Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: jCLO.parse(arg0)
test data is: Object object = new Object();
String[][] stringArray = new String[4][1];
String[] stringArray = new String[5];
stringArray[0] = "-";
JCLO jCLO = new JCLO(object, stringArray);
jCLO.parse(stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Object object = new Object();
        String[][] stringArray = new String[4][1];
        stringArray[0] = "Test data";
        JCLO jCLO = new JCLO(object, stringArray);
        jCLO.parse(stringArray);
    }
}
statement is: Object object = new Object(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: String[][] stringArray = new String[4][1], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [4, 1] Ct is: String[][] stringArray = new String[4][1] isAssignment: false Array: new String[4][1] Elements: []
lengths: [4, 1] [4, 1]
Their type are: class [[Ljava.lang.String; String[][]
statement is: stringArray[0] = "Test data", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String[] Assignment:"Test data" Ct is: stringArray[0] = "Test data"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: JCLO jCLO = new JCLO(object, stringArray), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[][])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;[[Ljava/lang/String;)V callee: VariableReference: Statement 4, type edu.mscd.cs.jclo.JCLOindex is: 2
Matched Method is: parse([Ljava/lang/String;)V
TestCase Could not be added: parse([Ljava/lang/String;)V
TestCase is: Object object = new Object();
String[][] stringArray = new String[4][1];
JCLO jCLO = new JCLO(object, stringArray);

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("fields-----ff---")
statement is: org.evosuite.testcase.statements.ArrayStatement@9f27e3a3 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[10]
statement is: org.evosuite.testcase.statements.AssignmentStatement@d887e684 type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[0] = "-Ivalue"
statement is: parse([Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: jCLO.parse(arg0)
test data is: JCLO jCLO = new JCLO("fields-----ff---");
String[] stringArray = new String[10];
stringArray[0] = "-Ivalue";
jCLO.parse(stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JCLO jCLO = new JCLO("fields-----ff---");
        String[] stringArray = new String[10];
        stringArray[0] = "-Ivalue";
        jCLO.parse(stringArray);
        // Improved test data:
        stringArray[1] = "--number-of-iterations=5";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        stringArray[2] = "-d";// A shorter and easier-to-read version of the flag.

        jCLO.parse(stringArray);
        stringArray[3] = "--filename=output.txt";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        stringArray[4] = "-h";// A shorter and easier-to-read version of the flag.

        jCLO.parse(stringArray);
        stringArray[5] = "--help";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        stringArray[6] = "-v";// A shorter and easier-to-read version of the flag.

        jCLO.parse(stringArray);
        stringArray[7] = "--version";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        stringArray[8] = "-f";// A shorter and easier-to-read version of the flag.

        jCLO.parse(stringArray);
        stringArray[9] = "--force";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        // Improved test data:
        stringArray[10] = "-Ivalue=10";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        stringArray[11] = "--number-of-iterations=100";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        stringArray[12] = "-d=true";// A shorter and easier-to-read version of the flag.

        jCLO.parse(stringArray);
        stringArray[13] = "--filename=output.txt";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        stringArray[14] = "-h=false";// A shorter and easier-to-read version of the flag.

        jCLO.parse(stringArray);
        stringArray[15] = "--help=true";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        stringArray[16] = "-v=false";// A shorter and easier-to-read version of the flag.

        jCLO.parse(stringArray);
        stringArray[17] = "--version=true";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        stringArray[18] = "-f=false";// A shorter and easier-to-read version of the flag.

        jCLO.parse(stringArray);
        stringArray[19] = "--force=true";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        // Improved test data:
        stringArray[20] = "-Ivalue=50";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        stringArray[21] = "--number-of-iterations=500";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        stringArray[22] = "-d=false";// A shorter and easier-to-read version of the flag.

        jCLO.parse(stringArray);
        stringArray[23] = "--filename=output.txt";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        stringArray[24] = "-h=true";// A shorter and easier-to-read version of the flag.

        jCLO.parse(stringArray);
        stringArray[25] = "--help=false";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        stringArray[26] = "-v=true";// A shorter and easier-to-read version of the flag.

        jCLO.parse(stringArray);
        stringArray[27] = "--version=false";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
        stringArray[28] = "-f=true";// A shorter and easier-to-read version of the flag.

        jCLO.parse(stringArray);
        stringArray[29] = "--force=false";// A more descriptive name for the flag, and a better value to demonstrate its functionality.

        jCLO.parse(stringArray);
    }
}
statement is: JCLO jCLO = new JCLO("fields-----ff---"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: String[] stringArray = new String[10], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [10] Ct is: String[] stringArray = new String[10] isAssignment: false Array: new String[10] Elements: []
lengths: [10] [10]
Their type are: class [Ljava.lang.String; String[]
statement is: stringArray[0] = "-Ivalue", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-Ivalue" Ct is: stringArray[0] = "-Ivalue"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@b0054b9b
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: // Improved test data:
stringArray[1] = "--number-of-iterations=5"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[1] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--number-of-iterations=5" Ct is: // Improved test data:
stringArray[1] = "--number-of-iterations=5"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@98f603a3
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[2] = "-d"// A shorter and easier-to-read version of the flag.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[2] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-d" Ct is: stringArray[2] = "-d"// A shorter and easier-to-read version of the flag.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@72b01e1b
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[3] = "--filename=output.txt"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[3] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--filename=output.txt" Ct is: stringArray[3] = "--filename=output.txt"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@5cc5ab91
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[4] = "-h"// A shorter and easier-to-read version of the flag.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[4] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-h" Ct is: stringArray[4] = "-h"// A shorter and easier-to-read version of the flag.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@c56bc455
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[5] = "--help"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[5] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--help" Ct is: stringArray[5] = "--help"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@95b2ebbe
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[6] = "-v"// A shorter and easier-to-read version of the flag.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[6] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-v" Ct is: stringArray[6] = "-v"// A shorter and easier-to-read version of the flag.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@9d2acbde
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[7] = "--version"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[7] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--version" Ct is: stringArray[7] = "--version"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@7cf4ddae
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[8] = "-f"// A shorter and easier-to-read version of the flag.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[8] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-f" Ct is: stringArray[8] = "-f"// A shorter and easier-to-read version of the flag.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@5f900509
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[9] = "--force"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[9] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--force" Ct is: stringArray[9] = "--force"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@a147b2f7
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: // Improved test data:
stringArray[10] = "-Ivalue=10"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[10] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-Ivalue=10" Ct is: // Improved test data:
stringArray[10] = "-Ivalue=10"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@5560dc22
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[11] = "--number-of-iterations=100"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[11] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--number-of-iterations=100" Ct is: stringArray[11] = "--number-of-iterations=100"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@793653b9
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[12] = "-d=true"// A shorter and easier-to-read version of the flag.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[12] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-d=true" Ct is: stringArray[12] = "-d=true"// A shorter and easier-to-read version of the flag.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@7ef14430
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[13] = "--filename=output.txt"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[13] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--filename=output.txt" Ct is: stringArray[13] = "--filename=output.txt"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@85615388
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[14] = "-h=false"// A shorter and easier-to-read version of the flag.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[14] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-h=false" Ct is: stringArray[14] = "-h=false"// A shorter and easier-to-read version of the flag.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@bdfc227e
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[15] = "--help=true"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[15] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--help=true" Ct is: stringArray[15] = "--help=true"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@535fd14f
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[16] = "-v=false"// A shorter and easier-to-read version of the flag.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[16] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-v=false" Ct is: stringArray[16] = "-v=false"// A shorter and easier-to-read version of the flag.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@b7141a84
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[17] = "--version=true"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[17] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--version=true" Ct is: stringArray[17] = "--version=true"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@b9b59c7f
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[18] = "-f=false"// A shorter and easier-to-read version of the flag.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[18] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-f=false" Ct is: stringArray[18] = "-f=false"// A shorter and easier-to-read version of the flag.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@a2b067c4
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[19] = "--force=true"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[19] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--force=true" Ct is: stringArray[19] = "--force=true"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@b074a8bb
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: // Improved test data:
stringArray[20] = "-Ivalue=50"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[20] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-Ivalue=50" Ct is: // Improved test data:
stringArray[20] = "-Ivalue=50"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@99880a68
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[21] = "--number-of-iterations=500"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[21] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--number-of-iterations=500" Ct is: stringArray[21] = "--number-of-iterations=500"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@72e6cc60
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[22] = "-d=false"// A shorter and easier-to-read version of the flag.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[22] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-d=false" Ct is: stringArray[22] = "-d=false"// A shorter and easier-to-read version of the flag.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@5ba9c7dc
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[23] = "--filename=output.txt"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[23] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--filename=output.txt" Ct is: stringArray[23] = "--filename=output.txt"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@ba110306
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[24] = "-h=true"// A shorter and easier-to-read version of the flag.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[24] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-h=true" Ct is: stringArray[24] = "-h=true"// A shorter and easier-to-read version of the flag.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@74af5c9e
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[25] = "--help=false"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[25] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--help=false" Ct is: stringArray[25] = "--help=false"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@8e67e3d1
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[26] = "-v=true"// A shorter and easier-to-read version of the flag.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[26] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-v=true" Ct is: stringArray[26] = "-v=true"// A shorter and easier-to-read version of the flag.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@6cc4d16e
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[27] = "--version=false"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[27] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--version=false" Ct is: stringArray[27] = "--version=false"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@61ccdc71
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[28] = "-f=true"// A shorter and easier-to-read version of the flag.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[28] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"-f=true" Ct is: stringArray[28] = "-f=true"// A shorter and easier-to-read version of the flag.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@ca263457
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
statement is: stringArray[29] = "--force=false"// A more descriptive name for the flag, and a better value to demonstrate its functionality.
, class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[29] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--force=false" Ct is: stringArray[29] = "--force=false"// A more descriptive name for the flag, and a better value to demonstrate its functionality.

target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@537ef2bf
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
* this is vulnerable: String string = "-Ivalue"
* this is vulnerable: String string = "--number-of-iterations=5"
* this is vulnerable: String string = "-d"
* this is vulnerable: String string = "--filename=output.txt"
* this is vulnerable: String string = "-h"
* this is vulnerable: String string = "--help"
* this is vulnerable: String string = "-v"
* this is vulnerable: String string = "--version"
* this is vulnerable: String string = "-f"
* this is vulnerable: String string = "--force"
* this is vulnerable: String string = "-Ivalue=10"
* this is vulnerable: String string = "--number-of-iterations=100"
* this is vulnerable: String string = "-d=true"
* this is vulnerable: String string = "--filename=output.txt"
* this is vulnerable: String string = "-h=false"
* this is vulnerable: String string = "--help=true"
* this is vulnerable: String string = "-v=false"
* this is vulnerable: String string = "--version=true"
* this is vulnerable: String string = "-f=false"
* this is vulnerable: String string = "--force=true"
* this is vulnerable: String string = "-Ivalue=50"
* this is vulnerable: String string = "--number-of-iterations=500"
* this is vulnerable: String string = "-d=false"
* this is vulnerable: String string = "--filename=output.txt"
* this is vulnerable: String string = "-h=true"
* this is vulnerable: String string = "--help=false"
* this is vulnerable: String string = "-v=true"
* this is vulnerable: String string = "--version=false"
* this is vulnerable: String string = "-f=true"
* this is vulnerable: String string = "--force=false"
TestCase is: String string = "fields-----ff---";
JCLO jCLO = new JCLO(string);
String[] stringArray = new String[10];
String string = "-Ivalue";
((JCLO) string).parse(stringArray);
String string = "--number-of-iterations=5";
((JCLO) string).parse(stringArray);
String string = "-d";
((JCLO) string).parse(stringArray);
String string = "--filename=output.txt";
((JCLO) string).parse(stringArray);
String string = "-h";
((JCLO) string).parse(stringArray);
String string = "--help";
((JCLO) string).parse(stringArray);
String string = "-v";
((JCLO) string).parse(stringArray);
String string = "--version";
((JCLO) string).parse(stringArray);
String string = "-f";
((JCLO) string).parse(stringArray);
String string = "--force";
((JCLO) string).parse(stringArray);
String string = "-Ivalue=10";
((JCLO) string).parse(stringArray);
String string = "--number-of-iterations=100";
((JCLO) string).parse(stringArray);
String string = "-d=true";
((JCLO) string).parse(stringArray);
String string = "--filename=output.txt";
((JCLO) string).parse(stringArray);
String string = "-h=false";
((JCLO) string).parse(stringArray);
String string = "--help=true";
((JCLO) string).parse(stringArray);
String string = "-v=false";
((JCLO) string).parse(stringArray);
String string = "--version=true";
((JCLO) string).parse(stringArray);
String string = "-f=false";
((JCLO) string).parse(stringArray);
String string = "--force=true";
((JCLO) string).parse(stringArray);
String string = "-Ivalue=50";
((JCLO) string).parse(stringArray);
String string = "--number-of-iterations=500";
((JCLO) string).parse(stringArray);
String string = "-d=false";
((JCLO) string).parse(stringArray);
String string = "--filename=output.txt";
((JCLO) string).parse(stringArray);
String string = "-h=true";
((JCLO) string).parse(stringArray);
String string = "--help=false";
((JCLO) string).parse(stringArray);
String string = "-v=true";
((JCLO) string).parse(stringArray);
String string = "--version=false";
((JCLO) string).parse(stringArray);
String string = "-f=true";
((JCLO) string).parse(stringArray);
String string = "--force=false";
((JCLO) string).parse(stringArray);

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("&s9oMg&7.")
statement is: org.evosuite.testcase.statements.ArrayStatement@db88c80d type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[0]
statement is: parse([Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: jCLO.parse(arg0)
test data is: JCLO jCLO = new JCLO("&s9oMg&7.");
String[] stringArray = new String[0];
jCLO.parse(stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JCLO jCLO = new JCLO("&s9oMg&7.");
        String[] stringArray = new String[]{ "John", "Doe" };
        jCLO.parse(stringArray);
    }
}
statement is: JCLO jCLO = new JCLO("&s9oMg&7."), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: String[] stringArray = new String[]{ "John", "Doe" }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [] Ct is: String[] stringArray = new String[0] isAssignment: false Array: new String[]{ "John", "Doe" } Elements: ["John", "Doe"]
lengths: [0] []
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
i 0 Parameters size() 0 Num of Method Parameters: 1
TestCase is: String string = "&s9oMg&7.";
JCLO jCLO = new JCLO(string);
String[] stringArray = null;
((JCLO) string).parse(stringArray);

statement is: java.lang.Byte(B)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Byte
statement code is: Byte byte = new Byte((byte)119)
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO(arg0)
statement is: org.evosuite.testcase.statements.ArrayStatement@139cab23 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[5]
statement is: org.evosuite.testcase.statements.AssignmentStatement@a4e7db67 type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[0] = "-value"
statement is: parse([Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: jCLO.parse(arg0)
test data is: Byte byte = new Byte((byte)119);
JCLO jCLO = new JCLO(byte);
String[] stringArray = new String[5];
stringArray[0] = "-value";
jCLO.parse(stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Byte = new Byte(((byte) (-128)));
        JCLO jCLO = new JCLO(byte.class);
        String[] stringArray = new String[5];
        stringArray[0] = "--value";
        jCLO.parse(stringArray);
    }
}
statement is: Byte = new Byte(((byte) (-128))), class spoon.support.reflect.code.CtAssignmentImpl
statement is: JCLO jCLO = new JCLO(byte.class), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
TestCase Could not be added: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V
statement is: String[] stringArray = new String[5], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [5] Ct is: String[] stringArray = new String[5] isAssignment: false Array: new String[5] Elements: []
lengths: [5] [5]
Their type are: class [Ljava.lang.String; String[]
statement is: stringArray[0] = "--value", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"--value" Ct is: stringArray[0] = "--value"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@1438c73c
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: org.evosuite.testcase.statements.ArrayStatement@b988affe callee: VariableReference: Statement 1, type edu.mscd.cs.jclo.JCLOindex is: 0
* this is vulnerable: String string = "--value"
TestCase is: String[] stringArray = new String[5];
String string = "--value";

statement is: org.evosuite.testcase.statements.ArrayStatement@b7eea2b8 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[2]
statement is: main([Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: JCLO.main(arg0)
test data is: String[] stringArray = new String[2];
JCLO.main(stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        String[] stringArray = new String[]{ "-c", "path/to/input/file" };
        JCLO.main(stringArray);
    }
}
statement is: String[] stringArray = new String[]{ "-c", "path/to/input/file" }, class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [] Ct is: String[] stringArray = new String[2] isAssignment: false Array: new String[]{ "-c", "path/to/input/file" } Elements: ["-c", "path/to/input/file"]
lengths: [2] []
statement is: JCLO.main(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: JCLO.main(stringArray) target is: JCLO method is: main(java.lang.String[])
Matched Method is: main([Ljava/lang/String;)V
i 0 Parameters size() 0 Num of Method Parameters: 1
TestCase is: String[] stringArray = null;
JCLO.main(stringArray);

statement is: org.evosuite.testcase.statements.ArrayStatement@4bebbcab type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[1]
statement is: org.evosuite.testcase.statements.AssignmentStatement@957ca52d type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[0] = "MIN_VALUE"
statement is: main([Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: JCLO.main(arg0)
test data is: String[] stringArray = new String[1];
stringArray[0] = "MIN_VALUE";
JCLO.main(stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        String[] stringArray = new String[1];
        stringArray[0] = "The quick brown fox jumps over the lazy dog.";
        JCLO.main(stringArray);
    }
}
statement is: String[] stringArray = new String[1], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [1] Ct is: String[] stringArray = new String[1] isAssignment: false Array: new String[1] Elements: []
lengths: [1] [1]
Their type are: class [Ljava.lang.String; String[]
statement is: stringArray[0] = "The quick brown fox jumps over the lazy dog.", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"The quick brown fox jumps over the lazy dog." Ct is: stringArray[0] = "The quick brown fox jumps over the lazy dog."
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
statement is: JCLO.main(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: JCLO.main(stringArray) target is: JCLO method is: main(java.lang.String[])
Matched Method is: main([Ljava/lang/String;)V
TestCase is: String[] stringArray = new String[1];
String string = "The quick brown fox jumps over the lazy dog.";
stringArray[0] = string;
JCLO.main(stringArray);

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("2")
statement is: getValue(Ljava/lang/String;)Ljava/lang/Object; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.Object
statement code is: Object value = jCLO.getValue("value")
test data is: JCLO jCLO = new JCLO("2");
jCLO.getValue("value");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JCLO jCLO = new JCLO("10");
        jCLO.getValue("value");
    }
}
statement is: JCLO jCLO = new JCLO("10"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.getValue("value"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getValue("value") target is: jCLO method is: getValue(java.lang.String)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: getValue(Ljava/lang/String;)Ljava/lang/Object;
TestCase is: String string = "10";
JCLO jCLO = new JCLO(string);
String string = "value";
((JCLO) string).getValue(string);

statement is: java.lang.Object()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Object
statement code is: Object object = new Object()
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("r5", arg1)
statement is: getValue(Ljava/lang/String;)Ljava/lang/Object; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.Object
statement code is: Object value = jCLO.getValue("r5")
test data is: Object object = new Object();
JCLO jCLO = new JCLO("r5", object);
jCLO.getValue("r5");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        // Improved test data for the code snippet above
        Object object = new Object();
        JCLO jCLO = new JCLO("r5", object);
        String expectedValue = "value";
        assertEquals(expectedValue, jCLO.getValue("r5"));
    }
}
statement is: // Improved test data for the code snippet above
Object object = new Object(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: JCLO jCLO = new JCLO("r5", object), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: String expectedValue = "value", class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtLiteralImpl
statement is: assertEquals(expectedValue, jCLO.getValue("r5")), class spoon.support.reflect.code.CtInvocationImpl
invocation is: assertEquals(expectedValue, jCLO.getValue("r5")) target is:  method is: assertEquals(java.lang.String,<unknown>)
* this is vulnerable: String string = "value"
TestCase is: Object object = new Object();
String string = "r5";
JCLO jCLO = new JCLO(string, object);
String string = "value";

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO(" ")
statement is: org.evosuite.testcase.statements.ArrayStatement@4de6ceb3 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [Ljava.lang.String;
statement code is: String[] stringArray = new String[2]
statement is: org.evosuite.testcase.statements.AssignmentStatement@5cfdd713 type is: class org.evosuite.testcase.statements.AssignmentStatement return type class java.lang.String
statement code is: stringArray[0] = " "
statement is: parse([Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.MethodStatement return type void
statement code is: jCLO.parse(arg0)
test data is: JCLO jCLO = new JCLO(" ");
String[] stringArray = new String[2];
stringArray[0] = " ";
jCLO.parse(stringArray);

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JCLO jCLO = new JCLO("abc");
        String[] stringArray = new String[2];
        stringArray[0] = "def";
        jCLO.parse(stringArray);
    }
}
statement is: JCLO jCLO = new JCLO("abc"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: String[] stringArray = new String[2], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [2] Ct is: String[] stringArray = new String[2] isAssignment: false Array: new String[2] Elements: []
lengths: [2] [2]
Their type are: class [Ljava.lang.String; String[]
statement is: stringArray[0] = "def", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"def" Ct is: stringArray[0] = "def"
target : stringArray class spoon.support.reflect.code.CtLiteralImpl
TestCase Could not be added: org.evosuite.testcase.statements.AssignmentStatement@ca075685
statement is: jCLO.parse(stringArray), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.parse(stringArray) target is: jCLO method is: parse(java.lang.String[])
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: parse([Ljava/lang/String;)V
* this is vulnerable: String string = "def"
TestCase is: String string = "abc";
JCLO jCLO = new JCLO(string);
String[] stringArray = new String[2];
String string = "def";
((JCLO) string).parse(stringArray);

statement is: java.lang.Byte(B)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Byte
statement code is: Byte byte = new Byte((byte)92)
statement is: org.evosuite.testcase.statements.ArrayStatement@9c5cb169 type is: class org.evosuite.testcase.statements.ArrayStatement return type class [[Ljava.lang.String;
statement code is: String[][] stringArray = new String[5][2]
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;[[Ljava/lang/String;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO((String) null, arg1, arg2)
statement is: getByte(Ljava/lang/String;)B type is: class org.evosuite.testcase.statements.MethodStatement return type byte
statement code is: byte _byte = jCLO.getByte("MIN_VALUE")
test data is: Byte byte = new Byte((byte)92);
String[][] stringArray = new String[5][2];
JCLO jCLO = new JCLO((String) null, byte, stringArray);
jCLO.getByte("MIN_VALUE");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Byte = new Byte(((byte) (-128)));
        String[][] stringArray = new String[5][2];
        stringArray[0][0] = "ABC";
        stringArray[0][1] = "DEF";
        stringArray[1][0] = "GHI";
        stringArray[1][1] = "JKL";
        stringArray[2][0] = "MNO";
        stringArray[2][1] = "PQR";
        stringArray[3][0] = "STU";
        stringArray[3][1] = "VWX";
        stringArray[4][0] = "YZA";
        stringArray[4][1] = "BCD";
        JCLO jCLO = new JCLO(((String) (null)), byte.class, stringArray);
        jCLO.getByte("MIN_VALUE");
    }
}
statement is: Byte = new Byte(((byte) (-128))), class spoon.support.reflect.code.CtAssignmentImpl
statement is: String[][] stringArray = new String[5][2], class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtNewArrayImpl
Dimension: [5, 2] Ct is: String[][] stringArray = new String[5][2] isAssignment: false Array: new String[5][2] Elements: []
lengths: [5, 2] [5, 2]
Their type are: class [[Ljava.lang.String; String[][]
statement is: stringArray[0][0] = "ABC", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0][0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"ABC" Ct is: stringArray[0][0] = "ABC"
target : stringArray[0] class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[0][1] = "DEF", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[0][1] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"DEF" Ct is: stringArray[0][1] = "DEF"
target : stringArray[0] class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[1][0] = "GHI", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[1][0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"GHI" Ct is: stringArray[1][0] = "GHI"
target : stringArray[1] class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[1][1] = "JKL", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[1][1] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"JKL" Ct is: stringArray[1][1] = "JKL"
target : stringArray[1] class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[2][0] = "MNO", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[2][0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"MNO" Ct is: stringArray[2][0] = "MNO"
target : stringArray[2] class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[2][1] = "PQR", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[2][1] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"PQR" Ct is: stringArray[2][1] = "PQR"
target : stringArray[2] class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[3][0] = "STU", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[3][0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"STU" Ct is: stringArray[3][0] = "STU"
target : stringArray[3] class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[3][1] = "VWX", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[3][1] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"VWX" Ct is: stringArray[3][1] = "VWX"
target : stringArray[3] class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[4][0] = "YZA", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[4][0] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"YZA" Ct is: stringArray[4][0] = "YZA"
target : stringArray[4] class spoon.support.reflect.code.CtLiteralImpl
statement is: stringArray[4][1] = "BCD", class spoon.support.reflect.code.CtAssignmentImpl
Assigned : stringArray[4][1] Assigned Type class spoon.support.reflect.code.CtArrayWriteImpl String Assignment:"BCD" Ct is: stringArray[4][1] = "BCD"
target : stringArray[4] class spoon.support.reflect.code.CtLiteralImpl
statement is: JCLO jCLO = new JCLO(((String) (null)), byte.class, stringArray), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
TestCase Could not be added: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;[[Ljava/lang/String;)V
statement is: jCLO.getByte("MIN_VALUE"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getByte("MIN_VALUE") target is: jCLO method is: getByte(java.lang.String)
TestCase is: String[][] stringArray = new String[5][2];

statement is: java.lang.Byte(B)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Byte
statement code is: Byte byte = new Byte((byte)28)
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO((String) null, arg1)
statement is: getByte(Ljava/lang/String;)B type is: class org.evosuite.testcase.statements.MethodStatement return type byte
statement code is: byte _byte = jCLO.getByte("value")
test data is: Byte byte = new Byte((byte)28);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.getByte("value");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Byte = new Byte(((byte) (127)));
        JCLO jCLO = new JCLO("Hello", byte.class);
        jCLO.getByte("value");
    }
}
statement is: Byte = new Byte(((byte) (127))), class spoon.support.reflect.code.CtAssignmentImpl
statement is: JCLO jCLO = new JCLO("Hello", byte.class), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.getByte("value"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getByte("value") target is: jCLO method is: getByte(java.lang.String)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/String;Ljava/lang/Object;)V callee: VariableReference: Statement 1, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: getByte(Ljava/lang/String;)B
TestCase is: String string = "Hello";
JCLO jCLO = new JCLO(string, string);
String string = "value";
jCLO.getByte(string);

statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO("\fields----f---")
statement is: getChars(Ljava/lang/String;)[C type is: class org.evosuite.testcase.statements.MethodStatement return type class [C
statement code is: char[] chars = jCLO.getChars("\fields----f---")
test data is: JCLO jCLO = new JCLO("\fields----f---");
jCLO.getChars("\fields----f---");

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        JCLO jCLO = new JCLO("A1234567890B");
        jCLO.getChars("A1234567890B");
    }
}
statement is: JCLO jCLO = new JCLO("A1234567890B"), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.getChars("A1234567890B"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.getChars("A1234567890B") target is: jCLO method is: getChars(java.lang.String)
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 0, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: getChars(Ljava/lang/String;)[C
TestCase is: String string = "A1234567890B";
JCLO jCLO = new JCLO(string);
String string = "A1234567890B";
((JCLO) string).getChars(string);

statement is: java.lang.Object()V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class java.lang.Object
statement code is: Object object = new Object()
statement is: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V type is: class org.evosuite.testcase.statements.ConstructorStatement return type class edu.mscd.cs.jclo.JCLO
statement code is: JCLO jCLO = new JCLO(arg0)
statement is: toString()Ljava/lang/String; type is: class org.evosuite.testcase.statements.MethodStatement return type class java.lang.String
statement code is: String string = jCLO.toString()
test data is: Object object = new Object();
JCLO jCLO = new JCLO(object);
jCLO.toString();

** It was a parseable test case! 
Improved test data is: class DummyClass {
    public static void main() {
        Object object = new Object();
        object.setName("John");
        object.setAge(30);
        JCLO jCLO = new JCLO(object);
        jCLO.toString();
    }
}
statement is: Object object = new Object(), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: object.setName("John"), class spoon.support.reflect.code.CtInvocationImpl
invocation is: object.setName("John") target is: object method is: setName(java.lang.String)
statement is: object.setAge(30), class spoon.support.reflect.code.CtInvocationImpl
invocation is: object.setAge(30) target is: object method is: setAge(int)
statement is: JCLO jCLO = new JCLO(object), class spoon.support.reflect.code.CtLocalVariableImpl
class spoon.support.reflect.code.CtConstructorCallImpl
statement is: jCLO.toString(), class spoon.support.reflect.code.CtInvocationImpl
invocation is: jCLO.toString() target is: jCLO method is: toString()
source statement: edu.mscd.cs.jclo.JCLO(Ljava/lang/Object;)V callee: VariableReference: Statement 1, type edu.mscd.cs.jclo.JCLOindex is: 1
Matched Method is: toString()Ljava/lang/String;
TestCase is: Object object = new Object();
JCLO jCLO = new JCLO(object);
jCLO.toString();

* test suite isTestSuite: 68
Test 0: 
JCLO jCLO = new JCLO("_");
jCLO.getLong("serialVersionUID");
Test 1: 
JCLO jCLO = new JCLO("MINYVrLUE");
jCLO.getInts("MINYVrLUE");
Test 2: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO(byte);
// Undeclared exception!
try { 
  jCLO.getChar("");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 3: 
JCLO jCLO = new JCLO("&s9oMg&7.");
jCLO.getString("&s9oMg&7.");
Test 4: 
JCLO jCLO = new JCLO("R|SH=lbH}G^z`SIZE");
// Undeclared exception!
try { 
  jCLO.getInt("R|SH=lbH}G^z`SIZE");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 5: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.getShorts("");
Test 6: 
JCLO jCLO = new JCLO("k.8Sq%VkKnaV4D`AGwSIZE");
jCLO.getChars("value");
Test 7: 
JCLO jCLO = new JCLO("/");
// Undeclared exception!
try { 
  jCLO.getBoolean("/");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 8: 
JCLO jCLO = new JCLO(" ");
jCLO.getDoubles(" ");
Test 9: 
Object object = new Object();
String[][] stringArray = new String[4][1];
JCLO jCLO = new JCLO(object, stringArray);
String[] stringArray = new String[9];
stringArray[0] = "-' requires '=VALUE'";
// Undeclared exception!
try { 
  jCLO.parse(stringArray);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
}

Test 10: 
JCLO jCLO = new JCLO("");
// Undeclared exception!
try { 
  jCLO.getDouble("");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 11: 
JCLO jCLO = new JCLO(" ");
// Undeclared exception!
try { 
  jCLO.getFloat(" ");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 12: 
JCLO jCLO = new JCLO("Yp7!}i{T1K[Z=Yz;dQ");
jCLO.getStrings("Yp7!}i{T1K[Z=Yz;dQ");
Test 13: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.getFloats("");
Test 14: 
Object object = new Object();
JCLO jCLO = new JCLO(object);
// Undeclared exception!
try { 
  jCLO.getShort("YcZ:)OB^");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 15: 
JCLO jCLO = new JCLO("");
jCLO.getLongs("");
Test 16: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO(byte);
jCLO.getBytes("*:7OM!WAG[x378");
Test 17: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
JCLO jCLO = new JCLO("", jCLO);
jCLO.usage();
Test 18: 
Byte byte = new Byte((byte) (-1));
JCLO jCLO = new JCLO("-{,vPwuV3ODk", byte);
String[] stringArray = new String[5];
stringArray[0] = "-{,vPwuV3ODk";
// Undeclared exception!
try { 
  jCLO.parse(stringArray);
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // No such option: \"{,vPwuV3ODk\"
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 19: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.toString();
Test 20: 
JCLO jCLO = new JCLO("\"");
// Undeclared exception!
try { 
  jCLO.toString();
  fail("Expecting exception: ClassCastException");

} catch(ClassCastException e) {
   //
   // [C cannot be cast to [Ljava.lang.Object;
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 21: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.usage();
Test 22: 
Byte byte = new Byte((byte)3);
JCLO jCLO = new JCLO("MIN_VALUE", byte);
jCLO.usage();
Test 23: 
Object object = new Object();
String[][] stringArray = new String[4][1];
String[] stringArray = new String[5];
stringArray[0] = "-";
JCLO jCLO = new JCLO(object, stringArray);
// Undeclared exception!
try { 
  jCLO.parse(stringArray);
  fail("Expecting exception: StringIndexOutOfBoundsException");

} catch(StringIndexOutOfBoundsException e) {
}

Test 24: 
JCLO jCLO = new JCLO("fields-----ff---");
String[] stringArray = new String[10];
stringArray[0] = "-Ivalue";
// Undeclared exception!
try { 
  jCLO.parse(stringArray);
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // '-Ivalue' requires '=VALUE'
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 25: 
JCLO jCLO = new JCLO("&s9oMg&7.");
String[] stringArray = new String[0];
jCLO.parse(stringArray);
Test 26: 
Byte byte = new Byte((byte)119);
JCLO jCLO = new JCLO(byte);
String[] stringArray = new String[5];
stringArray[0] = "-value";
// Undeclared exception!
try { 
  jCLO.parse(stringArray);
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // No such option: \"alue\"
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 27: 
String[] stringArray = new String[2];
JCLO.main(stringArray);
Test 28: 
String[] stringArray = new String[1];
stringArray[0] = "MIN_VALUE";
JCLO.main(stringArray);
Test 29: 
JCLO jCLO = new JCLO("2");
jCLO.getValue("value");
Test 30: 
Object object = new Object();
JCLO jCLO = new JCLO("r5", object);
jCLO.getValue("r5");
Test 31: 
JCLO jCLO = new JCLO(" ");
String[] stringArray = new String[2];
stringArray[0] = " ";
jCLO.parse(stringArray);
Test 32: 
Byte byte = new Byte((byte)92);
String[][] stringArray = new String[5][2];
JCLO jCLO = new JCLO((String) null, byte, stringArray);
jCLO.getByte("MIN_VALUE");
Test 33: 
Byte byte = new Byte((byte)28);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.getByte("value");
Test 34: 
JCLO jCLO = new JCLO("\fields----f---");
jCLO.getChars("\fields----f---");
Test 35: 
Object object = new Object();
JCLO jCLO = new JCLO(object);
jCLO.toString();
Test 36: 
JCLO jCLO = new JCLO("_");
((JCLO)"_").getLong((String) 0);

Test 37: 
JCLO jCLO = new JCLO("A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION");
((JCLO)"A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION").getInts("A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION");

Test 38: 
JCLO jCLO = new JCLO("A long string with special characters &^%$#@!");
((JCLO)"A long string with special characters &^%$#@!").getString("A long string with special characters &^%$#@!");

Test 39: 
JCLO jCLO = new JCLO("Inventory size");
((JCLO)"Inventory size").getInt("Inventory size");

Test 40: 
JCLO jCLO = new JCLO("Test", "Test");
jCLO.getShorts((String) null);

Test 41: 
JCLO jCLO = new JCLO("k.8Sq%VkKnaV4D`AGwSIZE");
((JCLO)"k.8Sq%VkKnaV4D`AGwSIZE").getChars("value");

Test 42: 
JCLO jCLO = new JCLO("//root/child");
((JCLO)"//root/child").getBoolean("//root/child");

Test 43: 
JCLO jCLO = new JCLO(10);

Test 44: 
Object object = new Object();
String[][] stringArray = new String[4][1];
JCLO jCLO = new JCLO(object, stringArray);
String[] stringArray = new String[9];
stringArray[0] = "Invalid syntax: '=' requires a value";
jCLO.parse(stringArray);

Test 45: 
String string = "hello";
JCLO jCLO = new JCLO("hello");
((JCLO)"hello").getDouble("9876543210.12345");
String string = "world";
JCLO jCLO = new JCLO(string);
String string = "-1234567890.12345";
((JCLO) string).getDouble(string);
String string = "test";
JCLO jCLO = new JCLO(string);
String string = "1234567890.12345";
((JCLO) string).getDouble(string);
String string = "foo";
JCLO jCLO = new JCLO(string);
String string = "-9876543210.12345";
((JCLO) string).getDouble(string);

Test 46: 
JCLO jCLO = new JCLO(" ");
((JCLO)" ").getFloat(" ");

Test 47: 
JCLO jCLO = new JCLO("string", "string");
jCLO.getFloats((String) 3.14F);

Test 48: 
Object object = new Object();
JCLO jCLO = new JCLO(object);
jCLO.getShort("123456789");

Test 49: 
JCLO jCLO = new JCLO("Hello, World!", "Hello, World!");
JCLO jCLO = new JCLO("Goodbye, World!", jCLO);

Test 50: 
JCLO jCLO = new JCLO("-{,vPwuV3ODk", "-{,vPwuV3ODk");
String[] stringArray = new String[5];
stringArray[0] = "This is a test string";
jCLO.parse(stringArray);

Test 51: 
JCLO jCLO = new JCLO("Another Test String", "Another Test String");
jCLO.toString();

Test 52: 

Test 53: 
JCLO jCLO = new JCLO("JCLO Test", "JCLO Test");
jCLO.usage();

Test 54: 
JCLO jCLO = new JCLO("MIN_VALUE", "MIN_VALUE");
jCLO.usage();

Test 55: 
Object object = new Object();
String[][] stringArray = new String[4][1];
JCLO jCLO = new JCLO(object, stringArray);

Test 56: 
String string = "fields-----ff---";
JCLO jCLO = new JCLO("fields-----ff---");
String[] stringArray = new String[10];
((JCLO)"fields-----ff---").parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);

Test 57: 
JCLO jCLO = new JCLO("&s9oMg&7.");
((JCLO)"&s9oMg&7.").parse((String[]) null);

Test 58: 
String[] stringArray = new String[5];

Test 59: 
JCLO.main((String[]) null);

Test 60: 
String[] stringArray = new String[1];
stringArray[0] = "The quick brown fox jumps over the lazy dog.";
JCLO.main(stringArray);

Test 61: 
JCLO jCLO = new JCLO("10");
((JCLO)"10").getValue("value");

Test 62: 
Object object = new Object();
JCLO jCLO = new JCLO("r5", object);

Test 63: 
JCLO jCLO = new JCLO("abc");
String[] stringArray = new String[2];
((JCLO)"abc").parse(stringArray);

Test 64: 
String[][] stringArray = new String[5][2];

Test 65: 
JCLO jCLO = new JCLO("Hello", "Hello");
jCLO.getByte("value");

Test 66: 
JCLO jCLO = new JCLO("A1234567890B");
((JCLO)"A1234567890B").getChars("A1234567890B");

Test 67: 
Object object = new Object();
JCLO jCLO = new JCLO(object);
jCLO.toString();


* Generated after the refinement and before minimization 68 tests with total length 220
* test suite isTestSuite: 68
Test 0: 
JCLO jCLO = new JCLO("_");
jCLO.getLong("serialVersionUID");
Test 1: 
JCLO jCLO = new JCLO("MINYVrLUE");
jCLO.getInts("MINYVrLUE");
Test 2: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO(byte);
// Undeclared exception!
try { 
  jCLO.getChar("");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 3: 
JCLO jCLO = new JCLO("&s9oMg&7.");
jCLO.getString("&s9oMg&7.");
Test 4: 
JCLO jCLO = new JCLO("R|SH=lbH}G^z`SIZE");
// Undeclared exception!
try { 
  jCLO.getInt("R|SH=lbH}G^z`SIZE");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 5: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.getShorts("");
Test 6: 
JCLO jCLO = new JCLO("k.8Sq%VkKnaV4D`AGwSIZE");
jCLO.getChars("value");
Test 7: 
JCLO jCLO = new JCLO("/");
// Undeclared exception!
try { 
  jCLO.getBoolean("/");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 8: 
JCLO jCLO = new JCLO(" ");
jCLO.getDoubles(" ");
Test 9: 
Object object = new Object();
String[][] stringArray = new String[4][1];
JCLO jCLO = new JCLO(object, stringArray);
String[] stringArray = new String[9];
stringArray[0] = "-' requires '=VALUE'";
// Undeclared exception!
try { 
  jCLO.parse(stringArray);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
}

Test 10: 
JCLO jCLO = new JCLO("");
// Undeclared exception!
try { 
  jCLO.getDouble("");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 11: 
JCLO jCLO = new JCLO(" ");
// Undeclared exception!
try { 
  jCLO.getFloat(" ");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 12: 
JCLO jCLO = new JCLO("Yp7!}i{T1K[Z=Yz;dQ");
jCLO.getStrings("Yp7!}i{T1K[Z=Yz;dQ");
Test 13: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.getFloats("");
Test 14: 
Object object = new Object();
JCLO jCLO = new JCLO(object);
// Undeclared exception!
try { 
  jCLO.getShort("YcZ:)OB^");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 15: 
JCLO jCLO = new JCLO("");
jCLO.getLongs("");
Test 16: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO(byte);
jCLO.getBytes("*:7OM!WAG[x378");
Test 17: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
JCLO jCLO = new JCLO("", jCLO);
jCLO.usage();
Test 18: 
Byte byte = new Byte((byte) (-1));
JCLO jCLO = new JCLO("-{,vPwuV3ODk", byte);
String[] stringArray = new String[5];
stringArray[0] = "-{,vPwuV3ODk";
// Undeclared exception!
try { 
  jCLO.parse(stringArray);
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // No such option: \"{,vPwuV3ODk\"
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 19: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.toString();
Test 20: 
JCLO jCLO = new JCLO("\"");
// Undeclared exception!
try { 
  jCLO.toString();
  fail("Expecting exception: ClassCastException");

} catch(ClassCastException e) {
   //
   // [C cannot be cast to [Ljava.lang.Object;
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 21: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.usage();
Test 22: 
Byte byte = new Byte((byte)3);
JCLO jCLO = new JCLO("MIN_VALUE", byte);
jCLO.usage();
Test 23: 
Object object = new Object();
String[][] stringArray = new String[4][1];
String[] stringArray = new String[5];
stringArray[0] = "-";
JCLO jCLO = new JCLO(object, stringArray);
// Undeclared exception!
try { 
  jCLO.parse(stringArray);
  fail("Expecting exception: StringIndexOutOfBoundsException");

} catch(StringIndexOutOfBoundsException e) {
}

Test 24: 
JCLO jCLO = new JCLO("fields-----ff---");
String[] stringArray = new String[10];
stringArray[0] = "-Ivalue";
// Undeclared exception!
try { 
  jCLO.parse(stringArray);
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // '-Ivalue' requires '=VALUE'
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 25: 
JCLO jCLO = new JCLO("&s9oMg&7.");
String[] stringArray = new String[0];
jCLO.parse(stringArray);
Test 26: 
Byte byte = new Byte((byte)119);
JCLO jCLO = new JCLO(byte);
String[] stringArray = new String[5];
stringArray[0] = "-value";
// Undeclared exception!
try { 
  jCLO.parse(stringArray);
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // No such option: \"alue\"
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 27: 
String[] stringArray = new String[2];
JCLO.main(stringArray);
Test 28: 
String[] stringArray = new String[1];
stringArray[0] = "MIN_VALUE";
JCLO.main(stringArray);
Test 29: 
JCLO jCLO = new JCLO("2");
jCLO.getValue("value");
Test 30: 
Object object = new Object();
JCLO jCLO = new JCLO("r5", object);
jCLO.getValue("r5");
Test 31: 
JCLO jCLO = new JCLO(" ");
String[] stringArray = new String[2];
stringArray[0] = " ";
jCLO.parse(stringArray);
Test 32: 
Byte byte = new Byte((byte)92);
String[][] stringArray = new String[5][2];
JCLO jCLO = new JCLO((String) null, byte, stringArray);
jCLO.getByte("MIN_VALUE");
Test 33: 
Byte byte = new Byte((byte)28);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.getByte("value");
Test 34: 
JCLO jCLO = new JCLO("\fields----f---");
jCLO.getChars("\fields----f---");
Test 35: 
Object object = new Object();
JCLO jCLO = new JCLO(object);
jCLO.toString();
Test 36: 
JCLO jCLO = new JCLO("_");
((JCLO)"_").getLong((String) 0);

Test 37: 
JCLO jCLO = new JCLO("A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION");
((JCLO)"A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION").getInts("A_MODERN_ALGORITHM_FOR_STRING_MANIPULATION");

Test 38: 
JCLO jCLO = new JCLO("A long string with special characters &^%$#@!");
((JCLO)"A long string with special characters &^%$#@!").getString("A long string with special characters &^%$#@!");

Test 39: 
JCLO jCLO = new JCLO("Inventory size");
((JCLO)"Inventory size").getInt("Inventory size");

Test 40: 
JCLO jCLO = new JCLO("Test", "Test");
jCLO.getShorts((String) null);

Test 41: 
JCLO jCLO = new JCLO("k.8Sq%VkKnaV4D`AGwSIZE");
((JCLO)"k.8Sq%VkKnaV4D`AGwSIZE").getChars("value");

Test 42: 
JCLO jCLO = new JCLO("//root/child");
((JCLO)"//root/child").getBoolean("//root/child");

Test 43: 
JCLO jCLO = new JCLO(10);

Test 44: 
Object object = new Object();
String[][] stringArray = new String[4][1];
JCLO jCLO = new JCLO(object, stringArray);
String[] stringArray = new String[9];
stringArray[0] = "Invalid syntax: '=' requires a value";
jCLO.parse(stringArray);

Test 45: 
String string = "hello";
JCLO jCLO = new JCLO("hello");
((JCLO)"hello").getDouble("9876543210.12345");
String string = "world";
JCLO jCLO = new JCLO(string);
String string = "-1234567890.12345";
((JCLO) string).getDouble(string);
String string = "test";
JCLO jCLO = new JCLO(string);
String string = "1234567890.12345";
((JCLO) string).getDouble(string);
String string = "foo";
JCLO jCLO = new JCLO(string);
String string = "-9876543210.12345";
((JCLO) string).getDouble(string);

Test 46: 
JCLO jCLO = new JCLO(" ");
((JCLO)" ").getFloat(" ");

Test 47: 
JCLO jCLO = new JCLO("string", "string");
jCLO.getFloats((String) 3.14F);

Test 48: 
Object object = new Object();
JCLO jCLO = new JCLO(object);
jCLO.getShort("123456789");

Test 49: 
JCLO jCLO = new JCLO("Hello, World!", "Hello, World!");
JCLO jCLO = new JCLO("Goodbye, World!", jCLO);

Test 50: 
JCLO jCLO = new JCLO("-{,vPwuV3ODk", "-{,vPwuV3ODk");
String[] stringArray = new String[5];
stringArray[0] = "This is a test string";
jCLO.parse(stringArray);

Test 51: 
JCLO jCLO = new JCLO("Another Test String", "Another Test String");
jCLO.toString();

Test 52: 

Test 53: 
JCLO jCLO = new JCLO("JCLO Test", "JCLO Test");
jCLO.usage();

Test 54: 
JCLO jCLO = new JCLO("MIN_VALUE", "MIN_VALUE");
jCLO.usage();

Test 55: 
Object object = new Object();
String[][] stringArray = new String[4][1];
JCLO jCLO = new JCLO(object, stringArray);

Test 56: 
String string = "fields-----ff---";
JCLO jCLO = new JCLO("fields-----ff---");
String[] stringArray = new String[10];
((JCLO)"fields-----ff---").parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);
((JCLO) string).parse(stringArray);

Test 57: 
JCLO jCLO = new JCLO("&s9oMg&7.");
((JCLO)"&s9oMg&7.").parse((String[]) null);

Test 58: 
String[] stringArray = new String[5];

Test 59: 
JCLO.main((String[]) null);

Test 60: 
String[] stringArray = new String[1];
stringArray[0] = "The quick brown fox jumps over the lazy dog.";
JCLO.main(stringArray);

Test 61: 
JCLO jCLO = new JCLO("10");
((JCLO)"10").getValue("value");

Test 62: 
Object object = new Object();
JCLO jCLO = new JCLO("r5", object);

Test 63: 
JCLO jCLO = new JCLO("abc");
String[] stringArray = new String[2];
((JCLO)"abc").parse(stringArray);

Test 64: 
String[][] stringArray = new String[5][2];

Test 65: 
JCLO jCLO = new JCLO("Hello", "Hello");
jCLO.getByte("value");

Test 66: 
JCLO jCLO = new JCLO("A1234567890B");
((JCLO)"A1234567890B").getChars("A1234567890B");

Test 67: 
Object object = new Object();
JCLO jCLO = new JCLO(object);
jCLO.toString();


* Minimizing test suite
* test suite isTestSuite: 34
Test 0: 
JCLO jCLO = new JCLO("_");
jCLO.getLong("serialVersionUID");
Test 1: 
JCLO jCLO = new JCLO("MINYVrLUE");
jCLO.getInts("MINYVrLUE");
Test 2: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO(byte);
// Undeclared exception!
try { 
  jCLO.getChar("");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 3: 
JCLO jCLO = new JCLO("&s9oMg&7.");
jCLO.getString("&s9oMg&7.");
Test 4: 
JCLO jCLO = new JCLO("R|SH=lbH}G^z`SIZE");
// Undeclared exception!
try { 
  jCLO.getInt("R|SH=lbH}G^z`SIZE");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 5: 
JCLO jCLO = new JCLO("Test", "Test");
jCLO.getShorts((String) null);
Test 6: 
JCLO jCLO = new JCLO("\fields----f---");
jCLO.getChars("\fields----f---");
Test 7: 
JCLO jCLO = new JCLO("/");
// Undeclared exception!
try { 
  jCLO.getBoolean("/");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 8: 
JCLO jCLO = new JCLO(" ");
jCLO.getDoubles(" ");
Test 9: 
Object object = new Object();
String[][] stringArray = new String[4][1];
JCLO jCLO = new JCLO(object, stringArray);
String[] stringArray = new String[9];
stringArray[0] = "Invalid syntax: '=' requires a value";
jCLO.parse(stringArray);
Test 10: 
JCLO jCLO = new JCLO("");
// Undeclared exception!
try { 
  jCLO.getDouble("");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 11: 
JCLO jCLO = new JCLO(" ");
// Undeclared exception!
try { 
  jCLO.getFloat(" ");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 12: 
JCLO jCLO = new JCLO("Yp7!}i{T1K[Z=Yz;dQ");
jCLO.getStrings("Yp7!}i{T1K[Z=Yz;dQ");
Test 13: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.getFloats("");
Test 14: 
Object object = new Object();
JCLO jCLO = new JCLO(object);
// Undeclared exception!
try { 
  jCLO.getShort("123456789");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 15: 
JCLO jCLO = new JCLO("");
jCLO.getLongs("");
Test 16: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO(byte);
jCLO.getBytes("*:7OM!WAG[x378");
Test 17: 
JCLO jCLO = new JCLO("Another Test String", "Another Test String");
// Undeclared exception!
try { 
  jCLO.toString();
  fail("Expecting exception: ClassCastException");

} catch(ClassCastException e) {
   //
   // [C cannot be cast to [Ljava.lang.Object;
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 18: 
Object object = new Object();
JCLO jCLO = new JCLO(object);
jCLO.toString();
Test 19: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.toString();
Test 20: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
JCLO jCLO = new JCLO("", jCLO);
jCLO.usage();
Test 21: 
Byte byte = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.usage();
Test 22: 
JCLO jCLO = new JCLO("JCLO Test", "JCLO Test");
jCLO.usage();
Test 23: 
JCLO jCLO = new JCLO("fields-----ff---");
String[] stringArray = new String[10];
stringArray[0] = "-Ivalue";
// Undeclared exception!
try { 
  jCLO.parse(stringArray);
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // '-Ivalue' requires '=VALUE'
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 24: 
Object object = new Object();
String[][] stringArray = new String[4][1];
JCLO jCLO = new JCLO(object, stringArray);
String[] stringArray = new String[9];
stringArray[0] = "-' requires '=VALUE'";
// Undeclared exception!
try { 
  jCLO.parse(stringArray);
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
}

Test 25: 
Byte byte = new Byte((byte) (-1));
JCLO jCLO = new JCLO("-{,vPwuV3ODk", byte);
String[] stringArray = new String[5];
stringArray[0] = "-{,vPwuV3ODk";
// Undeclared exception!
try { 
  jCLO.parse(stringArray);
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // No such option: \"{,vPwuV3ODk\"
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}

Test 26: 
JCLO jCLO = new JCLO("&s9oMg&7.");
String[] stringArray = new String[0];
jCLO.parse(stringArray);
Test 27: 
String[] stringArray = new String[2];
JCLO.main(stringArray);
Test 28: 
String[] stringArray = new String[1];
stringArray[0] = "The quick brown fox jumps over the lazy dog.";
JCLO.main(stringArray);
Test 29: 
JCLO jCLO = new JCLO("2");
jCLO.getValue("value");
Test 30: 
Object object = new Object();
JCLO jCLO = new JCLO("r5", object);
jCLO.getValue("r5");
Test 31: 
Byte byte = new Byte((byte)92);
String[][] stringArray = new String[5][2];
JCLO jCLO = new JCLO((String) null, byte, stringArray);
jCLO.getByte("MIN_VALUE");
Test 32: 
Byte byte = new Byte((byte)28);
JCLO jCLO = new JCLO((String) null, byte);
jCLO.getByte("value");
Test 33: 
JCLO jCLO = new JCLO("k.8Sq%VkKnaV4D`AGwSIZE");
jCLO.getChars("value");

* Going to analyze the coverage criteria
* Coverage analysis for criterion BRANCH
* Coverage of criterion BRANCH: 63%
* Total number of goals: 133
* Number of covered goals: 84
* Coverage analysis for criterion LINE
* Coverage of criterion LINE: 73%
* Total number of goals: 183
* Number of covered goals: 133
* Coverage analysis for criterion OUTPUT
* Coverage of criterion OUTPUT: 33%
* Total number of goals: 58
* Number of covered goals: 19
* Coverage analysis for criterion METHOD
* Coverage of criterion METHOD: 100%
* Total number of goals: 26
* Number of covered goals: 26
* Coverage analysis for criterion CBRANCH
* Coverage of criterion CBRANCH: 63%
* Total number of goals: 133
* Number of covered goals: 84
* Generated 34 tests with total length 96
* Resulting test suite's coverage: 76% (average coverage for all fitness functions)
* Generating assertions
* Resulting test suite's mutation score: 31%
* Compiling and checking tests
Going to execute: removeTestsThatDoNotCompile
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("_");
long _long = jCLO.getLong("serialVersionUID");
assertEquals((-6849794470754667710L), _long);


** It was a parseable test case! 
refined test name is: testGetLongWithValidSerializedRepresentation
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("MINYVrLUE");
int[] ints = jCLO.getInts("MINYVrLUE");
assertNull(ints);


** It was a parseable test case! 
refined test name is: testGetIntsReturnsNullWhenInputStringIsInvalid
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: Byte arg0 = new Byte((byte)0);
JCLO jCLO = new JCLO(arg0);
// Undeclared exception!
try { 
  jCLO.getChar("");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}


** It was a parseable test case! 
refined test name is: testGetCharemptyStringthrowsNullPointerException
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("&s9oMg&7.");
String string = jCLO.getString("&s9oMg&7.");
assertNull(string);


** It was a parseable test case! 
refined test name is: testGetStringWithEmptyInput
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("R|SH=lbH}G^z`SIZE");
// Undeclared exception!
try { 
  jCLO.getInt("R|SH=lbH}G^z`SIZE");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}


** It was a parseable test case! 
refined test name is: testGetIntthrowsNullPointerExceptionForNullInput
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("Test", "Test");
short[] shorts = jCLO.getShorts((String) null);
assertNull(shorts);


** It was a parseable test case! 
refined test name is: testGetShortsWithNullInput
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("\fields----f---");
char[] chars = jCLO.getChars("\fields----f---");
assertNull(chars);


** It was a parseable test case! 
refined test name is: testGetCharsForNonExistentField
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("/");
// Undeclared exception!
try { 
  jCLO.getBoolean("/");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}


** It was a parseable test case! 
refined test name is: testGetBooleanForNullPathThrowsNPE
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO(" ");
double[] doubles = jCLO.getDoubles(" ");
assertNull(doubles);


** It was a parseable test case! 
refined test name is: testGetDoublesWithEmptyStringReturnsNull
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("");
// Undeclared exception!
try { 
  jCLO.getDouble("");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}


** It was a parseable test case! 
refined test name is: testGetDoubleWithNullInputThrowsException
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO(" ");
// Undeclared exception!
try { 
  jCLO.getFloat(" ");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}


** It was a parseable test case! 
refined test name is: testGetFloatFromNullReference
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("Yp7!}i{T1K[Z=Yz;dQ");
String[] strings = jCLO.getStrings("Yp7!}i{T1K[Z=Yz;dQ");
assertNull(strings);


** It was a parseable test case! 
refined test name is: testGetStringsWithNoStringsReturnsNull
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: Byte arg1 = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, arg1);
float[] floats = jCLO.getFloats("");
assertNull(floats);


** It was a parseable test case! 
refined test name is: testGetFloatsReturnsNullWhenGivenANullInput
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: Object arg0 = new Object();
JCLO jCLO = new JCLO(arg0);
// Undeclared exception!
try { 
  jCLO.getShort("123456789");
  fail("Expecting exception: NullPointerException");

} catch(NullPointerException e) {
   //
   // no message in exception (getMessage() returned null)
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}


** It was a parseable test case! 
refined test name is: testGetShortWithInvalidArgument
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("");
long[] longs = jCLO.getLongs("");
assertNull(longs);


** It was a parseable test case! 
refined test name is: testGetLongsReturnsNullForEmptyString
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: Byte arg0 = new Byte((byte)0);
JCLO jCLO = new JCLO(arg0);
byte[] bytes = jCLO.getBytes("*:7OM!WAG[x378");
assertNull(bytes);


** It was a parseable test case! 
refined test name is: testGetBytesWithNonAsciiSequenceReturnsNull
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("Another Test String", "Another Test String");
// Undeclared exception!
try { 
  jCLO.toString();
  fail("Expecting exception: ClassCastException");

} catch(ClassCastException e) {
   //
   // [C cannot be cast to [Ljava.lang.Object;
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}


** It was a parseable test case! 
refined test name is: testToStringThrowsClassCastException
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: Object arg0 = new Object();
JCLO jCLO = new JCLO(arg0);
String string = jCLO.toString();
assertEquals("", string);


** It was a parseable test case! 
refined test name is: testToStringReturnsEmptyString
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: Byte arg1 = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, arg1);
String string = jCLO.toString();
assertEquals("byte: value = 0\nlong: serialVersionUID = -7183698231559129828\nbyte: MAX_VALUE = 127\nbyte: MIN_VALUE = -128\nint: BYTES = 1\nint: SIZE = 8\nClass: TYPE = byte", string);


** It was a parseable test case! 
refined test name is: testToStringWithDefaultValues
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: Byte arg1 = new Byte((byte)0);
JCLO jCLO = new JCLO((String) null, arg1);
String usage = jCLO.usage();
assertEquals("", usage);


** It was a parseable test case! 
refined test name is: testUsageWithZeroOutputFileArgument
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("JCLO Test", "JCLO Test");
String usage = jCLO.usage();
assertEquals("", usage);


** It was a parseable test case! 
refined test name is: testJCLOUsageNoArgs
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("fields-----ff---");
String[] arg0 = new String[10];
arg0[0] = "-Ivalue";
// Undeclared exception!
try { 
  jCLO.parse(arg0);
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // No such option: \"Ivalue\"
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}


** It was a parseable test case! 
refined test name is: testInvalidOptionThrowsIllegalArgumentException
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: Byte arg1 = new Byte((byte) (-1));
JCLO jCLO = new JCLO("-{,vPwuV3ODk", arg1);
String[] arg0 = new String[5];
arg0[0] = "-{,vPwuV3ODk";
// Undeclared exception!
try { 
  jCLO.parse(arg0);
  fail("Expecting exception: IllegalArgumentException");

} catch(IllegalArgumentException e) {
   //
   // No such option: \",vPwuV3ODk\"
   //
   verifyException("edu.mscd.cs.jclo.JCLO", e);
}


** It was a parseable test case! 
refined test name is: testInvalidOptionThrowsIllegalArgumentException
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("&s9oMg&7.");
String[] arg0 = new String[0];
jCLO.parse(arg0);
assertEquals(0, arg0.length);


** It was a parseable test case! 
refined test name is: testEmptyCommandLineArgumentsParsing
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: String[] arg0 = new String[2];
JCLO.main(arg0);
assertEquals(2, arg0.length);


** It was a parseable test case! 
refined test name is: testCorrectNumberOfArgumentsPassedToMainMethod
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: String[] arg0 = new String[1];
arg0[0] = "The quick brown fox jumps over the lazy dog.";
JCLO.main(arg0);
assertEquals(1, arg0.length);


** It was a parseable test case! 
refined test name is: testSingleArgument
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("2");
Object value = jCLO.getValue("value");
assertNotNull(value);


** It was a parseable test case! 
refined test name is: testGetValueshouldReturnNonNullValue
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: Object arg1 = new Object();
JCLO jCLO = new JCLO("r5", arg1);
Object value = jCLO.getValue("r5");
assertNull(value);


** It was a parseable test case! 
refined test name is: testGetValueOnNonExistentResource
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: Byte arg1 = new Byte((byte)92);
String[][] arg2 = new String[5][2];
JCLO jCLO = new JCLO((String) null, arg1, arg2);
byte _byte = jCLO.getByte("MIN_VALUE");
assertEquals((byte) (-128), _byte);


** It was a parseable test case! 
refined test name is: testGetByteMINVALUE
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: Byte arg1 = new Byte((byte)28);
JCLO jCLO = new JCLO((String) null, arg1);
byte _byte = jCLO.getByte("value");
assertEquals((byte)28, _byte);


** It was a parseable test case! 
refined test name is: testGetByteFromJCLO
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: false
* Compiling Tests
** Write a test suite: 0 called: 0 to improve: true
** Improve Understandability: ** Test Code is: JCLO jCLO = new JCLO("k.8Sq%VkKnaV4D`AGwSIZE");
char[] chars = jCLO.getChars("value");
assertEquals(22, chars.length);


** It was a parseable test case! 
refined test name is: testGetCharsValidValueReturnsCorrectLengthArray
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
[MASTER] 11:43:40.798 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:40.830 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:40.933 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:40.935 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
[MASTER] 11:43:41.059 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:41.061 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:41.197 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
* Compiling Tests
[MASTER] 11:43:41.199 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
[MASTER] 11:43:41.295 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
[MASTER] 11:43:41.297 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
[MASTER] 11:43:41.391 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:41.392 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:41.490 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
* Compiling Tests
[MASTER] 11:43:41.491 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
[MASTER] 11:43:41.617 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:41.618 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
[MASTER] 11:43:41.666 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:41.667 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
[MASTER] 11:43:41.767 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:41.768 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
[MASTER] 11:43:41.857 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:41.860 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
[MASTER] 11:43:41.960 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:41.964 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
[MASTER] 11:43:42.106 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:42.107 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:42.248 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:42.249 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
[MASTER] 11:43:42.373 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:42.385 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:42.502 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:42.503 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:42.655 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:42.656 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:42.787 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:42.788 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
[MASTER] 11:43:42.941 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:42.942 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
[MASTER] 11:43:43.404 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:43.419 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
[MASTER] 11:43:43.809 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:43.811 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
[MASTER] 11:43:44.137 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:44.161 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
[MASTER] 11:43:44.709 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:44.733 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
[MASTER] 11:43:45.233 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:45.249 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
[MASTER] 11:43:45.681 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:45.690 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
[MASTER] 11:43:46.045 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:46.047 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
[MASTER] 11:43:46.349 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:46.351 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
[MASTER] 11:43:46.710 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
[MASTER] 11:43:46.713 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
[MASTER] 11:43:47.129 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:47.153 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
[MASTER] 11:43:47.577 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:47.601 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
[MASTER] 11:43:48.053 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:48.073 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
Going to execute: handleTestsThatAreUnstable
* Compiling Tests
[MASTER] 11:43:49.285 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
Going to execute: handleTestsThatAreUnstable
[MASTER] 11:43:49.309 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Compiling Tests
[MASTER] 11:43:51.217 [logback-1] WARN  AgentLoader - Failed to find EvoSuite jar in current classloader. URLs of classloader:
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/localedata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunjce_provider.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/../lib/tools.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunpkcs11.jar
file:/tmp/EvoSuite_pathingJar1902397329586640172.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jaccess.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/sunec.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/zipfs.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/jfxrt.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/dnsns.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/cldrdata.jar
file:/home/ubuntu/.sdkman/candidates/java/8.0.333.fx-librca/jre/lib/ext/nashorn.jar
[MASTER] 11:43:51.229 [logback-1] WARN  JUnitAnalyzer - Found unstable test named initializationError -> class java.lang.RuntimeException: Cannot find either the compilation target folder nor the EvoSuite jar in classpath: /tmp/EvoSuite_pathingJar1902397329586640172.jar
* Writing tests to file
* Writing JUnit test case 'JCLO_ESTest' to evosuite-tests
* Done!

* Computation finished
