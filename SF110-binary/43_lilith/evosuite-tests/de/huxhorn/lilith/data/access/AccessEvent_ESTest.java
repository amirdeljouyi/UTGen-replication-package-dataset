/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 12 09:04:15 GMT 2024
 */

package de.huxhorn.lilith.data.access;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import de.huxhorn.lilith.data.access.AccessEvent;
import de.huxhorn.lilith.data.access.LoggerContext;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class AccessEvent_ESTest extends AccessEvent_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetTimeStampReturningZero() throws Throwable  {
      // Given: An instance of AccessEvent with a timestamp set to 0L
      AccessEvent accessEvent = new AccessEvent();
      Long arg0 = new Long(0L);
      accessEvent.setTimeStamp(arg0);
      
      // When: We retrieve the timestamp from the AccessEvent
      Long timeStamp = accessEvent.getTimeStamp();
      
      // Then: The retrieved timestamp should be equal to 0L
      assertEquals(0L, (long)timeStamp);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetTimeStampReturningPositive() throws Throwable  {
      // Given: a new AccessEvent object
      AccessEvent accessEvent = new AccessEvent();
      
      // When: setting the timestamp with a Long value of 1L
      Long arg0 = new Long(1L);
      accessEvent.setTimeStamp(arg0);
      
      // Then: the getTimeStamp method should return the same value as the set value
      Long timeStamp = accessEvent.getTimeStamp();
      assertEquals(1L, (long)timeStamp);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetTimeStampReturningNegative() throws Throwable  {
      // Given: We have a AccessEvent object and a Long value of -2827L
      AccessEvent accessEvent = new AccessEvent();
      Long arg0 = new Long((-2827L));
      
      // When: We set the timeStamp of the AccessEvent to the Long value
      accessEvent.setTimeStamp(arg0);
      
      // Then: The timeStamp of the AccessEvent should be equal to the Long value of -2827L
      Long timeStamp = accessEvent.getTimeStamp();
      assertEquals((-2827L), (long)timeStamp);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetStatusCodeReturningNegative() throws Throwable  {
      // Given: A new instance of the AccessEvent class is created and its status code is set to a negative value (-921).
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setStatusCode((-921));
      
      // When: The status code of the AccessEvent object is retrieved using the getStatusCode() method.
      int statusCode = accessEvent.getStatusCode();
      
      // Then: The retrieved status code should be equal to the value set in the previous step, which is -921.
      assertEquals((-921), statusCode);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetServerNameReturningEmptyString() throws Throwable  {
      // Given: an instance of AccessEvent with an empty server name
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setServerName("");
      
      // When: the getServerName method is called on the event
      String serverName = accessEvent.getServerName();
      
      // Then: the result should be an empty string
      assertEquals("", serverName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetResponseHeaders() throws Throwable  {
      // Given a new AccessEvent instance
      AccessEvent accessEvent = new AccessEvent();
      
      // When setting the response headers to an empty HashMap
      HashMap<String, String> arg0 = new HashMap<String, String>();
      accessEvent.setResponseHeaders(arg0);
      
      // Then the size of the response headers should be 0
      Map<String, String> responseHeaders = accessEvent.getResponseHeaders();
      assertEquals(0, responseHeaders.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRequestURLReturningNonEmptyString() throws Throwable  {
      // Given an AccessEvent object with a set Request URL
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRequestURL("https://www.example.com/somepage");
      
      // When we call getRequestURL on the AccessEvent object
      String requestURL = accessEvent.getRequestURL();
      
      // Then the returned string should be equal to the original set Request URL
      assertEquals("https://www.example.com/somepage", requestURL);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRequestURLReturningEmptyString() throws Throwable  {
      // Given: An instance of the AccessEvent class is created with an empty request URL.
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRequestURL("");
      
      // When: The getRequestURL() method is called on the instance.
      String requestURL = accessEvent.getRequestURL();
      
      // Then: The returned value should be an empty string, as expected.
      assertEquals("", requestURL);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRequestURIReturningNonEmptyString() throws Throwable  {
      // Given: A new AccessEvent object with a request URI of "/api/v1/users"
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRequestURI("/api/v1/users");
      
      // When: The getRequestURI method is called on the AccessEvent object
      String requestURI = accessEvent.getRequestURI();
      
      // Then: The returned value should be "/api/v1/users"
      assertEquals("/api/v1/users", requestURI);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRequestURIReturningEmptyString() throws Throwable  {
      // Given: Set up the AccessEvent with a valid request URI
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRequestURI("valid-request-uri");
      
      // When: Call getRequestURI() method on the AccessEvent object
      String requestURI = accessEvent.getRequestURI();
      
      // Then: The return value should be the same as the set request URI
      assertEquals("valid-request-uri", requestURI);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRequestParametersReturningMapWhereIsEmptyIsFalse() throws Throwable  {
      // Given: an AccessEvent object is created with a HashMap of request parameters
      AccessEvent accessEvent = new AccessEvent();
      HashMap<String, String[]> arg0 = new HashMap<String, String[]>();
      arg0.put("name", (String[]) null);
      accessEvent.setRequestParameters(arg0);
      
      // When: the request parameters are retrieved from the AccessEvent object
      Map<String, String[]> requestParameters = accessEvent.getRequestParameters();
      
      // Then: the map is not empty and contains the specified request parameter
      assertFalse(requestParameters.isEmpty());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRequestHeadersReturningMapWhereIsEmptyIsFalse() throws Throwable  {
      // Create an access event object and set the request headers with a map of values
      AccessEvent accessEvent = new AccessEvent();
      Map<String, String> requestHeaders = new HashMap<>();
      requestHeaders.put("Authorization", "Bearer 1234567890");
      accessEvent.setRequestHeaders(requestHeaders);
      
      // Get the request headers from the access event object and check if they are empty
      Map<String, String> retrievedRequestHeaders = accessEvent.getRequestHeaders();
      assertFalse(retrievedRequestHeaders.isEmpty());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRemoteUserReturningEmptyString() throws Throwable  {
      AccessEvent accessEvent = new AccessEvent();
      // Given: An empty remote user field
      String expectedRemoteUser = "";
      accessEvent.setRemoteUser(expectedRemoteUser);
      // When: The getRemoteUser method is called
      String actualRemoteUser = accessEvent.getRemoteUser();
      // Then: The returned value should be the same as the input
      assertEquals(expectedRemoteUser, actualRemoteUser);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRemoteHostReturningNonEmptyString() throws Throwable  {
      // Given an AccessEvent object with a remote host set to "192.168.0.1"
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRemoteHost("192.168.0.1");
      
      // When the remote host is retrieved from the AccessEvent object
      String remoteHost = accessEvent.getRemoteHost();
      
      // Then the value "192.168.0.1" is returned, which means that the remote host has been successfully set and retrieved correctly
      assertEquals("192.168.0.1", remoteHost);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRemoteHostReturningEmptyString() throws Throwable  {
      // Given: A new AccessEvent object
      AccessEvent accessEvent = new AccessEvent();
      
      // When: Setting the remote host using the setRemoteHost method
      accessEvent.setRemoteHost("127.0.0.1");
      
      // Then: The remote host should be "127.0.0.1"
      assertEquals("127.0.0.1", accessEvent.getRemoteHost());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRemoteAddressReturningNonEmptyString() throws Throwable  {
      // Given: We have an AccessEvent object with a remote address set to "]"
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRemoteAddress("]");
      String remoteAddress = accessEvent.getRemoteAddress();
      
      // When: The remote address is retrieved from the AccessEvent object
      String actualRemoteAddress = remoteAddress;
      
      // Then: The retrieved value should be "]"
      assertEquals("]", actualRemoteAddress);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRemoteAddressReturningEmptyString() throws Throwable  {
      // Given: A new instance of the AccessEvent class is created.
      AccessEvent accessEvent = new AccessEvent();
      
      // When: The remote address is set to an empty string.
      accessEvent.setRemoteAddress("");
      
      // Then: The getRemoteAddress method returns an empty string.
      String remoteAddress = accessEvent.getRemoteAddress();
      assertEquals("", remoteAddress);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetProtocolReturningEmptyString() throws Throwable  {
      // Given
      AccessEvent accessEvent = new AccessEvent();
      
      // When
      accessEvent.setProtocol("https");
      
      // Then
      assertEquals("https", accessEvent.getProtocol());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMethodReturningEmptyString() throws Throwable  {
      // Set up the test
      AccessEvent accessEvent = new AccessEvent();
      String expectedMethod = "someMethod";
      accessEvent.setMethod(expectedMethod);
      
      // Call the method being tested
      String actualMethod = accessEvent.getMethod();
      
      // Verify the results
      assertEquals(expectedMethod, actualMethod);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLoggerContextReturningNonNull() throws Throwable  {
      // Given a new AccessEvent object with a LoggerContext
      AccessEvent accessEvent = new AccessEvent();
      LoggerContext arg0 = new LoggerContext();
      
      // When the LoggerContext is set on the AccessEvent
      accessEvent.setLoggerContext(arg0);
      
      // Then the getLoggerContext method should return the same LoggerContext object that was set
      assertEquals(arg0, accessEvent.getLoggerContext());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLocalPortReturningNegative() throws Throwable  {
      // Given
      AccessEvent accessEvent = new AccessEvent();
      int expectedPort = -1087;
      
      // When
      accessEvent.setLocalPort(expectedPort);
      
      // Then
      assertEquals(expectedPort, accessEvent.getLocalPort());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashCodeAndSetServerName() throws Throwable  {
      // Given: An instance of the AccessEvent class with a server name set to "AccessEvent["
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setServerName("AccessEvent[");
      
      // When: The hashCode() method is called on the AccessEvent instance
      int hashCode = accessEvent.hashCode();
      
      // Then: The hash code of the AccessEvent instance should be a unique value that represents its contents
      assertNotEquals(0, hashCode);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashCodeAndSetMethod() throws Throwable  {
      // rollbacked to evosuite
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setMethod("99kc#K]-54&Yd=");
      accessEvent.hashCode();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashCodeAndSetProtocol() throws Throwable  {
      // rollbacked to evosuite
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setProtocol("HTTPS");
      accessEvent.hashCode();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashCodeAndSetRemoteUser() throws Throwable  {
      // Given: Set up the AccessEvent object with a remote user
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRemoteUser("user123");
      
      // When: Calling the hashCode() method on the AccessEvent object
      int actualHashCode = accessEvent.hashCode();
      
      // Then: The hashCode() method should return a valid integer value
      assertNotEquals(0, actualHashCode);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashCodeAndSetRequestURL() throws Throwable  {
      // Set up a new AccessEvent object to represent a login request
      AccessEvent accessEvent = new AccessEvent();
      
      // Set the URL of the requested resource to "/login"
      accessEvent.setRequestURL("/login");
      
      // Calculate the hashCode for the access event
      int hashCode = accessEvent.hashCode();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashCodeAndSetRequestURI() throws Throwable  {
      // Create an instance of AccessEvent with a request URI
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRequestURI("https://www.example.com/path/to/resource?query=true");
      
      // Compute the hash code using the hashCode() method
      int actualHashCode = accessEvent.hashCode();
      
      // Compare the result with a hard-coded expected value
      assertEquals(12345, actualHashCode);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetLoggerContext() throws Throwable  {
      // Given
      AccessEvent accessEvent = new AccessEvent();
      LoggerContext arg0 = new LoggerContext();
      
      // When
      accessEvent.setLoggerContext(arg0);
      
      // Then
      assertEquals(arg0, accessEvent.getLoggerContext());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetTimeStamp() throws Throwable  {
      // Given
      AccessEvent accessEvent = new AccessEvent();
      Long arg0 = new Long(0L);
      
      // When
      accessEvent.setTimeStamp(arg0);
      
      // Then
      assertEquals(arg0, accessEvent.getTimeStamp());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetServerName0() throws Throwable  {
      // Given two objects of the same class with different values
      AccessEvent arg0 = new AccessEvent();
      arg0.setServerName(",dxK#WYHu8_pR`M");
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setServerName("some-other-value");
      
      // When we call the equals method on one of these objects with the other as an argument
      boolean equals = accessEvent.equals(arg0);
      
      // Then we expect the result to be false
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetServerNameAndEqualsReturningTrue() throws Throwable  {
      // Given two AccessEvents with the same server name
      AccessEvent arg0 = new AccessEvent();
      arg0.setServerName("AccessEvent[");
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setServerName("AccessEvent[");
      
      // When we call the equals method with one of them as an argument
      boolean actualEquals = accessEvent.equals(arg0);
      
      // Then the result should be true, since both AccessEvents have the same server name
      assertTrue(actualEquals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetServerName1() throws Throwable  {
      // Given: a AccessEvent object with a specific serverName value
      String serverName = "+$v`}%jBz-";
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setServerName(serverName);
      
      // When: the equals method is called on this object with an argument that has the same serverName as this object
      AccessEvent arg0 = new AccessEvent();
      arg0.setServerName(serverName);
      boolean equals = accessEvent.equals(arg0);
      
      // Then: it returns false, since these two objects are not equal even though they have the same serverName value
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRequestURL0() throws Throwable  {
      // Given a new instance of AccessEvent with requestURL "de.huxhorn.lilith.data.access.LoggerContext"
      AccessEvent arg0 = new AccessEvent();
      arg0.setRequestURL("de.huxhorn.lilith.data.access.LoggerContext");
      
      // And a new instance of AccessEvent with the same requestURL
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRequestURL("de.huxhorn.lilith.data.access.LoggerContext");
      
      // When we call equals() method on arg0 and accessEvent
      boolean equals = arg0.equals(accessEvent);
      
      // Then the result should be true, as both instances have the same requestURL
      assertTrue(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRequestURLAndEqualsReturningTrue() throws Throwable  {
      // Given: The AccessEvent class is created with a specific request URL
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRequestURL("de.huxhorn.lilith.data.access.LoggerContext");
      
      // When: A new instance of the AccessEvent class is created with the same request URL as the first one
      AccessEvent arg0 = new AccessEvent();
      arg0.setRequestURL("de.huxhorn.lilith.data.access.LoggerContext");
      
      // Then: The two instances should be equal, because they have the same request URL
      assertTrue(accessEvent.equals(arg0));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRequestURL1() throws Throwable  {
      // Arrange
      AccessEvent event1 = new AccessEvent();
      event1.setRequestURL("de.huxhorn.lilith.data.access.LoggerContext");
      AccessEvent event2 = new AccessEvent();
      event2.setRequestURL("de.huxhorn.lilith.data.access.LoggerConfig");
      
      // Act
      boolean areEqual = event1.equals(event2);
      
      // Assert
      assertFalse(areEqual);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRequestURI0() throws Throwable  {
      // rollbacked to evosuite
      AccessEvent arg0 = new AccessEvent();
      arg0.setRequestURI("f");
      AccessEvent accessEvent = new AccessEvent();
      boolean equals = accessEvent.equals(arg0);
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRequestURIAndEqualsReturningTrue() throws Throwable  {
      // Given: We have two AccessEvents, one with a request URI of "f" and another with the same request URI.
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRequestURI("f");
      AccessEvent arg0 = new AccessEvent();
      arg0.setRequestURI("f");
      
      // When: We compare these two events using the equals method.
      boolean equals = accessEvent.equals(arg0);
      
      // Then: The equality check should pass, as both events have the same request URI.
      assertTrue(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRequestURI1() throws Throwable  {
      // Given
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRequestURI("f");
      
      // When
      boolean equals = accessEvent.equals(new AccessEvent());
      
      // Then
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRemoteUser0() throws Throwable  {
      // Create a new instance of AccessEvent
      AccessEvent arg0 = new AccessEvent();
      
      // Set the remote user for the first access event to "E"
      arg0.setRemoteUser("E");
      
      // Create another instance of AccessEvent
      AccessEvent accessEvent = new AccessEvent();
      
      // Compare the two instances using the equals method
      boolean equals = accessEvent.equals(arg0);
      
      // Assert that the result is false, as we expect them to be different
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRemoteUserAndEqualsReturningTrue() throws Throwable  {
      // Test that the equals method works correctly for two AccessEvents with different remote users
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRemoteUser("K");
      AccessEvent arg0 = new AccessEvent();
      arg0.setRemoteUser("K");
      assertFalse(arg0.equals((Object)accessEvent)); // assert that the two events are not equal (i.e., they have different remote users)
      
      // Test that the equals method works correctly for two AccessEvents with the same remote user
      AccessEvent arg1 = new AccessEvent();
      arg1.setRemoteUser("K");
      assertTrue(accessEvent.equals(arg1)); // assert that the two events are equal (i.e., they have the same remote user)
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRemoteUser1() throws Throwable  {
      // Given
      AccessEvent accessEvent1 = new AccessEvent();
      accessEvent1.setRemoteUser("John");
      AccessEvent accessEvent2 = new AccessEvent();
      accessEvent2.setRemoteUser("Jane");
      
      // When
      boolean areEqual = accessEvent1.equals(accessEvent2);
      
      // Then
      assertFalse(areEqual);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRemoteHost0() throws Throwable  {
      // Create two equal objects with different remote hosts
      AccessEvent accessEvent = new AccessEvent();
      AccessEvent arg0 = new AccessEvent();
      assertTrue(arg0.equals((Object)accessEvent));
      
      // Set the remote host of one object to a different value and verify that it is not equal
      arg0.setRemoteHost(",dxK#WYHu8_pR`M");
      boolean equals = accessEvent.equals(arg0);
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRemoteHostAndEqualsReturningTrue() throws Throwable  {
      // Given a new AccessEvent instance with a remote host
      AccessEvent arg0 = new AccessEvent();
      arg0.setRemoteHost("eJYN88yb|;0+C>lE8V`");
      
      // When we create another AccessEvent instance with the same remote host
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRemoteHost("eJYN88yb|;0+C>lE8V`");
      
      // Then both instances should be equal to each other
      assertTrue(accessEvent.equals(arg0));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRemoteHost1() throws Throwable  {
      // Given
      AccessEvent firstEvent = new AccessEvent();
      AccessEvent secondEvent = new AccessEvent();
      
      // When
      firstEvent.setRemoteHost("eJYN88yb|;0+C>lE8V`");
      boolean result = firstEvent.equals(secondEvent);
      
      // Then
      assertFalse(result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRemoteAddress0() throws Throwable  {
      // Given: Two instances of AccessEvent with different remote addresses
      AccessEvent arg0 = new AccessEvent();
      arg0.setRemoteAddress("K");
      AccessEvent accessEvent = new AccessEvent();
      
      // When: We compare the two instances using equals method
      boolean equals = accessEvent.equals(arg0);
      
      // Then: The result is false, as the remote addresses are different
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRemoteAddressAndEqualsReturningTrue() throws Throwable  {
      // Given two instances of AccessEvent, arg0 and accessEvent
      AccessEvent arg0 = new AccessEvent();
      AccessEvent accessEvent = new AccessEvent();
      
      // When setting the same remote address on both instances
      arg0.setRemoteAddress("~LoggerContextname=");
      accessEvent.setRemoteAddress("~LoggerContextname=");
      
      // Then both instances should be equal to each other
      assertTrue(arg0.equals(accessEvent));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetRemoteAddress1() throws Throwable  {
      // Given: two AccessEvents with different values
      AccessEvent arg0 = new AccessEvent();
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRemoteAddress("~LoggerContextname=");
      
      // When: we compare the two AccessEvents using the equals method
      boolean equals = accessEvent.equals(arg0);
      
      // Then: they should not be equal
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetProtocol0() throws Throwable  {
      // Given: Two instances of the same class with different data
      AccessEvent arg0 = new AccessEvent();
      arg0.setProtocol("v3dV_:v");
      AccessEvent accessEvent = new AccessEvent();
      
      // When: Checking if they are equal
      boolean equals = accessEvent.equals(arg0);
      
      // Then: They should not be equal as the data is different
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetProtocolAndEqualsReturningTrue() throws Throwable  {
      // Given: two AccessEvent objects with the same protocol value but different references
      AccessEvent arg0 = new AccessEvent();
      arg0.setProtocol("\"HaCg=GO&g^mn");
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setProtocol("\"HaCg=GO&g^mn");
      
      // When: the first object is compared with itself
      boolean equalsSelf = arg0.equals(arg0);
      
      // Then: the comparison result should be true
      assertTrue(equalsSelf);
      
      // Given: two AccessEvent objects with different protocol values
      AccessEvent arg1 = new AccessEvent();
      arg1.setProtocol("\"HaCg=GO&g^mn");
      AccessEvent accessEvent2 = new AccessEvent();
      accessEvent2.setProtocol("\"HaCg=GO&g^mX");
      
      // When: the first object is compared with the second one
      boolean equalsDifferent = arg0.equals(arg1);
      
      // Then: the comparison result should be false
      assertFalse(equalsDifferent);
      
      // Given: an AccessEvent object and an arbitrary object of a different type
      AccessEvent arg2 = new AccessEvent();
      Object obj = new Object();
      
      // When: the first object is compared with the second one
      boolean equalsOtherType = arg0.equals(obj);
      
      // Then: the comparison result should be false, since the other object is not an instance of AccessEvent
      assertFalse(equalsOtherType);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetProtocol1() throws Throwable  {
      // Given: We have two objects of the same type with different values for the protocol field
      AccessEvent accessEvent1 = new AccessEvent();
      accessEvent1.setProtocol("\"HTTPS\"");
      AccessEvent accessEvent2 = new AccessEvent();
      accessEvent2.setProtocol("\"HTTP\"");
      
      // When: We call the equals method on both objects
      boolean equal1 = accessEvent1.equals(accessEvent2);
      boolean equal2 = accessEvent2.equals(accessEvent1);
      
      // Then: The two objects should not be considered equal, as they have different values for the protocol field
      assertFalse(equal1);
      assertFalse(equal2);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetMethod0() throws Throwable  {
      // Given a new AccessEvent object, create a new instance and set its method to "]"
      AccessEvent accessEvent = new AccessEvent();
      AccessEvent arg0 = new AccessEvent();
      arg0.setMethod("]");
      
      // When the equals method is called on both instances with (Object)accessEvent as argument
      boolean equals1 = accessEvent.equals((Object)arg0);
      boolean equals2 = arg0.equals((Object)accessEvent);
      
      // Then the result of the first call to equals should be true, and the second call should return false
      assertTrue(equals1);
      assertFalse(equals2);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetMethodAndEqualsReturningTrue() throws Throwable  {
      // Given: Two AccessEvents with different values for "method" field
      AccessEvent event1 = new AccessEvent();
      event1.setMethod("Qk");
      AccessEvent event2 = new AccessEvent();
      event2.setMethod("Qk");
      
      // When: The two events are compared using the "equals()" method
      boolean equals = event1.equals(event2);
      
      // Then: Both events should be considered equal, as they have the same value for "method" field
      assertTrue(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsAndSetMethod1() throws Throwable  {
      // Given: two different objects of the same type
      AccessEvent accessEvent1 = new AccessEvent();
      accessEvent1.setMethod("Qk");
      AccessEvent accessEvent2 = new AccessEvent();
      accessEvent2.setMethod("Qk");
      
      // When: checking if they are equal using the equals method
      boolean actual = accessEvent1.equals(accessEvent2);
      
      // Then: they should be considered not equal
      assertFalse(actual);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetStatusCode() throws Throwable  {
      // Given two AccessEvent objects with different status codes
      AccessEvent accessEvent = new AccessEvent();
      AccessEvent arg0 = new AccessEvent();
      accessEvent.setStatusCode(401);
      arg0.setStatusCode(402);
      
      // When the equals method is called on both objects
      boolean equals = accessEvent.equals(arg0);
      
      // Then the result should be false, as the status codes are different
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetLocalPort() throws Throwable  {
      // Create an instance of AccessEvent
      AccessEvent accessEvent = new AccessEvent();
      
      // Set the local port for the access event
      accessEvent.setLocalPort(8080);
      
      // Create a second instance of AccessEvent to compare with
      AccessEvent arg0 = new AccessEvent();
      
      // Check if the two instances are equal (using the equals method)
      boolean isEqual = accessEvent.equals(arg0);
      
      // Assert that the local port is 8080 for both instances
      assertEquals(8080, accessEvent.getLocalPort());
      
      // Assert that the two instances are not equal (using the ! operator)
      assertFalse(isEqual);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsWithNonNull() throws Throwable  {
      // Given
      AccessEvent accessEvent = new AccessEvent();
      String[] arg0 = Locale.getISOLanguages();
      
      // When
      boolean equals = accessEvent.equals(arg0);
      
      // Then
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsWithNull() throws Throwable  {
      // Given: An object of type AccessEvent is created and stored in the variable "accessEvent".
      AccessEvent accessEvent = new AccessEvent();
      
      // When: The method "equals" is called on the object with a null argument.
      boolean equals = accessEvent.equals((Object) null);
      
      // Then: The result of the method should be false, since an object cannot equal null.
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEquals() throws Throwable  {
      // Given an AccessEvent object, arg0
      AccessEvent arg0 = new AccessEvent();
      
      // When we call equals on arg0 with itself as argument
      boolean equals = arg0.equals(arg0);
      
      // Then the result should be true
      assertTrue(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMethodReturningNonEmptyString() throws Throwable  {
      // Given a new instance of AccessEvent with the method "GET"
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setMethod("GET");
      
      // When we call getMethod on the event
      String method = accessEvent.getMethod();
      
      // Then the method returned should be "GET"
      assertEquals("GET", method);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashCodeAndSetRemoteAddress() throws Throwable  {
      // Given: A new AccessEvent object with a remote address of "192.168.0.1"
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRemoteAddress("192.168.0.1");
      
      // When: The hashCode() method is called on the object
      int hashCode = accessEvent.hashCode();
      
      // Then: The hash code should be non-zero and consistent
      assertTrue(hashCode != 0);
      assertEquals(accessEvent.hashCode(), accessEvent.hashCode());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRequestURIReturningNull() throws Throwable  {
      // Given a new access event with no request URI set
      AccessEvent accessEvent = new AccessEvent();
      
      // When we call getRequestURI on the access event object
      String requestURI = accessEvent.getRequestURI();
      
      // Then the request URI should be null, as it has not been set yet
      assertNull(requestURI);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMethodReturningNull() throws Throwable  {
      // Given: A new instance of AccessEvent
      AccessEvent accessEvent = new AccessEvent();
      
      // When: Getting the method from the event
      String method = accessEvent.getMethod();
      
      // Then: The method should be null
      assertNull(method);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetTimeStampReturningNull() throws Throwable  {
      // Given: a new AccessEvent instance is created
      AccessEvent accessEvent = new AccessEvent();
      
      // When: the time stamp is retrieved
      Long timeStamp = accessEvent.getTimeStamp();
      
      // Then: the time stamp should be null
      assertNull(timeStamp);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRemoteAddressReturningNull() throws Throwable  {
      // Given: A new instance of AccessEvent with a null remote address
      AccessEvent accessEvent = new AccessEvent();
      
      // When: The getRemoteAddress method is called
      String remoteAddress = accessEvent.getRemoteAddress();
      
      // Then: The returned value should be null
      assertNull(remoteAddress);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetServerNameReturningNonEmptyString() throws Throwable  {
      // Given a new AccessEvent object with a specific server name
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setServerName("Production Server 1");
      
      // When the server name is retrieved from the event
      String serverName = accessEvent.getServerName();
      
      // Then the expected server name should be returned
      assertEquals("Production Server 1", serverName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRemoteUserReturningNonEmptyString() throws Throwable  {
      // Given a new AccessEvent object with a remote user set to "johndoe"
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRemoteUser("johndoe");
      
      // When the getRemoteUser method is called on the AccessEvent object
      String remoteUser = accessEvent.getRemoteUser();
      
      // Then the returned value should be "johndoe"
      assertEquals("johndoe", remoteUser);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLoggerContextReturningNull() throws Throwable  {
      // Given
      AccessEvent accessEvent = new AccessEvent();
      
      // When
      LoggerContext loggerContext = accessEvent.getLoggerContext();
      
      // Then
      assertNull(loggerContext);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetResponseHeadersReturningNull() throws Throwable  {
      // Arrange
      AccessEvent accessEvent = new AccessEvent();
      
      // Act
      Map<String, String> responseHeaders = accessEvent.getResponseHeaders();
      
      // Assert
      assertNull(responseHeaders);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetStatusCodeReturningZero() throws Throwable  {
      // Given: a valid input (accessEvent) and a expected output (0)
      AccessEvent accessEvent = new AccessEvent();
      int expectedStatusCode = 0;
      
      // When: the getStatusCode method is called on the accessEvent object
      int actualStatusCode = accessEvent.getStatusCode();
      
      // Then: the actual status code should be equal to the expected status code
      assertEquals(expectedStatusCode, actualStatusCode);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetProtocolReturningNonEmptyString() throws Throwable  {
      // Given: An AccessEvent object has been created
      AccessEvent accessEvent = new AccessEvent();
      
      // When: The protocol field of the AccessEvent object is set to "https"
      accessEvent.setProtocol("https");
      
      // Then: The getProtocol method should return the expected value
      String expectedProtocol = "https";
      assertEquals(expectedProtocol, accessEvent.getProtocol());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRemoteHostReturningNull() throws Throwable  {
      // Create a new instance of AccessEvent
      AccessEvent accessEvent = new AccessEvent();
      
      // Check if the remote host is null
      assertNull(accessEvent.getRemoteHost());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRequestURLReturningNull() throws Throwable  {
      // Given the access event has been created
      AccessEvent accessEvent = new AccessEvent();
      
      // When the request URL is retrieved from the access event
      String requestURL = accessEvent.getRequestURL();
      
      // Then the request URL should be null
      assertNull(requestURL);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRequestHeadersReturningNull() throws Throwable  {
      // Given: A new instance of AccessEvent with no request headers
      AccessEvent accessEvent = new AccessEvent();
      
      // When: The method to get the request headers is called
      Map<String, String> requestHeaders = accessEvent.getRequestHeaders();
      
      // Then: The returned value should be null
      assertNull(requestHeaders);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRequestHeadersReturningMapWhereIsEmptyIsTrue() throws Throwable  {
      // Given: The AccessEvent object is created with a new HashMap as the request headers.
      AccessEvent accessEvent = new AccessEvent();
      HashMap<String, String> requestHeaders = new HashMap<>();
      accessEvent.setRequestHeaders(requestHeaders);
      
      // When: The getRequestHeaders method is called on the AccessEvent object.
      Map<String, String> retrievedHeaders = accessEvent.getRequestHeaders();
      
      // Then: The returned Map should be empty.
      assertEquals(0, retrievedHeaders.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetProtocolReturningNull() throws Throwable  {
      // Given a newly created AccessEvent object with no protocol specified
      AccessEvent accessEvent = new AccessEvent();
      
      // When the getProtocol method is called on the event
      String protocol = accessEvent.getProtocol();
      
      // Then the returned value should be null, as no protocol has been set
      assertNull(protocol);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLocalPortReturningPositive() throws Throwable  {
      // Given a new AccessEvent object
      AccessEvent accessEvent = new AccessEvent();
      
      // When the local port is set to 5001
      accessEvent.setLocalPort(5001);
      
      // Then the local port should be equal to 5001
      int expectedLocalPort = 5001;
      int actualLocalPort = accessEvent.getLocalPort();
      assertEquals(expectedLocalPort, actualLocalPort);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetServerNameReturningNull() throws Throwable  {
      // Given: A new AccessEvent object is created
      AccessEvent accessEvent = new AccessEvent();
      
      // When: The getServerName method is called on the object
      String serverName = accessEvent.getServerName();
      
      // Then: The return value should be null
      assertNull(serverName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRequestParametersReturningMapWhereIsEmptyIsTrue() throws Throwable  {
      // Given: A new AccessEvent instance
      AccessEvent accessEvent = new AccessEvent();
      
      // When: Setting an empty map of request parameters
      HashMap<String, String[]> arg0 = new HashMap<String, String[]>();
      accessEvent.setRequestParameters(arg0);
      
      // Then: The resulting map should be empty
      Map<String, String[]> requestParameters = accessEvent.getRequestParameters();
      assertEquals(0, requestParameters.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetLocalPortReturningZero() throws Throwable  {
      // Given: A new AccessEvent object is created
      AccessEvent accessEvent = new AccessEvent();
      
      // When: The getLocalPort method is called on the object
      int localPort = accessEvent.getLocalPort();
      
      // Then: The value returned should be 0
      assertEquals(0, localPort);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRequestParametersReturningNull() throws Throwable  {
      // Given: A new instance of AccessEvent is created
      AccessEvent accessEvent = new AccessEvent();
      
      // When: The request parameters are retrieved from the event
      Map<String, String[]> requestParameters = accessEvent.getRequestParameters();
      
      // Then: The request parameters should be null
      assertNull(requestParameters);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashCodeAndSetRemoteHost() throws Throwable  {
      // rollbacked to evosuite
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setRemoteHost("192.168.0.1");
      accessEvent.hashCode();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToString() throws Throwable  {
      // This test verifies that the toString method of the AccessEvent class returns a correct string representation of the event.
      AccessEvent accessEvent = new AccessEvent();
      String expectedString = "AccessEvent[loggerContext=null, timeStamp=null]";
      String actualString = accessEvent.toString();
      assertEquals(expectedString, actualString);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetRemoteUserReturningNull() throws Throwable  {
      // Given a null AccessEvent object
      AccessEvent accessEvent = null;
      
      // When getRemoteUser is called with a null AccessEvent
      String remoteUser = accessEvent.getRemoteUser();
      
      // Then the method should return null
      assertNull(remoteUser);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetStatusCodeReturningPositive() throws Throwable  {
      // Given: an instance of AccessEvent is created and its status code is set to 403
      AccessEvent accessEvent = new AccessEvent();
      accessEvent.setStatusCode(403);
      
      // When: the status code of the AccessEvent is retrieved
      int statusCode = accessEvent.getStatusCode();
      
      // Then: the retrieved status code should be equal to 403
      assertEquals(403, statusCode);
  }
}
