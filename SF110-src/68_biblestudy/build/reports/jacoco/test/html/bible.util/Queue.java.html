<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Queue.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">68_biblestudy</a> &gt; <a href="index.source.html" class="el_package">bible.util</a> &gt; <span class="el_source">Queue.java</span></div><h1>Queue.java</h1><pre class="source lang-java linenums">package bible.util;

import java.util.*;

/**
 * Queue is a storage class to link together &lt;b&gt;Node&lt;/b&gt; objects which are
 * stored in a first in first out storage system. 
 *
 * @see Node
 * @version   1.0
 * @author    LaMoine Zielieke, James Stauffer
 */
public class Queue  {
  public final static int NO_MAXIMUM = -1;
  /**
   * number of items in this list
   */
  private int  numItems;
  private int  maxNumItems;
  private int  maxCapacity;
  /**
   * first Node in list
   */
  private Node first;
  /**
   * last Node in list
   */
  private Node last;

  /**
   * Constructor creating an empty Queue.  All variables are set to zero
   * or null.
   */
  public Queue() {
<span class="fc" id="L35">    this(NO_MAXIMUM);</span>
<span class="fc" id="L36">  }</span>

  /**
   * Constructor creating an empty Queue.  All variables are set to zero
   * or null.
   */
<span class="fc" id="L42">  public Queue(int capacity) {</span>
<span class="fc" id="L43">    first = null;</span>
<span class="fc" id="L44">    last = null;</span>
<span class="fc" id="L45">    numItems = 0;</span>
<span class="fc" id="L46">    maxNumItems = 0;</span>
<span class="fc" id="L47">    maxCapacity = capacity;</span>
<span class="fc" id="L48">  }</span>

  /**
   * See if the queue is empty.
   * @return     &lt;code&gt;true&lt;/code&gt; if Queue is empty;
   *             &lt;code&gt;false&lt;/code&gt; otherwise.         
   */
  public boolean isEmpty() {
<span class="fc bfc" id="L56" title="All 2 branches covered.">    return (first == null);</span>
  }

  /**
   * Insert an object into the end of the queue
   * 
   * @param someObject  the Object to store 
   */
  public void enqueue(Object someObject) {
<span class="fc bfc" id="L65" title="All 2 branches covered.">    if(someObject != null) {</span>
<span class="fc" id="L66">      Node newNode = new Node(someObject);</span>

<span class="fc" id="L68">      synchronized(this) {</span>
//System.out.println(&quot;+++&quot; + someObject);

<span class="fc bfc" id="L71" title="All 2 branches covered.">          if(isEmpty())   {</span>
<span class="fc" id="L72">             first = newNode;</span>
<span class="fc" id="L73">             last = newNode;</span>
          } else {//Add at end
<span class="fc" id="L75">            last.next = newNode;</span>
<span class="fc" id="L76">            last = newNode;</span>
          }
<span class="fc" id="L78">          numItems++;</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">          if(numItems &gt; maxNumItems) {</span>
<span class="fc" id="L80">            maxNumItems = numItems;</span>
          }
<span class="fc" id="L82">      }</span>
    }
<span class="fc" id="L84">  }</span>

  /**
   * Remove an object from the front of the Queue
   *
   * @return       Object if Queue is not empty
   *               otherwise print message to dos window
   * @see GameQuestion
   */
  public synchronized Object dequeue() {
<span class="fc" id="L94">    Object obj = null;</span>

<span class="fc bfc" id="L96" title="All 2 branches covered.">    if(isEmpty()) {</span>
<span class="fc" id="L97">      System.out.println(&quot;Cannot remove when queue is empty&quot;);</span>

<span class="fc bfc" id="L99" title="All 2 branches covered.">    } else if(first == last) { // first see if we only have one item in the queue</span>
<span class="fc" id="L100">      obj = first.value;</span>
<span class="fc" id="L101">      first = null;</span>
<span class="fc" id="L102">      last = null;</span>
    } else {
<span class="fc" id="L104">      obj = first.value;</span>
<span class="fc" id="L105">      first = first.next;</span>
    }
<span class="fc" id="L107">    numItems--;</span>
<span class="fc" id="L108">    return obj;</span>
  }

  /**
   *  Removes all nodes where Node.value.equals(object).
   */
  public synchronized int remove(Object object) {
//System.out.println(&quot;---&quot; + object);
<span class="fc" id="L116">    int originalNumItems = numItems;</span>
<span class="pc bpc" id="L117" title="1 of 4 branches missed.">    while((first != null) &amp;&amp; (first.value.equals(object))) {// found it</span>
<span class="fc" id="L118">      first = first.next;</span>
<span class="fc" id="L119">      numItems--;</span>
    }

<span class="pc bpc" id="L122" title="1 of 2 branches missed.">    if(first == null) {//All elements removed</span>
<span class="fc" id="L123">      last = null;</span>
    } else {
      //Now it isn't in the first node
<span class="nc bnc" id="L126" title="All 2 branches missed.">      for(Node current = first; current.next != null; ) {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if(current.next.value.equals(object)) {// found it in the next Node</span>
<span class="nc" id="L128">          current.next = current.next.next;</span>
<span class="nc" id="L129">          numItems--;</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">          if(current.next == null) {// we are removing the last element</span>
<span class="nc" id="L131">            last = current;</span>
            // the for loop will be exited
          }
        } else {
<span class="nc" id="L135">          current = current.next;</span>
        }
      }// of for
    }

<span class="fc" id="L140">    return originalNumItems - numItems;</span>
  }

  /**
   *  Moves element to back of que.
   */
  public synchronized void refreshElement(Object object) {
<span class="fc" id="L147">      remove(object);</span>
<span class="fc" id="L148">      enqueue(object);</span>
<span class="fc" id="L149">  }</span>

  /**
   * See how many items are in the queue.
   *
   * @return integer value of number of items in queue 
   */
  public int getNumberItems() {
<span class="fc" id="L157">    return numItems;</span>
  }

  /**
   * The peak number of items in the Queue.
   *
   * @return peak number of items in queue 
   */
  public int getPeakNumberItems() {
<span class="fc" id="L166">    return maxNumItems;</span>
  }

  /**
   * The Queue is stepped through one node at a time and the 
   * QuestionNumber is inserted into a Vector.This action copies
   * unused question numbers from queue into temp vector.
   * 
   * @return   Vector of unused question numbers. In this way when 
   *           a new vector of randomized numbers is created the nunbers
   *           already in the queue will not be duplicated.  If number 
   *           396 is in the queue we do not want 396 to appear in the 
   *           new randomized vector.  This method is only called in 
   *           &lt;b&gt;DataBase&lt;/b&gt;
   * @see      Database#load
   * @see      GameQuestion
   */
  public Vector getObjects() {
    Node i;
<span class="fc" id="L185">    Vector tempVector = new Vector(numItems,10);</span>
     
<span class="fc bfc" id="L187" title="All 2 branches covered.">    for(i = first; i != null; i = i.next) {</span>
<span class="fc" id="L188">      tempVector.addElement(i.value);</span>
    } // end for
<span class="fc" id="L190">    return tempVector;</span>
  } // end getUnused

  /**
   *  Returns true if the first should be removed.
   */
  public boolean maxCapacityExceeded() {
<span class="fc bfc" id="L197" title="All 4 branches covered.">      return (numItems &gt; (maxCapacity - 1)) &amp;&amp; (maxCapacity != NO_MAXIMUM);</span>
  }

  public String toString() {
<span class="fc" id="L201">    return getClass().getName() + &quot;:[numItems=&quot; + numItems</span>
        + &quot;, maxNumItems=&quot; + maxNumItems
        + &quot;, maxCapacity=&quot; + maxCapacity
<span class="fc" id="L204">        + &quot;, getObjects()=&quot; + getObjects()</span>
        + &quot;\r\n]&quot;;
  }

  /**
   * Node objects hold the Object to be stored and the next node in our linked list. 
   * In this way we can access the next node in our &lt;b&gt;Queue&lt;/b&gt;.
   *
   * @version   2.0
   * @author    LaMoine Zielieke
   */
  class Node {   
    /**
     * The next Node in the chain.
     */
    Node  next;
    /**
     * The Object this node stores.
     */
    Object value;
      
    /** 
     * @param  obj   the Object to be inserted into the node. 
     */
<span class="fc" id="L228">    public Node(Object obj) {</span>
<span class="fc" id="L229">      value = obj;</span>
<span class="fc" id="L230">    }</span>
  }

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>