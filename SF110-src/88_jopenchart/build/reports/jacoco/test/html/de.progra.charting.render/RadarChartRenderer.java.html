<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RadarChartRenderer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">88_jopenchart</a> &gt; <a href="index.source.html" class="el_package">de.progra.charting.render</a> &gt; <span class="el_source">RadarChartRenderer.java</span></div><h1>RadarChartRenderer.java</h1><pre class="source lang-java linenums">/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian Mï¿½ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    PieChartRenderer.java
    Created on 7. August 2001, 18:14
*/

package de.progra.charting.render;

import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Arc2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;

import de.progra.charting.CoordSystem;
import java.awt.geom.AffineTransform;
import de.progra.charting.PointToPixelTranslator;

import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.RenderingHints;
import java.awt.Color;
import de.progra.charting.model.ChartDataModel;

/**
 * This renderer creates a PieChart.
 * @author  tbee
 * @version 1.0
 */
public class RadarChartRenderer extends AbstractChartRenderer {
        
    /** Creates new PieChartRenderer
     * @param model the DataModel that should be rendered
     */
    public RadarChartRenderer(ChartDataModel model) {
<span class="nc" id="L55">        super(model);</span>
<span class="nc" id="L56">    }</span>
    
    /** Creates new PieChartRenderer
     * @param cs the CoordSystem used to translate values into points
     * @param model the DataModel that should be rendered
     */
    public RadarChartRenderer(CoordSystem cs, ChartDataModel model) {
<span class="nc" id="L63">        super(cs, model);</span>
<span class="nc" id="L64">    }</span>

    /** Finally renders the Object in the Graphics object.
     * @param g the Graphics2D object in which to render
     */
    public void renderChart(Graphics2D g) {
    	// remember current anti aliasing rendering hint 
    	// then activate it
<span class="nc" id="L72">        Object rh = g.getRenderingHint(RenderingHints.KEY_ANTIALIASING);</span>
<span class="nc" id="L73">        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>
        
        // get the models
<span class="nc" id="L76">        ChartDataModel m = getChartDataModel();</span>
<span class="nc" id="L77">        RowColorModel rcm = getRowColorModel();</span>

		// get the available drawing space        
<span class="nc" id="L80">        double height = this.getBounds().getHeight();</span>
<span class="nc" id="L81">        double width = this.getBounds().getWidth();</span>

		// the number of dataset
<span class="nc" id="L84">        int lNumberOfRows = m.getDataSetNumber();</span>
        
        // determine shortest dataset length, this is the number of axis that we need to draw
<span class="nc" id="L87">        int lNumberOfColumns = Integer.MAX_VALUE;        </span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">        for(int i = 0; i &lt; lNumberOfRows; i++) </span>
<span class="nc" id="L89">            lNumberOfColumns = Math.min(lNumberOfColumns, m.getDataSetLength(i));</span>
        
<span class="nc" id="L91">        double[] maxvalues = new double[lNumberOfColumns];</span>
        
        // get center
<span class="nc" id="L94">        double center_y = getBounds().getCenterY();</span>
<span class="nc" id="L95">        double center_x = getBounds().getCenterX();</span>

		// determine the radius
<span class="nc" id="L98">        double lRadius = Math.min(width * 0.9, height * 0.9) / 2;</span>

		// scan through the datasets
<span class="nc bnc" id="L101" title="All 2 branches missed.">        for(int lRow = 0; lRow &lt; lNumberOfRows; lRow++) </span>
        {
			// scan through the values in the dataset
<span class="nc" id="L104">			GeneralPath filledPolygon = new GeneralPath(GeneralPath.WIND_EVEN_ODD, lNumberOfColumns);</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">			for (int lCol = 0; lCol &lt; lNumberOfColumns; lCol++)</span>
			{
				// get the value
<span class="nc" id="L108">                double lValue = m.getValueAt(lRow, lCol).doubleValue();</span>
				
        		// determine the scale 
<span class="nc" id="L111">        		double lMaxValue = maxvalues[lCol];</span>
                
<span class="nc bnc" id="L113" title="All 2 branches missed.">                if(lMaxValue == 0.0) {</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">                    for(int row = 0; row &lt; lNumberOfRows; row++)</span>
<span class="nc" id="L115">                        lMaxValue = Math.max(lMaxValue, m.getValueAt(row, lCol).doubleValue() * 1.1);</span>
                    
<span class="nc" id="L117">                    maxvalues[lCol] = lMaxValue;</span>
                }
                
<span class="nc" id="L120">        		double lScaledValue = lValue / lMaxValue;</span>
<span class="nc" id="L121">        		double lLineValue = lRadius * lScaledValue;</span>

				// determine rotation: there are 2PI/noOfCols vertexes, this is vertex no lCol		
				// -1 : we want to rotate clockwise
				// + PI: rotate 180 degree to get the first column pointing up
<span class="nc" id="L126">				double lRotation = (-1 * (2 * Math.PI / lNumberOfColumns) * lCol) + Math.PI;</span>

				// determine the end points
<span class="nc" id="L129">				double lX = center_x + (lLineValue * Math.sin(lRotation));</span>
<span class="nc" id="L130">				double lY = center_y + (lLineValue * Math.cos(lRotation));</span>

				// draw the line
<span class="nc" id="L133">				Line2D lLine = new Line2D.Double(center_x, center_y, lX, lY);</span>
<span class="nc" id="L134">		        g.setColor(Color.black);</span>
<span class="nc" id="L135">		        g.draw(lLine);</span>

				// add to polygone
<span class="nc bnc" id="L138" title="All 2 branches missed.">				if (lCol == 0) filledPolygon.moveTo((float)lX, (float)lY);</span>
<span class="nc" id="L139">				else filledPolygon.lineTo((float)lX, (float)lY);		        </span>
			}
			
			// draw the polygone
<span class="nc" id="L143">			filledPolygon.closePath();</span>
<span class="nc" id="L144">			g.setPaint( rcm.getColor(lRow) );</span>
<span class="nc" id="L145">			g.draw(filledPolygon);</span>
        }
        
        double lRotation;
        double lX;
        double lY;
        TextLayout lLabel;

		// draw the lines
<span class="nc bnc" id="L154" title="All 2 branches missed.">		for (int lCol = 0; lCol &lt; lNumberOfColumns; lCol++)</span>
		{
			// determine rotation: there are 2PI/noOfCols vertexes, this is vertex no lCol		
			// -1 : we want to rotate clockwise
			// + PI: rotate 180 degree to get the first column pointing up
            // Math.PI ... - Math.PI
<span class="nc" id="L160">			lRotation = (-1 * (2 * Math.PI / lNumberOfColumns) * lCol) + Math.PI;</span>

			// determine the end points
<span class="nc" id="L163">			lX = center_x + (lRadius * Math.sin(lRotation));</span>
<span class="nc" id="L164">			lY = center_y + (lRadius * Math.cos(lRotation));</span>

			// draw the line
<span class="nc" id="L167">			Line2D lLine = new Line2D.Double(center_x, center_y, lX, lY );</span>
<span class="nc" id="L168">	        g.setColor(Color.black);</span>
<span class="nc" id="L169">	        g.draw(lLine);</span>

	        // draw the label 
<span class="nc" id="L172">	        lLabel = new TextLayout(&quot;&quot; + model.getColumnValueAt(lCol), new Font(&quot;Courier&quot;, Font.BOLD, 9), new FontRenderContext(null, true, false));</span>
<span class="nc" id="L173">	        g.setColor(Color.black);</span>
            
            // Move the labels in the lower half circle down a bit, so the upper left corner touches the axis
<span class="nc bnc" id="L176" title="All 4 branches missed.">            if ((lRotation &lt;= Math.PI / 2) &amp;&amp; (lRotation &gt;= -Math.PI / 2))</span>
<span class="nc" id="L177">                lY += lLabel.getBounds().getHeight();</span>
            
            // Move the labels in the left half circle a bit left, so the upper right corner touches the axis
<span class="nc bnc" id="L180" title="All 2 branches missed.">            if (lRotation &lt;= 0)</span>
<span class="nc" id="L181">                lX -= lLabel.getBounds().getWidth();</span>
            
<span class="nc" id="L183">			lLabel.draw(g, (float)lX,  (float)lY);</span>
		}

		// reset rendering hint        
<span class="nc" id="L187">        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, rh);</span>
<span class="nc" id="L188">    }    </span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>