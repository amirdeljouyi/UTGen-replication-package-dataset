<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ChartUtilities.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">88_jopenchart</a> &gt; <a href="index.source.html" class="el_package">de.progra.charting</a> &gt; <span class="el_source">ChartUtilities.java</span></div><h1>ChartUtilities.java</h1><pre class="source lang-java linenums">/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian Mï¿½ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ChartUtilities.java
    Created on 21. September 2001, 17:42
 */

package de.progra.charting;

import java.util.*;

/**
 * This class offers multiple static methods to perform mathematical
 * operations concerning the Chart, e.g. methods for rounding the minimal and
 * maximal x-values gracefully.
 * @author  mueller
 * @version 1.0
 */
<span class="nc" id="L35">public class ChartUtilities {</span>

    /** This method calculates the optimal rounding for the minimal and
     * maximal ChartModel values. It computes the difference of the
     * minimal and maximal value and rounds the values min and max according
     * to the exponent of the difference.
     * @param min the minimal column value of the ChartDataModel
     * @param max the maximal column value of the ChartDataModel
     * @return a double[] with the rounded minimal value at index 0 and
     * the maximal value at index 1.
     */
    public static double[] performAutoScale(double min, double max) {
<span class="nc" id="L47">        double[] d = new double[2];  // d[0] = min d[1] = max</span>
        
<span class="nc" id="L49">        double diff = max - min;</span>
        
<span class="nc" id="L51">        d[0] = floor(min, exp(diff));</span>
<span class="nc" id="L52">        d[1] = ceil(max, exp(diff));</span>
        
<span class="nc" id="L54">        return d;</span>
    }
    
    /** Calculates the best tick spacing for the rounded minimal and maximal
     * values.
     * @param min the rounded minimal value
     * @param max the rounded maximal value
     * @return the spacing of ticks on the x-axis.
     */
    public static double calculateTickSpacing(double min, double max) {
<span class="nc" id="L64">        double spacing = 1.0;</span>
        
<span class="nc" id="L66">        double diff = max - min;</span>
        
<span class="nc" id="L68">        int exp = exp(diff);</span>
        
<span class="nc" id="L70">	exp--;</span>
        
<span class="nc" id="L72">        spacing = 1.0 * Math.pow(10.0, (double)exp);</span>
	
	// Currently, only every second tick gets a label, so 20 - 40 ticks are fine. 
	// This should be reduced in a loop probably.
<span class="nc bnc" id="L76" title="All 2 branches missed.">	if((diff / spacing) &lt; 20)</span>
<span class="nc" id="L77">            return 0.5 * spacing;</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">	else if((diff / spacing) &gt; 40)</span>
<span class="nc" id="L79">	    return 2 * spacing;</span>
        else
<span class="nc" id="L81">            return spacing;</span>
    }
    
    /** This function performs a polynomial interpolation using a set of
     * given x and y values. It uses Neville's interpolation algorithm.
     * @param xa the array of known x-values
     * @param ya the array of known y-values
     * @param x the x value for which the y value will be computed
     * @return the corresponding y value
     */
    public static double interpolate(double xa[], double ya[], double x) {
        /*
            Given arrays xa[1..n] and ya[1..n], and given a value x, 
            this routine returns a value y. 
            If P(x) is the polynomial of degree N ? 1 
            such that P(xa[i]) = ya[i]; 
            i = 1...n, then the returned value y = P(x).
         */

<span class="nc bnc" id="L100" title="All 6 branches missed.">        if(xa.length != ya.length || xa.length == 0 || ya.length == 0) {</span>
<span class="nc" id="L101">            System.out.println(&quot;** Invalid Parameter&quot;);</span>
<span class="nc" id="L102">            return Double.NaN;</span>
        }
        
<span class="nc" id="L105">        int n = xa.length;</span>
<span class="nc" id="L106">        double y = 0.0;</span>
<span class="nc" id="L107">        double dy = 0.0;</span>
        
<span class="nc" id="L109">        int i, m, ns = 1;</span>
        double den, dif, dift, ho, hp, w;
<span class="nc" id="L111">        double[] c = new double[n];</span>
<span class="nc" id="L112">        double[] d = new double[n];</span>
<span class="nc" id="L113">        dif = Math.abs(x - xa[0]);</span>
        
<span class="nc bnc" id="L115" title="All 2 branches missed.">        for (i = 0; i &lt; n; i++) { // Here we find the index ns of the closest table entry,</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">            if ( (dift = Math.abs(x - xa[i])) &lt; dif) {</span>
<span class="nc" id="L117">                ns = i;</span>
<span class="nc" id="L118">                dif=dift;</span>
            }
<span class="nc" id="L120">            c[i] = ya[i]; // and initialize the tableau of c's and d's.</span>
<span class="nc" id="L121">            d[i] = ya[i];</span>
        }
        
<span class="nc" id="L124">        y = ya[ns--]; // This is the initial approximation to y.</span>
        //System.out.println(&quot;** y ~ &quot;+y);
        
<span class="nc bnc" id="L127" title="All 2 branches missed.">        for (m = 0; m &lt; n - 1; m++) { // For each column of the tableau,</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">            for (i = 0; i &lt; n - m - 1; i++) { // we loop over the current c's and d's and update them. </span>
                
                //System.out.println(&quot;** m = &quot;+m+&quot;, i = &quot;+i);
<span class="nc" id="L131">                ho = xa[i] - x;</span>
<span class="nc" id="L132">                hp = xa[i + m + 1] - x;</span>
<span class="nc" id="L133">                w = c[i + 1] - d[i];</span>
                
<span class="nc bnc" id="L135" title="All 2 branches missed.">                if ( (den = ho - hp) == 0.0) {</span>
<span class="nc" id="L136">                    return Double.NaN;</span>
                }
                // This error can occur only if two input xa's are (to within roundof identical.
                
                //System.out.println(&quot;** ho = &quot;+ho+&quot;, hp = &quot;+hp);
                
<span class="nc" id="L142">                den = w / den;</span>
<span class="nc" id="L143">                d[i] = hp * den; // Here the c's and d's are updated.</span>
<span class="nc" id="L144">                c[i] = ho * den;</span>
                //System.out.println(&quot;** c[i] = &quot;+c[i]+&quot;, d[i] = &quot;+d[i]);
            }

<span class="nc bnc" id="L148" title="All 2 branches missed.">            y += (dy = (2 * (ns + 1) &lt; (n - m) ? c[ns + 1] : d[ns--]));</span>
            //System.out.println(&quot;** dy = &quot;+dy+&quot;, y = &quot;+y);

            /*
            After each column in the tableau is completed, we decide which correction, c or d,
            we want to add to our accumulating value of y, i.e., which path to take through the
            tableau forking up or down. We do this in such a way as to take the most &quot;straight
            line&quot; route through the tableau to its apex, updating ns accordingly to keep track of
            where we are. This route keeps the partial approximations centered (insofar as possible)
            on the target x. The last dy added is thus the error indication.
            */
      }

<span class="nc" id="L161">      return y;</span>
    }
    
    /** This method returns the largest double value that is smaller than
     * &lt;code&gt; d = x * 10&lt;sup&gt;exp&lt;/sup&gt;&lt;/code&gt; where x is rounded down to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return &lt;code&gt; Math.floor(x) * 10&lt;sup&gt;exp&lt;/sup&gt;&lt;/code&gt;
     */
    public static double floor(double d, int exp) {
<span class="nc" id="L172">        double x = 1.0 * Math.pow(10.0, (double)exp);</span>
        
<span class="nc" id="L174">        return Math.floor(d / x) * x;</span>
    }

    /** This method returns the smallest double value that is smaller than
     * &lt;code&gt; d = x * 10&lt;sup&gt;exp&lt;/exp&gt;&lt;/code&gt; where x is rounded up to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return &lt;code&gt; Math.ceil(x) * 10&lt;sup&gt;exp&lt;/sup&gt;&lt;/code&gt;
     */
    public static double ceil(double d, int exp) {
<span class="nc" id="L185">        double x = 1.0 * Math.pow(10.0, (double)exp);</span>
        
<span class="nc" id="L187">        return Math.ceil(d / x) * x;</span>
    }
    
    /** A double value can be represented like 
     * &lt;code&gt;d = x * 10&lt;sup&gt;exp&lt;/sup&gt;&lt;/code&gt; and this method returns
     * the value of exp for a double d.
     * @param d the double value
     * @return the exponent of 10
     */
    public static int exp(double d) {
<span class="nc" id="L197">        int exp = 0;</span>
<span class="nc bnc" id="L198" title="All 4 branches missed.">        boolean positive = (d &lt;= -1 || d &gt;= 1 );</span>
        
<span class="nc bnc" id="L200" title="All 8 branches missed.">        while((d &lt;= -10) || (d &gt;= 10) || ((d &gt; -1) &amp;&amp; (d &lt; 1))) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">            if(positive) {</span>
<span class="nc" id="L202">                d /= 10;</span>
<span class="nc" id="L203">                exp++;</span>
            } else {
<span class="nc" id="L205">                d *= 10;</span>
<span class="nc" id="L206">                exp--;</span>
            }
        }
        
<span class="nc" id="L210">        return exp;</span>
    }
    
            
    /** Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(int[][] data) {
<span class="nc" id="L218">        Number[][] n = new Number[data.length][data[0].length];</span>
        
<span class="nc bnc" id="L220" title="All 2 branches missed.">        for(int i = 0; i &lt; data.length; i++)</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">            for(int j = 0; j &lt; data[0].length; j++)</span>
<span class="nc" id="L222">                n[i][j] = new Integer(data[i][j]);</span>
                
<span class="nc" id="L224">        return n;</span>
    }
    
    /** Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(double[][] data) {
<span class="nc" id="L231">        Number[][] n = new Number[data.length][data[0].length];</span>
        
<span class="nc bnc" id="L233" title="All 2 branches missed.">        for(int i = 0; i &lt; data.length; i++)</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">            for(int j = 0; j &lt; data[0].length; j++)</span>
<span class="nc" id="L235">                n[i][j] = new Double(data[i][j]);</span>
                
<span class="nc" id="L237">        return n;</span>
    }
    
    /** Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(double[] data) {
<span class="nc" id="L244">        Number[] n = new Number[data.length];</span>
        
<span class="nc bnc" id="L246" title="All 2 branches missed.">        for(int i = 0; i &lt; data.length; i++)</span>
<span class="nc" id="L247">           n[i] = new Double(data[i]);</span>
                
<span class="nc" id="L249">        return n;</span>
    }
    
    /** Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(int[] data) {
<span class="nc" id="L256">        Number[] n = new Number[data.length];</span>
        
<span class="nc bnc" id="L258" title="All 2 branches missed.">        for(int i = 0; i &lt; data.length; i++)</span>
<span class="nc" id="L259">           n[i] = new Integer(data[i]);</span>
                
<span class="nc" id="L261">        return n;</span>
    }
    
    /** Adds a two-dimensional array to a TreeSet. */
    public static void addDataToSet(TreeSet set, Number[][] data) {
<span class="nc bnc" id="L266" title="All 2 branches missed.">        for(int i = 0; i &lt; data.length; i++) {</span>
<span class="nc" id="L267">            set.addAll(Arrays.asList(data[i]));</span>
        }
<span class="nc" id="L269">    }</span>
    
    /** A test routine. */
    public static void main(String[] args) {
<span class="nc" id="L273">        double min = -0.00337;</span>
<span class="nc" id="L274">        double max = 0.00745;</span>
        
<span class="nc" id="L276">        double[] d = performAutoScale(min, max);</span>
        
<span class="nc" id="L278">        System.out.println(&quot;** AutoScaling: (&quot;+min+&quot;, &quot;+max+&quot;) -&gt; (&quot;+d[0]+&quot;, &quot;+d[1]+&quot;)&quot;);</span>
        
<span class="nc" id="L280">        double s = calculateTickSpacing(d[0], d[1]);</span>
        
<span class="nc" id="L282">        System.out.print(&quot;** Ticks: &quot;);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">        for(double i = d[0]; i &lt;= d[1]; i += s)</span>
<span class="nc" id="L284">            System.out.print(&quot; &quot;+i+&quot; &quot;);</span>
<span class="nc" id="L285">        System.out.println();</span>
        
<span class="nc" id="L287">        System.out.println(&quot;** Performing interpolation for 4*x^2&quot;);</span>
<span class="nc" id="L288">        System.out.println(&quot;** Given values [-4, 64], [0, 0], [3, 36]&quot;);</span>
        
<span class="nc" id="L290">        double xa[] = {-4.0, 0.0, 3.0};</span>
<span class="nc" id="L291">        double ya[] = {64.0, 0.0, 36.0};</span>
        
<span class="nc" id="L293">        System.out.print(&quot;** Calculating values&quot;);</span>
        //double f = interpolate(xa, ya, 1.0);
        //System.out.println(&quot;** f(1) = &quot;+f);
        
<span class="nc bnc" id="L297" title="All 2 branches missed.">        for(double i = -5.0; i &lt; 6.0; i += 0.5) {</span>
<span class="nc" id="L298">            System.out.print(&quot;[&quot;+i+&quot;, &quot;+interpolate(xa, ya, i)+&quot;]&quot;);</span>
        }
        
<span class="nc" id="L301">        System.out.println();</span>
        
<span class="nc" id="L303">        System.out.println(&quot;** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5&quot;);</span>
<span class="nc" id="L304">        System.out.println(&quot;** Given values [-5, -740], [0, -5], [1, -2], [5, 530]&quot;);</span>
        
<span class="nc" id="L306">        double xb[] = {-5.0, 0.0, 1.0, 5.0};</span>
<span class="nc" id="L307">        double yb[] = {-740.0, -5.0, -2.0, 530.0};</span>
        
<span class="nc" id="L309">        System.out.print(&quot;** Calculating values &quot;);</span>
        
<span class="nc bnc" id="L311" title="All 2 branches missed.">        for(double i = -5.0; i &lt; 6.0; i += 0.5) {</span>
<span class="nc" id="L312">            System.out.print(&quot;[&quot;+i+&quot;, &quot;+interpolate(xb, yb, i)+&quot;]&quot;);</span>
        }
        
<span class="nc" id="L315">        System.out.println();</span>
         
<span class="nc" id="L317">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>