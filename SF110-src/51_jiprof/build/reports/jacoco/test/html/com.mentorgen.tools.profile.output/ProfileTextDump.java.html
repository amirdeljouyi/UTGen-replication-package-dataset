<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProfileTextDump.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">51_jiprof</a> &gt; <a href="index.source.html" class="el_package">com.mentorgen.tools.profile.output</a> &gt; <span class="el_source">ProfileTextDump.java</span></div><h1>ProfileTextDump.java</h1><pre class="source lang-java linenums">/*
Copyright (c) 2005 - 2006, MentorGen, LLC
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

+ Redistributions of source code must retain the above copyright notice, 
  this list of conditions and the following disclaimer.
+ Redistributions in binary form must reproduce the above copyright notice, 
  this list of conditions and the following disclaimer in the documentation 
  and/or other materials provided with the distribution.
+ Neither the name of MentorGen LLC nor the names of its contributors may be 
  used to endorse or promote products derived from this software without 
  specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
 */
package com.mentorgen.tools.profile.output;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;

import com.mentorgen.tools.profile.Controller;
import com.mentorgen.tools.profile.runtime.ClassAllocation;
import com.mentorgen.tools.profile.runtime.Frame;
import com.mentorgen.tools.profile.runtime.Profile;

/**
 * This class outputs the profile in a human-readable text format.
 * 
 * @author Andrew Wilcox
 * @see com.mentorgen.tools.profile.output.ProfileXMLDump 
 */
<span class="nc" id="L54">final class ProfileTextDump {</span>
	static HashMap&lt;String, Holder&gt; _clumpedFrameMap;
	
	static void dump() throws IOException {
		
		// init
		//
<span class="fc" id="L61">		_clumpedFrameMap = new HashMap&lt;String, Holder&gt;();</span>
		
		//
		// output
		//
<span class="fc" id="L66">		String fileName = null;</span>
<span class="fc" id="L67">		File f = new File(Controller._fileName);</span>
<span class="fc" id="L68">		Date now = new Date();</span>
		
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">		if (f.isDirectory()) {</span>
<span class="nc" id="L71">			StringBuffer b = new StringBuffer(f.getAbsolutePath());</span>
<span class="nc" id="L72">			b.append(File.separator);</span>
<span class="nc" id="L73">			b.append(new SimpleDateFormat(&quot;yyyyMMdd-HHmmss&quot;).format(now));</span>
<span class="nc" id="L74">			b.append(&quot;.txt&quot;);</span>
<span class="nc" id="L75">			fileName = b.toString();</span>
<span class="nc" id="L76">		} else {</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">			if (Controller._fileName.endsWith(&quot;.txt&quot;)) {</span>
<span class="fc" id="L78">				fileName = Controller._fileName;</span>
			} else {
<span class="fc" id="L80">				StringBuffer b = new StringBuffer(Controller._fileName);</span>
<span class="fc" id="L81">				b.append(&quot;.txt&quot;);</span>
<span class="fc" id="L82">				fileName = b.toString();</span>
			}
		}
		
<span class="fc" id="L86">		FileWriter out = new FileWriter(fileName);</span>
<span class="fc" id="L87">		BufferedWriter bufferedWriter = new BufferedWriter(out);</span>
<span class="fc" id="L88">		PrintWriter writer = new PrintWriter(bufferedWriter);</span>
		
<span class="fc" id="L90">		writer.println(&quot;+----------------------------------------------------------------------&quot;);		</span>
<span class="fc" id="L91">		writer.print(&quot;|  File: &quot;);</span>
<span class="fc" id="L92">		writer.println(fileName);</span>
<span class="fc" id="L93">		writer.print(&quot;|  Date: &quot;);</span>
<span class="fc" id="L94">		writer.println(new SimpleDateFormat(&quot;yyyy.MM.dd HH:mm:ss a&quot;).format(now));</span>
<span class="fc" id="L95">		writer.println(&quot;+----------------------------------------------------------------------&quot;);</span>
<span class="fc" id="L96">		writer.println();</span>

<span class="pc bpc" id="L98" title="1 of 2 branches missed.">		if (!Controller._outputSummaryOnly) {</span>
<span class="fc" id="L99">			dumpThreads(writer);</span>
		}
		
<span class="fc" id="L102">		dumpFrames(writer);</span>
<span class="fc" id="L103">		dumpClumpedFrames(writer);</span>
<span class="fc" id="L104">		dumpAllocation(writer);</span>
		
<span class="fc" id="L106">		writer.flush();</span>
<span class="fc" id="L107">		out.close();		</span>
<span class="fc" id="L108">	}</span>
	
	private static void dumpThreads(PrintWriter writer) {
		
		// announce the control level for the threads
		//
<span class="fc" id="L114">		writer.println(&quot;+------------------------------&quot;);</span>
<span class="fc" id="L115">		writer.print(&quot;| Thread depth limit: &quot;);</span>
		
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">		if (Controller._compactThreadDepth) {</span>
<span class="nc" id="L118">			writer.println(&quot;Compact&quot;);</span>
		}
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">		else if (Controller._threadDepth == Controller.UNLIMITED){</span>
<span class="fc" id="L121">			writer.println(&quot;Unlimited&quot;);</span>
		}
		else {
<span class="nc" id="L124">			writer.println(Controller._threadDepth);</span>
		}
		
<span class="fc" id="L127">		writer.println(&quot;+------------------------------&quot;);</span>
		
		// display the threads
		//
<span class="fc bfc" id="L131" title="All 2 branches covered.">		for (Long threadId: Profile.threads()) {</span>
<span class="fc" id="L132">			int i=1;</span>
			
<span class="fc bfc" id="L134" title="All 2 branches covered.">			for (Frame iteractionRoot: Profile.interactions(threadId)) {</span>
<span class="fc" id="L135">				FrameDump.dump(writer, iteractionRoot, i);</span>
<span class="fc" id="L136">				i++;</span>
<span class="fc" id="L137">			}</span>
<span class="fc" id="L138">		}</span>
<span class="fc" id="L139">	}</span>
	
	private static void dumpFrames(PrintWriter writer) {
		
		// announce the control level
		//
<span class="fc" id="L145">		writer.println();</span>
<span class="fc" id="L146">		writer.println(&quot;+--------------------------------------&quot;);</span>
<span class="fc" id="L147">		writer.println(&quot;| Most expensive methods (by net time)&quot;);</span>
<span class="fc" id="L148">		writer.print(&quot;| Frame Count Limit: &quot;);</span>
		
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">		if (Controller._compactMethodCount) {</span>
<span class="nc" id="L151">			writer.println(&quot;Compact&quot;);</span>
		}
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">		else if (Controller._methodCount == Controller.UNLIMITED){</span>
<span class="fc" id="L154">			writer.println(&quot;Unlimited&quot;);</span>
		}
		else {
<span class="nc" id="L157">			writer.println(Controller._methodCount);</span>
		}
		
<span class="fc" id="L160">		writer.println(&quot;+--------------------------------------&quot;);</span>
<span class="fc" id="L161">		writer.println();</span>
		
		// display the frame information
		//
<span class="fc" id="L165">		writer.println(&quot;               Net&quot;);</span>
<span class="fc" id="L166">		writer.println(&quot;          ------------&quot;); </span>
<span class="fc" id="L167">		writer.println(&quot; Count     Time    Pct  Location&quot;);</span>
<span class="fc" id="L168">		writer.println(&quot; =====     ====    ===  ========&quot;);</span>
<span class="fc" id="L169">		int count = 0;</span>
<span class="fc" id="L170">		boolean display = true;</span>
<span class="fc" id="L171">		Profile.sortFrameList(new FrameComparator());</span>
		
<span class="fc bfc" id="L173" title="All 2 branches covered.">		for (Frame frame: Profile.frameList()) {</span>
			
<span class="fc" id="L175">			long threadId = frame.getThreadId();</span>
			
<span class="fc" id="L177">			double threadTotalTime = Profile.getThreadTotalTime(threadId);</span>
<span class="fc" id="L178">			double percent = Math.toPercent(frame.netTime(), threadTotalTime);</span>
<span class="fc" id="L179">			double time = Math.nanoToMilli(frame.netTime());</span>
<span class="fc" id="L180">			String name = frame.getName();</span>
			
<span class="pc bpc" id="L182" title="2 of 4 branches missed.">			if (display &amp;&amp; belowThreshold(time, count)) {</span>
<span class="nc" id="L183">				display = false;</span>
			}
			
<span class="fc" id="L186">			count++;			</span>
			
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">			if (display) {</span>
<span class="fc" id="L189">				writer.printf(&quot;%6d &quot;, frame._metrics.getCount());</span>
<span class="fc" id="L190">				writer.printf(&quot;%8.1f  &quot;, time);</span>
<span class="fc" id="L191">				writer.printf(&quot;%5.1f  &quot;, percent);</span>
<span class="fc" id="L192">				writer.println(name);</span>
			}
			
<span class="fc" id="L195">			clumpFrame(frame._metrics.getCount(), time, percent, name);</span>
<span class="fc" id="L196">		}</span>
<span class="fc" id="L197">	}</span>
	
	private static void clumpFrame(long count, 
			double time, 
			double percent, 
			String name) {
<span class="fc" id="L203">		Holder h = _clumpedFrameMap.get(name);</span>
		
<span class="fc bfc" id="L205" title="All 2 branches covered.">		if (h == null) {</span>
<span class="fc" id="L206">			h = new Holder(count, time, percent, name);</span>
<span class="fc" id="L207">			_clumpedFrameMap.put(name, h);</span>
		} else {
<span class="fc" id="L209">			h._count   += count;</span>
<span class="fc" id="L210">			h._time    += time;</span>
<span class="fc" id="L211">			h._percent += percent;</span>
		}
<span class="fc" id="L213">	}</span>
	
	
	private static void dumpClumpedFrames(PrintWriter writer) {
<span class="fc" id="L217">		writer.println();</span>
<span class="fc" id="L218">		writer.println(&quot;+--------------------------------------+&quot;);</span>
<span class="fc" id="L219">		writer.println(&quot;| Most expensive methods summarized    |&quot;);</span>
<span class="fc" id="L220">		writer.println(&quot;+--------------------------------------+&quot;);</span>
<span class="fc" id="L221">		writer.println();</span>
		
<span class="fc" id="L223">		LinkedList&lt;Holder&gt; list = new LinkedList&lt;Holder&gt;();</span>

<span class="fc bfc" id="L225" title="All 2 branches covered.">		for (Holder h: _clumpedFrameMap.values()) {</span>
<span class="fc" id="L226">			list.add(h);</span>
<span class="fc" id="L227">		}</span>
		
<span class="fc" id="L229">		Collections.sort(list, new HolderComparator());</span>
		
<span class="fc" id="L231">		writer.println(&quot;               Net&quot;);</span>
<span class="fc" id="L232">		writer.println(&quot;          ------------&quot;); </span>
<span class="fc" id="L233">		writer.println(&quot; Count     Time    Pct  Location&quot;);</span>
<span class="fc" id="L234">		writer.println(&quot; =====     ====    ===  ========&quot;);</span>
		
<span class="fc" id="L236">		long count = 0;</span>
		
<span class="fc bfc" id="L238" title="All 2 branches covered.">		for (Holder h: list) {</span>
			
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">			if (belowThreshold(h._time, count)) {</span>
<span class="nc" id="L241">				break;</span>
			}
<span class="fc" id="L243">			count++;</span>
			
<span class="fc" id="L245">			writer.printf(&quot;%6d &quot;, h._count);</span>
<span class="fc" id="L246">			writer.printf(&quot;%8.1f  &quot;, h._time);</span>
<span class="fc" id="L247">			writer.printf(&quot;%5.1f  &quot;, h._percent);</span>
<span class="fc" id="L248">			writer.println(h._name);</span>
<span class="fc" id="L249">		}</span>
<span class="fc" id="L250">	}</span>
	
	private static boolean belowThreshold(double time, long count) {
		
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">		if (Controller._compactMethodCount) {  </span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">			if (time &lt; (Controller._compactMethodThreshold)) {</span>
<span class="nc" id="L256">				return true;</span>
			}
		}
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">		else if (Controller._methodCount != Controller.UNLIMITED) {</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">			if (count+1 == Controller._methodCount) </span>
<span class="nc" id="L261">				return true;</span>
		}
		
<span class="fc" id="L264">		return false;</span>
	}
	
	private static void dumpAllocation(PrintWriter writer) {
		
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">		if (!Controller._trackObjectAlloc) {</span>
<span class="fc" id="L270">			return;</span>
		}
		
<span class="nc" id="L273">		writer.println();</span>
<span class="nc" id="L274">		writer.println(&quot;+---------------------------------+&quot;);</span>
<span class="nc" id="L275">		writer.println(&quot;| Object Allocation               |&quot;);</span>
<span class="nc" id="L276">		writer.println(&quot;+---------------------------------+&quot;);</span>
<span class="nc" id="L277">		writer.println();</span>
<span class="nc" id="L278">		writer.println(&quot;     Count Class Name&quot;);</span>
<span class="nc" id="L279">		writer.println(&quot;     ===== ==========&quot;);</span>
		
<span class="nc" id="L281">		LinkedList&lt;ClassAllocation&gt; caList = new LinkedList&lt;ClassAllocation&gt;();</span>

<span class="nc bnc" id="L283" title="All 2 branches missed.">		for (ClassAllocation ca: Profile.allocations()) {</span>
<span class="nc" id="L284">			caList.add(ca);</span>
<span class="nc" id="L285">		}</span>
		
<span class="nc" id="L287">		Collections.sort(caList, new ClassAllocComparator());</span>
		
<span class="nc bnc" id="L289" title="All 2 branches missed.">		for (ClassAllocation ca: caList) {</span>
<span class="nc" id="L290">			writer.printf(&quot;%10d  &quot;, ca.getAllocCount());</span>
<span class="nc" id="L291">			writer.println(ca.getClassName());			</span>
<span class="nc" id="L292">		}</span>
<span class="nc" id="L293">	}	</span>
}



class Holder {
	long _count;
	double _time;
	double _percent;
	String _name;
	
<span class="fc" id="L304">	Holder(long count, double time, double percent, String name) {</span>
<span class="fc" id="L305">		_count = count;</span>
<span class="fc" id="L306">		_time = time;</span>
<span class="fc" id="L307">		_percent = percent;</span>
<span class="fc" id="L308">		_name = name;</span>
<span class="fc" id="L309">	}</span>
}


<span class="fc" id="L313">class FrameComparator implements Comparator&lt;Frame&gt; {</span>
	
	public int compare(Frame fa, Frame fb) {
		//
		// IMPORTANT NOTE: 
		// 
		// Returning:
		// fb.netTime() - fa.netTime()
		//
		// won't work. This is because netTime is a long. So, for 
		// example, if fb.netTime() is close to zero and fa.netTime()
		// is large, you might end up with a number that can't be expressed
		// properly as an integer.
		//
		
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">		if (fa.netTime() &lt; fb.netTime()) {</span>
<span class="nc" id="L329">			return 1;</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">		} else if (fa.netTime() == fb.netTime()) { </span>
<span class="nc" id="L331">			return 0;</span>
		} else {
<span class="fc" id="L333">			return -1;</span>
		}
	}
	
}

<span class="fc" id="L339">class HolderComparator implements Comparator&lt;Holder&gt; {</span>
	
	public int compare(Holder ha, Holder hb) {
		
<span class="nc bnc" id="L343" title="All 2 branches missed.">		if (ha._time &lt; hb._time) {</span>
<span class="nc" id="L344">			return 1;</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">		} else if (ha._time == hb._time) {</span>
<span class="nc" id="L346">			return 0;</span>
		} else {
<span class="nc" id="L348">			return -1;</span>
		}
	}
}

<span class="nc" id="L353">class ClassAllocComparator implements Comparator&lt;ClassAllocation&gt; {</span>
	
	public int compare(ClassAllocation ca1, ClassAllocation ca2) {
<span class="nc" id="L356">		return ca2.getAllocCount() - ca1.getAllocCount();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>