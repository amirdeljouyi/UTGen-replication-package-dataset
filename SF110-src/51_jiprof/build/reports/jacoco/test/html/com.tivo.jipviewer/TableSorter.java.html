<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TableSorter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">51_jiprof</a> &gt; <a href="index.source.html" class="el_package">com.tivo.jipviewer</a> &gt; <span class="el_source">TableSorter.java</span></div><h1>TableSorter.java</h1><pre class="source lang-java linenums">//
// The Swing JTable tutorial includes the TableSorter class in this file saying
// &quot;You can use TableSorter as-is to provide sorting functionality...&quot;. I've
// added the sample code license text I found on the tutorial site.  I also
// added the trivial viewIndex() method.  -- ab
//
// Useful links:
//
//  &quot;How to Use Tables&quot;:
//     http://java.sun.com/docs/books/tutorial/uiswing/components/table.html
//
//  TableSorter.java:
//     http://java.sun.com/docs/books/tutorial/uiswing/components/example-1dot4/TableSorter.java
//
//  &quot;Building GUIs with JFC/Swing APIs Code Samples&quot;:
//    http://java.sun.com/developer/codesamples/swing.html
//
//  License pointed at by &quot;Building GUIs...&quot; document.
//    http://developers.sun.com/license/berkeley_license.html
//

/*/////////////////////////////////////////////////////////////////////

Copyright 1994-2006 Sun Microsystems, Inc. All Rights Reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
 

    * Redistribution of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistribution in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.

 
Neither the name of Sun Microsystems, Inc. or the names of contributors may be
used to endorse or promote products derived from this software without specific
prior written permission.
 
This software is provided &quot;AS IS,&quot; without a warranty of any kind. ALL EXPRESS
OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY IMPLIED
WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
NON-INFRINGEMENT, ARE HEREBY EXCLUDED. SUN MICROSYSTEMS, INC. (&quot;SUN&quot;) AND ITS
LICENSORS SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT
OF USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES. IN NO
EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,
OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE
DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT
OF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF SUN HAS BEEN ADVISED
OF THE POSSIBILITY OF SUCH DAMAGES.
 
You acknowledge that this software is not designed, licensed or intended for
use in the design, construction, operation or maintenance of any nuclear
facility.

/////////////////////////////////////////////////////////////////////*/

package com.tivo.jipviewer;

import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;

import javax.swing.*;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.*;

/**
 * TableSorter is a decorator for TableModels; adding sorting
 * functionality to a supplied TableModel. TableSorter does
 * not store or copy the data in its TableModel; instead it maintains
 * a map from the row indexes of the view to the row indexes of the
 * model. As requests are made of the sorter (like getValueAt(row, col))
 * they are passed to the underlying model after the row numbers
 * have been translated via the internal mapping array. This way,
 * the TableSorter appears to hold another copy of the table
 * with the rows in a different order.
 * &lt;p/&gt;
 * TableSorter registers itself as a listener to the underlying model,
 * just as the JTable itself would. Events recieved from the model
 * are examined, sometimes manipulated (typically widened), and then
 * passed on to the TableSorter's listeners (typically the JTable).
 * If a change to the model has invalidated the order of TableSorter's
 * rows, a note of this is made and the sorter will resort the
 * rows the next time a value is requested.
 * &lt;p/&gt;
 * When the tableHeader property is set, either by using the
 * setTableHeader() method or the two argument constructor, the
 * table header may be used as a complete UI for TableSorter.
 * The default renderer of the tableHeader is decorated with a renderer
 * that indicates the sorting status of each column. In addition,
 * a mouse listener is installed with the following behavior:
 * &lt;ul&gt;
 * &lt;li&gt;
 * Mouse-click: Clears the sorting status of all other columns
 * and advances the sorting status of that column through three
 * values: {NOT_SORTED, ASCENDING, DESCENDING} (then back to
 * NOT_SORTED again).
 * &lt;li&gt;
 * SHIFT-mouse-click: Clears the sorting status of all other columns
 * and cycles the sorting status of the column through the same
 * three values, in the opposite order: {NOT_SORTED, DESCENDING, ASCENDING}.
 * &lt;li&gt;
 * CONTROL-mouse-click and CONTROL-SHIFT-mouse-click: as above except
 * that the changes to the column do not cancel the statuses of columns
 * that are already sorting - giving a way to initiate a compound
 * sort.
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * This is a long overdue rewrite of a class of the same name that
 * first appeared in the swing table demos in 1997.
 * 
 * @author Philip Milne
 * @author Brendon McLean 
 * @author Dan van Enckevort
 * @author Parwinder Sekhon
 * @version 2.0 02/27/04
 */

public class TableSorter extends AbstractTableModel {
    protected TableModel tableModel;

    public static final int DESCENDING = -1;
    public static final int NOT_SORTED = 0;
    public static final int ASCENDING = 1;

<span class="nc" id="L131">    private static Directive EMPTY_DIRECTIVE = new Directive(-1, NOT_SORTED);</span>

<span class="nc" id="L133">    public static final Comparator COMPARABLE_COMAPRATOR = new Comparator() {</span>
        public int compare(Object o1, Object o2) {
<span class="nc" id="L135">            return ((Comparable) o1).compareTo(o2);</span>
        }
    };
<span class="nc" id="L138">    public static final Comparator LEXICAL_COMPARATOR = new Comparator() {</span>
        public int compare(Object o1, Object o2) {
<span class="nc" id="L140">            return o1.toString().compareTo(o2.toString());</span>
        }
    };

    private Row[] viewToModel;
    private int[] modelToView;

    private JTableHeader tableHeader;
    private MouseListener mouseListener;
    private TableModelListener tableModelListener;
<span class="nc" id="L150">    private Map columnComparators = new HashMap();</span>
<span class="nc" id="L151">    private List sortingColumns = new ArrayList();</span>

<span class="nc" id="L153">    public TableSorter() {</span>
<span class="nc" id="L154">        this.mouseListener = new MouseHandler();</span>
<span class="nc" id="L155">        this.tableModelListener = new TableModelHandler();</span>
<span class="nc" id="L156">    }</span>

    public TableSorter(TableModel tableModel) {
<span class="nc" id="L159">        this();</span>
<span class="nc" id="L160">        setTableModel(tableModel);</span>
<span class="nc" id="L161">    }</span>

    public TableSorter(TableModel tableModel, JTableHeader tableHeader) {
<span class="nc" id="L164">        this();</span>
<span class="nc" id="L165">        setTableHeader(tableHeader);</span>
<span class="nc" id="L166">        setTableModel(tableModel);</span>
<span class="nc" id="L167">    }</span>

    private void clearSortingState() {
<span class="nc" id="L170">        viewToModel = null;</span>
<span class="nc" id="L171">        modelToView = null;</span>
<span class="nc" id="L172">    }</span>

    public TableModel getTableModel() {
<span class="nc" id="L175">        return tableModel;</span>
    }

    public void setTableModel(TableModel tableModel) {
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (this.tableModel != null) {</span>
<span class="nc" id="L180">            this.tableModel.removeTableModelListener(tableModelListener);</span>
        }

<span class="nc" id="L183">        this.tableModel = tableModel;</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (this.tableModel != null) {</span>
<span class="nc" id="L185">            this.tableModel.addTableModelListener(tableModelListener);</span>
        }

<span class="nc" id="L188">        clearSortingState();</span>
<span class="nc" id="L189">        fireTableStructureChanged();</span>
<span class="nc" id="L190">    }</span>

    public JTableHeader getTableHeader() {
<span class="nc" id="L193">        return tableHeader;</span>
    }

    public void setTableHeader(JTableHeader tableHeader) {
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (this.tableHeader != null) {</span>
<span class="nc" id="L198">            this.tableHeader.removeMouseListener(mouseListener);</span>
<span class="nc" id="L199">            TableCellRenderer defaultRenderer = this.tableHeader.getDefaultRenderer();</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            if (defaultRenderer instanceof SortableHeaderRenderer) {</span>
<span class="nc" id="L201">                this.tableHeader.setDefaultRenderer(((SortableHeaderRenderer) defaultRenderer).tableCellRenderer);</span>
            }
        }
<span class="nc" id="L204">        this.tableHeader = tableHeader;</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (this.tableHeader != null) {</span>
<span class="nc" id="L206">            this.tableHeader.addMouseListener(mouseListener);</span>
<span class="nc" id="L207">            this.tableHeader.setDefaultRenderer(</span>
<span class="nc" id="L208">                    new SortableHeaderRenderer(this.tableHeader.getDefaultRenderer()));</span>
        }
<span class="nc" id="L210">    }</span>

    public boolean isSorting() {
<span class="nc bnc" id="L213" title="All 2 branches missed.">        return sortingColumns.size() != 0;</span>
    }

    private Directive getDirective(int column) {
<span class="nc bnc" id="L217" title="All 2 branches missed.">        for (int i = 0; i &lt; sortingColumns.size(); i++) {</span>
<span class="nc" id="L218">            Directive directive = (Directive)sortingColumns.get(i);</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (directive.column == column) {</span>
<span class="nc" id="L220">                return directive;</span>
            }
        }
<span class="nc" id="L223">        return EMPTY_DIRECTIVE;</span>
    }

    public int getSortingStatus(int column) {
<span class="nc" id="L227">        return getDirective(column).direction;</span>
    }

    private void sortingStatusChanged() {
<span class="nc" id="L231">        clearSortingState();</span>
<span class="nc" id="L232">        fireTableDataChanged();</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (tableHeader != null) {</span>
<span class="nc" id="L234">            tableHeader.repaint();</span>
        }
<span class="nc" id="L236">    }</span>

    public void setSortingStatus(int column, int status) {
<span class="nc" id="L239">        Directive directive = getDirective(column);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (directive != EMPTY_DIRECTIVE) {</span>
<span class="nc" id="L241">            sortingColumns.remove(directive);</span>
        }
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (status != NOT_SORTED) {</span>
<span class="nc" id="L244">            sortingColumns.add(new Directive(column, status));</span>
        }
<span class="nc" id="L246">        sortingStatusChanged();</span>
<span class="nc" id="L247">    }</span>

    protected Icon getHeaderRendererIcon(int column, int size) {
<span class="nc" id="L250">        Directive directive = getDirective(column);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">        if (directive == EMPTY_DIRECTIVE) {</span>
<span class="nc" id="L252">            return null;</span>
        }
<span class="nc bnc" id="L254" title="All 2 branches missed.">        return new Arrow(directive.direction == DESCENDING, size, sortingColumns.indexOf(directive));</span>
    }

    private void cancelSorting() {
<span class="nc" id="L258">        sortingColumns.clear();</span>
<span class="nc" id="L259">        sortingStatusChanged();</span>
<span class="nc" id="L260">    }</span>

    public void setColumnComparator(Class type, Comparator comparator) {
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (comparator == null) {</span>
<span class="nc" id="L264">            columnComparators.remove(type);</span>
        } else {
<span class="nc" id="L266">            columnComparators.put(type, comparator);</span>
        }
<span class="nc" id="L268">    }</span>

    protected Comparator getComparator(int column) {
<span class="nc" id="L271">        Class columnType = tableModel.getColumnClass(column);</span>
<span class="nc" id="L272">        Comparator comparator = (Comparator) columnComparators.get(columnType);</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (comparator != null) {</span>
<span class="nc" id="L274">            return comparator;</span>
        }
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (Comparable.class.isAssignableFrom(columnType)) {</span>
<span class="nc" id="L277">            return COMPARABLE_COMAPRATOR;</span>
        }
<span class="nc" id="L279">        return LEXICAL_COMPARATOR;</span>
    }

    private Row[] getViewToModel() {
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (viewToModel == null) {</span>
<span class="nc" id="L284">            int tableModelRowCount = tableModel.getRowCount();</span>
<span class="nc" id="L285">            viewToModel = new Row[tableModelRowCount];</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">            for (int row = 0; row &lt; tableModelRowCount; row++) {</span>
<span class="nc" id="L287">                viewToModel[row] = new Row(row);</span>
            }

<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (isSorting()) {</span>
<span class="nc" id="L291">                Arrays.sort(viewToModel);</span>
            }
        }
<span class="nc" id="L294">        return viewToModel;</span>
    }

    public int modelIndex(int viewIndex) {
<span class="nc" id="L298">        return getViewToModel()[viewIndex].modelIndex;</span>
    }

    public int viewIndex(int modelIndex) {
<span class="nc" id="L302">        return getModelToView()[modelIndex];</span>
    }

    private int[] getModelToView() {
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (modelToView == null) {</span>
<span class="nc" id="L307">            int n = getViewToModel().length;</span>
<span class="nc" id="L308">            modelToView = new int[n];</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L310">                modelToView[modelIndex(i)] = i;</span>
            }
        }
<span class="nc" id="L313">        return modelToView;</span>
    }

    // TableModel interface methods 

    public int getRowCount() {
<span class="nc bnc" id="L319" title="All 2 branches missed.">        return (tableModel == null) ? 0 : tableModel.getRowCount();</span>
    }

    public int getColumnCount() {
<span class="nc bnc" id="L323" title="All 2 branches missed.">        return (tableModel == null) ? 0 : tableModel.getColumnCount();</span>
    }

    public String getColumnName(int column) {
<span class="nc" id="L327">        return tableModel.getColumnName(column);</span>
    }

    public Class getColumnClass(int column) {
<span class="nc" id="L331">        return tableModel.getColumnClass(column);</span>
    }

    public boolean isCellEditable(int row, int column) {
<span class="nc" id="L335">        return tableModel.isCellEditable(modelIndex(row), column);</span>
    }

    public Object getValueAt(int row, int column) {
<span class="nc" id="L339">        return tableModel.getValueAt(modelIndex(row), column);</span>
    }

    public void setValueAt(Object aValue, int row, int column) {
<span class="nc" id="L343">        tableModel.setValueAt(aValue, modelIndex(row), column);</span>
<span class="nc" id="L344">    }</span>

    // Helper classes
    
    private class Row implements Comparable {
        private int modelIndex;

<span class="nc" id="L351">        public Row(int index) {</span>
<span class="nc" id="L352">            this.modelIndex = index;</span>
<span class="nc" id="L353">        }</span>

        public int compareTo(Object o) {
<span class="nc" id="L356">            int row1 = modelIndex;</span>
<span class="nc" id="L357">            int row2 = ((Row) o).modelIndex;</span>

<span class="nc bnc" id="L359" title="All 2 branches missed.">            for (Iterator it = sortingColumns.iterator(); it.hasNext();) {</span>
<span class="nc" id="L360">                Directive directive = (Directive) it.next();</span>
<span class="nc" id="L361">                int column = directive.column;</span>
<span class="nc" id="L362">                Object o1 = tableModel.getValueAt(row1, column);</span>
<span class="nc" id="L363">                Object o2 = tableModel.getValueAt(row2, column);</span>

<span class="nc" id="L365">                int comparison = 0;</span>
                // Define null less than everything, except null.
<span class="nc bnc" id="L367" title="All 4 branches missed.">                if (o1 == null &amp;&amp; o2 == null) {</span>
<span class="nc" id="L368">                    comparison = 0;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">                } else if (o1 == null) {</span>
<span class="nc" id="L370">                    comparison = -1;</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">                } else if (o2 == null) {</span>
<span class="nc" id="L372">                    comparison = 1;</span>
                } else {
<span class="nc" id="L374">                    comparison = getComparator(column).compare(o1, o2);</span>
                }
<span class="nc bnc" id="L376" title="All 2 branches missed.">                if (comparison != 0) {</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">                    return directive.direction == DESCENDING ? -comparison : comparison;</span>
                }
<span class="nc" id="L379">            }</span>
<span class="nc" id="L380">            return 0;</span>
        }
    }

<span class="nc" id="L384">    private class TableModelHandler implements TableModelListener {</span>
        public void tableChanged(TableModelEvent e) {
            // If we're not sorting by anything, just pass the event along.             
<span class="nc bnc" id="L387" title="All 2 branches missed.">            if (!isSorting()) {</span>
<span class="nc" id="L388">                clearSortingState();</span>
<span class="nc" id="L389">                fireTableChanged(e);</span>
<span class="nc" id="L390">                return;</span>
            }
                
            // If the table structure has changed, cancel the sorting; the             
            // sorting columns may have been either moved or deleted from             
            // the model. 
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (e.getFirstRow() == TableModelEvent.HEADER_ROW) {</span>
<span class="nc" id="L397">                cancelSorting();</span>
<span class="nc" id="L398">                fireTableChanged(e);</span>
<span class="nc" id="L399">                return;</span>
            }

            // We can map a cell event through to the view without widening             
            // when the following conditions apply: 
            // 
            // a) all the changes are on one row (e.getFirstRow() == e.getLastRow()) and, 
            // b) all the changes are in one column (column != TableModelEvent.ALL_COLUMNS) and,
            // c) we are not sorting on that column (getSortingStatus(column) == NOT_SORTED) and, 
            // d) a reverse lookup will not trigger a sort (modelToView != null)
            //
            // Note: INSERT and DELETE events fail this test as they have column == ALL_COLUMNS.
            // 
            // The last check, for (modelToView != null) is to see if modelToView 
            // is already allocated. If we don't do this check; sorting can become 
            // a performance bottleneck for applications where cells  
            // change rapidly in different parts of the table. If cells 
            // change alternately in the sorting column and then outside of             
            // it this class can end up re-sorting on alternate cell updates - 
            // which can be a performance problem for large tables. The last 
            // clause avoids this problem. 
<span class="nc" id="L420">            int column = e.getColumn();</span>
<span class="nc bnc" id="L421" title="All 4 branches missed.">            if (e.getFirstRow() == e.getLastRow()</span>
                    &amp;&amp; column != TableModelEvent.ALL_COLUMNS
<span class="nc bnc" id="L423" title="All 2 branches missed.">                    &amp;&amp; getSortingStatus(column) == NOT_SORTED</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">                    &amp;&amp; modelToView != null) {</span>
<span class="nc" id="L425">                int viewIndex = getModelToView()[e.getFirstRow()];</span>
<span class="nc" id="L426">                fireTableChanged(new TableModelEvent(TableSorter.this, </span>
                                                     viewIndex, viewIndex, 
<span class="nc" id="L428">                                                     column, e.getType()));</span>
<span class="nc" id="L429">                return;</span>
            }

            // Something has happened to the data that may have invalidated the row order. 
<span class="nc" id="L433">            clearSortingState();</span>
<span class="nc" id="L434">            fireTableDataChanged();</span>
<span class="nc" id="L435">            return;</span>
        }
    }

<span class="nc" id="L439">    private class MouseHandler extends MouseAdapter {</span>
        public void mouseClicked(MouseEvent e) {
<span class="nc" id="L441">            JTableHeader h = (JTableHeader) e.getSource();</span>
<span class="nc" id="L442">            TableColumnModel columnModel = h.getColumnModel();</span>
<span class="nc" id="L443">            int viewColumn = columnModel.getColumnIndexAtX(e.getX());</span>
<span class="nc" id="L444">            int column = columnModel.getColumn(viewColumn).getModelIndex();</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">            if (column != -1) {</span>
<span class="nc" id="L446">                int status = getSortingStatus(column);</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                if (!e.isControlDown()) {</span>
<span class="nc" id="L448">                    cancelSorting();</span>
                }
                // Cycle the sorting states through {NOT_SORTED, ASCENDING, DESCENDING} or 
                // {NOT_SORTED, DESCENDING, ASCENDING} depending on whether shift is pressed. 
<span class="nc bnc" id="L452" title="All 2 branches missed.">                status = status + (e.isShiftDown() ? -1 : 1);</span>
<span class="nc" id="L453">                status = (status + 4) % 3 - 1; // signed mod, returning {-1, 0, 1}</span>
<span class="nc" id="L454">                setSortingStatus(column, status);</span>
            }
<span class="nc" id="L456">        }</span>
    }

    private static class Arrow implements Icon {
        private boolean descending;
        private int size;
        private int priority;

<span class="nc" id="L464">        public Arrow(boolean descending, int size, int priority) {</span>
<span class="nc" id="L465">            this.descending = descending;</span>
<span class="nc" id="L466">            this.size = size;</span>
<span class="nc" id="L467">            this.priority = priority;</span>
<span class="nc" id="L468">        }</span>

        public void paintIcon(Component c, Graphics g, int x, int y) {
<span class="nc bnc" id="L471" title="All 2 branches missed.">            Color color = c == null ? Color.GRAY : c.getBackground();             </span>
            // In a compound sort, make each succesive triangle 20% 
            // smaller than the previous one. 
<span class="nc" id="L474">            int dx = (int)(size/2*Math.pow(0.8, priority));</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">            int dy = descending ? dx : -dx;</span>
            // Align icon (roughly) with font baseline. 
<span class="nc bnc" id="L477" title="All 2 branches missed.">            y = y + 5*size/6 + (descending ? -dy : 0);</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">            int shift = descending ? 1 : -1;</span>
<span class="nc" id="L479">            g.translate(x, y);</span>

            // Right diagonal. 
<span class="nc" id="L482">            g.setColor(color.darker());</span>
<span class="nc" id="L483">            g.drawLine(dx / 2, dy, 0, 0);</span>
<span class="nc" id="L484">            g.drawLine(dx / 2, dy + shift, 0, shift);</span>
            
            // Left diagonal. 
<span class="nc" id="L487">            g.setColor(color.brighter());</span>
<span class="nc" id="L488">            g.drawLine(dx / 2, dy, dx, 0);</span>
<span class="nc" id="L489">            g.drawLine(dx / 2, dy + shift, dx, shift);</span>
            
            // Horizontal line. 
<span class="nc bnc" id="L492" title="All 2 branches missed.">            if (descending) {</span>
<span class="nc" id="L493">                g.setColor(color.darker().darker());</span>
            } else {
<span class="nc" id="L495">                g.setColor(color.brighter().brighter());</span>
            }
<span class="nc" id="L497">            g.drawLine(dx, 0, 0, 0);</span>

<span class="nc" id="L499">            g.setColor(color);</span>
<span class="nc" id="L500">            g.translate(-x, -y);</span>
<span class="nc" id="L501">        }</span>

        public int getIconWidth() {
<span class="nc" id="L504">            return size;</span>
        }

        public int getIconHeight() {
<span class="nc" id="L508">            return size;</span>
        }
    }

    private class SortableHeaderRenderer implements TableCellRenderer {
        private TableCellRenderer tableCellRenderer;

<span class="nc" id="L515">        public SortableHeaderRenderer(TableCellRenderer tableCellRenderer) {</span>
<span class="nc" id="L516">            this.tableCellRenderer = tableCellRenderer;</span>
<span class="nc" id="L517">        }</span>

        public Component getTableCellRendererComponent(JTable table, 
                                                       Object value,
                                                       boolean isSelected, 
                                                       boolean hasFocus,
                                                       int row, 
                                                       int column) {
<span class="nc" id="L525">            Component c = tableCellRenderer.getTableCellRendererComponent(table, </span>
                    value, isSelected, hasFocus, row, column);
<span class="nc bnc" id="L527" title="All 2 branches missed.">            if (c instanceof JLabel) {</span>
<span class="nc" id="L528">                JLabel l = (JLabel) c;</span>
<span class="nc" id="L529">                l.setHorizontalTextPosition(JLabel.LEFT);</span>
<span class="nc" id="L530">                int modelColumn = table.convertColumnIndexToModel(column);</span>
<span class="nc" id="L531">                l.setIcon(getHeaderRendererIcon(modelColumn, l.getFont().getSize()));</span>
            }
<span class="nc" id="L533">            return c;</span>
        }
    }

    private static class Directive {
        private int column;
        private int direction;

<span class="nc" id="L541">        public Directive(int column, int direction) {</span>
<span class="nc" id="L542">            this.column = column;</span>
<span class="nc" id="L543">            this.direction = direction;</span>
<span class="nc" id="L544">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>