<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MethodWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">51_jiprof</a> &gt; <a href="index.source.html" class="el_package">org.objectweb.asm.jip</a> &gt; <span class="el_source">MethodWriter.java</span></div><h1>MethodWriter.java</h1><pre class="source lang-java linenums">/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2007 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.objectweb.asm.jip;

/**
 * A {@link MethodVisitor} that generates methods in bytecode form. Each visit
 * method of this class appends the bytecode corresponding to the visited
 * instruction to a byte vector, in the order these methods are called.
 * 
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
class MethodWriter implements MethodVisitor {

    /**
     * Pseudo access flag used to denote constructors.
     */
    static final int ACC_CONSTRUCTOR = 262144;

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is zero.
     */
    static final int SAME_FRAME = 0; // to 63 (0-3f)

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is 1
     */
    static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64; // to 127 (40-7f)

    /**
     * Reserved for future use
     */
    static final int RESERVED = 128;

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is 1. Offset is bigger then 63;
     */
    static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247; // f7

    /**
     * Frame where current locals are the same as the locals in the previous
     * frame, except that the k last locals are absent. The value of k is given
     * by the formula 251-frame_type.
     */
    static final int CHOP_FRAME = 248; // to 250 (f8-fA)

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is zero. Offset is bigger then 63;
     */
    static final int SAME_FRAME_EXTENDED = 251; // fb

    /**
     * Frame where current locals are the same as the locals in the previous
     * frame, except that k additional locals are defined. The value of k is
     * given by the formula frame_type-251.
     */
    static final int APPEND_FRAME = 252; // to 254 // fc-fe

    /**
     * Full frame
     */
    static final int FULL_FRAME = 255; // ff

    /**
     * Indicates that the stack map frames must be recomputed from scratch. In
     * this case the maximum stack size and number of local variables is also
     * recomputed from scratch.
     * 
     * @see #compute
     */
    private static final int FRAMES = 0;

    /**
     * Indicates that the maximum stack size and number of local variables must
     * be automatically computed.
     * 
     * @see #compute
     */
    private static final int MAXS = 1;

    /**
     * Indicates that nothing must be automatically computed.
     * 
     * @see #compute
     */
    private static final int NOTHING = 2;

    /**
     * Next method writer (see {@link ClassWriter#firstMethod firstMethod}).
     */
    MethodWriter next;

    /**
     * The class writer to which this method must be added.
     */
    final ClassWriter cw;

    /**
     * Access flags of this method.
     */
    private int access;

    /**
     * The index of the constant pool item that contains the name of this
     * method.
     */
    private final int name;

    /**
     * The index of the constant pool item that contains the descriptor of this
     * method.
     */
    private final int desc;

    /**
     * The descriptor of this method.
     */
    private final String descriptor;

    /**
     * The signature of this method.
     */
    String signature;

    /**
     * If not zero, indicates that the code of this method must be copied from
     * the ClassReader associated to this writer in &lt;code&gt;cw.cr&lt;/code&gt;. More
     * precisely, this field gives the index of the first byte to copied from
     * &lt;code&gt;cw.cr.b&lt;/code&gt;.
     */
    int classReaderOffset;

    /**
     * If not zero, indicates that the code of this method must be copied from
     * the ClassReader associated to this writer in &lt;code&gt;cw.cr&lt;/code&gt;. More
     * precisely, this field gives the number of bytes to copied from
     * &lt;code&gt;cw.cr.b&lt;/code&gt;.
     */
    int classReaderLength;

    /**
     * Number of exceptions that can be thrown by this method.
     */
    int exceptionCount;

    /**
     * The exceptions that can be thrown by this method. More precisely, this
     * array contains the indexes of the constant pool items that contain the
     * internal names of these exception classes.
     */
    int[] exceptions;

    /**
     * The annotation default attribute of this method. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private ByteVector annd;

    /**
     * The runtime visible annotations of this method. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter anns;

    /**
     * The runtime invisible annotations of this method. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter ianns;

    /**
     * The runtime visible parameter annotations of this method. May be
     * &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter[] panns;

    /**
     * The runtime invisible parameter annotations of this method. May be
     * &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter[] ipanns;

    /**
     * The number of synthetic parameters of this method.
     */
    private int synthetics;

    /**
     * The non standard attributes of the method.
     */
    private Attribute attrs;

    /**
     * The bytecode of this method.
     */
<span class="fc" id="L224">    private ByteVector code = new ByteVector();</span>

    /**
     * Maximum stack size of this method.
     */
    private int maxStack;

    /**
     * Maximum number of local variables for this method.
     */
    private int maxLocals;

    /**
     * Number of stack map frames in the StackMapTable attribute.
     */
    private int frameCount;

    /**
     * The StackMapTable attribute.
     */
    private ByteVector stackMap;

    /**
     * The offset of the last frame that was written in the StackMapTable
     * attribute.
     */
    private int previousFrameOffset;

    /**
     * The last frame that was written in the StackMapTable attribute.
     * 
     * @see #frame
     */
    private int[] previousFrame;

    /**
     * Index of the next element to be added in {@link #frame}.
     */
    private int frameIndex;

    /**
     * The current stack map frame. The first element contains the offset of the
     * instruction to which the frame corresponds, the second element is the
     * number of locals and the third one is the number of stack elements. The
     * local variables start at index 3 and are followed by the operand stack
     * values. In summary frame[0] = offset, frame[1] = nLocal, frame[2] =
     * nStack, frame[3] = nLocal. All types are encoded as integers, with the
     * same format as the one used in {@link Label}, but limited to BASE types.
     */
    private int[] frame;

    /**
     * Number of elements in the exception handler list.
     */
    private int handlerCount;

    /**
     * The first element in the exception handler list.
     */
    private Handler firstHandler;

    /**
     * The last element in the exception handler list.
     */
    private Handler lastHandler;

    /**
     * Number of entries in the LocalVariableTable attribute.
     */
    private int localVarCount;

    /**
     * The LocalVariableTable attribute.
     */
    private ByteVector localVar;

    /**
     * Number of entries in the LocalVariableTypeTable attribute.
     */
    private int localVarTypeCount;

    /**
     * The LocalVariableTypeTable attribute.
     */
    private ByteVector localVarType;

    /**
     * Number of entries in the LineNumberTable attribute.
     */
    private int lineNumberCount;

    /**
     * The LineNumberTable attribute.
     */
    private ByteVector lineNumber;

    /**
     * The non standard attributes of the method's code.
     */
    private Attribute cattrs;

    /**
     * Indicates if some jump instructions are too small and need to be resized.
     */
    private boolean resize;

    /**
     * The number of subroutines in this method.
     */
    private int subroutines;

    // ------------------------------------------------------------------------

    /*
     * Fields for the control flow graph analysis algorithm (used to compute the
     * maximum stack size). A control flow graph contains one node per &quot;basic
     * block&quot;, and one edge per &quot;jump&quot; from one basic block to another. Each
     * node (i.e., each basic block) is represented by the Label object that
     * corresponds to the first instruction of this basic block. Each node also
     * stores the list of its successors in the graph, as a linked list of Edge
     * objects.
     */

    /**
     * Indicates what must be automatically computed.
     * 
     * @see #FRAMES
     * @see #MAXS
     * @see #NOTHING
     */
    private final int compute;

    /**
     * A list of labels. This list is the list of basic blocks in the method,
     * i.e. a list of Label objects linked to each other by their
     * {@link Label#successor} field, in the order they are visited by
     * {@link MethodVisitor#visitLabel}, and starting with the first basic block.
     */
    private Label labels;

    /**
     * The previous basic block.
     */
    private Label previousBlock;

    /**
     * The current basic block.
     */
    private Label currentBlock;

    /**
     * The (relative) stack size after the last visited instruction. This size
     * is relative to the beginning of the current basic block, i.e., the true
     * stack size after the last visited instruction is equal to the
     * {@link Label#inputStackTop beginStackSize} of the current basic block
     * plus &lt;tt&gt;stackSize&lt;/tt&gt;.
     */
    private int stackSize;

    /**
     * The (relative) maximum stack size after the last visited instruction.
     * This size is relative to the beginning of the current basic block, i.e.,
     * the true maximum stack size after the last visited instruction is equal
     * to the {@link Label#inputStackTop beginStackSize} of the current basic
     * block plus &lt;tt&gt;stackSize&lt;/tt&gt;.
     */
    private int maxStackSize;

    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------

    /**
     * Constructs a new {@link MethodWriter}.
     * 
     * @param cw the class writer in which the method must be added.
     * @param access the method's access flags (see {@link Opcodes}).
     * @param name the method's name.
     * @param desc the method's descriptor (see {@link Type}).
     * @param signature the method's signature. May be &lt;tt&gt;null&lt;/tt&gt;.
     * @param exceptions the internal names of the method's exceptions. May be
     *        &lt;tt&gt;null&lt;/tt&gt;.
     * @param computeMaxs &lt;tt&gt;true&lt;/tt&gt; if the maximum stack size and number
     *        of local variables must be automatically computed.
     * @param computeFrames &lt;tt&gt;true&lt;/tt&gt; if the stack map tables must be
     *        recomputed from scratch.
     */
    MethodWriter(
        final ClassWriter cw,
        final int access,
        final String name,
        final String desc,
        final String signature,
        final String[] exceptions,
        final boolean computeMaxs,
        final boolean computeFrames)
<span class="fc" id="L420">    {</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">        if (cw.firstMethod == null) {</span>
<span class="fc" id="L422">            cw.firstMethod = this;</span>
        } else {
<span class="fc" id="L424">            cw.lastMethod.next = this;</span>
        }
<span class="fc" id="L426">        cw.lastMethod = this;</span>
<span class="fc" id="L427">        this.cw = cw;</span>
<span class="fc" id="L428">        this.access = access;</span>
<span class="fc" id="L429">        this.name = cw.newUTF8(name);</span>
<span class="fc" id="L430">        this.desc = cw.newUTF8(desc);</span>
<span class="fc" id="L431">        this.descriptor = desc;</span>
        if (ClassReader.SIGNATURES) {
<span class="fc" id="L433">            this.signature = signature;</span>
        }
<span class="fc bfc" id="L435" title="All 4 branches covered.">        if (exceptions != null &amp;&amp; exceptions.length &gt; 0) {</span>
<span class="fc" id="L436">            exceptionCount = exceptions.length;</span>
<span class="fc" id="L437">            this.exceptions = new int[exceptionCount];</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">            for (int i = 0; i &lt; exceptionCount; ++i) {</span>
<span class="fc" id="L439">                this.exceptions[i] = cw.newClass(exceptions[i]);</span>
            }
        }
<span class="fc bfc" id="L442" title="All 4 branches covered.">        this.compute = computeFrames ? FRAMES : (computeMaxs ? MAXS : NOTHING);</span>
<span class="fc bfc" id="L443" title="All 4 branches covered.">        if (computeMaxs || computeFrames) {</span>
<span class="fc bfc" id="L444" title="All 4 branches covered.">            if (computeFrames &amp;&amp; &quot;&lt;init&gt;&quot;.equals(name)) {</span>
<span class="fc" id="L445">                this.access |= ACC_CONSTRUCTOR;</span>
            }
            // updates maxLocals
<span class="fc" id="L448">            int size = Type.getArgumentsAndReturnSizes(descriptor) &gt;&gt; 2;</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">            if ((access &amp; Opcodes.ACC_STATIC) != 0) {</span>
<span class="fc" id="L450">                --size;</span>
            }
<span class="fc" id="L452">            maxLocals = size;</span>
            // creates and visits the label for the first basic block
<span class="fc" id="L454">            labels = new Label();</span>
<span class="fc" id="L455">            labels.status |= Label.PUSHED;</span>
<span class="fc" id="L456">            visitLabel(labels);</span>
        }
<span class="fc" id="L458">    }</span>

    // ------------------------------------------------------------------------
    // Implementation of the MethodVisitor interface
    // ------------------------------------------------------------------------

    public AnnotationVisitor visitAnnotationDefault() {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="fc" id="L468">        annd = new ByteVector();</span>
<span class="fc" id="L469">        return new AnnotationWriter(cw, false, annd, null, 0);</span>
    }

    public AnnotationVisitor visitAnnotation(
        final String desc,
        final boolean visible)
    {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="fc" id="L479">        ByteVector bv = new ByteVector();</span>
        // write type, and reserve space for values count
<span class="fc" id="L481">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="fc" id="L482">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (visible) {</span>
<span class="fc" id="L484">            aw.next = anns;</span>
<span class="fc" id="L485">            anns = aw;</span>
        } else {
<span class="fc" id="L487">            aw.next = ianns;</span>
<span class="fc" id="L488">            ianns = aw;</span>
        }
<span class="fc" id="L490">        return aw;</span>
    }

    public AnnotationVisitor visitParameterAnnotation(
        final int parameter,
        final String desc,
        final boolean visible)
    {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="fc" id="L501">        ByteVector bv = new ByteVector();</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">        if (&quot;Ljava/lang/Synthetic;&quot;.equals(desc)) {</span>
            // workaround for a bug in javac with synthetic parameters
            // see ClassReader.readParameterAnnotations
<span class="fc" id="L505">            synthetics = Math.max(synthetics, parameter + 1);</span>
<span class="fc" id="L506">            return new AnnotationWriter(cw, false, bv, null, 0);</span>
        }
        // write type, and reserve space for values count
<span class="fc" id="L509">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="fc" id="L510">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">        if (visible) {</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">            if (panns == null) {</span>
<span class="fc" id="L513">                panns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];</span>
            }
<span class="nc" id="L515">            aw.next = panns[parameter];</span>
<span class="nc" id="L516">            panns[parameter] = aw;</span>
        } else {
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">            if (ipanns == null) {</span>
<span class="fc" id="L519">                ipanns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];</span>
            }
<span class="nc" id="L521">            aw.next = ipanns[parameter];</span>
<span class="nc" id="L522">            ipanns[parameter] = aw;</span>
        }
<span class="nc" id="L524">        return aw;</span>
    }

    public void visitAttribute(final Attribute attr) {
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if (attr.isCodeAttribute()) {</span>
<span class="nc" id="L529">            attr.next = cattrs;</span>
<span class="nc" id="L530">            cattrs = attr;</span>
        } else {
<span class="nc" id="L532">            attr.next = attrs;</span>
<span class="nc" id="L533">            attrs = attr;</span>
        }
<span class="nc" id="L535">    }</span>

    public void visitCode() {
<span class="fc" id="L538">    }</span>

    public void visitFrame(
        final int type,
        final int nLocal,
        final Object[] local,
        final int nStack,
        final Object[] stack)
    {
<span class="fc bfc" id="L547" title="All 2 branches covered.">        if (!ClassReader.FRAMES || compute == FRAMES) {</span>
<span class="fc" id="L548">            return;</span>
        }

<span class="fc bfc" id="L551" title="All 2 branches covered.">        if (type == Opcodes.F_NEW) {</span>
<span class="fc" id="L552">            startFrame(code.length, nLocal, nStack);</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">            for (int i = 0; i &lt; nLocal; ++i) {</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">                if (local[i] instanceof String) {</span>
<span class="fc" id="L555">                    frame[frameIndex++] = Frame.OBJECT</span>
<span class="fc" id="L556">                            | cw.addType((String) local[i]);</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                } else if (local[i] instanceof Integer) {</span>
<span class="nc" id="L558">                    frame[frameIndex++] = ((Integer) local[i]).intValue();</span>
                } else {
<span class="nc" id="L560">                    frame[frameIndex++] = Frame.UNINITIALIZED</span>
<span class="nc" id="L561">                            | cw.addUninitializedType(&quot;&quot;,</span>
                                    ((Label) local[i]).position);
                }
            }
<span class="fc bfc" id="L565" title="All 2 branches covered.">            for (int i = 0; i &lt; nStack; ++i) {</span>
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">                if (stack[i] instanceof String) {</span>
<span class="fc" id="L567">                    frame[frameIndex++] = Frame.OBJECT</span>
<span class="fc" id="L568">                            | cw.addType((String) stack[i]);</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">                } else if (stack[i] instanceof Integer) {</span>
<span class="nc" id="L570">                    frame[frameIndex++] = ((Integer) stack[i]).intValue();</span>
                } else {
<span class="nc" id="L572">                    frame[frameIndex++] = Frame.UNINITIALIZED</span>
<span class="nc" id="L573">                            | cw.addUninitializedType(&quot;&quot;,</span>
                                    ((Label) stack[i]).position);
                }
            }
<span class="fc" id="L577">            endFrame();</span>
        } else {
            int delta;
<span class="fc bfc" id="L580" title="All 2 branches covered.">            if (stackMap == null) {</span>
<span class="fc" id="L581">                stackMap = new ByteVector();</span>
<span class="fc" id="L582">                delta = code.length;</span>
            } else {
<span class="fc" id="L584">                delta = code.length - previousFrameOffset - 1;</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">                if (delta &lt; 0) {</span>
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">                    if (type == Opcodes.F_SAME) {</span>
<span class="fc" id="L587">                        return;</span>
                    } else {
<span class="nc" id="L589">                        throw new IllegalStateException();</span>
                    }
                }
            }

<span class="fc bfc" id="L594" title="All 6 branches covered.">            switch (type) {</span>
                case Opcodes.F_FULL:
<span class="fc" id="L596">                    stackMap.putByte(FULL_FRAME)</span>
<span class="fc" id="L597">                            .putShort(delta)</span>
<span class="fc" id="L598">                            .putShort(nLocal);</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">                    for (int i = 0; i &lt; nLocal; ++i) {</span>
<span class="fc" id="L600">                        writeFrameType(local[i]);</span>
                    }
<span class="fc" id="L602">                    stackMap.putShort(nStack);</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">                    for (int i = 0; i &lt; nStack; ++i) {</span>
<span class="fc" id="L604">                        writeFrameType(stack[i]);</span>
                    }
<span class="fc" id="L606">                    break;</span>
                case Opcodes.F_APPEND:
<span class="fc" id="L608">                    stackMap.putByte(SAME_FRAME_EXTENDED + nLocal)</span>
<span class="fc" id="L609">                            .putShort(delta);</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">                    for (int i = 0; i &lt; nLocal; ++i) {</span>
<span class="fc" id="L611">                        writeFrameType(local[i]);</span>
                    }
<span class="fc" id="L613">                    break;</span>
                case Opcodes.F_CHOP:
<span class="fc" id="L615">                    stackMap.putByte(SAME_FRAME_EXTENDED - nLocal)</span>
<span class="fc" id="L616">                            .putShort(delta);</span>
<span class="fc" id="L617">                    break;</span>
                case Opcodes.F_SAME:
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">                    if (delta &lt; 64) {</span>
<span class="fc" id="L620">                        stackMap.putByte(delta);</span>
                    } else {
<span class="nc" id="L622">                        stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);</span>
                    }
<span class="nc" id="L624">                    break;</span>
                case Opcodes.F_SAME1:
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">                    if (delta &lt; 64) {</span>
<span class="fc" id="L627">                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);</span>
                    } else {
<span class="nc" id="L629">                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)</span>
<span class="nc" id="L630">                                .putShort(delta);</span>
                    }
<span class="fc" id="L632">                    writeFrameType(stack[0]);</span>
                    break;
            }

<span class="fc" id="L636">            previousFrameOffset = code.length;</span>
<span class="fc" id="L637">            ++frameCount;</span>
        }
<span class="fc" id="L639">    }</span>

    public void visitInsn(final int opcode) {
        // adds the instruction to the bytecode of the method
<span class="fc" id="L643">        code.putByte(opcode);</span>
        // update currentBlock
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L646" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L648">                currentBlock.frame.execute(opcode, 0, null, null);</span>
            } else {
                // updates current and max stack sizes
<span class="fc" id="L651">                int size = stackSize + Frame.SIZE[opcode];</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">                if (size &gt; maxStackSize) {</span>
<span class="fc" id="L653">                    maxStackSize = size;</span>
                }
<span class="fc" id="L655">                stackSize = size;</span>
            }
            // if opcode == ATHROW or xRETURN, ends current block (no successor)
<span class="fc bfc" id="L658" title="All 6 branches covered.">            if ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN)</span>
                    || opcode == Opcodes.ATHROW)
            {
<span class="fc" id="L661">                noSuccessor();</span>
            }
        }
<span class="fc" id="L664">    }</span>

    public void visitIntInsn(final int opcode, final int operand) {
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L668" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L670">                currentBlock.frame.execute(opcode, operand, null, null);</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">            } else if (opcode != Opcodes.NEWARRAY) {</span>
                // updates current and max stack sizes only for NEWARRAY
                // (stack size variation = 0 for BIPUSH or SIPUSH)
<span class="fc" id="L674">                int size = stackSize + 1;</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">                if (size &gt; maxStackSize) {</span>
<span class="fc" id="L676">                    maxStackSize = size;</span>
                }
<span class="fc" id="L678">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc bfc" id="L682" title="All 2 branches covered.">        if (opcode == Opcodes.SIPUSH) {</span>
<span class="fc" id="L683">            code.put12(opcode, operand);</span>
        } else { // BIPUSH or NEWARRAY
<span class="fc" id="L685">            code.put11(opcode, operand);</span>
        }
<span class="fc" id="L687">    }</span>

    public void visitVarInsn(final int opcode, final int var) {
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L691" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L693">                currentBlock.frame.execute(opcode, var, null, null);</span>
            } else {
                // updates current and max stack sizes
<span class="fc bfc" id="L696" title="All 2 branches covered.">                if (opcode == Opcodes.RET) {</span>
                    // no stack change, but end of current block (no successor)
<span class="fc" id="L698">                    currentBlock.status |= Label.RET;</span>
                    // save 'stackSize' here for future use
                    // (see {@link #findSubroutineSuccessors})
<span class="fc" id="L701">                    currentBlock.inputStackTop = stackSize;</span>
<span class="fc" id="L702">                    noSuccessor();</span>
                } else { // xLOAD or xSTORE
<span class="fc" id="L704">                    int size = stackSize + Frame.SIZE[opcode];</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">                    if (size &gt; maxStackSize) {</span>
<span class="fc" id="L706">                        maxStackSize = size;</span>
                    }
<span class="fc" id="L708">                    stackSize = size;</span>
                }
            }
        }
<span class="fc bfc" id="L712" title="All 2 branches covered.">        if (compute != NOTHING) {</span>
            // updates max locals
            int n;
<span class="fc bfc" id="L715" title="All 8 branches covered.">            if (opcode == Opcodes.LLOAD || opcode == Opcodes.DLOAD</span>
                    || opcode == Opcodes.LSTORE || opcode == Opcodes.DSTORE)
            {
<span class="fc" id="L718">                n = var + 2;</span>
            } else {
<span class="fc" id="L720">                n = var + 1;</span>
            }
<span class="fc bfc" id="L722" title="All 2 branches covered.">            if (n &gt; maxLocals) {</span>
<span class="fc" id="L723">                maxLocals = n;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="pc bpc" id="L727" title="1 of 4 branches missed.">        if (var &lt; 4 &amp;&amp; opcode != Opcodes.RET) {</span>
            int opt;
<span class="fc bfc" id="L729" title="All 2 branches covered.">            if (opcode &lt; Opcodes.ISTORE) {</span>
                /* ILOAD_0 */
<span class="fc" id="L731">                opt = 26 + ((opcode - Opcodes.ILOAD) &lt;&lt; 2) + var;</span>
            } else {
                /* ISTORE_0 */
<span class="fc" id="L734">                opt = 59 + ((opcode - Opcodes.ISTORE) &lt;&lt; 2) + var;</span>
            }
<span class="fc" id="L736">            code.putByte(opt);</span>
<span class="fc bfc" id="L737" title="All 2 branches covered.">        } else if (var &gt;= 256) {</span>
<span class="fc" id="L738">            code.putByte(196 /* WIDE */).put12(opcode, var);</span>
        } else {
<span class="fc" id="L740">            code.put11(opcode, var);</span>
        }
<span class="fc bfc" id="L742" title="All 6 branches covered.">        if (opcode &gt;= Opcodes.ISTORE &amp;&amp; compute == FRAMES &amp;&amp; handlerCount &gt; 0) {</span>
<span class="fc" id="L743">            visitLabel(new Label());</span>
        }
<span class="fc" id="L745">    }</span>

    public void visitTypeInsn(final int opcode, final String type) {
<span class="fc" id="L748">        Item i = cw.newClassItem(type);</span>
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L750" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L752">                currentBlock.frame.execute(opcode, code.length, cw, i);</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">            } else if (opcode == Opcodes.NEW) {</span>
                // updates current and max stack sizes only if opcode == NEW
                // (no stack change for ANEWARRAY, CHECKCAST, INSTANCEOF)
<span class="fc" id="L756">                int size = stackSize + 1;</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">                if (size &gt; maxStackSize) {</span>
<span class="fc" id="L758">                    maxStackSize = size;</span>
                }
<span class="fc" id="L760">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc" id="L764">        code.put12(opcode, i.index);</span>
<span class="fc" id="L765">    }</span>

    public void visitFieldInsn(
        final int opcode,
        final String owner,
        final String name,
        final String desc)
    {
<span class="fc" id="L773">        Item i = cw.newFieldItem(owner, name, desc);</span>
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L775" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L777">                currentBlock.frame.execute(opcode, 0, cw, i);</span>
            } else {
                int size;
                // computes the stack size variation
<span class="fc" id="L781">                char c = desc.charAt(0);</span>
<span class="fc bfc" id="L782" title="All 4 branches covered.">                switch (opcode) {</span>
                    case Opcodes.GETSTATIC:
<span class="pc bpc" id="L784" title="2 of 4 branches missed.">                        size = stackSize + (c == 'D' || c == 'J' ? 2 : 1);</span>
<span class="fc" id="L785">                        break;</span>
                    case Opcodes.PUTSTATIC:
<span class="pc bpc" id="L787" title="2 of 4 branches missed.">                        size = stackSize + (c == 'D' || c == 'J' ? -2 : -1);</span>
<span class="fc" id="L788">                        break;</span>
                    case Opcodes.GETFIELD:
<span class="pc bpc" id="L790" title="2 of 4 branches missed.">                        size = stackSize + (c == 'D' || c == 'J' ? 1 : 0);</span>
<span class="fc" id="L791">                        break;</span>
                    // case Constants.PUTFIELD:
                    default:
<span class="fc bfc" id="L794" title="All 4 branches covered.">                        size = stackSize + (c == 'D' || c == 'J' ? -3 : -2);</span>
                        break;
                }
                // updates current and max stack sizes
<span class="fc bfc" id="L798" title="All 2 branches covered.">                if (size &gt; maxStackSize) {</span>
<span class="fc" id="L799">                    maxStackSize = size;</span>
                }
<span class="fc" id="L801">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc" id="L805">        code.put12(opcode, i.index);</span>
<span class="fc" id="L806">    }</span>

    public void visitMethodInsn(
        final int opcode,
        final String owner,
        final String name,
        final String desc)
    {
<span class="fc bfc" id="L814" title="All 2 branches covered.">        boolean itf = opcode == Opcodes.INVOKEINTERFACE;</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">        Item i = (opcode == Opcodes.INVOKEDYNAMIC) ?</span>
<span class="fc" id="L816">                cw.newNameTypeItem(name, desc):</span>
<span class="fc" id="L817">                cw.newMethodItem(owner, name, desc, itf);</span>
<span class="fc" id="L818">        int argSize = i.intVal;</span>
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L820" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L821" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L822">                currentBlock.frame.execute(opcode, 0, cw, i);</span>
            } else {
                /*
                 * computes the stack size variation. In order not to recompute
                 * several times this variation for the same Item, we use the
                 * intVal field of this item to store this variation, once it
                 * has been computed. More precisely this intVal field stores
                 * the sizes of the arguments and of the return value
                 * corresponding to desc.
                 */
<span class="fc bfc" id="L832" title="All 2 branches covered.">                if (argSize == 0) {</span>
                    // the above sizes have not been computed yet,
                    // so we compute them...
<span class="fc" id="L835">                    argSize = Type.getArgumentsAndReturnSizes(desc);</span>
                    // ... and we save them in order
                    // not to recompute them in the future
<span class="fc" id="L838">                    i.intVal = argSize;</span>
                }
                int size;
<span class="pc bpc" id="L841" title="1 of 4 branches missed.">                if (opcode == Opcodes.INVOKESTATIC || opcode == Opcodes.INVOKEDYNAMIC) {</span>
<span class="fc" id="L842">                    size = stackSize - (argSize &gt;&gt; 2) + (argSize &amp; 0x03) + 1;</span>
                } else {
<span class="fc" id="L844">                    size = stackSize - (argSize &gt;&gt; 2) + (argSize &amp; 0x03);</span>
                }
                // updates current and max stack sizes
<span class="fc bfc" id="L847" title="All 2 branches covered.">                if (size &gt; maxStackSize) {</span>
<span class="fc" id="L848">                    maxStackSize = size;</span>
                }
<span class="fc" id="L850">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc bfc" id="L854" title="All 2 branches covered.">        if (itf) {</span>
<span class="fc bfc" id="L855" title="All 2 branches covered.">            if (argSize == 0) {</span>
<span class="fc" id="L856">                argSize = Type.getArgumentsAndReturnSizes(desc);</span>
<span class="fc" id="L857">                i.intVal = argSize;</span>
            }
<span class="fc" id="L859">            code.put12(Opcodes.INVOKEINTERFACE, i.index).put11(argSize &gt;&gt; 2, 0);</span>
        } else {
<span class="fc" id="L861">            code.put12(opcode, i.index);</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">            if (opcode==Opcodes.INVOKEDYNAMIC) {</span>
<span class="fc" id="L863">                code.putShort(0);</span>
            }
        }
<span class="fc" id="L866">    }</span>

    public void visitJumpInsn(final int opcode, final Label label) {
<span class="fc" id="L869">        Label nextInsn = null;</span>
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L871" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L873">                currentBlock.frame.execute(opcode, 0, null, null);</span>
                // 'label' is the target of a jump instruction
<span class="fc" id="L875">                label.getFirst().status |= Label.TARGET;</span>
                // adds 'label' as a successor of this basic block
<span class="fc" id="L877">                addSuccessor(Edge.NORMAL, label);</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">                if (opcode != Opcodes.GOTO) {</span>
                    // creates a Label for the next basic block
<span class="fc" id="L880">                    nextInsn = new Label();</span>
                }
            } else {
<span class="fc bfc" id="L883" title="All 2 branches covered.">                if (opcode == Opcodes.JSR) {</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">                    if ((label.status &amp; Label.SUBROUTINE) == 0) {</span>
<span class="fc" id="L885">                        label.status |= Label.SUBROUTINE;</span>
<span class="fc" id="L886">                        ++subroutines;</span>
                    }
<span class="fc" id="L888">                    currentBlock.status |= Label.JSR;</span>
<span class="fc" id="L889">                    addSuccessor(stackSize + 1, label);</span>
                    // creates a Label for the next basic block
<span class="fc" id="L891">                    nextInsn = new Label();</span>
                    /*
                     * note that, by construction in this method, a JSR block
                     * has at least two successors in the control flow graph:
                     * the first one leads the next instruction after the JSR,
                     * while the second one leads to the JSR target.
                     */
                } else {
                    // updates current stack size (max stack size unchanged
                    // because stack size variation always negative in this
                    // case)
<span class="fc" id="L902">                    stackSize += Frame.SIZE[opcode];</span>
<span class="fc" id="L903">                    addSuccessor(stackSize, label);</span>
                }
            }
        }
        // adds the instruction to the bytecode of the method
<span class="pc bpc" id="L908" title="1 of 4 branches missed.">        if ((label.status &amp; Label.RESOLVED) != 0</span>
                &amp;&amp; label.position - code.length &lt; Short.MIN_VALUE)
        {
            /*
             * case of a backward jump with an offset &lt; -32768. In this case we
             * automatically replace GOTO with GOTO_W, JSR with JSR_W and IFxxx
             * &lt;l&gt; with IFNOTxxx &lt;l'&gt; GOTO_W &lt;l&gt;, where IFNOTxxx is the
             * &quot;opposite&quot; opcode of IFxxx (i.e., IFNE for IFEQ) and where &lt;l'&gt;
             * designates the instruction just after the GOTO_W.
             */
<span class="nc bnc" id="L918" title="All 2 branches missed.">            if (opcode == Opcodes.GOTO) {</span>
<span class="nc" id="L919">                code.putByte(200); // GOTO_W</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">            } else if (opcode == Opcodes.JSR) {</span>
<span class="nc" id="L921">                code.putByte(201); // JSR_W</span>
            } else {
                // if the IF instruction is transformed into IFNOT GOTO_W the
                // next instruction becomes the target of the IFNOT instruction
<span class="nc bnc" id="L925" title="All 2 branches missed.">                if (nextInsn != null) {</span>
<span class="nc" id="L926">                    nextInsn.status |= Label.TARGET;</span>
                }
<span class="nc bnc" id="L928" title="All 2 branches missed.">                code.putByte(opcode &lt;= 166</span>
                        ? ((opcode + 1) ^ 1) - 1
                        : opcode ^ 1);
<span class="nc" id="L931">                code.putShort(8); // jump offset</span>
<span class="nc" id="L932">                code.putByte(200); // GOTO_W</span>
            }
<span class="nc" id="L934">            label.put(this, code, code.length - 1, true);</span>
        } else {
            /*
             * case of a backward jump with an offset &gt;= -32768, or of a forward
             * jump with, of course, an unknown offset. In these cases we store
             * the offset in 2 bytes (which will be increased in
             * resizeInstructions, if needed).
             */
<span class="fc" id="L942">            code.putByte(opcode);</span>
<span class="fc" id="L943">            label.put(this, code, code.length - 1, false);</span>
        }
<span class="fc bfc" id="L945" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L946" title="All 2 branches covered.">            if (nextInsn != null) {</span>
                // if the jump instruction is not a GOTO, the next instruction
                // is also a successor of this instruction. Calling visitLabel
                // adds the label of this next instruction as a successor of the
                // current block, and starts a new basic block
<span class="fc" id="L951">                visitLabel(nextInsn);</span>
            }
<span class="fc bfc" id="L953" title="All 2 branches covered.">            if (opcode == Opcodes.GOTO) {</span>
<span class="fc" id="L954">                noSuccessor();</span>
            }
        }
<span class="fc" id="L957">    }</span>

    public void visitLabel(final Label label) {
        // resolves previous forward references to label, if any
<span class="fc" id="L961">        resize |= label.resolve(this, code.length, code.data);</span>
        // updates currentBlock
<span class="fc bfc" id="L963" title="All 2 branches covered.">        if ((label.status &amp; Label.DEBUG) != 0) {</span>
<span class="fc" id="L964">            return;</span>
        }
<span class="fc bfc" id="L966" title="All 2 branches covered.">        if (compute == FRAMES) {</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">            if (currentBlock != null) {</span>
<span class="fc bfc" id="L968" title="All 2 branches covered.">                if (label.position == currentBlock.position) {</span>
                    // successive labels, do not start a new basic block
<span class="fc" id="L970">                    currentBlock.status |= (label.status &amp; Label.TARGET);</span>
<span class="fc" id="L971">                    label.frame = currentBlock.frame;</span>
<span class="fc" id="L972">                    return;</span>
                }
                // ends current block (with one new successor)
<span class="fc" id="L975">                addSuccessor(Edge.NORMAL, label);</span>
            }
            // begins a new current block
<span class="fc" id="L978">            currentBlock = label;</span>
<span class="pc bpc" id="L979" title="1 of 2 branches missed.">            if (label.frame == null) {</span>
<span class="fc" id="L980">                label.frame = new Frame();</span>
<span class="fc" id="L981">                label.frame.owner = label;</span>
            }
            // updates the basic block list
<span class="fc bfc" id="L984" title="All 2 branches covered.">            if (previousBlock != null) {</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">                if (label.position == previousBlock.position) {</span>
<span class="fc" id="L986">                    previousBlock.status |= (label.status &amp; Label.TARGET);</span>
<span class="fc" id="L987">                    label.frame = previousBlock.frame;</span>
<span class="fc" id="L988">                    currentBlock = previousBlock;</span>
<span class="fc" id="L989">                    return;</span>
                }
<span class="fc" id="L991">                previousBlock.successor = label;</span>
            }
<span class="fc" id="L993">            previousBlock = label;</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">        } else if (compute == MAXS) {</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">            if (currentBlock != null) {</span>
                // ends current block (with one new successor)
<span class="fc" id="L997">                currentBlock.outputStackMax = maxStackSize;</span>
<span class="fc" id="L998">                addSuccessor(stackSize, label);</span>
            }
            // begins a new current block
<span class="fc" id="L1001">            currentBlock = label;</span>
            // resets the relative current and max stack sizes
<span class="fc" id="L1003">            stackSize = 0;</span>
<span class="fc" id="L1004">            maxStackSize = 0;</span>
            // updates the basic block list
<span class="fc bfc" id="L1006" title="All 2 branches covered.">            if (previousBlock != null) {</span>
<span class="fc" id="L1007">                previousBlock.successor = label;</span>
            }
<span class="fc" id="L1009">            previousBlock = label;</span>
        }
<span class="fc" id="L1011">    }</span>

    public void visitLdcInsn(final Object cst) {
<span class="fc" id="L1014">        Item i = cw.newConstItem(cst);</span>
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L1016" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L1017" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L1018">                currentBlock.frame.execute(Opcodes.LDC, 0, cw, i);</span>
            } else {
                int size;
                // computes the stack size variation
<span class="pc bpc" id="L1022" title="2 of 4 branches missed.">                if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE)</span>
                {
<span class="nc" id="L1024">                    size = stackSize + 2;</span>
                } else {
<span class="fc" id="L1026">                    size = stackSize + 1;</span>
                }
                // updates current and max stack sizes
<span class="fc bfc" id="L1029" title="All 2 branches covered.">                if (size &gt; maxStackSize) {</span>
<span class="fc" id="L1030">                    maxStackSize = size;</span>
                }
<span class="fc" id="L1032">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc" id="L1036">        int index = i.index;</span>
<span class="pc bpc" id="L1037" title="2 of 4 branches missed.">        if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {</span>
<span class="nc" id="L1038">            code.put12(20 /* LDC2_W */, index);</span>
<span class="fc bfc" id="L1039" title="All 2 branches covered.">        } else if (index &gt;= 256) {</span>
<span class="fc" id="L1040">            code.put12(19 /* LDC_W */, index);</span>
        } else {
<span class="fc" id="L1042">            code.put11(Opcodes.LDC, index);</span>
        }
<span class="fc" id="L1044">    }</span>

    public void visitIincInsn(final int var, final int increment) {
<span class="fc bfc" id="L1047" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L1048" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L1049">                currentBlock.frame.execute(Opcodes.IINC, var, null, null);</span>
            }
        }
<span class="fc bfc" id="L1052" title="All 2 branches covered.">        if (compute != NOTHING) {</span>
            // updates max locals
<span class="fc" id="L1054">            int n = var + 1;</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">            if (n &gt; maxLocals) {</span>
<span class="fc" id="L1056">                maxLocals = n;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="pc bpc" id="L1060" title="1 of 6 branches missed.">        if ((var &gt; 255) || (increment &gt; 127) || (increment &lt; -128)) {</span>
<span class="fc" id="L1061">            code.putByte(196 /* WIDE */)</span>
<span class="fc" id="L1062">                    .put12(Opcodes.IINC, var)</span>
<span class="fc" id="L1063">                    .putShort(increment);</span>
        } else {
<span class="fc" id="L1065">            code.putByte(Opcodes.IINC).put11(var, increment);</span>
        }
<span class="fc" id="L1067">    }</span>

    public void visitTableSwitchInsn(
        final int min,
        final int max,
        final Label dflt,
        final Label[] labels)
    {
        // adds the instruction to the bytecode of the method
<span class="fc" id="L1076">        int source = code.length;</span>
<span class="fc" id="L1077">        code.putByte(Opcodes.TABLESWITCH);</span>
<span class="fc" id="L1078">        code.putByteArray(null, 0, (4 - code.length % 4) % 4);</span>
<span class="fc" id="L1079">        dflt.put(this, code, source, true);</span>
<span class="fc" id="L1080">        code.putInt(min).putInt(max);</span>
<span class="fc bfc" id="L1081" title="All 2 branches covered.">        for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="fc" id="L1082">            labels[i].put(this, code, source, true);</span>
        }
        // updates currentBlock
<span class="fc" id="L1085">        visitSwitchInsn(dflt, labels);</span>
<span class="fc" id="L1086">    }</span>

    public void visitLookupSwitchInsn(
        final Label dflt,
        final int[] keys,
        final Label[] labels)
    {
        // adds the instruction to the bytecode of the method
<span class="nc" id="L1094">        int source = code.length;</span>
<span class="nc" id="L1095">        code.putByte(Opcodes.LOOKUPSWITCH);</span>
<span class="nc" id="L1096">        code.putByteArray(null, 0, (4 - code.length % 4) % 4);</span>
<span class="nc" id="L1097">        dflt.put(this, code, source, true);</span>
<span class="nc" id="L1098">        code.putInt(labels.length);</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">        for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="nc" id="L1100">            code.putInt(keys[i]);</span>
<span class="nc" id="L1101">            labels[i].put(this, code, source, true);</span>
        }
        // updates currentBlock
<span class="nc" id="L1104">        visitSwitchInsn(dflt, labels);</span>
<span class="nc" id="L1105">    }</span>

    private void visitSwitchInsn(final Label dflt, final Label[] labels) {
        // Label currentBlock = this.currentBlock;
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">        if (currentBlock != null) {</span>
<span class="pc bpc" id="L1110" title="1 of 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="fc" id="L1111">                currentBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);</span>
                // adds current block successors
<span class="fc" id="L1113">                addSuccessor(Edge.NORMAL, dflt);</span>
<span class="fc" id="L1114">                dflt.getFirst().status |= Label.TARGET;</span>
<span class="fc bfc" id="L1115" title="All 2 branches covered.">                for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="fc" id="L1116">                    addSuccessor(Edge.NORMAL, labels[i]);</span>
<span class="fc" id="L1117">                    labels[i].getFirst().status |= Label.TARGET;</span>
                }
            } else {
                // updates current stack size (max stack size unchanged)
<span class="nc" id="L1121">                --stackSize;</span>
                // adds current block successors
<span class="nc" id="L1123">                addSuccessor(stackSize, dflt);</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">                for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="nc" id="L1125">                    addSuccessor(stackSize, labels[i]);</span>
                }
            }
            // ends current block
<span class="fc" id="L1129">            noSuccessor();</span>
        }
<span class="fc" id="L1131">    }</span>

    public void visitMultiANewArrayInsn(final String desc, final int dims) {
<span class="fc" id="L1134">        Item i = cw.newClassItem(desc);</span>
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L1136" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L1137" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L1138">                currentBlock.frame.execute(Opcodes.MULTIANEWARRAY, dims, cw, i);</span>
            } else {
                // updates current stack size (max stack size unchanged because
                // stack size variation always negative or null)
<span class="fc" id="L1142">                stackSize += 1 - dims;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc" id="L1146">        code.put12(Opcodes.MULTIANEWARRAY, i.index).putByte(dims);</span>
<span class="fc" id="L1147">    }</span>

    public void visitTryCatchBlock(
        final Label start,
        final Label end,
        final Label handler,
        final String type)
    {
<span class="fc" id="L1155">        ++handlerCount;</span>
<span class="fc" id="L1156">        Handler h = new Handler();</span>
<span class="fc" id="L1157">        h.start = start;</span>
<span class="fc" id="L1158">        h.end = end;</span>
<span class="fc" id="L1159">        h.handler = handler;</span>
<span class="fc" id="L1160">        h.desc = type;</span>
<span class="fc bfc" id="L1161" title="All 2 branches covered.">        h.type = type != null ? cw.newClass(type) : 0;</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">        if (lastHandler == null) {</span>
<span class="fc" id="L1163">            firstHandler = h;</span>
        } else {
<span class="fc" id="L1165">            lastHandler.next = h;</span>
        }
<span class="fc" id="L1167">        lastHandler = h;</span>
<span class="fc" id="L1168">    }</span>

    public void visitLocalVariable(
        final String name,
        final String desc,
        final String signature,
        final Label start,
        final Label end,
        final int index)
    {
<span class="fc bfc" id="L1178" title="All 2 branches covered.">        if (signature != null) {</span>
<span class="fc bfc" id="L1179" title="All 2 branches covered.">            if (localVarType == null) {</span>
<span class="fc" id="L1180">                localVarType = new ByteVector();</span>
            }
<span class="fc" id="L1182">            ++localVarTypeCount;</span>
<span class="fc" id="L1183">            localVarType.putShort(start.position)</span>
<span class="fc" id="L1184">                    .putShort(end.position - start.position)</span>
<span class="fc" id="L1185">                    .putShort(cw.newUTF8(name))</span>
<span class="fc" id="L1186">                    .putShort(cw.newUTF8(signature))</span>
<span class="fc" id="L1187">                    .putShort(index);</span>
        }
<span class="fc bfc" id="L1189" title="All 2 branches covered.">        if (localVar == null) {</span>
<span class="fc" id="L1190">            localVar = new ByteVector();</span>
        }
<span class="fc" id="L1192">        ++localVarCount;</span>
<span class="fc" id="L1193">        localVar.putShort(start.position)</span>
<span class="fc" id="L1194">                .putShort(end.position - start.position)</span>
<span class="fc" id="L1195">                .putShort(cw.newUTF8(name))</span>
<span class="fc" id="L1196">                .putShort(cw.newUTF8(desc))</span>
<span class="fc" id="L1197">                .putShort(index);</span>
<span class="fc bfc" id="L1198" title="All 2 branches covered.">        if (compute != NOTHING) {</span>
            // updates max locals
<span class="fc" id="L1200">            char c = desc.charAt(0);</span>
<span class="fc bfc" id="L1201" title="All 4 branches covered.">            int n = index + (c == 'J' || c == 'D' ? 2 : 1);</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">            if (n &gt; maxLocals) {</span>
<span class="fc" id="L1203">                maxLocals = n;</span>
            }
        }
<span class="fc" id="L1206">    }</span>

    public void visitLineNumber(final int line, final Label start) {
<span class="fc bfc" id="L1209" title="All 2 branches covered.">        if (lineNumber == null) {</span>
<span class="fc" id="L1210">            lineNumber = new ByteVector();</span>
        }
<span class="fc" id="L1212">        ++lineNumberCount;</span>
<span class="fc" id="L1213">        lineNumber.putShort(start.position);</span>
<span class="fc" id="L1214">        lineNumber.putShort(line);</span>
<span class="fc" id="L1215">    }</span>

    public void visitMaxs(final int maxStack, final int maxLocals) {
<span class="fc bfc" id="L1218" title="All 2 branches covered.">        if (ClassReader.FRAMES &amp;&amp; compute == FRAMES) {</span>
            // completes the control flow graph with exception handler blocks
<span class="fc" id="L1220">            Handler handler = firstHandler;</span>
<span class="fc bfc" id="L1221" title="All 2 branches covered.">            while (handler != null) {</span>
<span class="fc" id="L1222">                Label l = handler.start.getFirst();</span>
<span class="fc" id="L1223">                Label h = handler.handler.getFirst();</span>
<span class="fc" id="L1224">                Label e = handler.end.getFirst();</span>
                // computes the kind of the edges to 'h'
<span class="fc bfc" id="L1226" title="All 2 branches covered.">                String t = handler.desc == null</span>
                        ? &quot;java/lang/Throwable&quot;
                        : handler.desc;
<span class="fc" id="L1229">                int kind = Frame.OBJECT | cw.addType(t);</span>
                // h is an exception handler
<span class="fc" id="L1231">                h.status |= Label.TARGET;</span>
                // adds 'h' as a successor of labels between 'start' and 'end'
<span class="fc bfc" id="L1233" title="All 2 branches covered.">                while (l != e) {</span>
                    // creates an edge to 'h'
<span class="fc" id="L1235">                    Edge b = new Edge();</span>
<span class="fc" id="L1236">                    b.info = kind;</span>
<span class="fc" id="L1237">                    b.successor = h;</span>
                    // adds it to the successors of 'l'
<span class="fc" id="L1239">                    b.next = l.successors;</span>
<span class="fc" id="L1240">                    l.successors = b;</span>
                    // goes to the next label
<span class="fc" id="L1242">                    l = l.successor;</span>
<span class="fc" id="L1243">                }</span>
<span class="fc" id="L1244">                handler = handler.next;</span>
<span class="fc" id="L1245">            }</span>

            // creates and visits the first (implicit) frame
<span class="fc" id="L1248">            Frame f = labels.frame;</span>
<span class="fc" id="L1249">            Type[] args = Type.getArgumentTypes(descriptor);</span>
<span class="fc" id="L1250">            f.initInputFrame(cw, access, args, this.maxLocals);</span>
<span class="fc" id="L1251">            visitFrame(f);</span>

            /*
             * fix point algorithm: mark the first basic block as 'changed'
             * (i.e. put it in the 'changed' list) and, while there are changed
             * basic blocks, choose one, mark it as unchanged, and update its
             * successors (which can be changed in the process).
             */
<span class="fc" id="L1259">            int max = 0;</span>
<span class="fc" id="L1260">            Label changed = labels;</span>
<span class="fc bfc" id="L1261" title="All 2 branches covered.">            while (changed != null) {</span>
                // removes a basic block from the list of changed basic blocks
<span class="fc" id="L1263">                Label l = changed;</span>
<span class="fc" id="L1264">                changed = changed.next;</span>
<span class="fc" id="L1265">                l.next = null;</span>
<span class="fc" id="L1266">                f = l.frame;</span>
                // a reachable jump target must be stored in the stack map
<span class="fc bfc" id="L1268" title="All 2 branches covered.">                if ((l.status &amp; Label.TARGET) != 0) {</span>
<span class="fc" id="L1269">                    l.status |= Label.STORE;</span>
                }
                // all visited labels are reachable, by definition
<span class="fc" id="L1272">                l.status |= Label.REACHABLE;</span>
                // updates the (absolute) maximum stack size
<span class="fc" id="L1274">                int blockMax = f.inputStack.length + l.outputStackMax;</span>
<span class="fc bfc" id="L1275" title="All 2 branches covered.">                if (blockMax &gt; max) {</span>
<span class="fc" id="L1276">                    max = blockMax;</span>
                }
                // updates the successors of the current basic block
<span class="fc" id="L1279">                Edge e = l.successors;</span>
<span class="fc bfc" id="L1280" title="All 2 branches covered.">                while (e != null) {</span>
<span class="fc" id="L1281">                    Label n = e.successor.getFirst();</span>
<span class="fc" id="L1282">                    boolean change = f.merge(cw, n.frame, e.info);</span>
<span class="fc bfc" id="L1283" title="All 4 branches covered.">                    if (change &amp;&amp; n.next == null) {</span>
                        // if n has changed and is not already in the 'changed'
                        // list, adds it to this list
<span class="fc" id="L1286">                        n.next = changed;</span>
<span class="fc" id="L1287">                        changed = n;</span>
                    }
<span class="fc" id="L1289">                    e = e.next;</span>
<span class="fc" id="L1290">                }</span>
<span class="fc" id="L1291">            }</span>

            // visits all the frames that must be stored in the stack map
<span class="fc" id="L1294">            Label l = labels;</span>
<span class="fc bfc" id="L1295" title="All 2 branches covered.">            while (l != null) {</span>
<span class="fc" id="L1296">                f = l.frame;</span>
<span class="fc bfc" id="L1297" title="All 2 branches covered.">                if ((l.status &amp; Label.STORE) != 0) {</span>
<span class="fc" id="L1298">                    visitFrame(f);</span>
                }
<span class="fc bfc" id="L1300" title="All 2 branches covered.">                if ((l.status &amp; Label.REACHABLE) == 0) {</span>
                    // finds start and end of dead basic block
<span class="fc" id="L1302">                    Label k = l.successor;</span>
<span class="fc" id="L1303">                    int start = l.position;</span>
<span class="pc bpc" id="L1304" title="1 of 2 branches missed.">                    int end = (k == null ? code.length : k.position) - 1;</span>
                    // if non empty basic block
<span class="pc bpc" id="L1306" title="1 of 2 branches missed.">                    if (end &gt;= start) {</span>
<span class="nc" id="L1307">                        max = Math.max(max, 1);</span>
                        // replaces instructions with NOP ... NOP ATHROW
<span class="nc bnc" id="L1309" title="All 2 branches missed.">                        for (int i = start; i &lt; end; ++i) {</span>
<span class="nc" id="L1310">                            code.data[i] = Opcodes.NOP;</span>
                        }
<span class="nc" id="L1312">                        code.data[end] = (byte) Opcodes.ATHROW;</span>
                        // emits a frame for this unreachable block
<span class="nc" id="L1314">                        startFrame(start, 0, 1);</span>
<span class="nc" id="L1315">                        frame[frameIndex++] = Frame.OBJECT</span>
<span class="nc" id="L1316">                                | cw.addType(&quot;java/lang/Throwable&quot;);</span>
<span class="nc" id="L1317">                        endFrame();</span>
                    }
                }
<span class="fc" id="L1320">                l = l.successor;</span>
            }
            
<span class="fc" id="L1323">            this.maxStack = max;</span>
<span class="fc bfc" id="L1324" title="All 2 branches covered.">        } else if (compute == MAXS) {</span>
            // completes the control flow graph with exception handler blocks
<span class="fc" id="L1326">            Handler handler = firstHandler;</span>
<span class="fc bfc" id="L1327" title="All 2 branches covered.">            while (handler != null) {</span>
<span class="fc" id="L1328">                Label l = handler.start;</span>
<span class="fc" id="L1329">                Label h = handler.handler;</span>
<span class="fc" id="L1330">                Label e = handler.end;</span>
                // adds 'h' as a successor of labels between 'start' and 'end'
<span class="fc bfc" id="L1332" title="All 2 branches covered.">                while (l != e) {</span>
                    // creates an edge to 'h'
<span class="fc" id="L1334">                    Edge b = new Edge();</span>
<span class="fc" id="L1335">                    b.info = Edge.EXCEPTION;</span>
<span class="fc" id="L1336">                    b.successor = h;</span>
                    // adds it to the successors of 'l'
<span class="pc bpc" id="L1338" title="1 of 2 branches missed.">                    if ((l.status &amp; Label.JSR) == 0) {</span>
<span class="fc" id="L1339">                        b.next = l.successors;</span>
<span class="fc" id="L1340">                        l.successors = b;</span>
                    } else {
                        // if l is a JSR block, adds b after the first two edges
                        // to preserve the hypothesis about JSR block successors
                        // order (see {@link #visitJumpInsn})
<span class="nc" id="L1345">                        b.next = l.successors.next.next;</span>
<span class="nc" id="L1346">                        l.successors.next.next = b;</span>
                    }
                    // goes to the next label
<span class="fc" id="L1349">                    l = l.successor;</span>
<span class="fc" id="L1350">                }</span>
<span class="fc" id="L1351">                handler = handler.next;</span>
<span class="fc" id="L1352">            }</span>

<span class="pc bpc" id="L1354" title="1 of 2 branches missed.">            if (subroutines &gt; 0) {</span>
                // completes the control flow graph with the RET successors
                /*
                 * first step: finds the subroutines. This step determines, for
                 * each basic block, to which subroutine(s) it belongs.
                 */
                // finds the basic blocks that belong to the &quot;main&quot; subroutine
<span class="nc" id="L1361">                int id = 0;</span>
<span class="nc" id="L1362">                labels.visitSubroutine(null, 1, subroutines);</span>
                // finds the basic blocks that belong to the real subroutines
<span class="nc" id="L1364">                Label l = labels;</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">                while (l != null) {</span>
<span class="nc bnc" id="L1366" title="All 2 branches missed.">                    if ((l.status &amp; Label.JSR) != 0) {</span>
                        // the subroutine is defined by l's TARGET, not by l
<span class="nc" id="L1368">                        Label subroutine = l.successors.next.successor;</span>
                        // if this subroutine has not been visited yet...
<span class="nc bnc" id="L1370" title="All 2 branches missed.">                        if ((subroutine.status &amp; Label.VISITED) == 0) {</span>
                            // ...assigns it a new id and finds its basic blocks
<span class="nc" id="L1372">                            id += 1;</span>
<span class="nc" id="L1373">                            subroutine.visitSubroutine(null, (id / 32L) &lt;&lt; 32</span>
                                    | (1L &lt;&lt; (id % 32)), subroutines);
                        }
                    }
<span class="nc" id="L1377">                    l = l.successor;</span>
                }
                // second step: finds the successors of RET blocks
<span class="nc" id="L1380">                l = labels;</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">                while (l != null) {</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">                    if ((l.status &amp; Label.JSR) != 0) {</span>
<span class="nc" id="L1383">                        Label L = labels;</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">                        while (L != null) {</span>
<span class="nc" id="L1385">                            L.status &amp;= ~Label.VISITED2;</span>
<span class="nc" id="L1386">                            L = L.successor;</span>
                        }
                        // the subroutine is defined by l's TARGET, not by l
<span class="nc" id="L1389">                        Label subroutine = l.successors.next.successor;</span>
<span class="nc" id="L1390">                        subroutine.visitSubroutine(l, 0, subroutines);</span>
                    }
<span class="nc" id="L1392">                    l = l.successor;</span>
                }
            }

            /*
             * control flow analysis algorithm: while the block stack is not
             * empty, pop a block from this stack, update the max stack size,
             * compute the true (non relative) begin stack size of the
             * successors of this block, and push these successors onto the
             * stack (unless they have already been pushed onto the stack).
             * Note: by hypothesis, the {@link Label#inputStackTop} of the
             * blocks in the block stack are the true (non relative) beginning
             * stack sizes of these blocks.
             */
<span class="fc" id="L1406">            int max = 0;</span>
<span class="fc" id="L1407">            Label stack = labels;</span>
<span class="fc bfc" id="L1408" title="All 2 branches covered.">            while (stack != null) {</span>
                // pops a block from the stack
<span class="fc" id="L1410">                Label l = stack;</span>
<span class="fc" id="L1411">                stack = stack.next;</span>
                // computes the true (non relative) max stack size of this block
<span class="fc" id="L1413">                int start = l.inputStackTop;</span>
<span class="fc" id="L1414">                int blockMax = start + l.outputStackMax;</span>
                // updates the global max stack size
<span class="fc bfc" id="L1416" title="All 2 branches covered.">                if (blockMax &gt; max) {</span>
<span class="fc" id="L1417">                    max = blockMax;</span>
                }
                // analyzes the successors of the block
<span class="fc" id="L1420">                Edge b = l.successors;</span>
<span class="pc bpc" id="L1421" title="1 of 2 branches missed.">                if ((l.status &amp; Label.JSR) != 0) {</span>
                    // ignores the first edge of JSR blocks (virtual successor)
<span class="nc" id="L1423">                    b = b.next;</span>
                }
<span class="fc bfc" id="L1425" title="All 2 branches covered.">                while (b != null) {</span>
<span class="fc" id="L1426">                    l = b.successor;</span>
                    // if this successor has not already been pushed...
<span class="fc bfc" id="L1428" title="All 2 branches covered.">                    if ((l.status &amp; Label.PUSHED) == 0) {</span>
                        // computes its true beginning stack size...
<span class="fc bfc" id="L1430" title="All 2 branches covered.">                        l.inputStackTop = b.info == Edge.EXCEPTION ? 1 : start</span>
                                + b.info;
                        // ...and pushes it onto the stack
<span class="fc" id="L1433">                        l.status |= Label.PUSHED;</span>
<span class="fc" id="L1434">                        l.next = stack;</span>
<span class="fc" id="L1435">                        stack = l;</span>
                    }
<span class="fc" id="L1437">                    b = b.next;</span>
                }
<span class="fc" id="L1439">            }</span>
<span class="fc" id="L1440">            this.maxStack = max;</span>
<span class="fc" id="L1441">        } else {</span>
<span class="fc" id="L1442">            this.maxStack = maxStack;</span>
<span class="fc" id="L1443">            this.maxLocals = maxLocals;</span>
        }
<span class="fc" id="L1445">    }</span>

    public void visitEnd() {
<span class="fc" id="L1448">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: control flow analysis algorithm
    // ------------------------------------------------------------------------

    /**
     * Adds a successor to the {@link #currentBlock currentBlock} block.
     * 
     * @param info information about the control flow edge to be added.
     * @param successor the successor block to be added to the current block.
     */
    private void addSuccessor(final int info, final Label successor) {
        // creates and initializes an Edge object...
<span class="fc" id="L1462">        Edge b = new Edge();</span>
<span class="fc" id="L1463">        b.info = info;</span>
<span class="fc" id="L1464">        b.successor = successor;</span>
        // ...and adds it to the successor list of the currentBlock block
<span class="fc" id="L1466">        b.next = currentBlock.successors;</span>
<span class="fc" id="L1467">        currentBlock.successors = b;</span>
<span class="fc" id="L1468">    }</span>

    /**
     * Ends the current basic block. This method must be used in the case where
     * the current basic block does not have any successor.
     */
    private void noSuccessor() {
<span class="fc bfc" id="L1475" title="All 2 branches covered.">        if (compute == FRAMES) {</span>
<span class="fc" id="L1476">            Label l = new Label();</span>
<span class="fc" id="L1477">            l.frame = new Frame();</span>
<span class="fc" id="L1478">            l.frame.owner = l;</span>
<span class="fc" id="L1479">            l.resolve(this, code.length, code.data);</span>
<span class="fc" id="L1480">            previousBlock.successor = l;</span>
<span class="fc" id="L1481">            previousBlock = l;</span>
<span class="fc" id="L1482">        } else {</span>
<span class="fc" id="L1483">            currentBlock.outputStackMax = maxStackSize;</span>
        }
<span class="fc" id="L1485">        currentBlock = null;</span>
<span class="fc" id="L1486">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: stack map frames
    // ------------------------------------------------------------------------

    /**
     * Visits a frame that has been computed from scratch.
     * 
     * @param f the frame that must be visited.
     */
    private void visitFrame(final Frame f) {
        int i, t;
<span class="fc" id="L1499">        int nTop = 0;</span>
<span class="fc" id="L1500">        int nLocal = 0;</span>
<span class="fc" id="L1501">        int nStack = 0;</span>
<span class="fc" id="L1502">        int[] locals = f.inputLocals;</span>
<span class="fc" id="L1503">        int[] stacks = f.inputStack;</span>
        // computes the number of locals (ignores TOP types that are just after
        // a LONG or a DOUBLE, and all trailing TOP types)
<span class="fc bfc" id="L1506" title="All 2 branches covered.">        for (i = 0; i &lt; locals.length; ++i) {</span>
<span class="fc" id="L1507">            t = locals[i];</span>
<span class="fc bfc" id="L1508" title="All 2 branches covered.">            if (t == Frame.TOP) {</span>
<span class="fc" id="L1509">                ++nTop;</span>
            } else {
<span class="fc" id="L1511">                nLocal += nTop + 1;</span>
<span class="fc" id="L1512">                nTop = 0;</span>
            }
<span class="pc bpc" id="L1514" title="2 of 4 branches missed.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="nc" id="L1515">                ++i;</span>
            }
        }
        // computes the stack size (ignores TOP types that are just after
        // a LONG or a DOUBLE)
<span class="fc bfc" id="L1520" title="All 2 branches covered.">        for (i = 0; i &lt; stacks.length; ++i) {</span>
<span class="fc" id="L1521">            t = stacks[i];</span>
<span class="fc" id="L1522">            ++nStack;</span>
<span class="pc bpc" id="L1523" title="2 of 4 branches missed.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="nc" id="L1524">                ++i;</span>
            }
        }
        // visits the frame and its content
<span class="fc" id="L1528">        startFrame(f.owner.position, nLocal, nStack);</span>
<span class="fc bfc" id="L1529" title="All 2 branches covered.">        for (i = 0; nLocal &gt; 0; ++i, --nLocal) {</span>
<span class="fc" id="L1530">            t = locals[i];</span>
<span class="fc" id="L1531">            frame[frameIndex++] = t;</span>
<span class="pc bpc" id="L1532" title="2 of 4 branches missed.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="nc" id="L1533">                ++i;</span>
            }
        }
<span class="fc bfc" id="L1536" title="All 2 branches covered.">        for (i = 0; i &lt; stacks.length; ++i) {</span>
<span class="fc" id="L1537">            t = stacks[i];</span>
<span class="fc" id="L1538">            frame[frameIndex++] = t;</span>
<span class="pc bpc" id="L1539" title="2 of 4 branches missed.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="nc" id="L1540">                ++i;</span>
            }
        }
<span class="fc" id="L1543">        endFrame();</span>
<span class="fc" id="L1544">    }</span>

    /**
     * Starts the visit of a stack map frame.
     * 
     * @param offset the offset of the instruction to which the frame
     *        corresponds.
     * @param nLocal the number of local variables in the frame.
     * @param nStack the number of stack elements in the frame.
     */
    private void startFrame(final int offset, final int nLocal, final int nStack)
    {
<span class="fc" id="L1556">        int n = 3 + nLocal + nStack;</span>
<span class="pc bpc" id="L1557" title="3 of 4 branches missed.">        if (frame == null || frame.length &lt; n) {</span>
<span class="fc" id="L1558">            frame = new int[n];</span>
        }
<span class="fc" id="L1560">        frame[0] = offset;</span>
<span class="fc" id="L1561">        frame[1] = nLocal;</span>
<span class="fc" id="L1562">        frame[2] = nStack;</span>
<span class="fc" id="L1563">        frameIndex = 3;</span>
<span class="fc" id="L1564">    }</span>

    /**
     * Checks if the visit of the current frame {@link #frame} is finished, and
     * if yes, write it in the StackMapTable attribute.
     */
    private void endFrame() {
<span class="fc bfc" id="L1571" title="All 2 branches covered.">        if (previousFrame != null) { // do not write the first frame</span>
<span class="fc bfc" id="L1572" title="All 2 branches covered.">            if (stackMap == null) {</span>
<span class="fc" id="L1573">                stackMap = new ByteVector();</span>
            }
<span class="fc" id="L1575">            writeFrame();</span>
<span class="fc" id="L1576">            ++frameCount;</span>
        }
<span class="fc" id="L1578">        previousFrame = frame;</span>
<span class="fc" id="L1579">        frame = null;</span>
<span class="fc" id="L1580">    }</span>

    /**
     * Compress and writes the current frame {@link #frame} in the StackMapTable
     * attribute.
     */
    private void writeFrame() {
<span class="fc" id="L1587">        int clocalsSize = frame[1];</span>
<span class="fc" id="L1588">        int cstackSize = frame[2];</span>
<span class="pc bpc" id="L1589" title="1 of 2 branches missed.">        if ((cw.version &amp; 0xFFFF) &lt; Opcodes.V1_6) {</span>
<span class="nc" id="L1590">            stackMap.putShort(frame[0]).putShort(clocalsSize);</span>
<span class="nc" id="L1591">            writeFrameTypes(3, 3 + clocalsSize);</span>
<span class="nc" id="L1592">            stackMap.putShort(cstackSize);</span>
<span class="nc" id="L1593">            writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);</span>
<span class="nc" id="L1594">            return;</span>
        }
<span class="fc" id="L1596">        int localsSize = previousFrame[1];</span>
<span class="fc" id="L1597">        int type = FULL_FRAME;</span>
<span class="fc" id="L1598">        int k = 0;</span>
        int delta;
<span class="fc bfc" id="L1600" title="All 2 branches covered.">        if (frameCount == 0) {</span>
<span class="fc" id="L1601">            delta = frame[0];</span>
        } else {
<span class="fc" id="L1603">            delta = frame[0] - previousFrame[0] - 1;</span>
        }
<span class="fc bfc" id="L1605" title="All 2 branches covered.">        if (cstackSize == 0) {</span>
<span class="fc" id="L1606">            k = clocalsSize - localsSize;</span>
<span class="fc bfc" id="L1607" title="All 4 branches covered.">            switch (k) {</span>
                case -3:
                case -2:
                case -1:
<span class="fc" id="L1611">                    type = CHOP_FRAME;</span>
<span class="fc" id="L1612">                    localsSize = clocalsSize;</span>
<span class="fc" id="L1613">                    break;</span>
                case 0:
<span class="fc bfc" id="L1615" title="All 2 branches covered.">                    type = delta &lt; 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;</span>
<span class="fc" id="L1616">                    break;</span>
                case 1:
                case 2:
                case 3:
<span class="fc" id="L1620">                    type = APPEND_FRAME;</span>
<span class="fc" id="L1621">                    break;</span>
            }
<span class="fc bfc" id="L1623" title="All 4 branches covered.">        } else if (clocalsSize == localsSize &amp;&amp; cstackSize == 1) {</span>
<span class="pc bpc" id="L1624" title="1 of 2 branches missed.">            type = delta &lt; 63</span>
                    ? SAME_LOCALS_1_STACK_ITEM_FRAME
                    : SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;
        }
<span class="fc bfc" id="L1628" title="All 2 branches covered.">        if (type != FULL_FRAME) {</span>
            // verify if locals are the same
<span class="fc" id="L1630">            int l = 3;</span>
<span class="fc bfc" id="L1631" title="All 2 branches covered.">            for (int j = 0; j &lt; localsSize; j++) {</span>
<span class="fc bfc" id="L1632" title="All 2 branches covered.">                if (frame[l] != previousFrame[l]) {</span>
<span class="fc" id="L1633">                    type = FULL_FRAME;</span>
<span class="fc" id="L1634">                    break;</span>
                }
<span class="fc" id="L1636">                l++;</span>
            }
        }
<span class="pc bpc" id="L1639" title="1 of 7 branches missed.">        switch (type) {</span>
            case SAME_FRAME:
<span class="fc" id="L1641">                stackMap.putByte(delta);</span>
<span class="fc" id="L1642">                break;</span>
            case SAME_LOCALS_1_STACK_ITEM_FRAME:
<span class="fc" id="L1644">                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);</span>
<span class="fc" id="L1645">                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);</span>
<span class="fc" id="L1646">                break;</span>
            case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:
<span class="nc" id="L1648">                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)</span>
<span class="nc" id="L1649">                        .putShort(delta);</span>
<span class="nc" id="L1650">                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);</span>
<span class="nc" id="L1651">                break;</span>
            case SAME_FRAME_EXTENDED:
<span class="fc" id="L1653">                stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);</span>
<span class="fc" id="L1654">                break;</span>
            case CHOP_FRAME:
<span class="fc" id="L1656">                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);</span>
<span class="fc" id="L1657">                break;</span>
            case APPEND_FRAME:
<span class="fc" id="L1659">                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);</span>
<span class="fc" id="L1660">                writeFrameTypes(3 + localsSize, 3 + clocalsSize);</span>
<span class="fc" id="L1661">                break;</span>
            // case FULL_FRAME:
            default:
<span class="fc" id="L1664">                stackMap.putByte(FULL_FRAME)</span>
<span class="fc" id="L1665">                        .putShort(delta)</span>
<span class="fc" id="L1666">                        .putShort(clocalsSize);</span>
<span class="fc" id="L1667">                writeFrameTypes(3, 3 + clocalsSize);</span>
<span class="fc" id="L1668">                stackMap.putShort(cstackSize);</span>
<span class="fc" id="L1669">                writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);</span>
        }
<span class="fc" id="L1671">    }</span>

    /**
     * Writes some types of the current frame {@link #frame} into the
     * StackMapTableAttribute. This method converts types from the format used
     * in {@link Label} to the format used in StackMapTable attributes. In
     * particular, it converts type table indexes to constant pool indexes.
     * 
     * @param start index of the first type in {@link #frame} to write.
     * @param end index of last type in {@link #frame} to write (exclusive).
     */
    private void writeFrameTypes(final int start, final int end) {
<span class="fc bfc" id="L1683" title="All 2 branches covered.">        for (int i = start; i &lt; end; ++i) {</span>
<span class="fc" id="L1684">            int t = frame[i];</span>
<span class="fc" id="L1685">            int d = t &amp; Frame.DIM;</span>
<span class="fc bfc" id="L1686" title="All 2 branches covered.">            if (d == 0) {</span>
<span class="fc" id="L1687">                int v = t &amp; Frame.BASE_VALUE;</span>
<span class="pc bpc" id="L1688" title="1 of 3 branches missed.">                switch (t &amp; Frame.BASE_KIND) {</span>
                    case Frame.OBJECT:
<span class="fc" id="L1690">                        stackMap.putByte(7)</span>
<span class="fc" id="L1691">                                .putShort(cw.newClass(cw.typeTable[v].strVal1));</span>
<span class="fc" id="L1692">                        break;</span>
                    case Frame.UNINITIALIZED:
<span class="nc" id="L1694">                        stackMap.putByte(8).putShort(cw.typeTable[v].intVal);</span>
<span class="nc" id="L1695">                        break;</span>
                    default:
<span class="fc" id="L1697">                        stackMap.putByte(v);</span>
                }
<span class="fc" id="L1699">            } else {</span>
<span class="fc" id="L1700">                StringBuffer buf = new StringBuffer();</span>
<span class="fc" id="L1701">                d &gt;&gt;= 28;</span>
<span class="fc bfc" id="L1702" title="All 2 branches covered.">                while (d-- &gt; 0) {</span>
<span class="fc" id="L1703">                    buf.append('[');</span>
                }
<span class="fc bfc" id="L1705" title="All 2 branches covered.">                if ((t &amp; Frame.BASE_KIND) == Frame.OBJECT) {</span>
<span class="fc" id="L1706">                    buf.append('L');</span>
<span class="fc" id="L1707">                    buf.append(cw.typeTable[t &amp; Frame.BASE_VALUE].strVal1);</span>
<span class="fc" id="L1708">                    buf.append(';');</span>
                } else {
<span class="pc bpc" id="L1710" title="7 of 8 branches missed.">                    switch (t &amp; 0xF) {</span>
                        case 1:
<span class="fc" id="L1712">                            buf.append('I');</span>
<span class="fc" id="L1713">                            break;</span>
                        case 2:
<span class="nc" id="L1715">                            buf.append('F');</span>
<span class="nc" id="L1716">                            break;</span>
                        case 3:
<span class="nc" id="L1718">                            buf.append('D');</span>
<span class="nc" id="L1719">                            break;</span>
                        case 9:
<span class="nc" id="L1721">                            buf.append('Z');</span>
<span class="nc" id="L1722">                            break;</span>
                        case 10:
<span class="nc" id="L1724">                            buf.append('B');</span>
<span class="nc" id="L1725">                            break;</span>
                        case 11:
<span class="nc" id="L1727">                            buf.append('C');</span>
<span class="nc" id="L1728">                            break;</span>
                        case 12:
<span class="nc" id="L1730">                            buf.append('S');</span>
<span class="nc" id="L1731">                            break;</span>
                        default:
<span class="nc" id="L1733">                            buf.append('J');</span>
                    }
                }
<span class="fc" id="L1736">                stackMap.putByte(7).putShort(cw.newClass(buf.toString()));</span>
            }
        }
<span class="fc" id="L1739">    }</span>

    private void writeFrameType(final Object type) {
<span class="fc bfc" id="L1742" title="All 2 branches covered.">        if (type instanceof String) {</span>
<span class="fc" id="L1743">            stackMap.putByte(7).putShort(cw.newClass((String) type));</span>
<span class="pc bpc" id="L1744" title="1 of 2 branches missed.">        } else if (type instanceof Integer) {</span>
<span class="fc" id="L1745">            stackMap.putByte(((Integer) type).intValue());</span>
        } else {
<span class="nc" id="L1747">            stackMap.putByte(8).putShort(((Label) type).position);</span>
        }
<span class="fc" id="L1749">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: dump bytecode array
    // ------------------------------------------------------------------------

    /**
     * Returns the size of the bytecode of this method.
     * 
     * @return the size of the bytecode of this method.
     */
    final int getSize() {
<span class="fc bfc" id="L1761" title="All 2 branches covered.">        if (classReaderOffset != 0) {</span>
<span class="fc" id="L1762">            return 6 + classReaderLength;</span>
        }
<span class="pc bpc" id="L1764" title="1 of 2 branches missed.">        if (resize) {</span>
            // replaces the temporary jump opcodes introduced by Label.resolve.
            if (ClassReader.RESIZE) {
<span class="nc" id="L1767">                resizeInstructions();</span>
            } else {
                throw new RuntimeException(&quot;Method code too large!&quot;);
            }
        }
<span class="fc" id="L1772">        int size = 8;</span>
<span class="fc bfc" id="L1773" title="All 2 branches covered.">        if (code.length &gt; 0) {</span>
<span class="fc" id="L1774">            cw.newUTF8(&quot;Code&quot;);</span>
<span class="fc" id="L1775">            size += 18 + code.length + 8 * handlerCount;</span>
<span class="fc bfc" id="L1776" title="All 2 branches covered.">            if (localVar != null) {</span>
<span class="fc" id="L1777">                cw.newUTF8(&quot;LocalVariableTable&quot;);</span>
<span class="fc" id="L1778">                size += 8 + localVar.length;</span>
            }
<span class="fc bfc" id="L1780" title="All 2 branches covered.">            if (localVarType != null) {</span>
<span class="fc" id="L1781">                cw.newUTF8(&quot;LocalVariableTypeTable&quot;);</span>
<span class="fc" id="L1782">                size += 8 + localVarType.length;</span>
            }
<span class="fc bfc" id="L1784" title="All 2 branches covered.">            if (lineNumber != null) {</span>
<span class="fc" id="L1785">                cw.newUTF8(&quot;LineNumberTable&quot;);</span>
<span class="fc" id="L1786">                size += 8 + lineNumber.length;</span>
            }
<span class="fc bfc" id="L1788" title="All 2 branches covered.">            if (stackMap != null) {</span>
<span class="pc bpc" id="L1789" title="1 of 2 branches missed.">                boolean zip = (cw.version &amp; 0xFFFF) &gt;= Opcodes.V1_6;</span>
<span class="pc bpc" id="L1790" title="1 of 2 branches missed.">                cw.newUTF8(zip ? &quot;StackMapTable&quot; : &quot;StackMap&quot;);</span>
<span class="fc" id="L1791">                size += 8 + stackMap.length;</span>
            }
<span class="pc bpc" id="L1793" title="1 of 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L1794">                size += cattrs.getSize(cw,</span>
                        code.data,
                        code.length,
                        maxStack,
                        maxLocals);
            }
        }
<span class="fc bfc" id="L1801" title="All 2 branches covered.">        if (exceptionCount &gt; 0) {</span>
<span class="fc" id="L1802">            cw.newUTF8(&quot;Exceptions&quot;);</span>
<span class="fc" id="L1803">            size += 8 + 2 * exceptionCount;</span>
        }
<span class="pc bpc" id="L1805" title="1 of 4 branches missed.">        if ((access &amp; Opcodes.ACC_SYNTHETIC) != 0</span>
                &amp;&amp; (cw.version &amp; 0xffff) &lt; Opcodes.V1_5)
        {
<span class="fc" id="L1808">            cw.newUTF8(&quot;Synthetic&quot;);</span>
<span class="fc" id="L1809">            size += 6;</span>
        }
<span class="fc bfc" id="L1811" title="All 2 branches covered.">        if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {</span>
<span class="fc" id="L1812">            cw.newUTF8(&quot;Deprecated&quot;);</span>
<span class="fc" id="L1813">            size += 6;</span>
        }
<span class="fc bfc" id="L1815" title="All 2 branches covered.">        if (ClassReader.SIGNATURES &amp;&amp; signature != null) {</span>
<span class="fc" id="L1816">            cw.newUTF8(&quot;Signature&quot;);</span>
<span class="fc" id="L1817">            cw.newUTF8(signature);</span>
<span class="fc" id="L1818">            size += 8;</span>
        }
<span class="fc bfc" id="L1820" title="All 2 branches covered.">        if (ClassReader.ANNOTATIONS &amp;&amp; annd != null) {</span>
<span class="fc" id="L1821">            cw.newUTF8(&quot;AnnotationDefault&quot;);</span>
<span class="fc" id="L1822">            size += 6 + annd.length;</span>
        }
<span class="fc bfc" id="L1824" title="All 2 branches covered.">        if (ClassReader.ANNOTATIONS &amp;&amp; anns != null) {</span>
<span class="fc" id="L1825">            cw.newUTF8(&quot;RuntimeVisibleAnnotations&quot;);</span>
<span class="fc" id="L1826">            size += 8 + anns.getSize();</span>
        }
<span class="fc bfc" id="L1828" title="All 2 branches covered.">        if (ClassReader.ANNOTATIONS &amp;&amp; ianns != null) {</span>
<span class="fc" id="L1829">            cw.newUTF8(&quot;RuntimeInvisibleAnnotations&quot;);</span>
<span class="fc" id="L1830">            size += 8 + ianns.getSize();</span>
        }
<span class="pc bpc" id="L1832" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; panns != null) {</span>
<span class="nc" id="L1833">            cw.newUTF8(&quot;RuntimeVisibleParameterAnnotations&quot;);</span>
<span class="nc" id="L1834">            size += 7 + 2 * (panns.length - synthetics);</span>
<span class="nc bnc" id="L1835" title="All 2 branches missed.">            for (int i = panns.length - 1; i &gt;= synthetics; --i) {</span>
<span class="nc bnc" id="L1836" title="All 2 branches missed.">                size += panns[i] == null ? 0 : panns[i].getSize();</span>
            }
        }
<span class="pc bpc" id="L1839" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ipanns != null) {</span>
<span class="nc" id="L1840">            cw.newUTF8(&quot;RuntimeInvisibleParameterAnnotations&quot;);</span>
<span class="nc" id="L1841">            size += 7 + 2 * (ipanns.length - synthetics);</span>
<span class="nc bnc" id="L1842" title="All 2 branches missed.">            for (int i = ipanns.length - 1; i &gt;= synthetics; --i) {</span>
<span class="nc bnc" id="L1843" title="All 2 branches missed.">                size += ipanns[i] == null ? 0 : ipanns[i].getSize();</span>
            }
        }
<span class="pc bpc" id="L1846" title="1 of 2 branches missed.">        if (attrs != null) {</span>
<span class="nc" id="L1847">            size += attrs.getSize(cw, null, 0, -1, -1);</span>
        }
<span class="fc" id="L1849">        return size;</span>
    }

    /**
     * Puts the bytecode of this method in the given byte vector.
     * 
     * @param out the byte vector into which the bytecode of this method must be
     *        copied.
     */
    final void put(final ByteVector out) {
<span class="fc" id="L1859">        out.putShort(access).putShort(name).putShort(desc);</span>
<span class="pc bpc" id="L1860" title="1 of 2 branches missed.">        if (classReaderOffset != 0) {</span>
<span class="nc" id="L1861">            out.putByteArray(cw.cr.b, classReaderOffset, classReaderLength);</span>
<span class="nc" id="L1862">            return;</span>
        }
<span class="fc" id="L1864">        int attributeCount = 0;</span>
<span class="fc bfc" id="L1865" title="All 2 branches covered.">        if (code.length &gt; 0) {</span>
<span class="fc" id="L1866">            ++attributeCount;</span>
        }
<span class="fc bfc" id="L1868" title="All 2 branches covered.">        if (exceptionCount &gt; 0) {</span>
<span class="fc" id="L1869">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1871" title="3 of 4 branches missed.">        if ((access &amp; Opcodes.ACC_SYNTHETIC) != 0</span>
                &amp;&amp; (cw.version &amp; 0xffff) &lt; Opcodes.V1_5)
        {
<span class="nc" id="L1874">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1876" title="1 of 2 branches missed.">        if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {</span>
<span class="nc" id="L1877">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1879" title="1 of 2 branches missed.">        if (ClassReader.SIGNATURES &amp;&amp; signature != null) {</span>
<span class="fc" id="L1880">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1882" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; annd != null) {</span>
<span class="nc" id="L1883">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1885" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; anns != null) {</span>
<span class="nc" id="L1886">            ++attributeCount;</span>
        }
<span class="fc bfc" id="L1888" title="All 2 branches covered.">        if (ClassReader.ANNOTATIONS &amp;&amp; ianns != null) {</span>
<span class="fc" id="L1889">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1891" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; panns != null) {</span>
<span class="nc" id="L1892">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1894" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ipanns != null) {</span>
<span class="nc" id="L1895">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1897" title="1 of 2 branches missed.">        if (attrs != null) {</span>
<span class="nc" id="L1898">            attributeCount += attrs.getCount();</span>
        }
<span class="fc" id="L1900">        out.putShort(attributeCount);</span>
<span class="fc bfc" id="L1901" title="All 2 branches covered.">        if (code.length &gt; 0) {</span>
<span class="fc" id="L1902">            int size = 12 + code.length + 8 * handlerCount;</span>
<span class="pc bpc" id="L1903" title="1 of 2 branches missed.">            if (localVar != null) {</span>
<span class="nc" id="L1904">                size += 8 + localVar.length;</span>
            }
<span class="pc bpc" id="L1906" title="1 of 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L1907">                size += 8 + localVarType.length;</span>
            }
<span class="fc bfc" id="L1909" title="All 2 branches covered.">            if (lineNumber != null) {</span>
<span class="fc" id="L1910">                size += 8 + lineNumber.length;</span>
            }
<span class="pc bpc" id="L1912" title="1 of 2 branches missed.">            if (stackMap != null) {</span>
<span class="nc" id="L1913">                size += 8 + stackMap.length;</span>
            }
<span class="pc bpc" id="L1915" title="1 of 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L1916">                size += cattrs.getSize(cw,</span>
                        code.data,
                        code.length,
                        maxStack,
                        maxLocals);
            }
<span class="fc" id="L1922">            out.putShort(cw.newUTF8(&quot;Code&quot;)).putInt(size);</span>
<span class="fc" id="L1923">            out.putShort(maxStack).putShort(maxLocals);</span>
<span class="fc" id="L1924">            out.putInt(code.length).putByteArray(code.data, 0, code.length);</span>
<span class="fc" id="L1925">            out.putShort(handlerCount);</span>
<span class="fc bfc" id="L1926" title="All 2 branches covered.">            if (handlerCount &gt; 0) {</span>
<span class="fc" id="L1927">                Handler h = firstHandler;</span>
<span class="fc bfc" id="L1928" title="All 2 branches covered.">                while (h != null) {</span>
<span class="fc" id="L1929">                    out.putShort(h.start.position)</span>
<span class="fc" id="L1930">                            .putShort(h.end.position)</span>
<span class="fc" id="L1931">                            .putShort(h.handler.position)</span>
<span class="fc" id="L1932">                            .putShort(h.type);</span>
<span class="fc" id="L1933">                    h = h.next;</span>
                }
            }
<span class="fc" id="L1936">            attributeCount = 0;</span>
<span class="pc bpc" id="L1937" title="1 of 2 branches missed.">            if (localVar != null) {</span>
<span class="nc" id="L1938">                ++attributeCount;</span>
            }
<span class="pc bpc" id="L1940" title="1 of 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L1941">                ++attributeCount;</span>
            }
<span class="fc bfc" id="L1943" title="All 2 branches covered.">            if (lineNumber != null) {</span>
<span class="fc" id="L1944">                ++attributeCount;</span>
            }
<span class="pc bpc" id="L1946" title="1 of 2 branches missed.">            if (stackMap != null) {</span>
<span class="nc" id="L1947">                ++attributeCount;</span>
            }
<span class="pc bpc" id="L1949" title="1 of 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L1950">                attributeCount += cattrs.getCount();</span>
            }
<span class="fc" id="L1952">            out.putShort(attributeCount);</span>
<span class="pc bpc" id="L1953" title="1 of 2 branches missed.">            if (localVar != null) {</span>
<span class="nc" id="L1954">                out.putShort(cw.newUTF8(&quot;LocalVariableTable&quot;));</span>
<span class="nc" id="L1955">                out.putInt(localVar.length + 2).putShort(localVarCount);</span>
<span class="nc" id="L1956">                out.putByteArray(localVar.data, 0, localVar.length);</span>
            }
<span class="pc bpc" id="L1958" title="1 of 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L1959">                out.putShort(cw.newUTF8(&quot;LocalVariableTypeTable&quot;));</span>
<span class="nc" id="L1960">                out.putInt(localVarType.length + 2).putShort(localVarTypeCount);</span>
<span class="nc" id="L1961">                out.putByteArray(localVarType.data, 0, localVarType.length);</span>
            }
<span class="fc bfc" id="L1963" title="All 2 branches covered.">            if (lineNumber != null) {</span>
<span class="fc" id="L1964">                out.putShort(cw.newUTF8(&quot;LineNumberTable&quot;));</span>
<span class="fc" id="L1965">                out.putInt(lineNumber.length + 2).putShort(lineNumberCount);</span>
<span class="fc" id="L1966">                out.putByteArray(lineNumber.data, 0, lineNumber.length);</span>
            }
<span class="pc bpc" id="L1968" title="1 of 2 branches missed.">            if (stackMap != null) {</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">                boolean zip = (cw.version &amp; 0xFFFF) &gt;= Opcodes.V1_6;</span>
<span class="nc bnc" id="L1970" title="All 2 branches missed.">                out.putShort(cw.newUTF8(zip ? &quot;StackMapTable&quot; : &quot;StackMap&quot;));</span>
<span class="nc" id="L1971">                out.putInt(stackMap.length + 2).putShort(frameCount);</span>
<span class="nc" id="L1972">                out.putByteArray(stackMap.data, 0, stackMap.length);</span>
            }
<span class="pc bpc" id="L1974" title="1 of 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L1975">                cattrs.put(cw, code.data, code.length, maxLocals, maxStack, out);</span>
            }
        }
<span class="fc bfc" id="L1978" title="All 2 branches covered.">        if (exceptionCount &gt; 0) {</span>
<span class="fc" id="L1979">            out.putShort(cw.newUTF8(&quot;Exceptions&quot;))</span>
<span class="fc" id="L1980">                    .putInt(2 * exceptionCount + 2);</span>
<span class="fc" id="L1981">            out.putShort(exceptionCount);</span>
<span class="fc bfc" id="L1982" title="All 2 branches covered.">            for (int i = 0; i &lt; exceptionCount; ++i) {</span>
<span class="fc" id="L1983">                out.putShort(exceptions[i]);</span>
            }
        }
<span class="pc bpc" id="L1986" title="3 of 4 branches missed.">        if ((access &amp; Opcodes.ACC_SYNTHETIC) != 0</span>
                &amp;&amp; (cw.version &amp; 0xffff) &lt; Opcodes.V1_5)
        {
<span class="nc" id="L1989">            out.putShort(cw.newUTF8(&quot;Synthetic&quot;)).putInt(0);</span>
        }
<span class="pc bpc" id="L1991" title="1 of 2 branches missed.">        if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {</span>
<span class="nc" id="L1992">            out.putShort(cw.newUTF8(&quot;Deprecated&quot;)).putInt(0);</span>
        }
<span class="pc bpc" id="L1994" title="1 of 2 branches missed.">        if (ClassReader.SIGNATURES &amp;&amp; signature != null) {</span>
<span class="fc" id="L1995">            out.putShort(cw.newUTF8(&quot;Signature&quot;))</span>
<span class="fc" id="L1996">                    .putInt(2)</span>
<span class="fc" id="L1997">                    .putShort(cw.newUTF8(signature));</span>
        }
<span class="pc bpc" id="L1999" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; annd != null) {</span>
<span class="nc" id="L2000">            out.putShort(cw.newUTF8(&quot;AnnotationDefault&quot;));</span>
<span class="nc" id="L2001">            out.putInt(annd.length);</span>
<span class="nc" id="L2002">            out.putByteArray(annd.data, 0, annd.length);</span>
        }
<span class="pc bpc" id="L2004" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; anns != null) {</span>
<span class="nc" id="L2005">            out.putShort(cw.newUTF8(&quot;RuntimeVisibleAnnotations&quot;));</span>
<span class="nc" id="L2006">            anns.put(out);</span>
        }
<span class="fc bfc" id="L2008" title="All 2 branches covered.">        if (ClassReader.ANNOTATIONS &amp;&amp; ianns != null) {</span>
<span class="fc" id="L2009">            out.putShort(cw.newUTF8(&quot;RuntimeInvisibleAnnotations&quot;));</span>
<span class="fc" id="L2010">            ianns.put(out);</span>
        }
<span class="pc bpc" id="L2012" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; panns != null) {</span>
<span class="nc" id="L2013">            out.putShort(cw.newUTF8(&quot;RuntimeVisibleParameterAnnotations&quot;));</span>
<span class="nc" id="L2014">            AnnotationWriter.put(panns, synthetics, out);</span>
        }
<span class="pc bpc" id="L2016" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ipanns != null) {</span>
<span class="nc" id="L2017">            out.putShort(cw.newUTF8(&quot;RuntimeInvisibleParameterAnnotations&quot;));</span>
<span class="nc" id="L2018">            AnnotationWriter.put(ipanns, synthetics, out);</span>
        }
<span class="pc bpc" id="L2020" title="1 of 2 branches missed.">        if (attrs != null) {</span>
<span class="nc" id="L2021">            attrs.put(cw, null, 0, -1, -1, out);</span>
        }
<span class="fc" id="L2023">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: instruction resizing (used to handle GOTO_W and JSR_W)
    // ------------------------------------------------------------------------

    /**
     * Resizes and replaces the temporary instructions inserted by
     * {@link Label#resolve} for wide forward jumps, while keeping jump offsets
     * and instruction addresses consistent. This may require to resize other
     * existing instructions, or even to introduce new instructions: for
     * example, increasing the size of an instruction by 2 at the middle of a
     * method can increases the offset of an IFEQ instruction from 32766 to
     * 32768, in which case IFEQ 32766 must be replaced with IFNEQ 8 GOTO_W
     * 32765. This, in turn, may require to increase the size of another jump
     * instruction, and so on... All these operations are handled automatically
     * by this method. &lt;p&gt; &lt;i&gt;This method must be called after all the method
     * that is being built has been visited&lt;/i&gt;. In particular, the
     * {@link Label Label} objects used to construct the method are no longer
     * valid after this method has been called.
     */
    private void resizeInstructions() {
<span class="nc" id="L2045">        byte[] b = code.data; // bytecode of the method</span>
        int u, v, label; // indexes in b
        int i, j; // loop indexes
        /*
         * 1st step: As explained above, resizing an instruction may require to
         * resize another one, which may require to resize yet another one, and
         * so on. The first step of the algorithm consists in finding all the
         * instructions that need to be resized, without modifying the code.
         * This is done by the following &quot;fix point&quot; algorithm:
         * 
         * Parse the code to find the jump instructions whose offset will need
         * more than 2 bytes to be stored (the future offset is computed from
         * the current offset and from the number of bytes that will be inserted
         * or removed between the source and target instructions). For each such
         * instruction, adds an entry in (a copy of) the indexes and sizes
         * arrays (if this has not already been done in a previous iteration!).
         * 
         * If at least one entry has been added during the previous step, go
         * back to the beginning, otherwise stop.
         * 
         * In fact the real algorithm is complicated by the fact that the size
         * of TABLESWITCH and LOOKUPSWITCH instructions depends on their
         * position in the bytecode (because of padding). In order to ensure the
         * convergence of the algorithm, the number of bytes to be added or
         * removed from these instructions is over estimated during the previous
         * loop, and computed exactly only after the loop is finished (this
         * requires another pass to parse the bytecode of the method).
         */
<span class="nc" id="L2073">        int[] allIndexes = new int[0]; // copy of indexes</span>
<span class="nc" id="L2074">        int[] allSizes = new int[0]; // copy of sizes</span>
        boolean[] resize; // instructions to be resized
        int newOffset; // future offset of a jump instruction

<span class="nc" id="L2078">        resize = new boolean[code.length];</span>

        // 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done
<span class="nc" id="L2081">        int state = 3;</span>
        do {
<span class="nc bnc" id="L2083" title="All 2 branches missed.">            if (state == 3) {</span>
<span class="nc" id="L2084">                state = 2;</span>
            }
<span class="nc" id="L2086">            u = 0;</span>
<span class="nc bnc" id="L2087" title="All 2 branches missed.">            while (u &lt; b.length) {</span>
<span class="nc" id="L2088">                int opcode = b[u] &amp; 0xFF; // opcode of current instruction</span>
<span class="nc" id="L2089">                int insert = 0; // bytes to be added after this instruction</span>

<span class="nc bnc" id="L2091" title="All 10 branches missed.">                switch (ClassWriter.TYPE[opcode]) {</span>
                    case ClassWriter.NOARG_INSN:
                    case ClassWriter.IMPLVAR_INSN:
<span class="nc" id="L2094">                        u += 1;</span>
<span class="nc" id="L2095">                        break;</span>
                    case ClassWriter.LABEL_INSN:
<span class="nc bnc" id="L2097" title="All 2 branches missed.">                        if (opcode &gt; 201) {</span>
                            // converts temporary opcodes 202 to 217, 218 and
                            // 219 to IFEQ ... JSR (inclusive), IFNULL and
                            // IFNONNULL
<span class="nc bnc" id="L2101" title="All 2 branches missed.">                            opcode = opcode &lt; 218 ? opcode - 49 : opcode - 20;</span>
<span class="nc" id="L2102">                            label = u + readUnsignedShort(b, u + 1);</span>
                        } else {
<span class="nc" id="L2104">                            label = u + readShort(b, u + 1);</span>
                        }
<span class="nc" id="L2106">                        newOffset = getNewOffset(allIndexes, allSizes, u, label);</span>
<span class="nc bnc" id="L2107" title="All 4 branches missed.">                        if (newOffset &lt; Short.MIN_VALUE</span>
                                || newOffset &gt; Short.MAX_VALUE)
                        {
<span class="nc bnc" id="L2110" title="All 2 branches missed.">                            if (!resize[u]) {</span>
<span class="nc bnc" id="L2111" title="All 4 branches missed.">                                if (opcode == Opcodes.GOTO</span>
                                        || opcode == Opcodes.JSR)
                                {
                                    // two additional bytes will be required to
                                    // replace this GOTO or JSR instruction with
                                    // a GOTO_W or a JSR_W
<span class="nc" id="L2117">                                    insert = 2;</span>
                                } else {
                                    // five additional bytes will be required to
                                    // replace this IFxxx &lt;l&gt; instruction with
                                    // IFNOTxxx &lt;l'&gt; GOTO_W &lt;l&gt;, where IFNOTxxx
                                    // is the &quot;opposite&quot; opcode of IFxxx (i.e.,
                                    // IFNE for IFEQ) and where &lt;l'&gt; designates
                                    // the instruction just after the GOTO_W.
<span class="nc" id="L2125">                                    insert = 5;</span>
                                }
<span class="nc" id="L2127">                                resize[u] = true;</span>
                            }
                        }
<span class="nc" id="L2130">                        u += 3;</span>
<span class="nc" id="L2131">                        break;</span>
                    case ClassWriter.LABELW_INSN:
<span class="nc" id="L2133">                        u += 5;</span>
<span class="nc" id="L2134">                        break;</span>
                    case ClassWriter.TABL_INSN:
<span class="nc bnc" id="L2136" title="All 2 branches missed.">                        if (state == 1) {</span>
                            // true number of bytes to be added (or removed)
                            // from this instruction = (future number of padding
                            // bytes - current number of padding byte) -
                            // previously over estimated variation =
                            // = ((3 - newOffset%4) - (3 - u%4)) - u%4
                            // = (-newOffset%4 + u%4) - u%4
                            // = -(newOffset &amp; 3)
<span class="nc" id="L2144">                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);</span>
<span class="nc" id="L2145">                            insert = -(newOffset &amp; 3);</span>
<span class="nc bnc" id="L2146" title="All 2 branches missed.">                        } else if (!resize[u]) {</span>
                            // over estimation of the number of bytes to be
                            // added to this instruction = 3 - current number
                            // of padding bytes = 3 - (3 - u%4) = u%4 = u &amp; 3
<span class="nc" id="L2150">                            insert = u &amp; 3;</span>
<span class="nc" id="L2151">                            resize[u] = true;</span>
                        }
                        // skips instruction
<span class="nc" id="L2154">                        u = u + 4 - (u &amp; 3);</span>
<span class="nc" id="L2155">                        u += 4 * (readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;</span>
<span class="nc" id="L2156">                        break;</span>
                    case ClassWriter.LOOK_INSN:
<span class="nc bnc" id="L2158" title="All 2 branches missed.">                        if (state == 1) {</span>
                            // like TABL_INSN
<span class="nc" id="L2160">                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);</span>
<span class="nc" id="L2161">                            insert = -(newOffset &amp; 3);</span>
<span class="nc bnc" id="L2162" title="All 2 branches missed.">                        } else if (!resize[u]) {</span>
                            // like TABL_INSN
<span class="nc" id="L2164">                            insert = u &amp; 3;</span>
<span class="nc" id="L2165">                            resize[u] = true;</span>
                        }
                        // skips instruction
<span class="nc" id="L2168">                        u = u + 4 - (u &amp; 3);</span>
<span class="nc" id="L2169">                        u += 8 * readInt(b, u + 4) + 8;</span>
<span class="nc" id="L2170">                        break;</span>
                    case ClassWriter.WIDE_INSN:
<span class="nc" id="L2172">                        opcode = b[u + 1] &amp; 0xFF;</span>
<span class="nc bnc" id="L2173" title="All 2 branches missed.">                        if (opcode == Opcodes.IINC) {</span>
<span class="nc" id="L2174">                            u += 6;</span>
                        } else {
<span class="nc" id="L2176">                            u += 4;</span>
                        }
<span class="nc" id="L2178">                        break;</span>
                    case ClassWriter.VAR_INSN:
                    case ClassWriter.SBYTE_INSN:
                    case ClassWriter.LDC_INSN:
<span class="nc" id="L2182">                        u += 2;</span>
<span class="nc" id="L2183">                        break;</span>
                    case ClassWriter.SHORT_INSN:
                    case ClassWriter.LDCW_INSN:
                    case ClassWriter.FIELDORMETH_INSN:
                    case ClassWriter.TYPE_INSN:
                    case ClassWriter.IINC_INSN:
<span class="nc" id="L2189">                        u += 3;</span>
<span class="nc" id="L2190">                        break;</span>
                    case ClassWriter.ITFDYNMETH_INSN:
<span class="nc" id="L2192">                        u += 5;</span>
<span class="nc" id="L2193">                        break;</span>
                    // case ClassWriter.MANA_INSN:
                    default:
<span class="nc" id="L2196">                        u += 4;</span>
                        break;
                }
<span class="nc bnc" id="L2199" title="All 2 branches missed.">                if (insert != 0) {</span>
                    // adds a new (u, insert) entry in the allIndexes and
                    // allSizes arrays
<span class="nc" id="L2202">                    int[] newIndexes = new int[allIndexes.length + 1];</span>
<span class="nc" id="L2203">                    int[] newSizes = new int[allSizes.length + 1];</span>
<span class="nc" id="L2204">                    System.arraycopy(allIndexes,</span>
                            0,
                            newIndexes,
                            0,
                            allIndexes.length);
<span class="nc" id="L2209">                    System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);</span>
<span class="nc" id="L2210">                    newIndexes[allIndexes.length] = u;</span>
<span class="nc" id="L2211">                    newSizes[allSizes.length] = insert;</span>
<span class="nc" id="L2212">                    allIndexes = newIndexes;</span>
<span class="nc" id="L2213">                    allSizes = newSizes;</span>
<span class="nc bnc" id="L2214" title="All 2 branches missed.">                    if (insert &gt; 0) {</span>
<span class="nc" id="L2215">                        state = 3;</span>
                    }
                }
<span class="nc" id="L2218">            }</span>
<span class="nc bnc" id="L2219" title="All 2 branches missed.">            if (state &lt; 3) {</span>
<span class="nc" id="L2220">                --state;</span>
            }
<span class="nc bnc" id="L2222" title="All 2 branches missed.">        } while (state != 0);</span>

        // 2nd step:
        // copies the bytecode of the method into a new bytevector, updates the
        // offsets, and inserts (or removes) bytes as requested.

<span class="nc" id="L2228">        ByteVector newCode = new ByteVector(code.length);</span>

<span class="nc" id="L2230">        u = 0;</span>
<span class="nc bnc" id="L2231" title="All 2 branches missed.">        while (u &lt; code.length) {</span>
<span class="nc" id="L2232">            int opcode = b[u] &amp; 0xFF;</span>
<span class="nc bnc" id="L2233" title="All 10 branches missed.">            switch (ClassWriter.TYPE[opcode]) {</span>
                case ClassWriter.NOARG_INSN:
                case ClassWriter.IMPLVAR_INSN:
<span class="nc" id="L2236">                    newCode.putByte(opcode);</span>
<span class="nc" id="L2237">                    u += 1;</span>
<span class="nc" id="L2238">                    break;</span>
                case ClassWriter.LABEL_INSN:
<span class="nc bnc" id="L2240" title="All 2 branches missed.">                    if (opcode &gt; 201) {</span>
                        // changes temporary opcodes 202 to 217 (inclusive), 218
                        // and 219 to IFEQ ... JSR (inclusive), IFNULL and
                        // IFNONNULL
<span class="nc bnc" id="L2244" title="All 2 branches missed.">                        opcode = opcode &lt; 218 ? opcode - 49 : opcode - 20;</span>
<span class="nc" id="L2245">                        label = u + readUnsignedShort(b, u + 1);</span>
                    } else {
<span class="nc" id="L2247">                        label = u + readShort(b, u + 1);</span>
                    }
<span class="nc" id="L2249">                    newOffset = getNewOffset(allIndexes, allSizes, u, label);</span>
<span class="nc bnc" id="L2250" title="All 2 branches missed.">                    if (resize[u]) {</span>
                        // replaces GOTO with GOTO_W, JSR with JSR_W and IFxxx
                        // &lt;l&gt; with IFNOTxxx &lt;l'&gt; GOTO_W &lt;l&gt;, where IFNOTxxx is
                        // the &quot;opposite&quot; opcode of IFxxx (i.e., IFNE for IFEQ)
                        // and where &lt;l'&gt; designates the instruction just after
                        // the GOTO_W.
<span class="nc bnc" id="L2256" title="All 2 branches missed.">                        if (opcode == Opcodes.GOTO) {</span>
<span class="nc" id="L2257">                            newCode.putByte(200); // GOTO_W</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">                        } else if (opcode == Opcodes.JSR) {</span>
<span class="nc" id="L2259">                            newCode.putByte(201); // JSR_W</span>
                        } else {
<span class="nc bnc" id="L2261" title="All 2 branches missed.">                            newCode.putByte(opcode &lt;= 166</span>
                                    ? ((opcode + 1) ^ 1) - 1
                                    : opcode ^ 1);
<span class="nc" id="L2264">                            newCode.putShort(8); // jump offset</span>
<span class="nc" id="L2265">                            newCode.putByte(200); // GOTO_W</span>
                            // newOffset now computed from start of GOTO_W
<span class="nc" id="L2267">                            newOffset -= 3;</span>
                        }
<span class="nc" id="L2269">                        newCode.putInt(newOffset);</span>
                    } else {
<span class="nc" id="L2271">                        newCode.putByte(opcode);</span>
<span class="nc" id="L2272">                        newCode.putShort(newOffset);</span>
                    }
<span class="nc" id="L2274">                    u += 3;</span>
<span class="nc" id="L2275">                    break;</span>
                case ClassWriter.LABELW_INSN:
<span class="nc" id="L2277">                    label = u + readInt(b, u + 1);</span>
<span class="nc" id="L2278">                    newOffset = getNewOffset(allIndexes, allSizes, u, label);</span>
<span class="nc" id="L2279">                    newCode.putByte(opcode);</span>
<span class="nc" id="L2280">                    newCode.putInt(newOffset);</span>
<span class="nc" id="L2281">                    u += 5;</span>
<span class="nc" id="L2282">                    break;</span>
                case ClassWriter.TABL_INSN:
                    // skips 0 to 3 padding bytes
<span class="nc" id="L2285">                    v = u;</span>
<span class="nc" id="L2286">                    u = u + 4 - (v &amp; 3);</span>
                    // reads and copies instruction
<span class="nc" id="L2288">                    newCode.putByte(Opcodes.TABLESWITCH);</span>
<span class="nc" id="L2289">                    newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);</span>
<span class="nc" id="L2290">                    label = v + readInt(b, u);</span>
<span class="nc" id="L2291">                    u += 4;</span>
<span class="nc" id="L2292">                    newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2293">                    newCode.putInt(newOffset);</span>
<span class="nc" id="L2294">                    j = readInt(b, u);</span>
<span class="nc" id="L2295">                    u += 4;</span>
<span class="nc" id="L2296">                    newCode.putInt(j);</span>
<span class="nc" id="L2297">                    j = readInt(b, u) - j + 1;</span>
<span class="nc" id="L2298">                    u += 4;</span>
<span class="nc" id="L2299">                    newCode.putInt(readInt(b, u - 4));</span>
<span class="nc bnc" id="L2300" title="All 2 branches missed.">                    for (; j &gt; 0; --j) {</span>
<span class="nc" id="L2301">                        label = v + readInt(b, u);</span>
<span class="nc" id="L2302">                        u += 4;</span>
<span class="nc" id="L2303">                        newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2304">                        newCode.putInt(newOffset);</span>
                    }
                    break;
                case ClassWriter.LOOK_INSN:
                    // skips 0 to 3 padding bytes
<span class="nc" id="L2309">                    v = u;</span>
<span class="nc" id="L2310">                    u = u + 4 - (v &amp; 3);</span>
                    // reads and copies instruction
<span class="nc" id="L2312">                    newCode.putByte(Opcodes.LOOKUPSWITCH);</span>
<span class="nc" id="L2313">                    newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);</span>
<span class="nc" id="L2314">                    label = v + readInt(b, u);</span>
<span class="nc" id="L2315">                    u += 4;</span>
<span class="nc" id="L2316">                    newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2317">                    newCode.putInt(newOffset);</span>
<span class="nc" id="L2318">                    j = readInt(b, u);</span>
<span class="nc" id="L2319">                    u += 4;</span>
<span class="nc" id="L2320">                    newCode.putInt(j);</span>
<span class="nc bnc" id="L2321" title="All 2 branches missed.">                    for (; j &gt; 0; --j) {</span>
<span class="nc" id="L2322">                        newCode.putInt(readInt(b, u));</span>
<span class="nc" id="L2323">                        u += 4;</span>
<span class="nc" id="L2324">                        label = v + readInt(b, u);</span>
<span class="nc" id="L2325">                        u += 4;</span>
<span class="nc" id="L2326">                        newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2327">                        newCode.putInt(newOffset);</span>
                    }
                    break;
                case ClassWriter.WIDE_INSN:
<span class="nc" id="L2331">                    opcode = b[u + 1] &amp; 0xFF;</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">                    if (opcode == Opcodes.IINC) {</span>
<span class="nc" id="L2333">                        newCode.putByteArray(b, u, 6);</span>
<span class="nc" id="L2334">                        u += 6;</span>
                    } else {
<span class="nc" id="L2336">                        newCode.putByteArray(b, u, 4);</span>
<span class="nc" id="L2337">                        u += 4;</span>
                    }
<span class="nc" id="L2339">                    break;</span>
                case ClassWriter.VAR_INSN:
                case ClassWriter.SBYTE_INSN:
                case ClassWriter.LDC_INSN:
<span class="nc" id="L2343">                    newCode.putByteArray(b, u, 2);</span>
<span class="nc" id="L2344">                    u += 2;</span>
<span class="nc" id="L2345">                    break;</span>
                case ClassWriter.SHORT_INSN:
                case ClassWriter.LDCW_INSN:
                case ClassWriter.FIELDORMETH_INSN:
                case ClassWriter.TYPE_INSN:
                case ClassWriter.IINC_INSN:
<span class="nc" id="L2351">                    newCode.putByteArray(b, u, 3);</span>
<span class="nc" id="L2352">                    u += 3;</span>
<span class="nc" id="L2353">                    break;</span>
                case ClassWriter.ITFDYNMETH_INSN:
<span class="nc" id="L2355">                    newCode.putByteArray(b, u, 5);</span>
<span class="nc" id="L2356">                    u += 5;</span>
<span class="nc" id="L2357">                    break;</span>
                // case MANA_INSN:
                default:
<span class="nc" id="L2360">                    newCode.putByteArray(b, u, 4);</span>
<span class="nc" id="L2361">                    u += 4;</span>
                    break;
            }
<span class="nc" id="L2364">        }</span>

        // recomputes the stack map frames
<span class="nc bnc" id="L2367" title="All 2 branches missed.">        if (frameCount &gt; 0) {</span>
<span class="nc bnc" id="L2368" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L2369">                frameCount = 0;</span>
<span class="nc" id="L2370">                stackMap = null;</span>
<span class="nc" id="L2371">                previousFrame = null;</span>
<span class="nc" id="L2372">                frame = null;</span>
<span class="nc" id="L2373">                Frame f = new Frame();</span>
<span class="nc" id="L2374">                f.owner = labels;</span>
<span class="nc" id="L2375">                Type[] args = Type.getArgumentTypes(descriptor);</span>
<span class="nc" id="L2376">                f.initInputFrame(cw, access, args, maxLocals);</span>
<span class="nc" id="L2377">                visitFrame(f);</span>
<span class="nc" id="L2378">                Label l = labels;</span>
<span class="nc bnc" id="L2379" title="All 2 branches missed.">                while (l != null) {</span>
                    /*
                     * here we need the original label position. getNewOffset
                     * must therefore never have been called for this label.
                     */
<span class="nc" id="L2384">                    u = l.position - 3;</span>
<span class="nc bnc" id="L2385" title="All 6 branches missed.">                    if ((l.status &amp; Label.STORE) != 0 || (u &gt;= 0 &amp;&amp; resize[u]))</span>
                    {
<span class="nc" id="L2387">                        getNewOffset(allIndexes, allSizes, l);</span>
                        // TODO update offsets in UNINITIALIZED values
<span class="nc" id="L2389">                        visitFrame(l.frame);</span>
                    }
<span class="nc" id="L2391">                    l = l.successor;</span>
                }
<span class="nc" id="L2393">            } else {</span>
                /*
                 * Resizing an existing stack map frame table is really hard.
                 * Not only the table must be parsed to update the offets, but
                 * new frames may be needed for jump instructions that were
                 * inserted by this method. And updating the offsets or
                 * inserting frames can change the format of the following
                 * frames, in case of packed frames. In practice the whole table
                 * must be recomputed. For this the frames are marked as
                 * potentially invalid. This will cause the whole class to be
                 * reread and rewritten with the COMPUTE_FRAMES option (see the
                 * ClassWriter.toByteArray method). This is not very efficient
                 * but is much easier and requires much less code than any other
                 * method I can think of.
                 */
<span class="nc" id="L2408">                cw.invalidFrames = true;</span>
            }
        }
        // updates the exception handler block labels
<span class="nc" id="L2412">        Handler h = firstHandler;</span>
<span class="nc bnc" id="L2413" title="All 2 branches missed.">        while (h != null) {</span>
<span class="nc" id="L2414">            getNewOffset(allIndexes, allSizes, h.start);</span>
<span class="nc" id="L2415">            getNewOffset(allIndexes, allSizes, h.end);</span>
<span class="nc" id="L2416">            getNewOffset(allIndexes, allSizes, h.handler);</span>
<span class="nc" id="L2417">            h = h.next;</span>
        }
        // updates the instructions addresses in the
        // local var and line number tables
<span class="nc bnc" id="L2421" title="All 2 branches missed.">        for (i = 0; i &lt; 2; ++i) {</span>
<span class="nc bnc" id="L2422" title="All 2 branches missed.">            ByteVector bv = i == 0 ? localVar : localVarType;</span>
<span class="nc bnc" id="L2423" title="All 2 branches missed.">            if (bv != null) {</span>
<span class="nc" id="L2424">                b = bv.data;</span>
<span class="nc" id="L2425">                u = 0;</span>
<span class="nc bnc" id="L2426" title="All 2 branches missed.">                while (u &lt; bv.length) {</span>
<span class="nc" id="L2427">                    label = readUnsignedShort(b, u);</span>
<span class="nc" id="L2428">                    newOffset = getNewOffset(allIndexes, allSizes, 0, label);</span>
<span class="nc" id="L2429">                    writeShort(b, u, newOffset);</span>
<span class="nc" id="L2430">                    label += readUnsignedShort(b, u + 2);</span>
<span class="nc" id="L2431">                    newOffset = getNewOffset(allIndexes, allSizes, 0, label)</span>
                            - newOffset;
<span class="nc" id="L2433">                    writeShort(b, u + 2, newOffset);</span>
<span class="nc" id="L2434">                    u += 10;</span>
                }
            }
        }
<span class="nc bnc" id="L2438" title="All 2 branches missed.">        if (lineNumber != null) {</span>
<span class="nc" id="L2439">            b = lineNumber.data;</span>
<span class="nc" id="L2440">            u = 0;</span>
<span class="nc bnc" id="L2441" title="All 2 branches missed.">            while (u &lt; lineNumber.length) {</span>
<span class="nc" id="L2442">                writeShort(b, u, getNewOffset(allIndexes,</span>
                        allSizes,
                        0,
<span class="nc" id="L2445">                        readUnsignedShort(b, u)));</span>
<span class="nc" id="L2446">                u += 4;</span>
            }
        }
        // updates the labels of the other attributes
<span class="nc" id="L2450">        Attribute attr = cattrs;</span>
<span class="nc bnc" id="L2451" title="All 2 branches missed.">        while (attr != null) {</span>
<span class="nc" id="L2452">            Label[] labels = attr.getLabels();</span>
<span class="nc bnc" id="L2453" title="All 2 branches missed.">            if (labels != null) {</span>
<span class="nc bnc" id="L2454" title="All 2 branches missed.">                for (i = labels.length - 1; i &gt;= 0; --i) {</span>
<span class="nc" id="L2455">                    getNewOffset(allIndexes, allSizes, labels[i]);</span>
                }
            }
<span class="nc" id="L2458">            attr = attr.next;</span>
<span class="nc" id="L2459">        }</span>

        // replaces old bytecodes with new ones
<span class="nc" id="L2462">        code = newCode;</span>
<span class="nc" id="L2463">    }</span>

    /**
     * Reads an unsigned short value in the given byte array.
     * 
     * @param b a byte array.
     * @param index the start index of the value to be read.
     * @return the read value.
     */
    static int readUnsignedShort(final byte[] b, final int index) {
<span class="fc" id="L2473">        return ((b[index] &amp; 0xFF) &lt;&lt; 8) | (b[index + 1] &amp; 0xFF);</span>
    }

    /**
     * Reads a signed short value in the given byte array.
     * 
     * @param b a byte array.
     * @param index the start index of the value to be read.
     * @return the read value.
     */
    static short readShort(final byte[] b, final int index) {
<span class="fc" id="L2484">        return (short) (((b[index] &amp; 0xFF) &lt;&lt; 8) | (b[index + 1] &amp; 0xFF));</span>
    }

    /**
     * Reads a signed int value in the given byte array.
     * 
     * @param b a byte array.
     * @param index the start index of the value to be read.
     * @return the read value.
     */
    static int readInt(final byte[] b, final int index) {
<span class="fc" id="L2495">        return ((b[index] &amp; 0xFF) &lt;&lt; 24) | ((b[index + 1] &amp; 0xFF) &lt;&lt; 16)</span>
                | ((b[index + 2] &amp; 0xFF) &lt;&lt; 8) | (b[index + 3] &amp; 0xFF);
    }

    /**
     * Writes a short value in the given byte array.
     * 
     * @param b a byte array.
     * @param index where the first byte of the short value must be written.
     * @param s the value to be written in the given byte array.
     */
    static void writeShort(final byte[] b, final int index, final int s) {
<span class="fc" id="L2507">        b[index] = (byte) (s &gt;&gt;&gt; 8);</span>
<span class="fc" id="L2508">        b[index + 1] = (byte) s;</span>
<span class="fc" id="L2509">    }</span>

    /**
     * Computes the future value of a bytecode offset. &lt;p&gt; Note: it is possible
     * to have several entries for the same instruction in the &lt;tt&gt;indexes&lt;/tt&gt;
     * and &lt;tt&gt;sizes&lt;/tt&gt;: two entries (index=a,size=b) and (index=a,size=b')
     * are equivalent to a single entry (index=a,size=b+b').
     * 
     * @param indexes current positions of the instructions to be resized. Each
     *        instruction must be designated by the index of its &lt;i&gt;last&lt;/i&gt;
     *        byte, plus one (or, in other words, by the index of the &lt;i&gt;first&lt;/i&gt;
     *        byte of the &lt;i&gt;next&lt;/i&gt; instruction).
     * @param sizes the number of bytes to be &lt;i&gt;added&lt;/i&gt; to the above
     *        instructions. More precisely, for each i &lt; &lt;tt&gt;len&lt;/tt&gt;,
     *        &lt;tt&gt;sizes&lt;/tt&gt;[i] bytes will be added at the end of the
     *        instruction designated by &lt;tt&gt;indexes&lt;/tt&gt;[i] or, if
     *        &lt;tt&gt;sizes&lt;/tt&gt;[i] is negative, the &lt;i&gt;last&lt;/i&gt; |&lt;tt&gt;sizes[i]&lt;/tt&gt;|
     *        bytes of the instruction will be removed (the instruction size
     *        &lt;i&gt;must not&lt;/i&gt; become negative or null).
     * @param begin index of the first byte of the source instruction.
     * @param end index of the first byte of the target instruction.
     * @return the future value of the given bytecode offset.
     */
    static int getNewOffset(
        final int[] indexes,
        final int[] sizes,
        final int begin,
        final int end)
    {
<span class="fc" id="L2538">        int offset = end - begin;</span>
<span class="fc bfc" id="L2539" title="All 2 branches covered.">        for (int i = 0; i &lt; indexes.length; ++i) {</span>
<span class="fc bfc" id="L2540" title="All 4 branches covered.">            if (begin &lt; indexes[i] &amp;&amp; indexes[i] &lt;= end) {</span>
                // forward jump
<span class="fc" id="L2542">                offset += sizes[i];</span>
<span class="fc bfc" id="L2543" title="All 4 branches covered.">            } else if (end &lt; indexes[i] &amp;&amp; indexes[i] &lt;= begin) {</span>
                // backward jump
<span class="fc" id="L2545">                offset -= sizes[i];</span>
            }
        }
<span class="fc" id="L2548">        return offset;</span>
    }

    /**
     * Updates the offset of the given label.
     * 
     * @param indexes current positions of the instructions to be resized. Each
     *        instruction must be designated by the index of its &lt;i&gt;last&lt;/i&gt;
     *        byte, plus one (or, in other words, by the index of the &lt;i&gt;first&lt;/i&gt;
     *        byte of the &lt;i&gt;next&lt;/i&gt; instruction).
     * @param sizes the number of bytes to be &lt;i&gt;added&lt;/i&gt; to the above
     *        instructions. More precisely, for each i &lt; &lt;tt&gt;len&lt;/tt&gt;,
     *        &lt;tt&gt;sizes&lt;/tt&gt;[i] bytes will be added at the end of the
     *        instruction designated by &lt;tt&gt;indexes&lt;/tt&gt;[i] or, if
     *        &lt;tt&gt;sizes&lt;/tt&gt;[i] is negative, the &lt;i&gt;last&lt;/i&gt; |&lt;tt&gt;sizes[i]&lt;/tt&gt;|
     *        bytes of the instruction will be removed (the instruction size
     *        &lt;i&gt;must not&lt;/i&gt; become negative or null).
     * @param label the label whose offset must be updated.
     */
    static void getNewOffset(
        final int[] indexes,
        final int[] sizes,
        final Label label)
    {
<span class="pc bpc" id="L2572" title="1 of 2 branches missed.">        if ((label.status &amp; Label.RESIZED) == 0) {</span>
<span class="fc" id="L2573">            label.position = getNewOffset(indexes, sizes, 0, label.position);</span>
<span class="fc" id="L2574">            label.status |= Label.RESIZED;</span>
        }
<span class="fc" id="L2576">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>