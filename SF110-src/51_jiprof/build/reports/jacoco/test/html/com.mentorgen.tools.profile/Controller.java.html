<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Controller.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">51_jiprof</a> &gt; <a href="index.source.html" class="el_package">com.mentorgen.tools.profile</a> &gt; <span class="el_source">Controller.java</span></div><h1>Controller.java</h1><pre class="source lang-java linenums">/*
Copyright (c) 2005-2006, MentorGen, LLC
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

+ Redistributions of source code must retain the above copyright notice, 
  this list of conditions and the following disclaimer.
+ Redistributions in binary form must reproduce the above copyright notice, 
  this list of conditions and the following disclaimer in the documentation 
  and/or other materials provided with the distribution.
+ Neither the name of MentorGen LLC nor the names of its contributors may be 
  used to endorse or promote products derived from this software without 
  specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
 */
package com.mentorgen.tools.profile;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.util.ArrayList;
import java.util.Properties;
import java.util.StringTokenizer;

import net.sourceforge.jiprof.instrument.clfilter.GenericClassLoaderFilter;

import com.mentorgen.tools.profile.instrument.clfilter.ClassLoaderFilter;
import com.mentorgen.tools.profile.instrument.clfilter.StandardClassLoaderFilter;
import com.mentorgen.tools.profile.output.ProfileDump;
import com.mentorgen.tools.profile.runtime.Profile;

/**
 * &lt;code&gt;Controller&lt;/code&gt; reads the properties file that controls
 * how the profiler operates, both when the byte code is instrumented
 * as well as at runtime. It also opens a server socket to receive 
 * remote commands to modify the profiler's behavior, like turning 
 * the profiler on and off, but only if &lt;code&gt;remote=on&lt;/code&gt; 
 * has been specified in the profile properties. Here's a short
 * description of all of the properties that are supported:
		&lt;ul&gt;
			&lt;li&gt;&lt;a href=&quot;#profiler&quot;&gt;profiler&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#remote&quot;&gt;remote&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#port&quot;&gt;port&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#classloader&quot;&gt;ClassLoaderFilter.x&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#thread-depth&quot;&gt;thread-depth&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#thread-threshold&quot;&gt;thread.compact.threshold.ms&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#max-method-count&quot;&gt;max-method-count&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#method-threshold&quot;&gt;method.compact.threshold.ms&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#file&quot;&gt;file&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#exlcude&quot;&gt;exclude&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#include&quot;&gt;include&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#alloc&quot;&gt;track.object.alloc&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#debug&quot;&gt;debug&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#profiler-class&quot;&gt;profiler-class&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#output-method-signatures&quot;&gt;output-method-signatures&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#clock-resolution&quot;&gt;clock-resolution&lt;/a&gt;&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#output-summary-only&quot;&gt;output-summary-only&lt;/li&gt;
			&lt;li&gt;&lt;a href=&quot;#accept-class-loaders&quot;&gt;accept-class-loaders&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#accept-class-loaders-byname&quot;&gt;accept-class-loaders-byname&lt;/li&gt;
		&lt;/ul&gt;
		
		&lt;A NAME=&quot;profiler&quot;/&gt;
		&lt;h3&gt;profiler&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: on, off&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: on&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: controls whether or not profiling information
			is gathered when the VM starts. Usually you'll want this to 
			be on for command-line apps but off if you're profiling a web
			app.
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;remote&quot;/&gt;
		&lt;h3&gt;remote&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: on, off&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: off&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: controls whether of not the remote interface
			is enabled or not. The remote interface allows you to turn the
			profiler on and off at runtime. This lets you take multiple 
			measurements without having to stop and start the application. 
			Usually you'll want this to be &lt;code&gt;on&lt;/code&gt; for webapps
			but &lt;code&gt;off&lt;/code&gt; for command-line apps.
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;port&quot;/&gt;
		&lt;h3&gt;port&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: any valid TCP port number&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: 15599&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: this controls which port the remote interface 
			listens on.
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;classloader&quot;/&gt;
		&lt;h3&gt;ClassLoaderFilter.x&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: any valid implemtation of 
			&lt;code&gt;com.mentorgen.tools.profile.ClassLoaderFilter&lt;/code&gt;&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: If no class loader filters a specificed then
		&lt;code&gt;net.sourceforge.jiprof.instrument.clfilter.GenericClassLoaderFilter&lt;/code&gt;
			is used (see also: &lt;a href=&quot;#accept-class-loaders&quot;&gt;accept-class-loaders&lt;/a&gt;).&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: JIP has to know which classloader will be 
			loading the classes to be profiled. With command-line
			apps we know what this is. However webapps and other
			kinds of apps that run in a container use different classloaders.
			The solution to this was to defined an interface: 
		&lt;code&gt;ClassLoaderFilter&lt;/code&gt; to use in a chain of responsilbility
			pattern to determine which classloader should be &quot;hooked&quot;
			for profiling. The way this works is that you can define a number
			of realizations of this interface, one of each different env.
			You specify the search order by appending a number to the end
			of the property. For exmaple, the standard setup is:&lt;pre&gt;&lt;code&gt;
ClassLoaderFilter.1=com.mentorgen.tools.profile.instrument.clfilter.WebAppClassLoaderFilter
ClassLoaderFilter.2=com.mentorgen.tools.profile.instrument.clfilter.StandardClassLoaderFilter		
	&lt;/code&gt;&lt;/pre&gt;
			This indicates that the &lt;code&gt;WebAppClassLoaderFilter&lt;/code&gt;
			should be called to determine if we're running in Tomcat. If that
			fails, call the &lt;code&gt;StandardClassLoaderFilter&lt;/code&gt;. Note
			that currently only the Java 5(tm) and Tomcat 5.5 environments
			are supported. People who would like to add support for other
			environments are encouraged to do so.
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;thread-depth&quot;/&gt;
		&lt;h3&gt;thread-depth&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: any positive integer, -1 or &lt;i&gt;compact&lt;/i&gt;&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: -1&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: Call stacks can get really deep and sometimes
			you only want to see a certain number of levels. This parameter
			controls the number of levels you will see. The default is -1 
			which means that there is no limit. Another option that can
			be used is &lt;i&gt;compact&lt;/i&gt;. This will limit the call stacks
			to items that have a gross time that is at least 10 ms (this 
			can be &lt;a href=&quot;#hread-threshold&quot;&gt;changed&lt;/a&gt;). Using
			&lt;i&gt;compact&lt;/i&gt; is nice way to limit what you see while not
			imposing an arbitrary limit on the thread-depth.
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;thread-threshold&quot;/&gt;
		&lt;h3&gt;thread.compact.threshold.ms&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: any positive integer&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: 10&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: Modifies the call stack output to 
			only show nodes with the given gross time. Only works when
			&lt;code&gt;thread-depth&lt;/code&gt; is set to &lt;i&gt;compact&lt;/i&gt;
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;max-method-count&quot;/&gt;
		&lt;h3&gt;max-method-count&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: any positive integer, -1 or &lt;i&gt;compact&lt;/i&gt;&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: -1&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: This property modifieds the section 
			of the profiler output that shows the most expensive method. 
			Giving a number greater than -1 will limit the number of methods
			that are shown. -1 means no limit. &lt;i&gt;compact&lt;/i&gt; can be usd to 
			show only methods with a creatin minimum gross time (the
			default is 10ms but can be changed by using 
			&lt;a href=&quot;#method-threshold&quot;&gt;method.compact.threshold.ms&lt;/a&gt;
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;method-threshold&quot;/&gt;
		&lt;h3&gt;method.compact.threshold.ms&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: any positive integer&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: 10&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: Modifies the method output to 
			only show methods with the given gross time. Only works when
			&lt;code&gt;max-method-count&lt;/code&gt; is set to &lt;i&gt;compact&lt;/i&gt;.
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;file&quot;/&gt;
		&lt;h3&gt;file&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: the name of any valid file or directory.&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: ./profile.txt&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: Names the file that the profile is
			sent to. If this is a directory, JIP will auto-generate 
			file names and
			put the files in that directory. The format for the
			generated file name is &lt;code&gt;yyyyMMdd-HHmmss&lt;/code&gt;.
		&lt;/blockquote&gt;

		&lt;a name=&quot;exlcude&quot;/&gt;
		&lt;h3&gt;exclude&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: a comman spearated list of package or class
			names (class names must be fully qualified).&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: &lt;i&gt;no default&lt;/i&gt;&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: the values for this property name
			packages or classes to be excluded from the profile. This
			is handy when you have a chatty package or class that you
			just don't want to see all over the place. Note that only
			classes that are loaded by the &amp;quot;app&amp;quot; class loader
			are profiled to start with.
		&lt;/blockquote&gt;

		&lt;a name=&quot;include&quot;/&gt;
		&lt;h3&gt;include&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: a comman spearated list of package or class
			names (class names must be fully qualified).&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: &lt;i&gt;no default&lt;/i&gt;&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: the values for this property name
			packages or classes to be explicitly included in the profile.
			Normally, you wouldn't use this, you'd let the &lt;code&gt;&lt;a href=&quot;#classloader&quot;&gt;ClassLoaderFilter&lt;/a&gt;&lt;/code&gt;
			determine which classes to include. If you don't want to see something,
			use &lt;code&gt;&lt;a href=&quot;#exlcude&quot;&gt;exclude&lt;/a&gt;&lt;/code&gt;. However, there
			are situations where you want to exclude so much stuff, that it's easier
			just to say what you want to be included. When using both exclude and include,
			the include list is applied, then the exclude list is applied.
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;alloc&quot;/&gt;
		&lt;h3&gt;track.object.alloc&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt;&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: &lt;code&gt;off&lt;/code&gt;&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: control whether or not JIP tracks 
			object allocation. 
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;output&quot;/&gt;
		&lt;h3&gt;output&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;xml&lt;/code&gt; or &lt;code&gt;both&lt;/code&gt;&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: &lt;code&gt;text&lt;/code&gt;&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: in addition to the standard human readable
			profiles, this option allows you to output the profile information
			in a raw XML format.
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;debug&quot;/&gt;
		&lt;h3&gt;debug&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt;&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: &lt;code&gt;off&lt;/code&gt;&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: when debug is turned on, text will be sent to 
			standard out each time a class is classloaded and inspected by
			the profiler for possbile instrumentation (see &lt;code&gt;
			com.mentorgen.tools.profile.instrument.Transformer&lt;/code&gt;). If the 
			class is instrumented, &lt;code&gt;INST&lt;/code&gt;, plus the class name
			plus the classloader name will be sent to stddout. If the class
			is not instrumented, &lt;code&gt;skip&lt;/code&gt;, plus the class name
			plus the classloader name will be sent to stddout. This is a 
			helpful tool when the profile you're getting (or not getting)
			doesn't match what you're expecting.&lt;p/&gt;
			In addition, text will be sent to standard error when an exception is
			detected and when the profile for a method has not been completed 
			when the profiler terminates. &lt;br/&gt;
			Exceptions are usually handled gracefully.
			However, there are some cases where they skew the timings and therefore
			the output is incorrect. Knowing that an exception is being thrown is a great
			help in diagnosing problems like this.&lt;br/&gt;
			Needing to &amp;quot;fixup&amp;quot; the profile
			for one or two methods is also not that unusual. However, if the timing
			for a method seems to be incorrect, knowing if the profiler needed to
			fixup that method can be useful from a diagnosics perspective.			
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;profiler-class&quot;/&gt;
		&lt;h3&gt;profiler-class&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values&lt;/b&gt;: any class name&lt;br/&gt;
			&lt;b&gt;Default&lt;/b&gt;: &lt;code&gt;com.mentorgen.tools.profile.runtime.Profile&lt;/code&gt;&lt;br/&gt;
			&lt;b&gt;Description&lt;/b&gt;: allows the another profiling backend to be used. 
		&lt;/blockquote&gt;		
		
		&lt;a name=&quot;output-method-signatures&quot;/&gt;
		&lt;h3&gt;output-method-signatures&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values:&lt;/b&gt; &lt;code&gt;yes&lt;/code&gt; or &lt;code&gt;no&lt;/code&gt;&lt;/br&gt;
			&lt;b&gt;Default:&lt;/b&gt; &lt;code&gt;no&lt;/code&gt;&lt;/br&gt;
			&lt;b&gt;Description:&lt;/b&gt; When set to &lt;code&gt;yes&lt;/code&gt;, outputs the signature
			of methods. By default, the method signature is omitted from the output
			to save space. However, if you're dealing with methods that have been overloaded
			you need to be able to see the method signature.&lt;/br&gt;
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;clock-resolution&quot;/&gt;
		&lt;h3&gt;clock-resolution&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values:&lt;/b&gt; &lt;code&gt;ms&lt;/code&gt; or &lt;code&gt;ns&lt;/code&gt;&lt;/br&gt;
			&lt;b&gt;Default:&lt;/b&gt; &lt;code&gt;ns&lt;/code&gt;&lt;/br&gt;
			&lt;b&gt;Description:&lt;/b&gt; Sets the resolution of the TimeLineProfiler's clock to either milliseconds
			(&lt;code&gt;ms&lt;/code&gt;) or nanoseconds (&lt;code&gt;ns&lt;/code&gt;). Only valid when using the &lt;code&gt;
			TimeLineProfiler&lt;/code&gt;.&lt;/br&gt;
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;output-summary-only&quot;/&gt;
		&lt;h3&gt;output-summary-only&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values:&lt;/b&gt; &lt;code&gt;yes&lt;/code&gt; or &lt;code&gt;no&lt;/code&gt;&lt;/br&gt;
			&lt;b&gt;Default:&lt;/b&gt; &lt;code&gt;no&lt;/code&gt;&lt;/br&gt;
			&lt;b&gt;Description:&lt;/b&gt; When set to &lt;code&gt;yes&lt;/code&gt; the top most section of the profiler output
			(the section that contains thread + call stack information) is omitted. The section can be 
			quite large so it is sometime desirable to not have to page through it to get to the 
			summary information. &lt;/br&gt;
		&lt;/blockquote&gt;
		
		&lt;a name=&quot;accept-class-loaders&quot;/&gt;
		&lt;h3&gt;accept-class-loaders&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values:&lt;/b&gt; A comma separated list of classloader names (you can also specify
			interface names)&lt;/br&gt;
			&lt;b&gt;Default:&lt;/b&gt; If no values are given, &lt;code&gt;java.lang.ClassLoader.getSystemClassLoader()&lt;/code&gt; 
			is used.&lt;/br&gt;
			&lt;b&gt;Description:&lt;/b&gt; A list of &lt;code&gt;Class Loaders&lt;/code&gt; whose classes will be instrumented 
			when using &lt;code&gt;net.sourceforge.jiprof.instrument.clfilter.GenericClassLoaderFilter&lt;/code&gt;
			as the classloader filter. Note that when looking to determine if profiling should be applied 
			to a classloader, &lt;code&gt;instanceof&lt;/code&gt; is used as the mode of comparison. This means, for 
			example, that when profiling Tomcat, you can specify &lt;code&gt;org.apache.catalina.loader.Reloader&lt;/code&gt;
			which is an interface rather than a subclass of &lt;code&gt;java.lang.ClassLoader&lt;/code&gt;.
			&lt;/br&gt;
		&lt;/blockquote&gt;

 		&lt;a name=&quot;accept-class-loaders-byname&quot;/&gt;
		&lt;h3&gt;accept-class-loaders-byname&lt;/h3&gt;
		&lt;blockquote&gt;
			&lt;b&gt;Values:&lt;/b&gt; A comma separated list of classloader names&lt;/br&gt;
			&lt;b&gt;Default:&lt;/b&gt;None&lt;/br&gt;
			&lt;b&gt;Description:&lt;/b&gt;A list of &lt;code&gt;Class Loaders&lt;/code&gt; whose classes will be instrumented
			when using &lt;code&gt;net.sourceforge.jiprof.instrument.clfilter.CustomMultiClassLoaderFilter&lt;/code&gt;
			as the classloader filter. The comparison used to determing if profiling should be applied is an exact
            string match to the classloader, an actual &lt;code&gt;instanceof&lt;/code&gt; is not used.
			&lt;/br&gt;
		&lt;/blockquote&gt;
 * 
 * 
 * 
 * @author Andrew Wilcox
 *
 */
<span class="fc" id="L356">public class Controller implements Runnable {</span>
	private static final String DEFAULT_PROFILE = &quot;on&quot;;
	private static final String DEFAULT_REMOVE = &quot;off&quot;;
	private static final String DEFAULT_PORT = &quot;15599&quot;;
	private static final String DEFAULT_MAX_THREAD_DEPTH = &quot;-1&quot;;
	private static final String DEFAULT_THREAD_COMPACT_THRESHOLD = &quot;10&quot;;
	private static final String DEFAULT_MAX_METHOD_COUNT = &quot;-1&quot;;
	private static final String DEFAULT_METHOD_COMPACT_THRESHOLD = &quot;10&quot;;
	private static final String DEFAULT_FILE=&quot;profile.txt&quot;;
	private static final String DEFAULT_OBJECT_ALLOC = &quot;off&quot;;
	private static final String DEFAULT_PROFILER_CLASS = &quot;com.mentorgen.tools.profile.runtime.Profile&quot;;
	
	private static final String ON = &quot;on&quot;;
	
	public static final int UNLIMITED = -1; 
	
	private static final String START = &quot;start&quot;;
	private static final String STOP = &quot;stop&quot;;
	private static final String DUMP = &quot;dump&quot;;
	private static final String FILE = &quot;file&quot;;
	private static final String CLEAR = &quot;clear&quot;;
	private static final String FINISH = &quot;finish&quot;;
    private static final String DEBUGON = &quot;debugon&quot;;
    private static final String DEBUGOFF = &quot;debugoff&quot;;
    private static final String REPLACEEXCLUDELIST = &quot;replaceexcludelist&quot;;
    private static final String GETEXCLUDELIST = &quot;getexcludelist&quot;;
    private static final String REPLACEINCLUDELIST = &quot;replaceincludelist&quot;;
    private static final String GETINCLUDELIST = &quot;getincludelist&quot;;
    private static final String GETCLASSLOADERSBYNAME = &quot;getclassloadersbyname&quot;;
    private static final String REPLACECLASSLOADERSBYNAME = &quot;replaceclassloadersbyname&quot;;
	
<span class="fc" id="L387">	public static enum OutputType {Text, XML, Both };</span>
<span class="fc" id="L388">	public static enum TimeResolution { ms, ns };</span>
	
	public static boolean _profile;
	public static boolean _remote;
	public static int _port;
	public static int _threadDepth;
	public static int _methodCount;
	public static String _fileName;
	public static String[] _excludeList;
	public static String[] _includeList;
    public static String[] _acceptClassLoadersByName;
<span class="fc" id="L399">	public static boolean _compactThreadDepth = false;</span>
<span class="fc" id="L400">	public static boolean _compactMethodCount = false;</span>
	public static int _compactThreadThreshold;
	public static int _compactMethodThreshold;
<span class="fc" id="L403">	public static boolean _trackObjectAlloc = false;</span>
	public static ClassLoaderFilter _filter;
<span class="fc" id="L405">	public static OutputType _outputType  = OutputType.Text;</span>
<span class="fc" id="L406">	public static boolean _debug = false;</span>
	public static String _profiler;
<span class="fc" id="L408">	public static boolean _outputMethodSignatures = false;</span>
	public static TimeResolution _timeResoltion;
<span class="fc" id="L410">	public static boolean _outputSummaryOnly = false;</span>
	public static Class[] _acceptClassLoaders;
	
<span class="fc" id="L413">	public static int _instrumentCount = 0;</span>
	
	private ServerSocket _socket; 
	
	static {
<span class="fc" id="L418">		Properties props = new Properties();</span>
<span class="fc" id="L419">		String propsFile = System.getProperty(&quot;profile.properties&quot;);</span>
		
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">		if (propsFile != null) {</span>
			try {
<span class="nc" id="L423">				props.load(new FileInputStream(propsFile));</span>
<span class="nc" id="L424">			} catch (IOException e) {</span>
<span class="nc" id="L425">				System.err.print(&quot;Unable to open &quot;);</span>
<span class="nc" id="L426">				System.err.print(propsFile);</span>
<span class="nc" id="L427">				System.err.println(&quot;. Using the defaults.&quot;);</span>
<span class="nc" id="L428">			}			</span>
		}
		
<span class="fc" id="L431">		String profile = getProperty(props,&quot;profiler&quot;, DEFAULT_PROFILE);</span>
<span class="fc" id="L432">		String remote = getProperty(props, &quot;remote&quot;, DEFAULT_REMOVE);</span>
<span class="fc" id="L433">		String port = getProperty(props, &quot;port&quot;, DEFAULT_PORT);</span>
<span class="fc" id="L434">		String threadDepth = getProperty(props, &quot;thread-depth&quot;, DEFAULT_MAX_THREAD_DEPTH);</span>
<span class="fc" id="L435">		String threadCompactThreshold = getProperty(props, &quot;thread.compact.threshold.ms&quot;, DEFAULT_THREAD_COMPACT_THRESHOLD);</span>
<span class="fc" id="L436">		String maxMethodCount = getProperty(props, &quot;max-method-count&quot;, DEFAULT_MAX_METHOD_COUNT);</span>
<span class="fc" id="L437">		String methodCompactThreshold = getProperty(props, &quot;method.compact.threshold.ms&quot;, DEFAULT_METHOD_COMPACT_THRESHOLD);</span>
<span class="fc" id="L438">		String file = getProperty(props,&quot;file&quot;, DEFAULT_FILE);</span>
<span class="fc" id="L439">		String objectAlloc = getProperty(props,&quot;track.object.alloc&quot;, DEFAULT_OBJECT_ALLOC);</span>
<span class="fc" id="L440">		String outputType = getProperty(props, &quot;output&quot;, &quot;text&quot;);</span>
<span class="fc" id="L441">		String debug = getProperty(props, &quot;debug&quot;, &quot;off&quot;);</span>
<span class="fc" id="L442">		String profiler = getProperty(props, &quot;profiler-class&quot;, DEFAULT_PROFILER_CLASS);</span>
<span class="fc" id="L443">		String methodSigs = getProperty(props, &quot;output-method-signatures&quot;, &quot;no&quot;);</span>
<span class="fc" id="L444">		String clockResolution = getProperty(props, &quot;clock-resolution&quot;, &quot;ms&quot;);</span>
<span class="fc" id="L445">		String outputSummaryOnly = getProperty(props, &quot;output-summary-only&quot;, &quot;no&quot;);</span>
		
<span class="fc" id="L447">		Controller._profile = profile.equals(ON);</span>
<span class="fc" id="L448">		Controller._remote = remote.equals(ON);</span>
<span class="fc" id="L449">		Controller._port = Integer.parseInt(port);</span>
<span class="fc" id="L450">		Controller._compactThreadThreshold = Integer.parseInt(threadCompactThreshold);</span>
<span class="fc" id="L451">		Controller._compactMethodThreshold = Integer.parseInt(methodCompactThreshold);</span>
		
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">		if (&quot;compact&quot;.equals(threadDepth.trim())) {</span>
<span class="nc" id="L454">			Controller._compactThreadDepth = true;</span>
		} else {
<span class="fc" id="L456">			Controller._threadDepth = Integer.parseInt(threadDepth);</span>
		}
		
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">		if (&quot;compact&quot;.equals(maxMethodCount.trim())) {</span>
<span class="nc" id="L460">			Controller._compactMethodCount = true;</span>
		} else {
<span class="fc" id="L462">			Controller._methodCount = Integer.parseInt(maxMethodCount);</span>
		}
		
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">		if (&quot;on&quot;.equalsIgnoreCase(objectAlloc.trim())) {</span>
<span class="nc" id="L466">			_trackObjectAlloc = true;</span>
		}
		
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">		if (&quot;on&quot;.equalsIgnoreCase(debug.trim())) {</span>
<span class="nc" id="L470">			_debug = true;</span>
		}
		
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">		if (&quot;yes&quot;.equalsIgnoreCase(methodSigs)) {</span>
<span class="nc" id="L474">			_outputMethodSignatures = true;</span>
		}
		
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">		if (&quot;text&quot;.equalsIgnoreCase(outputType.trim())) {</span>
<span class="fc" id="L478">			_outputType = OutputType.Text;</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">		} else if (&quot;xml&quot;.equalsIgnoreCase(outputType.trim())) {</span>
<span class="nc" id="L480">			_outputType = OutputType.XML;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">		} else if (&quot;both&quot;.equalsIgnoreCase(outputType.trim())) {</span>
<span class="nc" id="L482">			_outputType = OutputType.Both;</span>
		}
		
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">		if (&quot;ms&quot;.equalsIgnoreCase(clockResolution)) {</span>
<span class="fc" id="L486">			_timeResoltion = TimeResolution.ms;</span>
		} else {
<span class="nc" id="L488">			_timeResoltion = TimeResolution.ns;</span>
		}
		
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">		if (&quot;yes&quot;.equalsIgnoreCase(outputSummaryOnly)) {</span>
<span class="nc" id="L492">			_outputSummaryOnly = true;</span>
		}
		
<span class="fc" id="L495">		Controller._fileName = file;</span>
		
<span class="fc" id="L497">		String excludeList = props.getProperty(&quot;exclude&quot;);</span>
<span class="fc" id="L498">		String includeList = props.getProperty(&quot;include&quot;);</span>

<span class="fc" id="L500">		System.out.print(&quot;exclude:&quot;);</span>
<span class="fc" id="L501">		System.out.println(excludeList);</span>

<span class="pc bpc" id="L503" title="3 of 4 branches missed.">		if (includeList != null &amp;&amp; includeList.length() &gt; 0) {</span>
<span class="nc" id="L504">			System.out.print(&quot;include:&quot;);</span>
<span class="nc" id="L505">			System.out.println(includeList);</span>
		}
		
<span class="fc" id="L508">		Controller._excludeList = parseList(excludeList, true);</span>
<span class="fc" id="L509">		Controller._includeList = parseList(includeList, true);</span>

<span class="fc" id="L511">        String ClassLoadersByName = props.getProperty(&quot;accept-class-loaders-byname&quot;);</span>

<span class="pc bpc" id="L513" title="3 of 4 branches missed.">        if (ClassLoadersByName != null &amp;&amp; ClassLoadersByName.length() &gt; 0) {</span>
<span class="nc" id="L514">          System.out.println(&quot;Class loaders by name:&quot;);</span>
<span class="nc" id="L515">          System.out.println(ClassLoadersByName);</span>
        }

<span class="fc" id="L518">        Controller._acceptClassLoadersByName = parseList(props.getProperty(&quot;accept-class-loaders-byname&quot;),false);</span>

<span class="fc" id="L520">		String[] classLoaderNames = parseList(props.getProperty(&quot;accept-class-loaders&quot;, </span>
<span class="fc" id="L521">				ClassLoader.getSystemClassLoader().getClass().getName()), false);</span>

<span class="fc" id="L523">		Controller._acceptClassLoaders = new Class[classLoaderNames.length];</span>
		
<span class="fc bfc" id="L525" title="All 2 branches covered.">		for (int i=0; i&lt;classLoaderNames.length; i++) {</span>
			try {
<span class="fc" id="L527">				Controller._acceptClassLoaders[i] = Class.forName(classLoaderNames[i]);</span>
<span class="fc" id="L528">				System.out.println(&quot;Accept ClassLoader: &quot; + Controller._acceptClassLoaders[i].getName());</span>
<span class="nc" id="L529">			} catch (ClassNotFoundException e) {</span>
<span class="nc" id="L530">				System.err.println(&quot;UNKNOWN CLASSLOADER: &quot; + classLoaderNames[i]);</span>
<span class="nc" id="L531">				System.err.println(&quot;Using the system classloader instead&quot;);</span>
<span class="nc" id="L532">				Controller._acceptClassLoaders[i] = ClassLoader.getSystemClassLoader().getClass();</span>
<span class="fc" id="L533">			}	</span>
		}
		
		// get the class loader filter;
		
<span class="pc" id="L538">		for (int i=1; ; i++) {</span>
<span class="fc" id="L539">			StringBuffer b = new StringBuffer(&quot;ClassLoaderFilter.&quot;);</span>
<span class="fc" id="L540">			b.append(i);</span>
<span class="fc" id="L541">			String filter = getProperty(props, b.toString(), null);</span>
			
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">			if (filter == null) {</span>
<span class="fc" id="L544">				break;</span>
			}
			
			try {
<span class="nc" id="L548">				ClassLoaderFilter clf = (ClassLoaderFilter) </span>
<span class="nc" id="L549">					Class.forName(filter).newInstance();</span>
				
<span class="nc bnc" id="L551" title="All 2 branches missed.">				if (clf.canFilter()) {</span>
<span class="nc" id="L552">					_filter = clf;</span>
<span class="nc" id="L553">					break;</span>
				}
<span class="nc" id="L555">			} catch (Exception e) {</span>
<span class="nc" id="L556">				System.err.print(&quot;Could not instantiate ClassLoaderFilter &quot;);</span>
<span class="nc" id="L557">				System.err.println(filter);</span>
<span class="nc" id="L558">			}</span>
		}
		
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">		if (_filter == null) {</span>
<span class="fc" id="L562">			System.err.println(&quot;Using the generic class loader filter.&quot;);</span>
<span class="fc" id="L563">			_filter = new GenericClassLoaderFilter();</span>
		}
		
<span class="fc" id="L566">		Controller._profiler = profiler.replace('.', '/');</span>
		
		try {
<span class="fc" id="L569">			Class c = Class.forName(profiler);</span>
<span class="fc" id="L570">			Method m = c.getMethod(&quot;initProfiler&quot;, new Class[0]);</span>
<span class="fc" id="L571">			m.invoke(null, new Object[0]);</span>
<span class="nc" id="L572">		} catch (Exception e) {</span>
<span class="nc" id="L573">			System.err.println(&quot;Unable to invoke init on Profiler class.&quot;);</span>
<span class="fc" id="L574">		}</span>
		
<span class="fc" id="L576">		System.out.println(&quot;------------------&quot;);</span>
<span class="fc" id="L577">	}</span>
	
	private static String[] parseList(String list, boolean doReplacement) {	
<span class="pc bpc" id="L580" title="2 of 6 branches missed.">		if (list == null || list.length() == 0 || list.equals(&quot;null&quot;)) {</span>
<span class="fc" id="L581">			return new String[0];</span>
		}
		
<span class="fc" id="L584">		ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L585">		StringTokenizer t = new StringTokenizer(list, &quot;, &quot;);</span>
		
<span class="fc bfc" id="L587" title="All 2 branches covered.">		while (t.hasMoreTokens()) {</span>
<span class="fc" id="L588">			String token = t.nextToken();</span>
			
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">			if (doReplacement) { </span>
<span class="nc" id="L591">				al.add(token.replace('.' , '/'));</span>
			} else {
<span class="fc" id="L593">				al.add(token);</span>
			}
<span class="fc" id="L595">		}</span>
		
<span class="fc" id="L597">		String[] sl = new String[al.size()];</span>
<span class="fc" id="L598">		al.toArray(sl);</span>
<span class="fc" id="L599">		return sl;</span>
	}
	
	private static String getProperty(Properties props, 
			String key, 
			String defaultValue) {
		
<span class="fc" id="L606">		String value = props.getProperty(key, defaultValue);</span>
<span class="fc" id="L607">		System.out.print(key);</span>
<span class="fc" id="L608">		System.out.print(&quot;: &quot;);</span>
<span class="fc" id="L609">		System.out.println(value);</span>
<span class="fc" id="L610">		return value;</span>
	}	
	
	public void setFileName(String fileName) {
<span class="fc" id="L614">		_fileName = fileName;</span>
<span class="fc" id="L615">	}</span>
    
    private void printStringArray(String[] TheArray)
    {

<span class="nc bnc" id="L620" title="All 4 branches missed.">      if (TheArray == null || TheArray.length == 0)</span>
<span class="nc" id="L621">        return;</span>
      
<span class="nc" id="L623">      StringBuilder MyBuffer = new StringBuilder(256);</span>
                    
<span class="nc bnc" id="L625" title="All 2 branches missed.">      for (String MyWorkString : TheArray)</span>
      {
<span class="nc" id="L627">        MyBuffer.append(MyWorkString.replace(&quot;/&quot;,&quot;.&quot;));</span>
<span class="nc" id="L628">        MyBuffer.append(',');</span>
      }
                    
<span class="nc" id="L631">      System.out.println(MyBuffer.toString().substring(0,MyBuffer.length()-1)); </span>
<span class="nc" id="L632">    }</span>

	//
	// Thread to open a server socket and listen for commands
	//
	
	public void run() {
		try {
<span class="fc" id="L640">			_socket = new ServerSocket(_port);</span>
			
			top:
			while (true) {
<span class="nc" id="L644">				Socket child = _socket.accept();</span>

				// so that someone cannot tie-up this socket for too long
				//
<span class="nc" id="L648">				child.setSoTimeout(5000); </span>
<span class="nc" id="L649">				InputStream in = child.getInputStream();</span>
<span class="nc" id="L650">				BufferedInputStream bin = new BufferedInputStream(in);</span>
<span class="nc" id="L651">				StringBuffer b = new StringBuffer();</span>
				
				while (true) {
<span class="nc" id="L654">					char c = (char) bin.read();</span>
					
<span class="nc bnc" id="L656" title="All 2 branches missed.">					if (c == '\r') {</span>
<span class="nc" id="L657">						break;</span>
					} else {
<span class="nc" id="L659">						b.append(c);</span>
					}
<span class="nc" id="L661">				}</span>
				
<span class="nc" id="L663">				String command = b.toString();</span>
<span class="nc" id="L664">				System.out.println(command);</span>
				
<span class="nc bnc" id="L666" title="All 2 branches missed.">				if (command.startsWith(START)) {</span>
<span class="nc" id="L667">					start();</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">				} else if (command.startsWith(STOP)) {</span>
<span class="nc" id="L669">					stop();</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">				} else if (command.startsWith(DUMP)) {</span>
<span class="nc" id="L671">					ProfileDump.dump();</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">				} else if (command.startsWith(CLEAR)) {</span>
<span class="nc" id="L673">					Profile.init();</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">				} else if (command.startsWith(FILE)) {</span>
<span class="nc" id="L675">					String name = command.substring(command.indexOf(' ')+1);</span>
<span class="nc" id="L676">					_fileName = name;</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">                } else if (command.startsWith(GETCLASSLOADERSBYNAME)) {</span>
<span class="nc" id="L678">                    System.out.println(&quot;Current class loaders by name:&quot;);</span>
<span class="nc" id="L679">                    printStringArray(Controller._acceptClassLoadersByName);</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">                } else if (command.startsWith(REPLACECLASSLOADERSBYNAME)) {</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">                    if (Controller._profile == true) {</span>
<span class="nc" id="L682">                      stop();</span>
<span class="nc" id="L683">                      ProfileDump.dump();</span>
                    }
<span class="nc" id="L685">                    String NewClassesByName = command.substring(command.indexOf(' ') + 1);</span>
<span class="nc" id="L686">                    Controller._acceptClassLoadersByName = parseList(NewClassesByName,false);</span>
<span class="nc" id="L687">                    System.out.print(&quot;New class loaders by name:&quot;);</span>
<span class="nc" id="L688">                    printStringArray(Controller._acceptClassLoadersByName);</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">                } else if (command.startsWith(GETEXCLUDELIST)) {</span>
<span class="nc" id="L690">                    System.out.println(&quot;Current exclude list:&quot;);</span>
<span class="nc" id="L691">                    printStringArray(Controller._excludeList);</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                } else if (command.startsWith(REPLACEEXCLUDELIST)) {</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">                    if (Controller._profile == true) {</span>
<span class="nc" id="L694">                      stop();</span>
<span class="nc" id="L695">                      ProfileDump.dump();</span>
                    }
<span class="nc" id="L697">                    String TheExcludes = command.substring(command.indexOf(' ') + 1);</span>
<span class="nc" id="L698">                    Controller._excludeList = parseList(TheExcludes, true);</span>
<span class="nc" id="L699">                    System.out.println(&quot;New exclude list:&quot;);</span>
<span class="nc" id="L700">                    printStringArray(Controller._excludeList);</span>
<span class="nc" id="L701">                    Profile.init();</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">                } else if (command.startsWith(GETINCLUDELIST)) {</span>
<span class="nc" id="L703">                    System.out.println(&quot;Current include list:&quot;);</span>
<span class="nc" id="L704">                    printStringArray(Controller._includeList);</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                } else if (command.startsWith(REPLACEINCLUDELIST)) {</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">                    if (Controller._profile == true) {</span>
<span class="nc" id="L707">                      stop();</span>
<span class="nc" id="L708">                      ProfileDump.dump();</span>
                    }
<span class="nc" id="L710">                    String TheIncludes = command.substring(command.indexOf(' ') + 1);</span>
<span class="nc" id="L711">                    Controller._includeList = parseList(TheIncludes, true);</span>
<span class="nc" id="L712">                    System.out.println(&quot;New include list:&quot;);</span>
<span class="nc" id="L713">                    printStringArray(Controller._includeList);</span>
<span class="nc" id="L714">                    Profile.init();</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">                } else if (command.startsWith(DEBUGON)) {</span>
<span class="nc" id="L716">                    _debug = true;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">                } else if (command.startsWith(DEBUGOFF)) {</span>
<span class="nc" id="L718">                    _debug = false;</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">				} else if (command.startsWith(FINISH)) {</span>
<span class="nc" id="L720">					stop();              // stop</span>
<span class="nc" id="L721">					ProfileDump.dump();	// dump</span>
<span class="nc" id="L722">					Profile.init();		// clear</span>
				}
				
<span class="nc" id="L725">				child.close();</span>
<span class="nc" id="L726">			}</span>
<span class="fc" id="L727">		} catch (SocketException e) {</span>
			// eat this type of exception ...
<span class="nc" id="L729">		} catch (IOException e) {</span>
<span class="nc" id="L730">			e.printStackTrace();</span>
<span class="nc" id="L731">			throw new RuntimeException(e);</span>
<span class="fc" id="L732">		}</span>

<span class="fc" id="L734">	}</span>
	
	public void close() throws IOException {
<span class="fc" id="L737">		System.err.println(&quot;Controller -- shuttingdown&quot;);</span>
		
<span class="pc bpc" id="L739" title="1 of 6 branches missed.">		if (_remote &amp;&amp; _socket!= null &amp;&amp; !_socket.isClosed()) {</span>
<span class="fc" id="L740">			_socket.close();</span>
		}
<span class="fc" id="L742">	}</span>
	
	
	public void start() {

		// Nice little hack to explain to the user why they aren't getting
		// a profile.
		//
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">		if (_instrumentCount == 0) {</span>
<span class="fc" id="L751">			System.err.println(&quot;Warning: a request has been made to start the &quot; +</span>
					&quot;profiler but no classes have been instrumented. &quot; +
					&quot;Possible reasons: &quot;);
<span class="fc" id="L754">			System.err.println(&quot;1. All the classes that have been classloaded &quot; +</span>
					&quot;have been \&quot;excluded\&quot;. Check the exclude property in &quot; +
					&quot;the current profile properties file.&quot;);
<span class="fc" id="L757">			System.err.println(&quot;2. No appropriate class loader filter has been &quot; +</span>
					&quot;provided (see \&quot;ClassLoaderFilter.x\&quot; in the current &quot; +
					&quot;profile properties file.) If no appropriate &quot; +
					&quot;filter can be found, the standard filter is used. This&quot; +
					&quot;filter is really only useful for stand-alone &quot; +
					&quot;applications. Make sure your environment has a &quot; +
					&quot;ClassLoaderFilter and that your profile properties &quot; +
					&quot;file is configured correctly.&quot;);
<span class="fc" id="L765">			System.err.println(&quot;3. Sometimes when Tomcat is launched from &quot; +</span>
					&quot;within &quot; +
					&quot;Eclipse, Tomcat, for some reason, will start using the &quot; +
					&quot;appication classloader (the one that stand-alone &quot; +
					&quot;apps use) to classload the webapp rather than the &quot; +
					&quot;web app classloader that it should use. One thing that &quot; +
					&quot;you can try to get around this odd behavior is to not &quot; +
					&quot;run Tomcat in debug mode (Window &gt; Perferences &gt; Tomcat &gt; &quot; +
					&quot;JVM settings : Don't run Tomcat in debug mode.) If this &quot; +
					&quot;doesn't work, you could try removing the webapp &quot; +
					&quot;classlaoder filter from your profile properties file.&quot;);
		}
		
<span class="fc" id="L778">		Profile.clear();</span>
<span class="fc" id="L779">		_profile = true;</span>
<span class="fc" id="L780">	}</span>
	
	public void stop() {
		
		// Explain to the user why they aren't going to be seeing a profile.
		//
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">		if (_instrumentCount == 0) {</span>
<span class="fc" id="L787">			System.err.println(&quot;No classes have been instrumented for &quot; +</span>
					&quot;profiling. There should be a previous message to this &quot; +
					&quot;effect which outlines why this is happening.&quot;);
		}
		
<span class="fc" id="L792">		Profile.shutdown();</span>
<span class="fc" id="L793">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>