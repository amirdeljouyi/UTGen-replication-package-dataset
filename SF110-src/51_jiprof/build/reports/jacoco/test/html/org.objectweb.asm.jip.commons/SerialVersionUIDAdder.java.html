<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SerialVersionUIDAdder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">51_jiprof</a> &gt; <a href="index.source.html" class="el_package">org.objectweb.asm.jip.commons</a> &gt; <span class="el_source">SerialVersionUIDAdder.java</span></div><h1>SerialVersionUIDAdder.java</h1><pre class="source lang-java linenums">/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2007 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.objectweb.asm.jip.commons;

import java.io.ByteArrayOutputStream;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOException;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

import org.objectweb.asm.jip.ClassAdapter;
import org.objectweb.asm.jip.ClassVisitor;
import org.objectweb.asm.jip.FieldVisitor;
import org.objectweb.asm.jip.MethodVisitor;
import org.objectweb.asm.jip.Opcodes;

/**
 * A {@link ClassAdapter} that adds a serial version unique identifier to a
 * class if missing. Here is typical usage of this class:
 * 
 * &lt;pre&gt;
 *   ClassWriter cw = new ClassWriter(...);
 *   ClassVisitor sv = new SerialVersionUIDAdder(cw);
 *   ClassVisitor ca = new MyClassAdapter(sv);
 *   new ClassReader(orginalClass).accept(ca, false);
 * &lt;/pre&gt;
 * 
 * The SVUID algorithm can be found &lt;a href=
 * &quot;http://java.sun.com/j2se/1.4.2/docs/guide/serialization/spec/class.html&quot;
 * &gt;http://java.sun.com/j2se/1.4.2/docs/guide/serialization/spec/class.html&lt;/a&gt;:
 * 
 * &lt;pre&gt;
 * The serialVersionUID is computed using the signature of a stream of bytes
 * that reflect the class definition. The National Institute of Standards and
 * Technology (NIST) Secure Hash Algorithm (SHA-1) is used to compute a
 * signature for the stream. The first two 32-bit quantities are used to form a
 * 64-bit hash. A java.lang.DataOutputStream is used to convert primitive data
 * types to a sequence of bytes. The values input to the stream are defined by
 * the Java Virtual Machine (VM) specification for classes.
 *
 * The sequence of items in the stream is as follows:
 *
 * 1. The class name written using UTF encoding.
 * 2. The class modifiers written as a 32-bit integer.
 * 3. The name of each interface sorted by name written using UTF encoding.
 * 4. For each field of the class sorted by field name (except private static
 * and private transient fields):
 * 1. The name of the field in UTF encoding.
 * 2. The modifiers of the field written as a 32-bit integer.
 * 3. The descriptor of the field in UTF encoding
 * 5. If a class initializer exists, write out the following:
 * 1. The name of the method, &amp;lt;clinit&amp;gt;, in UTF encoding.
 * 2. The modifier of the method, java.lang.reflect.Modifier.STATIC,
 * written as a 32-bit integer.
 * 3. The descriptor of the method, ()V, in UTF encoding.
 * 6. For each non-private constructor sorted by method name and signature:
 * 1. The name of the method, &amp;lt;init&amp;gt;, in UTF encoding.
 * 2. The modifiers of the method written as a 32-bit integer.
 * 3. The descriptor of the method in UTF encoding.
 * 7. For each non-private method sorted by method name and signature:
 * 1. The name of the method in UTF encoding.
 * 2. The modifiers of the method written as a 32-bit integer.
 * 3. The descriptor of the method in UTF encoding.
 * 8. The SHA-1 algorithm is executed on the stream of bytes produced by
 * DataOutputStream and produces five 32-bit values sha[0..4].
 *
 * 9. The hash value is assembled from the first and second 32-bit values of 
 * the SHA-1 message digest. If the result of the message digest, the five
 * 32-bit words H0 H1 H2 H3 H4, is in an array of five int values named 
 * sha, the hash value would be computed as follows:
 *
 * long hash = ((sha[0] &amp;gt;&amp;gt;&amp;gt; 24) &amp;amp; 0xFF) |
 * ((sha[0] &amp;gt;&amp;gt;&amp;gt; 16) &amp;amp; 0xFF) &amp;lt;&amp;lt; 8 |
 * ((sha[0] &amp;gt;&amp;gt;&amp;gt; 8) &amp;amp; 0xFF) &amp;lt;&amp;lt; 16 |
 * ((sha[0] &amp;gt;&amp;gt;&amp;gt; 0) &amp;amp; 0xFF) &amp;lt;&amp;lt; 24 |
 * ((sha[1] &amp;gt;&amp;gt;&amp;gt; 24) &amp;amp; 0xFF) &amp;lt;&amp;lt; 32 |
 * ((sha[1] &amp;gt;&amp;gt;&amp;gt; 16) &amp;amp; 0xFF) &amp;lt;&amp;lt; 40 |
 * ((sha[1] &amp;gt;&amp;gt;&amp;gt; 8) &amp;amp; 0xFF) &amp;lt;&amp;lt; 48 |
 * ((sha[1] &amp;gt;&amp;gt;&amp;gt; 0) &amp;amp; 0xFF) &amp;lt;&amp;lt; 56;
 * &lt;/pre&gt;
 * 
 * @author Rajendra Inamdar, Vishal Vishnoi
 */
public class SerialVersionUIDAdder extends ClassAdapter {

    /**
     * Flag that indicates if we need to compute SVUID.
     */
    protected boolean computeSVUID;

    /**
     * Set to true if the class already has SVUID.
     */
    protected boolean hasSVUID;

    /**
     * Classes access flags.
     */
    protected int access;

    /**
     * Internal name of the class
     */
    protected String name;

    /**
     * Interfaces implemented by the class.
     */
    protected String[] interfaces;

    /**
     * Collection of fields. (except private static and private transient
     * fields)
     */
    protected Collection svuidFields;

    /**
     * Set to true if the class has static initializer.
     */
    protected boolean hasStaticInitializer;

    /**
     * Collection of non-private constructors.
     */
    protected Collection svuidConstructors;

    /**
     * Collection of non-private methods.
     */
    protected Collection svuidMethods;

    /**
     * Creates a new {@link SerialVersionUIDAdder}.
     * 
     * @param cv a {@link ClassVisitor} to which this visitor will delegate
     *        calls.
     */
    public SerialVersionUIDAdder(final ClassVisitor cv) {
<span class="nc" id="L169">        super(cv);</span>
<span class="nc" id="L170">        svuidFields = new ArrayList();</span>
<span class="nc" id="L171">        svuidConstructors = new ArrayList();</span>
<span class="nc" id="L172">        svuidMethods = new ArrayList();</span>
<span class="nc" id="L173">    }</span>

    // ------------------------------------------------------------------------
    // Overriden methods
    // ------------------------------------------------------------------------

    /*
     * Visit class header and get class name, access , and interfaces
     * information (step 1,2, and 3) for SVUID computation.
     */
    public void visit(
        final int version,
        final int access,
        final String name,
        final String signature,
        final String superName,
        final String[] interfaces)
    {
<span class="nc bnc" id="L191" title="All 2 branches missed.">        computeSVUID = (access &amp; Opcodes.ACC_INTERFACE) == 0;</span>

<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (computeSVUID) {</span>
<span class="nc" id="L194">            this.name = name;</span>
<span class="nc" id="L195">            this.access = access;</span>
<span class="nc" id="L196">            this.interfaces = interfaces;</span>
        }

<span class="nc" id="L199">        super.visit(version, access, name, signature, superName, interfaces);</span>
<span class="nc" id="L200">    }</span>

    /*
     * Visit the methods and get constructor and method information (step 5 and
     * 7). Also determine if there is a class initializer (step 6).
     */
    public MethodVisitor visitMethod(
        final int access,
        final String name,
        final String desc,
        final String signature,
        final String[] exceptions)
    {
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (computeSVUID) {</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            if (&quot;&lt;clinit&gt;&quot;.equals(name)) {</span>
<span class="nc" id="L215">                hasStaticInitializer = true;</span>
            }
            /*
             * Remembers non private constructors and methods for SVUID
             * computation For constructor and method modifiers, only the
             * ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,
             * ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT and ACC_STRICT flags
             * are used.
             */
<span class="nc" id="L224">            int mods = access</span>
                    &amp; (Opcodes.ACC_PUBLIC | Opcodes.ACC_PRIVATE
                            | Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC
                            | Opcodes.ACC_FINAL | Opcodes.ACC_SYNCHRONIZED
                            | Opcodes.ACC_NATIVE | Opcodes.ACC_ABSTRACT | Opcodes.ACC_STRICT);

            // all non private methods
<span class="nc bnc" id="L231" title="All 2 branches missed.">            if ((access &amp; Opcodes.ACC_PRIVATE) == 0) {</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">                if (&quot;&lt;init&gt;&quot;.equals(name)) {</span>
<span class="nc" id="L233">                    svuidConstructors.add(new Item(name, mods, desc));</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                } else if (!&quot;&lt;clinit&gt;&quot;.equals(name)) {</span>
<span class="nc" id="L235">                    svuidMethods.add(new Item(name, mods, desc));</span>
                }
            }
        }

<span class="nc" id="L240">        return cv.visitMethod(access, name, desc, signature, exceptions);</span>
    }

    /*
     * Gets class field information for step 4 of the algorithm. Also determines
     * if the class already has a SVUID.
     */
    public FieldVisitor visitField(
        final int access,
        final String name,
        final String desc,
        final String signature,
        final Object value)
    {
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (computeSVUID) {</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">            if (&quot;serialVersionUID&quot;.equals(name)) {</span>
                // since the class already has SVUID, we won't be computing it.
<span class="nc" id="L257">                computeSVUID = false;</span>
<span class="nc" id="L258">                hasSVUID = true;</span>
            }
            /*
             * Remember field for SVUID computation For field modifiers, only
             * the ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC,
             * ACC_FINAL, ACC_VOLATILE, and ACC_TRANSIENT flags are used when
             * computing serialVersionUID values.
             */
<span class="nc bnc" id="L266" title="All 4 branches missed.">            if ((access &amp; Opcodes.ACC_PRIVATE) == 0</span>
                    || (access &amp; (Opcodes.ACC_STATIC | Opcodes.ACC_TRANSIENT)) == 0)
            {
<span class="nc" id="L269">                int mods = access</span>
                &amp; (Opcodes.ACC_PUBLIC | Opcodes.ACC_PRIVATE
                        | Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC
                        | Opcodes.ACC_FINAL | Opcodes.ACC_VOLATILE | Opcodes.ACC_TRANSIENT);
<span class="nc" id="L273">                svuidFields.add(new Item(name, mods, desc));</span>
            }
        }

<span class="nc" id="L277">        return super.visitField(access, name, desc, signature, value);</span>
    }

    /**
     * Handle a bizarre special case. Nested classes (static classes declared
     * inside another class) that are protected have their access bit set to
     * public in their class files to deal with some odd reflection situation.
     * Our SVUID computation must do as the JVM does and ignore access bits in
     * the class file in favor of the access bits InnerClass attribute.
     */
    public void visitInnerClass(final String aname, final String outerName, final String innerName, final int attr_access) {
<span class="nc bnc" id="L288" title="All 4 branches missed.">        if ((name != null) &amp;&amp; name.equals(aname)) {</span>
<span class="nc" id="L289">            this.access = attr_access;</span>
        }
<span class="nc" id="L291">        super.visitInnerClass(aname, outerName, innerName, attr_access);</span>
<span class="nc" id="L292">    }</span>
    
    /*
     * Add the SVUID if class doesn't have one
     */
    public void visitEnd() {
        // compute SVUID and add it to the class
<span class="nc bnc" id="L299" title="All 4 branches missed.">        if (computeSVUID &amp;&amp; !hasSVUID) {</span>
            try {
<span class="nc" id="L301">                cv.visitField(Opcodes.ACC_FINAL + Opcodes.ACC_STATIC,</span>
                        &quot;serialVersionUID&quot;,
                        &quot;J&quot;,
                        null,
<span class="nc" id="L305">                        new Long(computeSVUID()));</span>
<span class="nc" id="L306">            } catch (Throwable e) {</span>
<span class="nc" id="L307">                throw new RuntimeException(&quot;Error while computing SVUID for &quot;</span>
                        + name, e);
<span class="nc" id="L309">            }</span>
        }

<span class="nc" id="L312">        super.visitEnd();</span>
<span class="nc" id="L313">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods
    // ------------------------------------------------------------------------

    /**
     * Returns the value of SVUID if the class doesn't have one already. Please
     * note that 0 is returned if the class already has SVUID, thus use
     * &lt;code&gt;isHasSVUID&lt;/code&gt; to determine if the class already had an SVUID.
     * 
     * @return Returns the serial version UID
     */
    protected long computeSVUID() throws IOException {
        ByteArrayOutputStream bos;
<span class="nc" id="L328">        DataOutputStream dos = null;</span>
<span class="nc" id="L329">        long svuid = 0;</span>

        try {
<span class="nc" id="L332">            bos = new ByteArrayOutputStream();</span>
<span class="nc" id="L333">            dos = new DataOutputStream(bos);</span>

            /*
             * 1. The class name written using UTF encoding.
             */
<span class="nc" id="L338">            dos.writeUTF(name.replace('/', '.'));</span>

            /*
             * 2. The class modifiers written as a 32-bit integer.
             */
<span class="nc" id="L343">            dos.writeInt(access</span>
                    &amp; (Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL
                            | Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT));

            /*
             * 3. The name of each interface sorted by name written using UTF
             * encoding.
             */
<span class="nc" id="L351">            Arrays.sort(interfaces);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            for (int i = 0; i &lt; interfaces.length; i++) {</span>
<span class="nc" id="L353">                dos.writeUTF(interfaces[i].replace('/', '.'));</span>
            }

            /*
             * 4. For each field of the class sorted by field name (except
             * private static and private transient fields):
             * 
             * 1. The name of the field in UTF encoding. 2. The modifiers of the
             * field written as a 32-bit integer. 3. The descriptor of the field
             * in UTF encoding
             * 
             * Note that field signatures are not dot separated. Method and
             * constructor signatures are dot separated. Go figure...
             */
<span class="nc" id="L367">            writeItems(svuidFields, dos, false);</span>

            /*
             * 5. If a class initializer exists, write out the following: 1. The
             * name of the method, &lt;clinit&gt;, in UTF encoding. 2. The modifier of
             * the method, java.lang.reflect.Modifier.STATIC, written as a
             * 32-bit integer. 3. The descriptor of the method, ()V, in UTF
             * encoding.
             */
<span class="nc bnc" id="L376" title="All 2 branches missed.">            if (hasStaticInitializer) {</span>
<span class="nc" id="L377">                dos.writeUTF(&quot;&lt;clinit&gt;&quot;);</span>
<span class="nc" id="L378">                dos.writeInt(Opcodes.ACC_STATIC);</span>
<span class="nc" id="L379">                dos.writeUTF(&quot;()V&quot;);</span>
            } // if..

            /*
             * 6. For each non-private constructor sorted by method name and
             * signature: 1. The name of the method, &lt;init&gt;, in UTF encoding. 2.
             * The modifiers of the method written as a 32-bit integer. 3. The
             * descriptor of the method in UTF encoding.
             */
<span class="nc" id="L388">            writeItems(svuidConstructors, dos, true);</span>

            /*
             * 7. For each non-private method sorted by method name and
             * signature: 1. The name of the method in UTF encoding. 2. The
             * modifiers of the method written as a 32-bit integer. 3. The
             * descriptor of the method in UTF encoding.
             */
<span class="nc" id="L396">            writeItems(svuidMethods, dos, true);</span>

<span class="nc" id="L398">            dos.flush();</span>

            /*
             * 8. The SHA-1 algorithm is executed on the stream of bytes
             * produced by DataOutputStream and produces five 32-bit values
             * sha[0..4].
             */
<span class="nc" id="L405">            byte[] hashBytes = computeSHAdigest(bos.toByteArray());</span>

            /*
             * 9. The hash value is assembled from the first and second 32-bit
             * values of the SHA-1 message digest. If the result of the message
             * digest, the five 32-bit words H0 H1 H2 H3 H4, is in an array of
             * five int values named sha, the hash value would be computed as
             * follows:
             * 
             * long hash = ((sha[0] &gt;&gt;&gt; 24) &amp; 0xFF) | ((sha[0] &gt;&gt;&gt; 16) &amp; 0xFF) &lt;&lt;
             * 8 | ((sha[0] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 16 | ((sha[0] &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt;
             * 24 | ((sha[1] &gt;&gt;&gt; 24) &amp; 0xFF) &lt;&lt; 32 | ((sha[1] &gt;&gt;&gt; 16) &amp; 0xFF) &lt;&lt;
             * 40 | ((sha[1] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 48 | ((sha[1] &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt;
             * 56;
             */
<span class="nc bnc" id="L420" title="All 2 branches missed.">            for (int i = Math.min(hashBytes.length, 8) - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L421">                svuid = (svuid &lt;&lt; 8) | (hashBytes[i] &amp; 0xFF);</span>
            }
        } finally {
            // close the stream (if open)
<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (dos != null) {</span>
<span class="nc" id="L426">                dos.close();</span>
            }
        }

<span class="nc" id="L430">        return svuid;</span>
    }

    /**
     * Returns the SHA-1 message digest of the given value.
     * 
     * @param value the value whose SHA message digest must be computed.
     * @return the SHA-1 message digest of the given value.
     */
    protected byte[] computeSHAdigest(final byte[] value) {
        try {
<span class="nc" id="L441">            return MessageDigest.getInstance(&quot;SHA&quot;).digest(value);</span>
<span class="nc" id="L442">        } catch (Exception e) {</span>
<span class="nc" id="L443">            throw new UnsupportedOperationException(e.toString());</span>
        }
    }

    /**
     * Sorts the items in the collection and writes it to the data output stream
     * 
     * @param itemCollection collection of items
     * @param dos a &lt;code&gt;DataOutputStream&lt;/code&gt; value
     * @param dotted a &lt;code&gt;boolean&lt;/code&gt; value
     * @exception IOException if an error occurs
     */
    private static void writeItems(
        final Collection itemCollection,
        final DataOutput dos,
        final boolean dotted) throws IOException
    {
<span class="nc" id="L460">        int size = itemCollection.size();</span>
<span class="nc" id="L461">        Item[] items = (Item[]) itemCollection.toArray(new Item[size]);</span>
<span class="nc" id="L462">        Arrays.sort(items);</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L464">            dos.writeUTF(items[i].name);</span>
<span class="nc" id="L465">            dos.writeInt(items[i].access);</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            dos.writeUTF(dotted</span>
<span class="nc" id="L467">                    ? items[i].desc.replace('/', '.')</span>
                    : items[i].desc);
        }
<span class="nc" id="L470">    }</span>

    // ------------------------------------------------------------------------
    // Inner classes
    // ------------------------------------------------------------------------

    static class Item implements Comparable {

        final String name;

        final int access;

        final String desc;

<span class="nc" id="L484">        Item(final String name, final int access, final String desc) {</span>
<span class="nc" id="L485">            this.name = name;</span>
<span class="nc" id="L486">            this.access = access;</span>
<span class="nc" id="L487">            this.desc = desc;</span>
<span class="nc" id="L488">        }</span>

        public int compareTo(final Object o) {
<span class="nc" id="L491">            Item other = (Item) o;</span>
<span class="nc" id="L492">            int retVal = name.compareTo(other.name);</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">            if (retVal == 0) {</span>
<span class="nc" id="L494">                retVal = desc.compareTo(other.desc);</span>
            }
<span class="nc" id="L496">            return retVal;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>