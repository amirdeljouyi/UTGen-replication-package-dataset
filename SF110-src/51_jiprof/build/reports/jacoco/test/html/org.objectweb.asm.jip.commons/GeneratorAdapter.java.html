<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeneratorAdapter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">51_jiprof</a> &gt; <a href="index.source.html" class="el_package">org.objectweb.asm.jip.commons</a> &gt; <span class="el_source">GeneratorAdapter.java</span></div><h1>GeneratorAdapter.java</h1><pre class="source lang-java linenums">/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2007 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.objectweb.asm.jip.commons;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.objectweb.asm.jip.ClassVisitor;
import org.objectweb.asm.jip.Label;
import org.objectweb.asm.jip.MethodVisitor;
import org.objectweb.asm.jip.Opcodes;
import org.objectweb.asm.jip.Type;

/**
 * A {@link org.objectweb.asm.jip.MethodAdapter} with convenient methods to generate
 * code. For example, using this adapter, the class below
 * 
 * &lt;pre&gt;
 * public class Example {
 *     public static void main(String[] args) {
 *         System.out.println(&amp;quot;Hello world!&amp;quot;);
 *     }
 * }
 * &lt;/pre&gt;
 * 
 * can be generated as follows:
 * 
 * &lt;pre&gt;
 * ClassWriter cw = new ClassWriter(true);
 * cw.visit(V1_1, ACC_PUBLIC, &amp;quot;Example&amp;quot;, null, &amp;quot;java/lang/Object&amp;quot;, null);
 * 
 * Method m = Method.getMethod(&amp;quot;void &amp;lt;init&amp;gt; ()&amp;quot;);
 * GeneratorAdapter mg = new GeneratorAdapter(ACC_PUBLIC, m, null, null, cw);
 * mg.loadThis();
 * mg.invokeConstructor(Type.getType(Object.class), m);
 * mg.returnValue();
 * mg.endMethod();
 * 
 * m = Method.getMethod(&amp;quot;void main (String[])&amp;quot;);
 * mg = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, m, null, null, cw);
 * mg.getStatic(Type.getType(System.class), &amp;quot;out&amp;quot;, Type.getType(PrintStream.class));
 * mg.push(&amp;quot;Hello world!&amp;quot;);
 * mg.invokeVirtual(Type.getType(PrintStream.class), Method.getMethod(&amp;quot;void println (String)&amp;quot;));
 * mg.returnValue();
 * mg.endMethod();
 * 
 * cw.visitEnd();
 * &lt;/pre&gt;
 * 
 * @author Juozas Baliuka
 * @author Chris Nokleberg
 * @author Eric Bruneton
 */
public class GeneratorAdapter extends LocalVariablesSorter {

    private static final String CLDESC = &quot;Ljava/lang/Class;&quot;;

<span class="nc" id="L86">    private static final Type BYTE_TYPE = Type.getObjectType(&quot;java/lang/Byte&quot;);</span>

<span class="nc" id="L88">    private static final Type BOOLEAN_TYPE = Type.getObjectType(&quot;java/lang/Boolean&quot;);</span>

<span class="nc" id="L90">    private static final Type SHORT_TYPE = Type.getObjectType(&quot;java/lang/Short&quot;);</span>

<span class="nc" id="L92">    private static final Type CHARACTER_TYPE = Type.getObjectType(&quot;java/lang/Character&quot;);</span>

<span class="nc" id="L94">    private static final Type INTEGER_TYPE = Type.getObjectType(&quot;java/lang/Integer&quot;);</span>

<span class="nc" id="L96">    private static final Type FLOAT_TYPE = Type.getObjectType(&quot;java/lang/Float&quot;);</span>

<span class="nc" id="L98">    private static final Type LONG_TYPE = Type.getObjectType(&quot;java/lang/Long&quot;);</span>

<span class="nc" id="L100">    private static final Type DOUBLE_TYPE = Type.getObjectType(&quot;java/lang/Double&quot;);</span>

<span class="nc" id="L102">    private static final Type NUMBER_TYPE = Type.getObjectType(&quot;java/lang/Number&quot;);</span>

<span class="nc" id="L104">    private static final Type OBJECT_TYPE = Type.getObjectType(&quot;java/lang/Object&quot;);</span>

<span class="nc" id="L106">    private static final Method BOOLEAN_VALUE = Method.getMethod(&quot;boolean booleanValue()&quot;);</span>

<span class="nc" id="L108">    private static final Method CHAR_VALUE = Method.getMethod(&quot;char charValue()&quot;);</span>

<span class="nc" id="L110">    private static final Method INT_VALUE = Method.getMethod(&quot;int intValue()&quot;);</span>

<span class="nc" id="L112">    private static final Method FLOAT_VALUE = Method.getMethod(&quot;float floatValue()&quot;);</span>

<span class="nc" id="L114">    private static final Method LONG_VALUE = Method.getMethod(&quot;long longValue()&quot;);</span>

<span class="nc" id="L116">    private static final Method DOUBLE_VALUE = Method.getMethod(&quot;double doubleValue()&quot;);</span>

    /**
     * Constant for the {@link #math math} method.
     */
    public static final int ADD = Opcodes.IADD;

    /**
     * Constant for the {@link #math math} method.
     */
    public static final int SUB = Opcodes.ISUB;

    /**
     * Constant for the {@link #math math} method.
     */
    public static final int MUL = Opcodes.IMUL;

    /**
     * Constant for the {@link #math math} method.
     */
    public static final int DIV = Opcodes.IDIV;

    /**
     * Constant for the {@link #math math} method.
     */
    public static final int REM = Opcodes.IREM;

    /**
     * Constant for the {@link #math math} method.
     */
    public static final int NEG = Opcodes.INEG;

    /**
     * Constant for the {@link #math math} method.
     */
    public static final int SHL = Opcodes.ISHL;

    /**
     * Constant for the {@link #math math} method.
     */
    public static final int SHR = Opcodes.ISHR;

    /**
     * Constant for the {@link #math math} method.
     */
    public static final int USHR = Opcodes.IUSHR;

    /**
     * Constant for the {@link #math math} method.
     */
    public static final int AND = Opcodes.IAND;

    /**
     * Constant for the {@link #math math} method.
     */
    public static final int OR = Opcodes.IOR;

    /**
     * Constant for the {@link #math math} method.
     */
    public static final int XOR = Opcodes.IXOR;

    /**
     * Constant for the {@link #ifCmp ifCmp} method.
     */
    public static final int EQ = Opcodes.IFEQ;

    /**
     * Constant for the {@link #ifCmp ifCmp} method.
     */
    public static final int NE = Opcodes.IFNE;

    /**
     * Constant for the {@link #ifCmp ifCmp} method.
     */
    public static final int LT = Opcodes.IFLT;

    /**
     * Constant for the {@link #ifCmp ifCmp} method.
     */
    public static final int GE = Opcodes.IFGE;

    /**
     * Constant for the {@link #ifCmp ifCmp} method.
     */
    public static final int GT = Opcodes.IFGT;

    /**
     * Constant for the {@link #ifCmp ifCmp} method.
     */
    public static final int LE = Opcodes.IFLE;

    /**
     * Access flags of the method visited by this adapter.
     */
    private final int access;

    /**
     * Return type of the method visited by this adapter.
     */
    private final Type returnType;

    /**
     * Argument types of the method visited by this adapter.
     */
    private final Type[] argumentTypes;

    /**
     * Types of the local variables of the method visited by this adapter.
     */
<span class="nc" id="L226">    private final List localTypes = new ArrayList();</span>

    /**
     * Creates a new {@link GeneratorAdapter}.
     * 
     * @param mv the method visitor to which this adapter delegates calls.
     * @param access the method's access flags (see {@link Opcodes}).
     * @param name the method's name.
     * @param desc the method's descriptor (see {@link Type Type}).
     */
    public GeneratorAdapter(
        final MethodVisitor mv,
        final int access,
        final String name,
        final String desc)
    {
<span class="nc" id="L242">        super(access, desc, mv);</span>
<span class="nc" id="L243">        this.access = access;</span>
<span class="nc" id="L244">        this.returnType = Type.getReturnType(desc);</span>
<span class="nc" id="L245">        this.argumentTypes = Type.getArgumentTypes(desc);</span>
<span class="nc" id="L246">    }</span>

    /**
     * Creates a new {@link GeneratorAdapter}.
     * 
     * @param access access flags of the adapted method.
     * @param method the adapted method.
     * @param mv the method visitor to which this adapter delegates calls.
     */
    public GeneratorAdapter(
        final int access,
        final Method method,
        final MethodVisitor mv)
    {
<span class="nc" id="L260">        super(access, method.getDescriptor(), mv);</span>
<span class="nc" id="L261">        this.access = access;</span>
<span class="nc" id="L262">        this.returnType = method.getReturnType();</span>
<span class="nc" id="L263">        this.argumentTypes = method.getArgumentTypes();</span>
<span class="nc" id="L264">    }</span>

    /**
     * Creates a new {@link GeneratorAdapter}.
     * 
     * @param access access flags of the adapted method.
     * @param method the adapted method.
     * @param signature the signature of the adapted method (may be
     *        &lt;tt&gt;null&lt;/tt&gt;).
     * @param exceptions the exceptions thrown by the adapted method (may be
     *        &lt;tt&gt;null&lt;/tt&gt;).
     * @param cv the class visitor to which this adapter delegates calls.
     */
    public GeneratorAdapter(
        final int access,
        final Method method,
        final String signature,
        final Type[] exceptions,
        final ClassVisitor cv)
    {
<span class="nc" id="L284">        this(access, method, cv.visitMethod(access,</span>
<span class="nc" id="L285">                method.getName(),</span>
<span class="nc" id="L286">                method.getDescriptor(),</span>
                signature,
<span class="nc" id="L288">                getInternalNames(exceptions)));</span>
<span class="nc" id="L289">    }</span>

    /**
     * Returns the internal names of the given types.
     * 
     * @param types a set of types.
     * @return the internal names of the given types.
     */
    private static String[] getInternalNames(final Type[] types) {
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (types == null) {</span>
<span class="nc" id="L299">            return null;</span>
        }
<span class="nc" id="L301">        String[] names = new String[types.length];</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        for (int i = 0; i &lt; names.length; ++i) {</span>
<span class="nc" id="L303">            names[i] = types[i].getInternalName();</span>
        }
<span class="nc" id="L305">        return names;</span>
    }

    // ------------------------------------------------------------------------
    // Instructions to push constants on the stack
    // ------------------------------------------------------------------------

    /**
     * Generates the instruction to push the given value on the stack.
     * 
     * @param value the value to be pushed on the stack.
     */
    public void push(final boolean value) {
<span class="nc bnc" id="L318" title="All 2 branches missed.">        push(value ? 1 : 0);</span>
<span class="nc" id="L319">    }</span>

    /**
     * Generates the instruction to push the given value on the stack.
     * 
     * @param value the value to be pushed on the stack.
     */
    public void push(final int value) {
<span class="nc bnc" id="L327" title="All 4 branches missed.">        if (value &gt;= -1 &amp;&amp; value &lt;= 5) {</span>
<span class="nc" id="L328">            mv.visitInsn(Opcodes.ICONST_0 + value);</span>
<span class="nc bnc" id="L329" title="All 4 branches missed.">        } else if (value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE) {</span>
<span class="nc" id="L330">            mv.visitIntInsn(Opcodes.BIPUSH, value);</span>
<span class="nc bnc" id="L331" title="All 4 branches missed.">        } else if (value &gt;= Short.MIN_VALUE &amp;&amp; value &lt;= Short.MAX_VALUE) {</span>
<span class="nc" id="L332">            mv.visitIntInsn(Opcodes.SIPUSH, value);</span>
        } else {
<span class="nc" id="L334">            mv.visitLdcInsn(new Integer(value));</span>
        }
<span class="nc" id="L336">    }</span>

    /**
     * Generates the instruction to push the given value on the stack.
     * 
     * @param value the value to be pushed on the stack.
     */
    public void push(final long value) {
<span class="nc bnc" id="L344" title="All 4 branches missed.">        if (value == 0L || value == 1L) {</span>
<span class="nc" id="L345">            mv.visitInsn(Opcodes.LCONST_0 + (int) value);</span>
        } else {
<span class="nc" id="L347">            mv.visitLdcInsn(new Long(value));</span>
        }
<span class="nc" id="L349">    }</span>

    /**
     * Generates the instruction to push the given value on the stack.
     * 
     * @param value the value to be pushed on the stack.
     */
    public void push(final float value) {
<span class="nc" id="L357">        int bits = Float.floatToIntBits(value);</span>
<span class="nc bnc" id="L358" title="All 6 branches missed.">        if (bits == 0L || bits == 0x3f800000 || bits == 0x40000000) { // 0..2</span>
<span class="nc" id="L359">            mv.visitInsn(Opcodes.FCONST_0 + (int) value);</span>
        } else {
<span class="nc" id="L361">            mv.visitLdcInsn(new Float(value));</span>
        }
<span class="nc" id="L363">    }</span>

    /**
     * Generates the instruction to push the given value on the stack.
     * 
     * @param value the value to be pushed on the stack.
     */
    public void push(final double value) {
<span class="nc" id="L371">        long bits = Double.doubleToLongBits(value);</span>
<span class="nc bnc" id="L372" title="All 4 branches missed.">        if (bits == 0L || bits == 0x3ff0000000000000L) { // +0.0d and 1.0d</span>
<span class="nc" id="L373">            mv.visitInsn(Opcodes.DCONST_0 + (int) value);</span>
        } else {
<span class="nc" id="L375">            mv.visitLdcInsn(new Double(value));</span>
        }
<span class="nc" id="L377">    }</span>

    /**
     * Generates the instruction to push the given value on the stack.
     * 
     * @param value the value to be pushed on the stack. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    public void push(final String value) {
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L386">            mv.visitInsn(Opcodes.ACONST_NULL);</span>
        } else {
<span class="nc" id="L388">            mv.visitLdcInsn(value);</span>
        }
<span class="nc" id="L390">    }</span>

    /**
     * Generates the instruction to push the given value on the stack.
     * 
     * @param value the value to be pushed on the stack.
     */
    public void push(final Type value) {
<span class="nc bnc" id="L398" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L399">            mv.visitInsn(Opcodes.ACONST_NULL);</span>
        } else {
<span class="nc bnc" id="L401" title="All 9 branches missed.">            switch (value.getSort()) {</span>
                case Type.BOOLEAN:
<span class="nc" id="L403">                    mv.visitFieldInsn(Opcodes.GETSTATIC,</span>
                            &quot;java/lang/Boolean&quot;,
                            &quot;TYPE&quot;,
                            CLDESC);
<span class="nc" id="L407">                    break;</span>
                case Type.CHAR:
<span class="nc" id="L409">                    mv.visitFieldInsn(Opcodes.GETSTATIC,</span>
                            &quot;java/lang/Character&quot;,
                            &quot;TYPE&quot;,
                            CLDESC);
<span class="nc" id="L413">                    break;</span>
                case Type.BYTE:
<span class="nc" id="L415">                    mv.visitFieldInsn(Opcodes.GETSTATIC,</span>
                            &quot;java/lang/Byte&quot;,
                            &quot;TYPE&quot;,
                            CLDESC);
<span class="nc" id="L419">                    break;</span>
                case Type.SHORT:
<span class="nc" id="L421">                    mv.visitFieldInsn(Opcodes.GETSTATIC,</span>
                            &quot;java/lang/Short&quot;,
                            &quot;TYPE&quot;,
                            CLDESC);
<span class="nc" id="L425">                    break;</span>
                case Type.INT:
<span class="nc" id="L427">                    mv.visitFieldInsn(Opcodes.GETSTATIC,</span>
                            &quot;java/lang/Integer&quot;,
                            &quot;TYPE&quot;,
                            CLDESC);
<span class="nc" id="L431">                    break;</span>
                case Type.FLOAT:
<span class="nc" id="L433">                    mv.visitFieldInsn(Opcodes.GETSTATIC,</span>
                            &quot;java/lang/Float&quot;,
                            &quot;TYPE&quot;,
                            CLDESC);
<span class="nc" id="L437">                    break;</span>
                case Type.LONG:
<span class="nc" id="L439">                    mv.visitFieldInsn(Opcodes.GETSTATIC,</span>
                            &quot;java/lang/Long&quot;,
                            &quot;TYPE&quot;,
                            CLDESC);
<span class="nc" id="L443">                    break;</span>
                case Type.DOUBLE:
<span class="nc" id="L445">                    mv.visitFieldInsn(Opcodes.GETSTATIC,</span>
                            &quot;java/lang/Double&quot;,
                            &quot;TYPE&quot;,
                            CLDESC);
<span class="nc" id="L449">                    break;</span>
                default:
<span class="nc" id="L451">                    mv.visitLdcInsn(value);</span>
            }
        }
<span class="nc" id="L454">    }</span>

    // ------------------------------------------------------------------------
    // Instructions to load and store method arguments
    // ------------------------------------------------------------------------

    /**
     * Returns the index of the given method argument in the frame's local
     * variables array.
     * 
     * @param arg the index of a method argument.
     * @return the index of the given method argument in the frame's local
     *         variables array.
     */
    private int getArgIndex(final int arg) {
<span class="nc bnc" id="L469" title="All 2 branches missed.">        int index = (access &amp; Opcodes.ACC_STATIC) == 0 ? 1 : 0;</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">        for (int i = 0; i &lt; arg; i++) {</span>
<span class="nc" id="L471">            index += argumentTypes[i].getSize();</span>
        }
<span class="nc" id="L473">        return index;</span>
    }

    /**
     * Generates the instruction to push a local variable on the stack.
     * 
     * @param type the type of the local variable to be loaded.
     * @param index an index in the frame's local variables array.
     */
    private void loadInsn(final Type type, final int index) {
<span class="nc" id="L483">        mv.visitVarInsn(type.getOpcode(Opcodes.ILOAD), index);</span>
<span class="nc" id="L484">    }</span>

    /**
     * Generates the instruction to store the top stack value in a local
     * variable.
     * 
     * @param type the type of the local variable to be stored.
     * @param index an index in the frame's local variables array.
     */
    private void storeInsn(final Type type, final int index) {
<span class="nc" id="L494">        mv.visitVarInsn(type.getOpcode(Opcodes.ISTORE), index);</span>
<span class="nc" id="L495">    }</span>

    /**
     * Generates the instruction to load 'this' on the stack.
     */
    public void loadThis() {
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if ((access &amp; Opcodes.ACC_STATIC) != 0) {</span>
<span class="nc" id="L502">            throw new IllegalStateException(&quot;no 'this' pointer within static method&quot;);</span>
        }
<span class="nc" id="L504">        mv.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="nc" id="L505">    }</span>

    /**
     * Generates the instruction to load the given method argument on the stack.
     * 
     * @param arg the index of a method argument.
     */
    public void loadArg(final int arg) {
<span class="nc" id="L513">        loadInsn(argumentTypes[arg], getArgIndex(arg));</span>
<span class="nc" id="L514">    }</span>

    /**
     * Generates the instructions to load the given method arguments on the
     * stack.
     * 
     * @param arg the index of the first method argument to be loaded.
     * @param count the number of method arguments to be loaded.
     */
    public void loadArgs(final int arg, final int count) {
<span class="nc" id="L524">        int index = getArgIndex(arg);</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">        for (int i = 0; i &lt; count; ++i) {</span>
<span class="nc" id="L526">            Type t = argumentTypes[arg + i];</span>
<span class="nc" id="L527">            loadInsn(t, index);</span>
<span class="nc" id="L528">            index += t.getSize();</span>
        }
<span class="nc" id="L530">    }</span>

    /**
     * Generates the instructions to load all the method arguments on the stack.
     */
    public void loadArgs() {
<span class="nc" id="L536">        loadArgs(0, argumentTypes.length);</span>
<span class="nc" id="L537">    }</span>

    /**
     * Generates the instructions to load all the method arguments on the stack,
     * as a single object array.
     */
    public void loadArgArray() {
<span class="nc" id="L544">        push(argumentTypes.length);</span>
<span class="nc" id="L545">        newArray(OBJECT_TYPE);</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">        for (int i = 0; i &lt; argumentTypes.length; i++) {</span>
<span class="nc" id="L547">            dup();</span>
<span class="nc" id="L548">            push(i);</span>
<span class="nc" id="L549">            loadArg(i);</span>
<span class="nc" id="L550">            box(argumentTypes[i]);</span>
<span class="nc" id="L551">            arrayStore(OBJECT_TYPE);</span>
        }
<span class="nc" id="L553">    }</span>

    /**
     * Generates the instruction to store the top stack value in the given
     * method argument.
     * 
     * @param arg the index of a method argument.
     */
    public void storeArg(final int arg) {
<span class="nc" id="L562">        storeInsn(argumentTypes[arg], getArgIndex(arg));</span>
<span class="nc" id="L563">    }</span>

    // ------------------------------------------------------------------------
    // Instructions to load and store local variables
    // ------------------------------------------------------------------------

    /**
     * Returns the type of the given local variable.
     * 
     * @param local a local variable identifier, as returned by
     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.
     * @return the type of the given local variable.
     */
    public Type getLocalType(final int local) {
<span class="nc" id="L577">        return (Type) localTypes.get(local - firstLocal);</span>
    }

    protected void setLocalType(final int local, final Type type) {
<span class="nc" id="L581">        int index = local - firstLocal;</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">        while (localTypes.size() &lt; index + 1) {</span>
<span class="nc" id="L583">            localTypes.add(null);</span>
        }
<span class="nc" id="L585">        localTypes.set(index, type);</span>
<span class="nc" id="L586">    }</span>

    /**
     * Generates the instruction to load the given local variable on the stack.
     * 
     * @param local a local variable identifier, as returned by
     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.
     */
    public void loadLocal(final int local) {
<span class="nc" id="L595">        loadInsn(getLocalType(local), local);</span>
<span class="nc" id="L596">    }</span>

    /**
     * Generates the instruction to load the given local variable on the stack.
     * 
     * @param local a local variable identifier, as returned by
     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.
     * @param type the type of this local variable.
     */
    public void loadLocal(final int local, final Type type) {
<span class="nc" id="L606">        setLocalType(local, type);</span>
<span class="nc" id="L607">        loadInsn(type, local);</span>
<span class="nc" id="L608">    }</span>

    /**
     * Generates the instruction to store the top stack value in the given local
     * variable.
     * 
     * @param local a local variable identifier, as returned by
     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.
     */
    public void storeLocal(final int local) {
<span class="nc" id="L618">        storeInsn(getLocalType(local), local);</span>
<span class="nc" id="L619">    }</span>

    /**
     * Generates the instruction to store the top stack value in the given local
     * variable.
     * 
     * @param local a local variable identifier, as returned by
     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.
     * @param type the type of this local variable.
     */
    public void storeLocal(final int local, final Type type) {
<span class="nc" id="L630">        setLocalType(local, type);</span>
<span class="nc" id="L631">        storeInsn(type, local);</span>
<span class="nc" id="L632">    }</span>

    /**
     * Generates the instruction to load an element from an array.
     * 
     * @param type the type of the array element to be loaded.
     */
    public void arrayLoad(final Type type) {
<span class="nc" id="L640">        mv.visitInsn(type.getOpcode(Opcodes.IALOAD));</span>
<span class="nc" id="L641">    }</span>

    /**
     * Generates the instruction to store an element in an array.
     * 
     * @param type the type of the array element to be stored.
     */
    public void arrayStore(final Type type) {
<span class="nc" id="L649">        mv.visitInsn(type.getOpcode(Opcodes.IASTORE));</span>
<span class="nc" id="L650">    }</span>

    // ------------------------------------------------------------------------
    // Instructions to manage the stack
    // ------------------------------------------------------------------------

    /**
     * Generates a POP instruction.
     */
    public void pop() {
<span class="nc" id="L660">        mv.visitInsn(Opcodes.POP);</span>
<span class="nc" id="L661">    }</span>

    /**
     * Generates a POP2 instruction.
     */
    public void pop2() {
<span class="nc" id="L667">        mv.visitInsn(Opcodes.POP2);</span>
<span class="nc" id="L668">    }</span>

    /**
     * Generates a DUP instruction.
     */
    public void dup() {
<span class="nc" id="L674">        mv.visitInsn(Opcodes.DUP);</span>
<span class="nc" id="L675">    }</span>

    /**
     * Generates a DUP2 instruction.
     */
    public void dup2() {
<span class="nc" id="L681">        mv.visitInsn(Opcodes.DUP2);</span>
<span class="nc" id="L682">    }</span>

    /**
     * Generates a DUP_X1 instruction.
     */
    public void dupX1() {
<span class="nc" id="L688">        mv.visitInsn(Opcodes.DUP_X1);</span>
<span class="nc" id="L689">    }</span>

    /**
     * Generates a DUP_X2 instruction.
     */
    public void dupX2() {
<span class="nc" id="L695">        mv.visitInsn(Opcodes.DUP_X2);</span>
<span class="nc" id="L696">    }</span>

    /**
     * Generates a DUP2_X1 instruction.
     */
    public void dup2X1() {
<span class="nc" id="L702">        mv.visitInsn(Opcodes.DUP2_X1);</span>
<span class="nc" id="L703">    }</span>

    /**
     * Generates a DUP2_X2 instruction.
     */
    public void dup2X2() {
<span class="nc" id="L709">        mv.visitInsn(Opcodes.DUP2_X2);</span>
<span class="nc" id="L710">    }</span>

    /**
     * Generates a SWAP instruction.
     */
    public void swap() {
<span class="nc" id="L716">        mv.visitInsn(Opcodes.SWAP);</span>
<span class="nc" id="L717">    }</span>

    /**
     * Generates the instructions to swap the top two stack values.
     * 
     * @param prev type of the top - 1 stack value.
     * @param type type of the top stack value.
     */
    public void swap(final Type prev, final Type type) {
<span class="nc bnc" id="L726" title="All 2 branches missed.">        if (type.getSize() == 1) {</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">            if (prev.getSize() == 1) {</span>
<span class="nc" id="L728">                swap(); // same as dupX1(), pop();</span>
            } else {
<span class="nc" id="L730">                dupX2();</span>
<span class="nc" id="L731">                pop();</span>
            }
        } else {
<span class="nc bnc" id="L734" title="All 2 branches missed.">            if (prev.getSize() == 1) {</span>
<span class="nc" id="L735">                dup2X1();</span>
<span class="nc" id="L736">                pop2();</span>
            } else {
<span class="nc" id="L738">                dup2X2();</span>
<span class="nc" id="L739">                pop2();</span>
            }
        }
<span class="nc" id="L742">    }</span>

    // ------------------------------------------------------------------------
    // Instructions to do mathematical and logical operations
    // ------------------------------------------------------------------------

    /**
     * Generates the instruction to do the specified mathematical or logical
     * operation.
     * 
     * @param op a mathematical or logical operation. Must be one of ADD, SUB,
     *        MUL, DIV, REM, NEG, SHL, SHR, USHR, AND, OR, XOR.
     * @param type the type of the operand(s) for this operation.
     */
    public void math(final int op, final Type type) {
<span class="nc" id="L757">        mv.visitInsn(type.getOpcode(op));</span>
<span class="nc" id="L758">    }</span>

    /**
     * Generates the instructions to compute the bitwise negation of the top
     * stack value.
     */
    public void not() {
<span class="nc" id="L765">        mv.visitInsn(Opcodes.ICONST_1);</span>
<span class="nc" id="L766">        mv.visitInsn(Opcodes.IXOR);</span>
<span class="nc" id="L767">    }</span>

    /**
     * Generates the instruction to increment the given local variable.
     * 
     * @param local the local variable to be incremented.
     * @param amount the amount by which the local variable must be incremented.
     */
    public void iinc(final int local, final int amount) {
<span class="nc" id="L776">        mv.visitIincInsn(local, amount);</span>
<span class="nc" id="L777">    }</span>

    /**
     * Generates the instructions to cast a numerical value from one type to
     * another.
     * 
     * @param from the type of the top stack value
     * @param to the type into which this value must be cast.
     */
    public void cast(final Type from, final Type to) {
<span class="nc bnc" id="L787" title="All 2 branches missed.">        if (from != to) {</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">            if (from == Type.DOUBLE_TYPE) {</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">                if (to == Type.FLOAT_TYPE) {</span>
<span class="nc" id="L790">                    mv.visitInsn(Opcodes.D2F);</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">                } else if (to == Type.LONG_TYPE) {</span>
<span class="nc" id="L792">                    mv.visitInsn(Opcodes.D2L);</span>
                } else {
<span class="nc" id="L794">                    mv.visitInsn(Opcodes.D2I);</span>
<span class="nc" id="L795">                    cast(Type.INT_TYPE, to);</span>
                }
<span class="nc bnc" id="L797" title="All 2 branches missed.">            } else if (from == Type.FLOAT_TYPE) {</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">                if (to == Type.DOUBLE_TYPE) {</span>
<span class="nc" id="L799">                    mv.visitInsn(Opcodes.F2D);</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">                } else if (to == Type.LONG_TYPE) {</span>
<span class="nc" id="L801">                    mv.visitInsn(Opcodes.F2L);</span>
                } else {
<span class="nc" id="L803">                    mv.visitInsn(Opcodes.F2I);</span>
<span class="nc" id="L804">                    cast(Type.INT_TYPE, to);</span>
                }
<span class="nc bnc" id="L806" title="All 2 branches missed.">            } else if (from == Type.LONG_TYPE) {</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">                if (to == Type.DOUBLE_TYPE) {</span>
<span class="nc" id="L808">                    mv.visitInsn(Opcodes.L2D);</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">                } else if (to == Type.FLOAT_TYPE) {</span>
<span class="nc" id="L810">                    mv.visitInsn(Opcodes.L2F);</span>
                } else {
<span class="nc" id="L812">                    mv.visitInsn(Opcodes.L2I);</span>
<span class="nc" id="L813">                    cast(Type.INT_TYPE, to);</span>
                }
            } else {
<span class="nc bnc" id="L816" title="All 2 branches missed.">                if (to == Type.BYTE_TYPE) {</span>
<span class="nc" id="L817">                    mv.visitInsn(Opcodes.I2B);</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">                } else if (to == Type.CHAR_TYPE) {</span>
<span class="nc" id="L819">                    mv.visitInsn(Opcodes.I2C);</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">                } else if (to == Type.DOUBLE_TYPE) {</span>
<span class="nc" id="L821">                    mv.visitInsn(Opcodes.I2D);</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">                } else if (to == Type.FLOAT_TYPE) {</span>
<span class="nc" id="L823">                    mv.visitInsn(Opcodes.I2F);</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">                } else if (to == Type.LONG_TYPE) {</span>
<span class="nc" id="L825">                    mv.visitInsn(Opcodes.I2L);</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">                } else if (to == Type.SHORT_TYPE) {</span>
<span class="nc" id="L827">                    mv.visitInsn(Opcodes.I2S);</span>
                }
            }
        }
<span class="nc" id="L831">    }</span>

    // ------------------------------------------------------------------------
    // Instructions to do boxing and unboxing operations
    // ------------------------------------------------------------------------

    private static Type getBoxedType(final Type type) {
<span class="nc bnc" id="L838" title="All 9 branches missed.">        switch (type.getSort()) {</span>
            case Type.BYTE:
<span class="nc" id="L840">                return BYTE_TYPE;</span>
            case Type.BOOLEAN:
<span class="nc" id="L842">                return BOOLEAN_TYPE;</span>
            case Type.SHORT:
<span class="nc" id="L844">                return SHORT_TYPE;</span>
            case Type.CHAR:
<span class="nc" id="L846">                return CHARACTER_TYPE;</span>
            case Type.INT:
<span class="nc" id="L848">                return INTEGER_TYPE;</span>
            case Type.FLOAT:
<span class="nc" id="L850">                return FLOAT_TYPE;</span>
            case Type.LONG:
<span class="nc" id="L852">                return LONG_TYPE;</span>
            case Type.DOUBLE:
<span class="nc" id="L854">                return DOUBLE_TYPE;</span>
        }
<span class="nc" id="L856">        return type;</span>
    }
    
    /**
     * Generates the instructions to box the top stack value. This value is
     * replaced by its boxed equivalent on top of the stack.
     * 
     * @param type the type of the top stack value.
     */
    public void box(final Type type) {
<span class="nc bnc" id="L866" title="All 4 branches missed.">        if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {</span>
<span class="nc" id="L867">            return;</span>
        }
<span class="nc bnc" id="L869" title="All 2 branches missed.">        if (type == Type.VOID_TYPE) {</span>
<span class="nc" id="L870">            push((String) null);</span>
        } else {
<span class="nc" id="L872">            Type boxed = getBoxedType(type);</span>
<span class="nc" id="L873">            newInstance(boxed);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">            if (type.getSize() == 2) {</span>
                // Pp -&gt; Ppo -&gt; oPpo -&gt; ooPpo -&gt; ooPp -&gt; o
<span class="nc" id="L876">                dupX2();</span>
<span class="nc" id="L877">                dupX2();</span>
<span class="nc" id="L878">                pop();</span>
            } else {
                // p -&gt; po -&gt; opo -&gt; oop -&gt; o
<span class="nc" id="L881">                dupX1();</span>
<span class="nc" id="L882">                swap();</span>
            }
<span class="nc" id="L884">            invokeConstructor(boxed, new Method(&quot;&lt;init&gt;&quot;,</span>
                    Type.VOID_TYPE,
                    new Type[] { type }));
        }
<span class="nc" id="L888">    }</span>

    /**
     * Generates the instructions to box the top stack value using Java 5's
     * valueOf() method. This value is replaced by its boxed equivalent on top
     * of the stack.
     * 
     * @param type the type of the top stack value.
     * @author Prashant Deva
     */
    public void valueOf(final Type type) {
<span class="nc bnc" id="L899" title="All 4 branches missed.">        if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {</span>
<span class="nc" id="L900">            return;</span>
        }
<span class="nc bnc" id="L902" title="All 2 branches missed.">        if (type == Type.VOID_TYPE) {</span>
<span class="nc" id="L903">            push((String) null);</span>
        } else {
<span class="nc" id="L905">            Type boxed = getBoxedType(type);</span>
<span class="nc" id="L906">            invokeStatic(boxed, new Method(&quot;valueOf&quot;,</span>
                    boxed,
                    new Type[] { type }));
        }
<span class="nc" id="L910">    }</span>
    
    /**
     * Generates the instructions to unbox the top stack value. This value is
     * replaced by its unboxed equivalent on top of the stack.
     * 
     * @param type the type of the top stack value.
     */
    public void unbox(final Type type) {
<span class="nc" id="L919">        Type t = NUMBER_TYPE;</span>
<span class="nc" id="L920">        Method sig = null;</span>
<span class="nc bnc" id="L921" title="All 8 branches missed.">        switch (type.getSort()) {</span>
            case Type.VOID:
<span class="nc" id="L923">                return;</span>
            case Type.CHAR:
<span class="nc" id="L925">                t = CHARACTER_TYPE;</span>
<span class="nc" id="L926">                sig = CHAR_VALUE;</span>
<span class="nc" id="L927">                break;</span>
            case Type.BOOLEAN:
<span class="nc" id="L929">                t = BOOLEAN_TYPE;</span>
<span class="nc" id="L930">                sig = BOOLEAN_VALUE;</span>
<span class="nc" id="L931">                break;</span>
            case Type.DOUBLE:
<span class="nc" id="L933">                sig = DOUBLE_VALUE;</span>
<span class="nc" id="L934">                break;</span>
            case Type.FLOAT:
<span class="nc" id="L936">                sig = FLOAT_VALUE;</span>
<span class="nc" id="L937">                break;</span>
            case Type.LONG:
<span class="nc" id="L939">                sig = LONG_VALUE;</span>
<span class="nc" id="L940">                break;</span>
            case Type.INT:
            case Type.SHORT:
            case Type.BYTE:
<span class="nc" id="L944">                sig = INT_VALUE;</span>
        }
<span class="nc bnc" id="L946" title="All 2 branches missed.">        if (sig == null) {</span>
<span class="nc" id="L947">            checkCast(type);</span>
        } else {
<span class="nc" id="L949">            checkCast(t);</span>
<span class="nc" id="L950">            invokeVirtual(t, sig);</span>
        }
<span class="nc" id="L952">    }</span>

    // ------------------------------------------------------------------------
    // Instructions to jump to other instructions
    // ------------------------------------------------------------------------

    /**
     * Creates a new {@link Label}.
     * 
     * @return a new {@link Label}.
     */
    public Label newLabel() {
<span class="nc" id="L964">        return new Label();</span>
    }

    /**
     * Marks the current code position with the given label.
     * 
     * @param label a label.
     */
    public void mark(final Label label) {
<span class="nc" id="L973">        mv.visitLabel(label);</span>
<span class="nc" id="L974">    }</span>

    /**
     * Marks the current code position with a new label.
     * 
     * @return the label that was created to mark the current code position.
     */
    public Label mark() {
<span class="nc" id="L982">        Label label = new Label();</span>
<span class="nc" id="L983">        mv.visitLabel(label);</span>
<span class="nc" id="L984">        return label;</span>
    }

    /**
     * Generates the instructions to jump to a label based on the comparison of
     * the top two stack values.
     * 
     * @param type the type of the top two stack values.
     * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT,
     *        LE.
     * @param label where to jump if the comparison result is &lt;tt&gt;true&lt;/tt&gt;.
     */
    public void ifCmp(final Type type, final int mode, final Label label) {
<span class="nc bnc" id="L997" title="All 5 branches missed.">        switch (type.getSort()) {</span>
            case Type.LONG:
<span class="nc" id="L999">                mv.visitInsn(Opcodes.LCMP);</span>
<span class="nc" id="L1000">                break;</span>
            case Type.DOUBLE:
<span class="nc bnc" id="L1002" title="All 4 branches missed.">                mv.visitInsn(mode == GE || mode == GT ? Opcodes.DCMPG : Opcodes.DCMPL);</span>
<span class="nc" id="L1003">                break;</span>
            case Type.FLOAT:
<span class="nc bnc" id="L1005" title="All 4 branches missed.">                mv.visitInsn(mode == GE || mode == GT ? Opcodes.FCMPG : Opcodes.FCMPL);</span>
<span class="nc" id="L1006">                break;</span>
            case Type.ARRAY:
            case Type.OBJECT:
<span class="nc bnc" id="L1009" title="All 3 branches missed.">                switch (mode) {</span>
                    case EQ:
<span class="nc" id="L1011">                        mv.visitJumpInsn(Opcodes.IF_ACMPEQ, label);</span>
<span class="nc" id="L1012">                        return;</span>
                    case NE:
<span class="nc" id="L1014">                        mv.visitJumpInsn(Opcodes.IF_ACMPNE, label);</span>
<span class="nc" id="L1015">                        return;</span>
                }
<span class="nc" id="L1017">                throw new IllegalArgumentException(&quot;Bad comparison for type &quot;</span>
                        + type);
            default:
<span class="nc" id="L1020">                int intOp = -1;</span>
<span class="nc bnc" id="L1021" title="All 7 branches missed.">                switch (mode) {</span>
                    case EQ:
<span class="nc" id="L1023">                        intOp = Opcodes.IF_ICMPEQ;</span>
<span class="nc" id="L1024">                        break;</span>
                    case NE:
<span class="nc" id="L1026">                        intOp = Opcodes.IF_ICMPNE;</span>
<span class="nc" id="L1027">                        break;</span>
                    case GE:
<span class="nc" id="L1029">                        intOp = Opcodes.IF_ICMPGE;</span>
<span class="nc" id="L1030">                        break;</span>
                    case LT:
<span class="nc" id="L1032">                        intOp = Opcodes.IF_ICMPLT;</span>
<span class="nc" id="L1033">                        break;</span>
                    case LE:
<span class="nc" id="L1035">                        intOp = Opcodes.IF_ICMPLE;</span>
<span class="nc" id="L1036">                        break;</span>
                    case GT:
<span class="nc" id="L1038">                        intOp = Opcodes.IF_ICMPGT;</span>
                        break;
                }
<span class="nc" id="L1041">                mv.visitJumpInsn(intOp, label);</span>
<span class="nc" id="L1042">                return;</span>
        }
<span class="nc" id="L1044">        mv.visitJumpInsn(mode, label);</span>
<span class="nc" id="L1045">    }</span>

    /**
     * Generates the instructions to jump to a label based on the comparison of
     * the top two integer stack values.
     * 
     * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT,
     *        LE.
     * @param label where to jump if the comparison result is &lt;tt&gt;true&lt;/tt&gt;.
     */
    public void ifICmp(final int mode, final Label label) {
<span class="nc" id="L1056">        ifCmp(Type.INT_TYPE, mode, label);</span>
<span class="nc" id="L1057">    }</span>

    /**
     * Generates the instructions to jump to a label based on the comparison of
     * the top integer stack value with zero.
     * 
     * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT,
     *        LE.
     * @param label where to jump if the comparison result is &lt;tt&gt;true&lt;/tt&gt;.
     */
    public void ifZCmp(final int mode, final Label label) {
<span class="nc" id="L1068">        mv.visitJumpInsn(mode, label);</span>
<span class="nc" id="L1069">    }</span>

    /**
     * Generates the instruction to jump to the given label if the top stack
     * value is null.
     * 
     * @param label where to jump if the condition is &lt;tt&gt;true&lt;/tt&gt;.
     */
    public void ifNull(final Label label) {
<span class="nc" id="L1078">        mv.visitJumpInsn(Opcodes.IFNULL, label);</span>
<span class="nc" id="L1079">    }</span>

    /**
     * Generates the instruction to jump to the given label if the top stack
     * value is not null.
     * 
     * @param label where to jump if the condition is &lt;tt&gt;true&lt;/tt&gt;.
     */
    public void ifNonNull(final Label label) {
<span class="nc" id="L1088">        mv.visitJumpInsn(Opcodes.IFNONNULL, label);</span>
<span class="nc" id="L1089">    }</span>

    /**
     * Generates the instruction to jump to the given label.
     * 
     * @param label where to jump if the condition is &lt;tt&gt;true&lt;/tt&gt;.
     */
    public void goTo(final Label label) {
<span class="nc" id="L1097">        mv.visitJumpInsn(Opcodes.GOTO, label);</span>
<span class="nc" id="L1098">    }</span>

    /**
     * Generates a RET instruction.
     * 
     * @param local a local variable identifier, as returned by
     *        {@link LocalVariablesSorter#newLocal(Type) newLocal()}.
     */
    public void ret(final int local) {
<span class="nc" id="L1107">        mv.visitVarInsn(Opcodes.RET, local);</span>
<span class="nc" id="L1108">    }</span>

    /**
     * Generates the instructions for a switch statement.
     * 
     * @param keys the switch case keys.
     * @param generator a generator to generate the code for the switch cases.
     */
    public void tableSwitch(
        final int[] keys,
        final TableSwitchGenerator generator)
    {
        float density;
<span class="nc bnc" id="L1121" title="All 2 branches missed.">        if (keys.length == 0) {</span>
<span class="nc" id="L1122">            density = 0;</span>
        } else {
<span class="nc" id="L1124">            density = (float) keys.length</span>
                    / (keys[keys.length - 1] - keys[0] + 1);
        }
<span class="nc bnc" id="L1127" title="All 2 branches missed.">        tableSwitch(keys, generator, density &gt;= 0.5f);</span>
<span class="nc" id="L1128">    }</span>

    /**
     * Generates the instructions for a switch statement.
     * 
     * @param keys the switch case keys.
     * @param generator a generator to generate the code for the switch cases.
     * @param useTable &lt;tt&gt;true&lt;/tt&gt; to use a TABLESWITCH instruction, or
     *        &lt;tt&gt;false&lt;/tt&gt; to use a LOOKUPSWITCH instruction.
     */
    public void tableSwitch(
        final int[] keys,
        final TableSwitchGenerator generator,
        final boolean useTable)
    {
<span class="nc bnc" id="L1143" title="All 2 branches missed.">        for (int i = 1; i &lt; keys.length; ++i) {</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">            if (keys[i] &lt; keys[i - 1]) {</span>
<span class="nc" id="L1145">                throw new IllegalArgumentException(&quot;keys must be sorted ascending&quot;);</span>
            }
        }
<span class="nc" id="L1148">        Label def = newLabel();</span>
<span class="nc" id="L1149">        Label end = newLabel();</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">        if (keys.length &gt; 0) {</span>
<span class="nc" id="L1151">            int len = keys.length;</span>
<span class="nc" id="L1152">            int min = keys[0];</span>
<span class="nc" id="L1153">            int max = keys[len - 1];</span>
<span class="nc" id="L1154">            int range = max - min + 1;</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">            if (useTable) {</span>
<span class="nc" id="L1156">                Label[] labels = new Label[range];</span>
<span class="nc" id="L1157">                Arrays.fill(labels, def);</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">                for (int i = 0; i &lt; len; ++i) {</span>
<span class="nc" id="L1159">                    labels[keys[i] - min] = newLabel();</span>
                }
<span class="nc" id="L1161">                mv.visitTableSwitchInsn(min, max, def, labels);</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">                for (int i = 0; i &lt; range; ++i) {</span>
<span class="nc" id="L1163">                    Label label = labels[i];</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">                    if (label != def) {</span>
<span class="nc" id="L1165">                        mark(label);</span>
<span class="nc" id="L1166">                        generator.generateCase(i + min, end);</span>
                    }
                }
<span class="nc" id="L1169">            } else {</span>
<span class="nc" id="L1170">                Label[] labels = new Label[len];</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">                for (int i = 0; i &lt; len; ++i) {</span>
<span class="nc" id="L1172">                    labels[i] = newLabel();</span>
                }
<span class="nc" id="L1174">                mv.visitLookupSwitchInsn(def, keys, labels);</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">                for (int i = 0; i &lt; len; ++i) {</span>
<span class="nc" id="L1176">                    mark(labels[i]);</span>
<span class="nc" id="L1177">                    generator.generateCase(keys[i], end);</span>
                }
            }
        }
<span class="nc" id="L1181">        mark(def);</span>
<span class="nc" id="L1182">        generator.generateDefault();</span>
<span class="nc" id="L1183">        mark(end);</span>
<span class="nc" id="L1184">    }</span>

    /**
     * Generates the instruction to return the top stack value to the caller.
     */
    public void returnValue() {
<span class="nc" id="L1190">        mv.visitInsn(returnType.getOpcode(Opcodes.IRETURN));</span>
<span class="nc" id="L1191">    }</span>

    // ------------------------------------------------------------------------
    // Instructions to load and store fields
    // ------------------------------------------------------------------------

    /**
     * Generates a get field or set field instruction.
     * 
     * @param opcode the instruction's opcode.
     * @param ownerType the class in which the field is defined.
     * @param name the name of the field.
     * @param fieldType the type of the field.
     */
    private void fieldInsn(
        final int opcode,
        final Type ownerType,
        final String name,
        final Type fieldType)
    {
<span class="nc" id="L1211">        mv.visitFieldInsn(opcode,</span>
<span class="nc" id="L1212">                ownerType.getInternalName(),</span>
                name,
<span class="nc" id="L1214">                fieldType.getDescriptor());</span>
<span class="nc" id="L1215">    }</span>

    /**
     * Generates the instruction to push the value of a static field on the
     * stack.
     * 
     * @param owner the class in which the field is defined.
     * @param name the name of the field.
     * @param type the type of the field.
     */
    public void getStatic(final Type owner, final String name, final Type type)
    {
<span class="nc" id="L1227">        fieldInsn(Opcodes.GETSTATIC, owner, name, type);</span>
<span class="nc" id="L1228">    }</span>

    /**
     * Generates the instruction to store the top stack value in a static field.
     * 
     * @param owner the class in which the field is defined.
     * @param name the name of the field.
     * @param type the type of the field.
     */
    public void putStatic(final Type owner, final String name, final Type type)
    {
<span class="nc" id="L1239">        fieldInsn(Opcodes.PUTSTATIC, owner, name, type);</span>
<span class="nc" id="L1240">    }</span>

    /**
     * Generates the instruction to push the value of a non static field on the
     * stack.
     * 
     * @param owner the class in which the field is defined.
     * @param name the name of the field.
     * @param type the type of the field.
     */
    public void getField(final Type owner, final String name, final Type type) {
<span class="nc" id="L1251">        fieldInsn(Opcodes.GETFIELD, owner, name, type);</span>
<span class="nc" id="L1252">    }</span>

    /**
     * Generates the instruction to store the top stack value in a non static
     * field.
     * 
     * @param owner the class in which the field is defined.
     * @param name the name of the field.
     * @param type the type of the field.
     */
    public void putField(final Type owner, final String name, final Type type) {
<span class="nc" id="L1263">        fieldInsn(Opcodes.PUTFIELD, owner, name, type);</span>
<span class="nc" id="L1264">    }</span>

    // ------------------------------------------------------------------------
    // Instructions to invoke methods
    // ------------------------------------------------------------------------

    /**
     * Generates an invoke method instruction.
     * 
     * @param opcode the instruction's opcode.
     * @param type the class in which the method is defined.
     * @param method the method to be invoked.
     */
    private void invokeInsn(
        final int opcode,
        final Type type,
        final Method method)
    {
<span class="nc bnc" id="L1282" title="All 2 branches missed.">        String owner = type.getSort() == Type.ARRAY</span>
<span class="nc" id="L1283">                ? type.getDescriptor()</span>
<span class="nc" id="L1284">                : type.getInternalName();</span>
<span class="nc" id="L1285">        mv.visitMethodInsn(opcode,</span>
                owner,
<span class="nc" id="L1287">                method.getName(),</span>
<span class="nc" id="L1288">                method.getDescriptor());</span>
<span class="nc" id="L1289">    }</span>

    /**
     * Generates the instruction to invoke a normal method.
     * 
     * @param owner the class in which the method is defined.
     * @param method the method to be invoked.
     */
    public void invokeVirtual(final Type owner, final Method method) {
<span class="nc" id="L1298">        invokeInsn(Opcodes.INVOKEVIRTUAL, owner, method);</span>
<span class="nc" id="L1299">    }</span>

    /**
     * Generates the instruction to invoke a constructor.
     * 
     * @param type the class in which the constructor is defined.
     * @param method the constructor to be invoked.
     */
    public void invokeConstructor(final Type type, final Method method) {
<span class="nc" id="L1308">        invokeInsn(Opcodes.INVOKESPECIAL, type, method);</span>
<span class="nc" id="L1309">    }</span>

    /**
     * Generates the instruction to invoke a static method.
     * 
     * @param owner the class in which the method is defined.
     * @param method the method to be invoked.
     */
    public void invokeStatic(final Type owner, final Method method) {
<span class="nc" id="L1318">        invokeInsn(Opcodes.INVOKESTATIC, owner, method);</span>
<span class="nc" id="L1319">    }</span>

    /**
     * Generates the instruction to invoke an interface method.
     * 
     * @param owner the class in which the method is defined.
     * @param method the method to be invoked.
     */
    public void invokeInterface(final Type owner, final Method method) {
<span class="nc" id="L1328">        invokeInsn(Opcodes.INVOKEINTERFACE, owner, method);</span>
<span class="nc" id="L1329">    }</span>
    
    /**
     * Generates the instruction to invoke a dynamic method.
     * 
     * @param method the method to be invoked.
     */
    public void invokeDynamic(final Method method) {
<span class="nc" id="L1337">        invokeInsn(Opcodes.INVOKEDYNAMIC,</span>
<span class="nc" id="L1338">                Type.getObjectType(Opcodes.INVOKEDYNAMIC_OWNER),</span>
                method);
<span class="nc" id="L1340">    }</span>

    // ------------------------------------------------------------------------
    // Instructions to create objects and arrays
    // ------------------------------------------------------------------------

    /**
     * Generates a type dependent instruction.
     * 
     * @param opcode the instruction's opcode.
     * @param type the instruction's operand.
     */
    private void typeInsn(final int opcode, final Type type) {
<span class="nc" id="L1353">        mv.visitTypeInsn(opcode, type.getInternalName());</span>
<span class="nc" id="L1354">    }</span>

    /**
     * Generates the instruction to create a new object.
     * 
     * @param type the class of the object to be created.
     */
    public void newInstance(final Type type) {
<span class="nc" id="L1362">        typeInsn(Opcodes.NEW, type);</span>
<span class="nc" id="L1363">    }</span>

    /**
     * Generates the instruction to create a new array.
     * 
     * @param type the type of the array elements.
     */
    public void newArray(final Type type) {
        int typ;
<span class="nc bnc" id="L1372" title="All 9 branches missed.">        switch (type.getSort()) {</span>
            case Type.BOOLEAN:
<span class="nc" id="L1374">                typ = Opcodes.T_BOOLEAN;</span>
<span class="nc" id="L1375">                break;</span>
            case Type.CHAR:
<span class="nc" id="L1377">                typ = Opcodes.T_CHAR;</span>
<span class="nc" id="L1378">                break;</span>
            case Type.BYTE:
<span class="nc" id="L1380">                typ = Opcodes.T_BYTE;</span>
<span class="nc" id="L1381">                break;</span>
            case Type.SHORT:
<span class="nc" id="L1383">                typ = Opcodes.T_SHORT;</span>
<span class="nc" id="L1384">                break;</span>
            case Type.INT:
<span class="nc" id="L1386">                typ = Opcodes.T_INT;</span>
<span class="nc" id="L1387">                break;</span>
            case Type.FLOAT:
<span class="nc" id="L1389">                typ = Opcodes.T_FLOAT;</span>
<span class="nc" id="L1390">                break;</span>
            case Type.LONG:
<span class="nc" id="L1392">                typ = Opcodes.T_LONG;</span>
<span class="nc" id="L1393">                break;</span>
            case Type.DOUBLE:
<span class="nc" id="L1395">                typ = Opcodes.T_DOUBLE;</span>
<span class="nc" id="L1396">                break;</span>
            default:
<span class="nc" id="L1398">                typeInsn(Opcodes.ANEWARRAY, type);</span>
<span class="nc" id="L1399">                return;</span>
        }
<span class="nc" id="L1401">        mv.visitIntInsn(Opcodes.NEWARRAY, typ);</span>
<span class="nc" id="L1402">    }</span>

    // ------------------------------------------------------------------------
    // Miscelaneous instructions
    // ------------------------------------------------------------------------

    /**
     * Generates the instruction to compute the length of an array.
     */
    public void arrayLength() {
<span class="nc" id="L1412">        mv.visitInsn(Opcodes.ARRAYLENGTH);</span>
<span class="nc" id="L1413">    }</span>

    /**
     * Generates the instruction to throw an exception.
     */
    public void throwException() {
<span class="nc" id="L1419">        mv.visitInsn(Opcodes.ATHROW);</span>
<span class="nc" id="L1420">    }</span>

    /**
     * Generates the instructions to create and throw an exception. The
     * exception class must have a constructor with a single String argument.
     * 
     * @param type the class of the exception to be thrown.
     * @param msg the detailed message of the exception.
     */
    public void throwException(final Type type, final String msg) {
<span class="nc" id="L1430">        newInstance(type);</span>
<span class="nc" id="L1431">        dup();</span>
<span class="nc" id="L1432">        push(msg);</span>
<span class="nc" id="L1433">        invokeConstructor(type, Method.getMethod(&quot;void &lt;init&gt; (String)&quot;));</span>
<span class="nc" id="L1434">        throwException();</span>
<span class="nc" id="L1435">    }</span>

    /**
     * Generates the instruction to check that the top stack value is of the
     * given type.
     * 
     * @param type a class or interface type.
     */
    public void checkCast(final Type type) {
<span class="nc bnc" id="L1444" title="All 2 branches missed.">        if (!type.equals(OBJECT_TYPE)) {</span>
<span class="nc" id="L1445">            typeInsn(Opcodes.CHECKCAST, type);</span>
        }
<span class="nc" id="L1447">    }</span>

    /**
     * Generates the instruction to test if the top stack value is of the given
     * type.
     * 
     * @param type a class or interface type.
     */
    public void instanceOf(final Type type) {
<span class="nc" id="L1456">        typeInsn(Opcodes.INSTANCEOF, type);</span>
<span class="nc" id="L1457">    }</span>

    /**
     * Generates the instruction to get the monitor of the top stack value.
     */
    public void monitorEnter() {
<span class="nc" id="L1463">        mv.visitInsn(Opcodes.MONITORENTER);</span>
<span class="nc" id="L1464">    }</span>

    /**
     * Generates the instruction to release the monitor of the top stack value.
     */
    public void monitorExit() {
<span class="nc" id="L1470">        mv.visitInsn(Opcodes.MONITOREXIT);</span>
<span class="nc" id="L1471">    }</span>

    // ------------------------------------------------------------------------
    // Non instructions
    // ------------------------------------------------------------------------

    /**
     * Marks the end of the visited method.
     */
    public void endMethod() {
<span class="nc bnc" id="L1481" title="All 2 branches missed.">        if ((access &amp; Opcodes.ACC_ABSTRACT) == 0) {</span>
<span class="nc" id="L1482">            mv.visitMaxs(0, 0);</span>
        }
<span class="nc" id="L1484">        mv.visitEnd();</span>
<span class="nc" id="L1485">    }</span>

    /**
     * Marks the start of an exception handler.
     * 
     * @param start beginning of the exception handler's scope (inclusive).
     * @param end end of the exception handler's scope (exclusive).
     * @param exception internal name of the type of exceptions handled by the
     *        handler.
     */
    public void catchException(
        final Label start,
        final Label end,
        final Type exception)
    {
<span class="nc bnc" id="L1500" title="All 2 branches missed.">        if (exception == null) {</span>
<span class="nc" id="L1501">            mv.visitTryCatchBlock(start, end, mark(), null);            </span>
        } else {
<span class="nc" id="L1503">            mv.visitTryCatchBlock(start, end, mark(), exception.getInternalName());</span>
        }
<span class="nc" id="L1505">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>