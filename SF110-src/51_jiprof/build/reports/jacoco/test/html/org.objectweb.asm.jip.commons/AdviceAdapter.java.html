<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AdviceAdapter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">51_jiprof</a> &gt; <a href="index.source.html" class="el_package">org.objectweb.asm.jip.commons</a> &gt; <span class="el_source">AdviceAdapter.java</span></div><h1>AdviceAdapter.java</h1><pre class="source lang-java linenums">/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2007 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.objectweb.asm.jip.commons;

import org.objectweb.asm.jip.Label;
import org.objectweb.asm.jip.MethodVisitor;
import org.objectweb.asm.jip.Opcodes;
import org.objectweb.asm.jip.Type;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * A {@link org.objectweb.asm.jip.MethodAdapter} to insert before, after and around
 * advices in methods and constructors. &lt;p&gt; The behavior for constructors is
 * like this: &lt;ol&gt;
 *
 * &lt;li&gt;as long as the INVOKESPECIAL for the object initialization has not been
 * reached, every bytecode instruction is dispatched in the ctor code visitor&lt;/li&gt;
 *
 * &lt;li&gt;when this one is reached, it is only added in the ctor code visitor and
 * a JP invoke is added&lt;/li&gt;
 *
 * &lt;li&gt;after that, only the other code visitor receives the instructions&lt;/li&gt;
 *
 * &lt;/ol&gt;
 *
 * @author Eugene Kuleshov
 * @author Eric Bruneton
 */
public abstract class AdviceAdapter extends GeneratorAdapter implements Opcodes
{
<span class="nc" id="L62">    private static final Object THIS = new Object();</span>
<span class="nc" id="L63">    private static final Object OTHER = new Object();</span>

    protected int methodAccess;
    protected String methodDesc;

    private boolean constructor;
    private boolean superInitialized;
    private List stackFrame;
    private Map branches;

    /**
     * Creates a new {@link AdviceAdapter}.
     *
     * @param mv the method visitor to which this adapter delegates calls.
     * @param access the method's access flags (see {@link Opcodes}).
     * @param name the method's name.
     * @param desc the method's descriptor (see {@link Type Type}).
     */
    protected AdviceAdapter(
        final MethodVisitor mv,
        final int access,
        final String name,
        final String desc)
    {
<span class="nc" id="L87">        super(mv, access, name, desc);</span>
<span class="nc" id="L88">        methodAccess = access;</span>
<span class="nc" id="L89">        methodDesc = desc;</span>

<span class="nc" id="L91">        constructor = &quot;&lt;init&gt;&quot;.equals(name);</span>
<span class="nc" id="L92">    }</span>

    public void visitCode() {
<span class="nc" id="L95">        mv.visitCode();</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (constructor) {</span>
<span class="nc" id="L97">            stackFrame = new ArrayList();</span>
<span class="nc" id="L98">            branches = new HashMap();</span>
        } else {
<span class="nc" id="L100">            superInitialized = true;</span>
<span class="nc" id="L101">            onMethodEnter();</span>
        }
<span class="nc" id="L103">    }</span>

    public void visitLabel(final Label label) {
<span class="nc" id="L106">        mv.visitLabel(label);</span>

<span class="nc bnc" id="L108" title="All 4 branches missed.">        if (constructor &amp;&amp; branches != null) {</span>
<span class="nc" id="L109">            List frame = (List) branches.get(label);</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            if (frame != null) {</span>
<span class="nc" id="L111">                stackFrame = frame;</span>
<span class="nc" id="L112">                branches.remove(label);</span>
            }
        }
<span class="nc" id="L115">    }</span>

    public void visitInsn(final int opcode) {
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (constructor) {</span>
            int s;
<span class="nc bnc" id="L120" title="All 18 branches missed.">            switch (opcode) {</span>
                case RETURN: // empty stack
<span class="nc" id="L122">                    onMethodExit(opcode);</span>
<span class="nc" id="L123">                    break;</span>

                case IRETURN: // 1 before n/a after
                case FRETURN: // 1 before n/a after
                case ARETURN: // 1 before n/a after
                case ATHROW: // 1 before n/a after
<span class="nc" id="L129">                    popValue();</span>
<span class="nc" id="L130">                    onMethodExit(opcode);</span>
<span class="nc" id="L131">                    break;</span>

                case LRETURN: // 2 before n/a after
                case DRETURN: // 2 before n/a after
<span class="nc" id="L135">                    popValue();</span>
<span class="nc" id="L136">                    popValue();</span>
<span class="nc" id="L137">                    onMethodExit(opcode);</span>
<span class="nc" id="L138">                    break;</span>

                case NOP:
                case LALOAD: // remove 2 add 2
                case DALOAD: // remove 2 add 2
                case LNEG:
                case DNEG:
                case FNEG:
                case INEG:
                case L2D:
                case D2L:
                case F2I:
                case I2B:
                case I2C:
                case I2S:
                case I2F:
                case ARRAYLENGTH:
<span class="nc" id="L155">                    break;</span>

                case ACONST_NULL:
                case ICONST_M1:
                case ICONST_0:
                case ICONST_1:
                case ICONST_2:
                case ICONST_3:
                case ICONST_4:
                case ICONST_5:
                case FCONST_0:
                case FCONST_1:
                case FCONST_2:
                case F2L: // 1 before 2 after
                case F2D:
                case I2L:
                case I2D:
<span class="nc" id="L172">                    pushValue(OTHER);</span>
<span class="nc" id="L173">                    break;</span>

                case LCONST_0:
                case LCONST_1:
                case DCONST_0:
                case DCONST_1:
<span class="nc" id="L179">                    pushValue(OTHER);</span>
<span class="nc" id="L180">                    pushValue(OTHER);</span>
<span class="nc" id="L181">                    break;</span>

                case IALOAD: // remove 2 add 1
                case FALOAD: // remove 2 add 1
                case AALOAD: // remove 2 add 1
                case BALOAD: // remove 2 add 1
                case CALOAD: // remove 2 add 1
                case SALOAD: // remove 2 add 1
                case POP:
                case IADD:
                case FADD:
                case ISUB:
                case LSHL: // 3 before 2 after
                case LSHR: // 3 before 2 after
                case LUSHR: // 3 before 2 after
                case L2I: // 2 before 1 after
                case L2F: // 2 before 1 after
                case D2I: // 2 before 1 after
                case D2F: // 2 before 1 after
                case FSUB:
                case FMUL:
                case FDIV:
                case FREM:
                case FCMPL: // 2 before 1 after
                case FCMPG: // 2 before 1 after
                case IMUL:
                case IDIV:
                case IREM:
                case ISHL:
                case ISHR:
                case IUSHR:
                case IAND:
                case IOR:
                case IXOR:
                case MONITORENTER:
                case MONITOREXIT:
<span class="nc" id="L217">                    popValue();</span>
<span class="nc" id="L218">                    break;</span>

                case POP2:
                case LSUB:
                case LMUL:
                case LDIV:
                case LREM:
                case LADD:
                case LAND:
                case LOR:
                case LXOR:
                case DADD:
                case DMUL:
                case DSUB:
                case DDIV:
                case DREM:
<span class="nc" id="L234">                    popValue();</span>
<span class="nc" id="L235">                    popValue();</span>
<span class="nc" id="L236">                    break;</span>

                case IASTORE:
                case FASTORE:
                case AASTORE:
                case BASTORE:
                case CASTORE:
                case SASTORE:
                case LCMP: // 4 before 1 after
                case DCMPL:
                case DCMPG:
<span class="nc" id="L247">                    popValue();</span>
<span class="nc" id="L248">                    popValue();</span>
<span class="nc" id="L249">                    popValue();</span>
<span class="nc" id="L250">                    break;</span>

                case LASTORE:
                case DASTORE:
<span class="nc" id="L254">                    popValue();</span>
<span class="nc" id="L255">                    popValue();</span>
<span class="nc" id="L256">                    popValue();</span>
<span class="nc" id="L257">                    popValue();</span>
<span class="nc" id="L258">                    break;</span>

                case DUP:
<span class="nc" id="L261">                    pushValue(peekValue());</span>
<span class="nc" id="L262">                    break;</span>

                case DUP_X1:
<span class="nc" id="L265">                    s = stackFrame.size();</span>
<span class="nc" id="L266">                    stackFrame.add(s - 2, stackFrame.get(s - 1));</span>
<span class="nc" id="L267">                    break;</span>

                case DUP_X2:
<span class="nc" id="L270">                    s = stackFrame.size();</span>
<span class="nc" id="L271">                    stackFrame.add(s - 3, stackFrame.get(s - 1));</span>
<span class="nc" id="L272">                    break;</span>

                case DUP2:
<span class="nc" id="L275">                    s = stackFrame.size();</span>
<span class="nc" id="L276">                    stackFrame.add(s - 2, stackFrame.get(s - 1));</span>
<span class="nc" id="L277">                    stackFrame.add(s - 2, stackFrame.get(s - 1));</span>
<span class="nc" id="L278">                    break;</span>

                case DUP2_X1:
<span class="nc" id="L281">                    s = stackFrame.size();</span>
<span class="nc" id="L282">                    stackFrame.add(s - 3, stackFrame.get(s - 1));</span>
<span class="nc" id="L283">                    stackFrame.add(s - 3, stackFrame.get(s - 1));</span>
<span class="nc" id="L284">                    break;</span>

                case DUP2_X2:
<span class="nc" id="L287">                    s = stackFrame.size();</span>
<span class="nc" id="L288">                    stackFrame.add(s - 4, stackFrame.get(s - 1));</span>
<span class="nc" id="L289">                    stackFrame.add(s - 4, stackFrame.get(s - 1));</span>
<span class="nc" id="L290">                    break;</span>

                case SWAP:
<span class="nc" id="L293">                    s = stackFrame.size();</span>
<span class="nc" id="L294">                    stackFrame.add(s - 2, stackFrame.get(s - 1));</span>
<span class="nc" id="L295">                    stackFrame.remove(s);</span>
<span class="nc" id="L296">                    break;</span>
            }
        } else {
<span class="nc bnc" id="L299" title="All 2 branches missed.">            switch (opcode) {</span>
                case RETURN:
                case IRETURN:
                case FRETURN:
                case ARETURN:
                case LRETURN:
                case DRETURN:
                case ATHROW:
<span class="nc" id="L307">                    onMethodExit(opcode);</span>
                    break;
            }
        }
<span class="nc" id="L311">        mv.visitInsn(opcode);</span>
<span class="nc" id="L312">    }</span>

    public void visitVarInsn(final int opcode, final int var) {
<span class="nc" id="L315">        super.visitVarInsn(opcode, var);</span>

<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (constructor) {</span>
<span class="nc bnc" id="L318" title="All 6 branches missed.">            switch (opcode) {</span>
                case ILOAD:
                case FLOAD:
<span class="nc" id="L321">                    pushValue(OTHER);</span>
<span class="nc" id="L322">                    break;</span>
                case LLOAD:
                case DLOAD:
<span class="nc" id="L325">                    pushValue(OTHER);</span>
<span class="nc" id="L326">                    pushValue(OTHER);</span>
<span class="nc" id="L327">                    break;</span>
                case ALOAD:
<span class="nc bnc" id="L329" title="All 2 branches missed.">                    pushValue(var == 0 ? THIS : OTHER);</span>
<span class="nc" id="L330">                    break;</span>
                case ASTORE:
                case ISTORE:
                case FSTORE:
<span class="nc" id="L334">                    popValue();</span>
<span class="nc" id="L335">                    break;</span>
                case LSTORE:
                case DSTORE:
<span class="nc" id="L338">                    popValue();</span>
<span class="nc" id="L339">                    popValue();</span>
                    break;
            }
        }
<span class="nc" id="L343">    }</span>

    public void visitFieldInsn(
        final int opcode,
        final String owner,
        final String name,
        final String desc)
    {
<span class="nc" id="L351">        mv.visitFieldInsn(opcode, owner, name, desc);</span>

<span class="nc bnc" id="L353" title="All 2 branches missed.">        if (constructor) {</span>
<span class="nc" id="L354">            char c = desc.charAt(0);</span>
<span class="nc bnc" id="L355" title="All 4 branches missed.">            boolean longOrDouble = c == 'J' || c == 'D';</span>
<span class="nc bnc" id="L356" title="All 4 branches missed.">            switch (opcode) {</span>
                case GETSTATIC:
<span class="nc" id="L358">                    pushValue(OTHER);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">                    if (longOrDouble) {</span>
<span class="nc" id="L360">                        pushValue(OTHER);</span>
                    }
                    break;
                case PUTSTATIC:
<span class="nc" id="L364">                    popValue();</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                    if (longOrDouble) {</span>
<span class="nc" id="L366">                        popValue();</span>
                    }
                    break;
                case PUTFIELD:
<span class="nc" id="L370">                    popValue();</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">                    if (longOrDouble) {</span>
<span class="nc" id="L372">                        popValue();</span>
<span class="nc" id="L373">                        popValue();</span>
                    }
                    break;
                // case GETFIELD:
                default:
<span class="nc bnc" id="L378" title="All 2 branches missed.">                    if (longOrDouble) {</span>
<span class="nc" id="L379">                        pushValue(OTHER);</span>
                    }
            }
        }
<span class="nc" id="L383">    }</span>

    public void visitIntInsn(final int opcode, final int operand) {
<span class="nc" id="L386">        mv.visitIntInsn(opcode, operand);</span>

<span class="nc bnc" id="L388" title="All 4 branches missed.">        if (constructor &amp;&amp; opcode!=NEWARRAY) {</span>
<span class="nc" id="L389">            pushValue(OTHER);</span>
        }
<span class="nc" id="L391">    }</span>

    public void visitLdcInsn(final Object cst) {
<span class="nc" id="L394">        mv.visitLdcInsn(cst);</span>

<span class="nc bnc" id="L396" title="All 2 branches missed.">        if (constructor) {</span>
<span class="nc" id="L397">            pushValue(OTHER);</span>
<span class="nc bnc" id="L398" title="All 4 branches missed.">            if (cst instanceof Double || cst instanceof Long) {</span>
<span class="nc" id="L399">                pushValue(OTHER);</span>
            }
        }
<span class="nc" id="L402">    }</span>

    public void visitMultiANewArrayInsn(final String desc, final int dims) {
<span class="nc" id="L405">        mv.visitMultiANewArrayInsn(desc, dims);</span>

<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (constructor) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            for (int i = 0; i &lt; dims; i++) {</span>
<span class="nc" id="L409">                popValue();</span>
            }
<span class="nc" id="L411">            pushValue(OTHER);</span>
        }
<span class="nc" id="L413">    }</span>

    public void visitTypeInsn(final int opcode, final String type) {
<span class="nc" id="L416">        mv.visitTypeInsn(opcode, type);</span>

        // ANEWARRAY, CHECKCAST or INSTANCEOF don't change stack
<span class="nc bnc" id="L419" title="All 4 branches missed.">        if (constructor &amp;&amp; opcode == NEW) {</span>
<span class="nc" id="L420">            pushValue(OTHER);</span>
        }
<span class="nc" id="L422">    }</span>

    public void visitMethodInsn(
        final int opcode,
        final String owner,
        final String name,
        final String desc)
    {
<span class="nc" id="L430">        mv.visitMethodInsn(opcode, owner, name, desc);</span>

<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (constructor) {</span>
<span class="nc" id="L433">            Type[] types = Type.getArgumentTypes(desc);</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">            for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc" id="L435">                popValue();</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">                if (types[i].getSize() == 2) {</span>
<span class="nc" id="L437">                    popValue();</span>
                }
            }
<span class="nc bnc" id="L440" title="All 3 branches missed.">            switch (opcode) {</span>
                // case INVOKESTATIC:
                // case INVOKEDYNAMIC
                // break;

                case INVOKEINTERFACE:
                case INVOKEVIRTUAL:
<span class="nc" id="L447">                    popValue(); // objectref</span>
<span class="nc" id="L448">                    break;</span>

                case INVOKESPECIAL:
<span class="nc" id="L451">                    Object type = popValue(); // objectref</span>
<span class="nc bnc" id="L452" title="All 4 branches missed.">                    if (type == THIS &amp;&amp; !superInitialized) {</span>
<span class="nc" id="L453">                        onMethodEnter();</span>
<span class="nc" id="L454">                        superInitialized = true;</span>
                        // once super has been initialized it is no longer
                        // necessary to keep track of stack state
<span class="nc" id="L457">                        constructor = false;</span>
                    }
                    break;
            }

<span class="nc" id="L462">            Type returnType = Type.getReturnType(desc);</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">            if (returnType != Type.VOID_TYPE) {</span>
<span class="nc" id="L464">                pushValue(OTHER);</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">                if (returnType.getSize() == 2) {</span>
<span class="nc" id="L466">                    pushValue(OTHER);</span>
                }
            }
        }
<span class="nc" id="L470">    }</span>

    public void visitJumpInsn(final int opcode, final Label label) {
<span class="nc" id="L473">        mv.visitJumpInsn(opcode, label);</span>

<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (constructor) {</span>
<span class="nc bnc" id="L476" title="All 4 branches missed.">            switch (opcode) {</span>
                case IFEQ:
                case IFNE:
                case IFLT:
                case IFGE:
                case IFGT:
                case IFLE:
                case IFNULL:
                case IFNONNULL:
<span class="nc" id="L485">                    popValue();</span>
<span class="nc" id="L486">                    break;</span>

                case IF_ICMPEQ:
                case IF_ICMPNE:
                case IF_ICMPLT:
                case IF_ICMPGE:
                case IF_ICMPGT:
                case IF_ICMPLE:
                case IF_ACMPEQ:
                case IF_ACMPNE:
<span class="nc" id="L496">                    popValue();</span>
<span class="nc" id="L497">                    popValue();</span>
<span class="nc" id="L498">                    break;</span>

                case JSR:
<span class="nc" id="L501">                    pushValue(OTHER);</span>
                    break;
            }
<span class="nc" id="L504">            addBranch(label);</span>
        }
<span class="nc" id="L506">    }</span>

    public void visitLookupSwitchInsn(
        final Label dflt,
        final int[] keys,
        final Label[] labels)
    {
<span class="nc" id="L513">        mv.visitLookupSwitchInsn(dflt, keys, labels);</span>

<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (constructor) {</span>
<span class="nc" id="L516">            popValue();</span>
<span class="nc" id="L517">            addBranches(dflt, labels);</span>
        }
<span class="nc" id="L519">    }</span>

    public void visitTableSwitchInsn(
        final int min,
        final int max,
        final Label dflt,
        final Label[] labels)
    {
<span class="nc" id="L527">        mv.visitTableSwitchInsn(min, max, dflt, labels);</span>

<span class="nc bnc" id="L529" title="All 2 branches missed.">        if (constructor) {</span>
<span class="nc" id="L530">            popValue();</span>
<span class="nc" id="L531">            addBranches(dflt, labels);</span>
        }
<span class="nc" id="L533">    }</span>

    private void addBranches(final Label dflt, final Label[] labels) {
<span class="nc" id="L536">        addBranch(dflt);</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">        for (int i = 0; i &lt; labels.length; i++) {</span>
<span class="nc" id="L538">            addBranch(labels[i]);</span>
        }
<span class="nc" id="L540">    }</span>

    private void addBranch(final Label label) {
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (branches.containsKey(label)) {</span>
<span class="nc" id="L544">            return;</span>
        }
<span class="nc" id="L546">        branches.put(label, new ArrayList(stackFrame));</span>
<span class="nc" id="L547">    }</span>

    private Object popValue() {
<span class="nc" id="L550">        return stackFrame.remove(stackFrame.size() - 1);</span>
    }

    private Object peekValue() {
<span class="nc" id="L554">        return stackFrame.get(stackFrame.size() - 1);</span>
    }

    private void pushValue(final Object o) {
<span class="nc" id="L558">        stackFrame.add(o);</span>
<span class="nc" id="L559">    }</span>

    /**
     * Called at the beginning of the method or after super class class call in
     * the constructor. &lt;br&gt;&lt;br&gt;
     *
     * &lt;i&gt;Custom code can use or change all the local variables, but should not
     * change state of the stack.&lt;/i&gt;
     */
    protected void onMethodEnter() {
<span class="nc" id="L569">    }</span>

    /**
     * Called before explicit exit from the method using either return or throw.
     * Top element on the stack contains the return value or exception instance.
     * For example:
     *
     * &lt;pre&gt;
     *   public void onMethodExit(int opcode) {
     *     if(opcode==RETURN) {
     *         visitInsn(ACONST_NULL);
     *     } else if(opcode==ARETURN || opcode==ATHROW) {
     *         dup();
     *     } else {
     *         if(opcode==LRETURN || opcode==DRETURN) {
     *             dup2();
     *         } else {
     *             dup();
     *         }
     *         box(Type.getReturnType(this.methodDesc));
     *     }
     *     visitIntInsn(SIPUSH, opcode);
     *     visitMethodInsn(INVOKESTATIC, owner, &quot;onExit&quot;, &quot;(Ljava/lang/Object;I)V&quot;);
     *   }
     *
     *   // an actual call back method
     *   public static void onExit(Object param, int opcode) {
     *     ...
     * &lt;/pre&gt;
     *
     * &lt;br&gt;&lt;br&gt;
     *
     * &lt;i&gt;Custom code can use or change all the local variables, but should not
     * change state of the stack.&lt;/i&gt;
     *
     * @param opcode one of the RETURN, IRETURN, FRETURN, ARETURN, LRETURN,
     *        DRETURN or ATHROW
     *
     */
    protected void onMethodExit(int opcode) {
<span class="nc" id="L609">    }</span>

    // TODO onException, onMethodCall

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>