<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MethodWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">80_wheelwebtool</a> &gt; <a href="index.source.html" class="el_package">wheel.asm</a> &gt; <span class="el_source">MethodWriter.java</span></div><h1>MethodWriter.java</h1><pre class="source lang-java linenums">/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2007 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package wheel.asm;

/**
 * A {@link MethodVisitor} that generates methods in bytecode form. Each visit
 * method of this class appends the bytecode corresponding to the visited
 * instruction to a byte vector, in the order these methods are called.
 * 
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
class MethodWriter implements MethodVisitor {

    /**
     * Pseudo access flag used to denote constructors.
     */
    static final int ACC_CONSTRUCTOR = 262144;

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is zero.
     */
    static final int SAME_FRAME = 0; // to 63 (0-3f)

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is 1
     */
    static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64; // to 127 (40-7f)

    /**
     * Reserved for future use
     */
    static final int RESERVED = 128;

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is 1. Offset is bigger then 63;
     */
    static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247; // f7

    /**
     * Frame where current locals are the same as the locals in the previous
     * frame, except that the k last locals are absent. The value of k is given
     * by the formula 251-frame_type.
     */
    static final int CHOP_FRAME = 248; // to 250 (f8-fA)

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is zero. Offset is bigger then 63;
     */
    static final int SAME_FRAME_EXTENDED = 251; // fb

    /**
     * Frame where current locals are the same as the locals in the previous
     * frame, except that k additional locals are defined. The value of k is
     * given by the formula frame_type-251.
     */
    static final int APPEND_FRAME = 252; // to 254 // fc-fe

    /**
     * Full frame
     */
    static final int FULL_FRAME = 255; // ff

    /**
     * Indicates that the stack map frames must be recomputed from scratch. In
     * this case the maximum stack size and number of local variables is also
     * recomputed from scratch.
     * 
     * @see #compute
     */
    private static final int FRAMES = 0;

    /**
     * Indicates that the maximum stack size and number of local variables must
     * be automatically computed.
     * 
     * @see #compute
     */
    private static final int MAXS = 1;

    /**
     * Indicates that nothing must be automatically computed.
     * 
     * @see #compute
     */
    private static final int NOTHING = 2;

    /**
     * Next method writer (see {@link ClassWriter#firstMethod firstMethod}).
     */
    MethodWriter next;

    /**
     * The class writer to which this method must be added.
     */
    final ClassWriter cw;

    /**
     * Access flags of this method.
     */
    private int access;

    /**
     * The index of the constant pool item that contains the name of this
     * method.
     */
    private final int name;

    /**
     * The index of the constant pool item that contains the descriptor of this
     * method.
     */
    private final int desc;

    /**
     * The descriptor of this method.
     */
    private final String descriptor;

    /**
     * The signature of this method.
     */
    String signature;

    /**
     * If not zero, indicates that the code of this method must be copied from
     * the ClassReader associated to this writer in &lt;code&gt;cw.cr&lt;/code&gt;. More
     * precisely, this field gives the index of the first byte to copied from
     * &lt;code&gt;cw.cr.b&lt;/code&gt;.
     */
    int classReaderOffset;

    /**
     * If not zero, indicates that the code of this method must be copied from
     * the ClassReader associated to this writer in &lt;code&gt;cw.cr&lt;/code&gt;. More
     * precisely, this field gives the number of bytes to copied from
     * &lt;code&gt;cw.cr.b&lt;/code&gt;.
     */
    int classReaderLength;

    /**
     * Number of exceptions that can be thrown by this method.
     */
    int exceptionCount;

    /**
     * The exceptions that can be thrown by this method. More precisely, this
     * array contains the indexes of the constant pool items that contain the
     * internal names of these exception classes.
     */
    int[] exceptions;

    /**
     * The annotation default attribute of this method. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private ByteVector annd;

    /**
     * The runtime visible annotations of this method. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter anns;

    /**
     * The runtime invisible annotations of this method. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter ianns;

    /**
     * The runtime visible parameter annotations of this method. May be
     * &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter[] panns;

    /**
     * The runtime invisible parameter annotations of this method. May be
     * &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter[] ipanns;

    /**
     * The number of synthetic parameters of this method.
     */
    private int synthetics;

    /**
     * The non standard attributes of the method.
     */
    private Attribute attrs;

    /**
     * The bytecode of this method.
     */
<span class="fc" id="L224">    private ByteVector code = new ByteVector();</span>

    /**
     * Maximum stack size of this method.
     */
    private int maxStack;

    /**
     * Maximum number of local variables for this method.
     */
    private int maxLocals;

    /**
     * Number of stack map frames in the StackMapTable attribute.
     */
    private int frameCount;

    /**
     * The StackMapTable attribute.
     */
    private ByteVector stackMap;

    /**
     * The offset of the last frame that was written in the StackMapTable
     * attribute.
     */
    private int previousFrameOffset;

    /**
     * The last frame that was written in the StackMapTable attribute.
     * 
     * @see #frame
     */
    private int[] previousFrame;

    /**
     * Index of the next element to be added in {@link #frame}.
     */
    private int frameIndex;

    /**
     * The current stack map frame. The first element contains the offset of the
     * instruction to which the frame corresponds, the second element is the
     * number of locals and the third one is the number of stack elements. The
     * local variables start at index 3 and are followed by the operand stack
     * values. In summary frame[0] = offset, frame[1] = nLocal, frame[2] =
     * nStack, frame[3] = nLocal. All types are encoded as integers, with the
     * same format as the one used in {@link Label}, but limited to BASE types.
     */
    private int[] frame;

    /**
     * Number of elements in the exception handler list.
     */
    private int handlerCount;

    /**
     * The first element in the exception handler list.
     */
    private Handler firstHandler;

    /**
     * The last element in the exception handler list.
     */
    private Handler lastHandler;

    /**
     * Number of entries in the LocalVariableTable attribute.
     */
    private int localVarCount;

    /**
     * The LocalVariableTable attribute.
     */
    private ByteVector localVar;

    /**
     * Number of entries in the LocalVariableTypeTable attribute.
     */
    private int localVarTypeCount;

    /**
     * The LocalVariableTypeTable attribute.
     */
    private ByteVector localVarType;

    /**
     * Number of entries in the LineNumberTable attribute.
     */
    private int lineNumberCount;

    /**
     * The LineNumberTable attribute.
     */
    private ByteVector lineNumber;

    /**
     * The non standard attributes of the method's code.
     */
    private Attribute cattrs;

    /**
     * Indicates if some jump instructions are too small and need to be resized.
     */
    private boolean resize;

    /**
     * The number of subroutines in this method.
     */
    private int subroutines;

    // ------------------------------------------------------------------------

    /*
     * Fields for the control flow graph analysis algorithm (used to compute the
     * maximum stack size). A control flow graph contains one node per &quot;basic
     * block&quot;, and one edge per &quot;jump&quot; from one basic block to another. Each
     * node (i.e., each basic block) is represented by the Label object that
     * corresponds to the first instruction of this basic block. Each node also
     * stores the list of its successors in the graph, as a linked list of Edge
     * objects.
     */

    /**
     * Indicates what must be automatically computed.
     * 
     * @see #FRAMES
     * @see #MAXS
     * @see #NOTHING
     */
    private final int compute;

    /**
     * A list of labels. This list is the list of basic blocks in the method,
     * i.e. a list of Label objects linked to each other by their
     * {@link Label#successor} field, in the order they are visited by
     * {@link MethodVisitor#visitLabel}, and starting with the first basic block.
     */
    private Label labels;

    /**
     * The previous basic block.
     */
    private Label previousBlock;

    /**
     * The current basic block.
     */
    private Label currentBlock;

    /**
     * The (relative) stack size after the last visited instruction. This size
     * is relative to the beginning of the current basic block, i.e., the true
     * stack size after the last visited instruction is equal to the
     * {@link Label#inputStackTop beginStackSize} of the current basic block
     * plus &lt;tt&gt;stackSize&lt;/tt&gt;.
     */
    private int stackSize;

    /**
     * The (relative) maximum stack size after the last visited instruction.
     * This size is relative to the beginning of the current basic block, i.e.,
     * the true maximum stack size after the last visited instruction is equal
     * to the {@link Label#inputStackTop beginStackSize} of the current basic
     * block plus &lt;tt&gt;stackSize&lt;/tt&gt;.
     */
    private int maxStackSize;

    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------

    /**
     * Constructs a new {@link MethodWriter}.
     * 
     * @param cw the class writer in which the method must be added.
     * @param access the method's access flags (see {@link Opcodes}).
     * @param name the method's name.
     * @param desc the method's descriptor (see {@link Type}).
     * @param signature the method's signature. May be &lt;tt&gt;null&lt;/tt&gt;.
     * @param exceptions the internal names of the method's exceptions. May be
     *        &lt;tt&gt;null&lt;/tt&gt;.
     * @param computeMaxs &lt;tt&gt;true&lt;/tt&gt; if the maximum stack size and number
     *        of local variables must be automatically computed.
     * @param computeFrames &lt;tt&gt;true&lt;/tt&gt; if the stack map tables must be
     *        recomputed from scratch.
     */
    MethodWriter(
        final ClassWriter cw,
        final int access,
        final String name,
        final String desc,
        final String signature,
        final String[] exceptions,
        final boolean computeMaxs,
        final boolean computeFrames)
<span class="fc" id="L420">    {</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">        if (cw.firstMethod == null) {</span>
<span class="fc" id="L422">            cw.firstMethod = this;</span>
        } else {
<span class="fc" id="L424">            cw.lastMethod.next = this;</span>
        }
<span class="fc" id="L426">        cw.lastMethod = this;</span>
<span class="fc" id="L427">        this.cw = cw;</span>
<span class="fc" id="L428">        this.access = access;</span>
<span class="fc" id="L429">        this.name = cw.newUTF8(name);</span>
<span class="fc" id="L430">        this.desc = cw.newUTF8(desc);</span>
<span class="fc" id="L431">        this.descriptor = desc;</span>
        if (ClassReader.SIGNATURES) {
<span class="fc" id="L433">            this.signature = signature;</span>
        }
<span class="pc bpc" id="L435" title="1 of 4 branches missed.">        if (exceptions != null &amp;&amp; exceptions.length &gt; 0) {</span>
<span class="fc" id="L436">            exceptionCount = exceptions.length;</span>
<span class="fc" id="L437">            this.exceptions = new int[exceptionCount];</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">            for (int i = 0; i &lt; exceptionCount; ++i) {</span>
<span class="fc" id="L439">                this.exceptions[i] = cw.newClass(exceptions[i]);</span>
            }
        }
<span class="pc bpc" id="L442" title="1 of 4 branches missed.">        this.compute = computeFrames ? FRAMES : (computeMaxs ? MAXS : NOTHING);</span>
<span class="pc bpc" id="L443" title="1 of 4 branches missed.">        if (computeMaxs || computeFrames) {</span>
<span class="pc bpc" id="L444" title="3 of 4 branches missed.">            if (computeFrames &amp;&amp; &quot;&lt;init&gt;&quot;.equals(name)) {</span>
<span class="nc" id="L445">                this.access |= ACC_CONSTRUCTOR;</span>
            }
            // updates maxLocals
<span class="fc" id="L448">            int size = getArgumentsAndReturnSizes(descriptor) &gt;&gt; 2;</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">            if ((access &amp; Opcodes.ACC_STATIC) != 0) {</span>
<span class="fc" id="L450">                --size;</span>
            }
<span class="fc" id="L452">            maxLocals = size;</span>
            // creates and visits the label for the first basic block
<span class="fc" id="L454">            labels = new Label();</span>
<span class="fc" id="L455">            labels.status |= Label.PUSHED;</span>
<span class="fc" id="L456">            visitLabel(labels);</span>
        }
<span class="fc" id="L458">    }</span>

    // ------------------------------------------------------------------------
    // Implementation of the MethodVisitor interface
    // ------------------------------------------------------------------------

    public AnnotationVisitor visitAnnotationDefault() {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L468">        annd = new ByteVector();</span>
<span class="nc" id="L469">        return new AnnotationWriter(cw, false, annd, null, 0);</span>
    }

    public AnnotationVisitor visitAnnotation(
        final String desc,
        final boolean visible)
    {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L479">        ByteVector bv = new ByteVector();</span>
        // write type, and reserve space for values count
<span class="nc" id="L481">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="nc" id="L482">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L484">            aw.next = anns;</span>
<span class="nc" id="L485">            anns = aw;</span>
        } else {
<span class="nc" id="L487">            aw.next = ianns;</span>
<span class="nc" id="L488">            ianns = aw;</span>
        }
<span class="nc" id="L490">        return aw;</span>
    }

    public AnnotationVisitor visitParameterAnnotation(
        final int parameter,
        final String desc,
        final boolean visible)
    {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L501">        ByteVector bv = new ByteVector();</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        if (&quot;Ljava/lang/Synthetic;&quot;.equals(desc)) {</span>
            // workaround for a bug in javac with synthetic parameters
            // see ClassReader.readParameterAnnotations
<span class="nc" id="L505">            synthetics = Math.max(synthetics, parameter + 1);</span>
<span class="nc" id="L506">            return new AnnotationWriter(cw, false, bv, null, 0);</span>
        }
        // write type, and reserve space for values count
<span class="nc" id="L509">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="nc" id="L510">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">            if (panns == null) {</span>
<span class="nc" id="L513">                panns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];</span>
            }
<span class="nc" id="L515">            aw.next = panns[parameter];</span>
<span class="nc" id="L516">            panns[parameter] = aw;</span>
        } else {
<span class="nc bnc" id="L518" title="All 2 branches missed.">            if (ipanns == null) {</span>
<span class="nc" id="L519">                ipanns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];</span>
            }
<span class="nc" id="L521">            aw.next = ipanns[parameter];</span>
<span class="nc" id="L522">            ipanns[parameter] = aw;</span>
        }
<span class="nc" id="L524">        return aw;</span>
    }

    public void visitAttribute(final Attribute attr) {
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if (attr.isCodeAttribute()) {</span>
<span class="nc" id="L529">            attr.next = cattrs;</span>
<span class="nc" id="L530">            cattrs = attr;</span>
        } else {
<span class="nc" id="L532">            attr.next = attrs;</span>
<span class="nc" id="L533">            attrs = attr;</span>
        }
<span class="nc" id="L535">    }</span>

    public void visitCode() {
<span class="fc" id="L538">    }</span>

    public void visitFrame(
        final int type,
        final int nLocal,
        final Object[] local,
        final int nStack,
        final Object[] stack)
    {
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        if (!ClassReader.FRAMES || compute == FRAMES) {</span>
<span class="nc" id="L548">            return;</span>
        }

<span class="fc bfc" id="L551" title="All 2 branches covered.">        if (type == Opcodes.F_NEW) {</span>
<span class="fc" id="L552">            startFrame(code.length, nLocal, nStack);</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">            for (int i = 0; i &lt; nLocal; ++i) {</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">                if (local[i] instanceof String) {</span>
<span class="fc" id="L555">                    frame[frameIndex++] = Frame.OBJECT</span>
<span class="fc" id="L556">                            | cw.addType((String) local[i]);</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">                } else if (local[i] instanceof Integer) {</span>
<span class="fc" id="L558">                    frame[frameIndex++] = ((Integer) local[i]).intValue();</span>
                } else {
<span class="nc" id="L560">                    frame[frameIndex++] = Frame.UNINITIALIZED</span>
<span class="nc" id="L561">                            | cw.addUninitializedType(&quot;&quot;,</span>
                                    ((Label) local[i]).position);
                }
            }
<span class="fc bfc" id="L565" title="All 2 branches covered.">            for (int i = 0; i &lt; nStack; ++i) {</span>
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">                if (stack[i] instanceof String) {</span>
<span class="nc" id="L567">                    frame[frameIndex++] = Frame.OBJECT</span>
<span class="nc" id="L568">                            | cw.addType((String) stack[i]);</span>
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">                } else if (stack[i] instanceof Integer) {</span>
<span class="fc" id="L570">                    frame[frameIndex++] = ((Integer) stack[i]).intValue();</span>
                } else {
<span class="nc" id="L572">                    frame[frameIndex++] = Frame.UNINITIALIZED</span>
<span class="nc" id="L573">                            | cw.addUninitializedType(&quot;&quot;,</span>
                                    ((Label) stack[i]).position);
                }
            }
<span class="fc" id="L577">            endFrame();</span>
        } else {
            int delta;
<span class="fc bfc" id="L580" title="All 2 branches covered.">            if (stackMap == null) {</span>
<span class="fc" id="L581">                stackMap = new ByteVector();</span>
<span class="fc" id="L582">                delta = code.length;</span>
            } else {
<span class="fc" id="L584">                delta = code.length - previousFrameOffset - 1;</span>
            }

<span class="pc bpc" id="L587" title="5 of 6 branches missed.">            switch (type) {</span>
                case Opcodes.F_FULL:
<span class="nc" id="L589">                    stackMap.putByte(FULL_FRAME)</span>
<span class="nc" id="L590">                            .putShort(delta)</span>
<span class="nc" id="L591">                            .putShort(nLocal);</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">                    for (int i = 0; i &lt; nLocal; ++i) {</span>
<span class="nc" id="L593">                        writeFrameType(local[i]);</span>
                    }
<span class="nc" id="L595">                    stackMap.putShort(nStack);</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                    for (int i = 0; i &lt; nStack; ++i) {</span>
<span class="nc" id="L597">                        writeFrameType(stack[i]);</span>
                    }
<span class="nc" id="L599">                    break;</span>
                case Opcodes.F_APPEND:
<span class="nc" id="L601">                    stackMap.putByte(SAME_FRAME_EXTENDED + nLocal)</span>
<span class="nc" id="L602">                            .putShort(delta);</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">                    for (int i = 0; i &lt; nLocal; ++i) {</span>
<span class="nc" id="L604">                        writeFrameType(local[i]);</span>
                    }
<span class="nc" id="L606">                    break;</span>
                case Opcodes.F_CHOP:
<span class="nc" id="L608">                    stackMap.putByte(SAME_FRAME_EXTENDED - nLocal)</span>
<span class="nc" id="L609">                            .putShort(delta);</span>
<span class="nc" id="L610">                    break;</span>
                case Opcodes.F_SAME:
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">                    if (delta &lt; 64) {</span>
<span class="fc" id="L613">                        stackMap.putByte(delta);</span>
                    } else {
<span class="nc" id="L615">                        stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);</span>
                    }
<span class="nc" id="L617">                    break;</span>
                case Opcodes.F_SAME1:
<span class="nc bnc" id="L619" title="All 2 branches missed.">                    if (delta &lt; 64) {</span>
<span class="nc" id="L620">                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);</span>
                    } else {
<span class="nc" id="L622">                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)</span>
<span class="nc" id="L623">                                .putShort(delta);</span>
                    }
<span class="nc" id="L625">                    writeFrameType(stack[0]);</span>
                    break;
            }

<span class="fc" id="L629">            previousFrameOffset = code.length;</span>
<span class="fc" id="L630">            ++frameCount;</span>
        }
<span class="fc" id="L632">    }</span>

    public void visitInsn(final int opcode) {
        // adds the instruction to the bytecode of the method
<span class="fc" id="L636">        code.putByte(opcode);</span>
        // update currentBlock
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L639" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L641">                currentBlock.frame.execute(opcode, 0, null, null);</span>
            } else {
                // updates current and max stack sizes
<span class="fc" id="L644">                int size = stackSize + Frame.SIZE[opcode];</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">                if (size &gt; maxStackSize) {</span>
<span class="fc" id="L646">                    maxStackSize = size;</span>
                }
<span class="fc" id="L648">                stackSize = size;</span>
            }
            // if opcode == ATHROW or xRETURN, ends current block (no successor)
<span class="fc bfc" id="L651" title="All 6 branches covered.">            if ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN)</span>
                    || opcode == Opcodes.ATHROW)
            {
<span class="fc" id="L654">                noSuccessor();</span>
            }
        }
<span class="fc" id="L657">    }</span>

    public void visitIntInsn(final int opcode, final int operand) {
        // Label currentBlock = this.currentBlock;
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L663">                currentBlock.frame.execute(opcode, operand, null, null);</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">            } else if (opcode != Opcodes.NEWARRAY) {</span>
                // updates current and max stack sizes only for NEWARRAY
                // (stack size variation = 0 for BIPUSH or SIPUSH)
<span class="nc" id="L667">                int size = stackSize + 1;</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">                if (size &gt; maxStackSize) {</span>
<span class="nc" id="L669">                    maxStackSize = size;</span>
                }
<span class="nc" id="L671">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc bfc" id="L675" title="All 2 branches covered.">        if (opcode == Opcodes.SIPUSH) {</span>
<span class="fc" id="L676">            code.put12(opcode, operand);</span>
        } else { // BIPUSH or NEWARRAY
<span class="fc" id="L678">            code.put11(opcode, operand);</span>
        }
<span class="fc" id="L680">    }</span>

    public void visitVarInsn(final int opcode, final int var) {
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L684" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L686">                currentBlock.frame.execute(opcode, var, null, null);</span>
            } else {
                // updates current and max stack sizes
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">                if (opcode == Opcodes.RET) {</span>
                    // no stack change, but end of current block (no successor)
<span class="nc" id="L691">                    currentBlock.status |= Label.RET;</span>
                    // save 'stackSize' here for future use
                    // (see {@link #findSubroutineSuccessors})
<span class="nc" id="L694">                    currentBlock.inputStackTop = stackSize;</span>
<span class="nc" id="L695">                    noSuccessor();</span>
                } else { // xLOAD or xSTORE
<span class="fc" id="L697">                    int size = stackSize + Frame.SIZE[opcode];</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">                    if (size &gt; maxStackSize) {</span>
<span class="fc" id="L699">                        maxStackSize = size;</span>
                    }
<span class="fc" id="L701">                    stackSize = size;</span>
                }
            }
        }
<span class="fc bfc" id="L705" title="All 2 branches covered.">        if (compute != NOTHING) {</span>
            // updates max locals
            int n;
<span class="pc bpc" id="L708" title="2 of 8 branches missed.">            if (opcode == Opcodes.LLOAD || opcode == Opcodes.DLOAD</span>
                    || opcode == Opcodes.LSTORE || opcode == Opcodes.DSTORE)
            {
<span class="fc" id="L711">                n = var + 2;</span>
            } else {
<span class="fc" id="L713">                n = var + 1;</span>
            }
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">            if (n &gt; maxLocals) {</span>
<span class="nc" id="L716">                maxLocals = n;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="pc bpc" id="L720" title="1 of 4 branches missed.">        if (var &lt; 4 &amp;&amp; opcode != Opcodes.RET) {</span>
            int opt;
<span class="fc bfc" id="L722" title="All 2 branches covered.">            if (opcode &lt; Opcodes.ISTORE) {</span>
                /* ILOAD_0 */
<span class="fc" id="L724">                opt = 26 + ((opcode - Opcodes.ILOAD) &lt;&lt; 2) + var;</span>
            } else {
                /* ISTORE_0 */
<span class="fc" id="L727">                opt = 59 + ((opcode - Opcodes.ISTORE) &lt;&lt; 2) + var;</span>
            }
<span class="fc" id="L729">            code.putByte(opt);</span>
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">        } else if (var &gt;= 256) {</span>
<span class="nc" id="L731">            code.putByte(196 /* WIDE */).put12(opcode, var);</span>
        } else {
<span class="fc" id="L733">            code.put11(opcode, var);</span>
        }
<span class="pc bpc" id="L735" title="3 of 6 branches missed.">        if (opcode &gt;= Opcodes.ISTORE &amp;&amp; compute == FRAMES &amp;&amp; handlerCount &gt; 0) {</span>
<span class="nc" id="L736">            visitLabel(new Label());</span>
        }
<span class="fc" id="L738">    }</span>

    public void visitTypeInsn(final int opcode, final String type) {
<span class="fc" id="L741">        Item i = cw.newClassItem(type);</span>
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L743" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L745">                currentBlock.frame.execute(opcode, code.length, cw, i);</span>
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">            } else if (opcode == Opcodes.NEW) {</span>
                // updates current and max stack sizes only if opcode == NEW
                // (no stack change for ANEWARRAY, CHECKCAST, INSTANCEOF)
<span class="fc" id="L749">                int size = stackSize + 1;</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">                if (size &gt; maxStackSize) {</span>
<span class="fc" id="L751">                    maxStackSize = size;</span>
                }
<span class="fc" id="L753">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc" id="L757">        code.put12(opcode, i.index);</span>
<span class="fc" id="L758">    }</span>

    public void visitFieldInsn(
        final int opcode,
        final String owner,
        final String name,
        final String desc)
    {
<span class="fc" id="L766">        Item i = cw.newFieldItem(owner, name, desc);</span>
        // Label currentBlock = this.currentBlock;
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L770">                currentBlock.frame.execute(opcode, 0, cw, i);</span>
            } else {
                int size;
                // computes the stack size variation
<span class="nc" id="L774">                char c = desc.charAt(0);</span>
<span class="nc bnc" id="L775" title="All 4 branches missed.">                switch (opcode) {</span>
                    case Opcodes.GETSTATIC:
<span class="nc bnc" id="L777" title="All 4 branches missed.">                        size = stackSize + (c == 'D' || c == 'J' ? 2 : 1);</span>
<span class="nc" id="L778">                        break;</span>
                    case Opcodes.PUTSTATIC:
<span class="nc bnc" id="L780" title="All 4 branches missed.">                        size = stackSize + (c == 'D' || c == 'J' ? -2 : -1);</span>
<span class="nc" id="L781">                        break;</span>
                    case Opcodes.GETFIELD:
<span class="nc bnc" id="L783" title="All 4 branches missed.">                        size = stackSize + (c == 'D' || c == 'J' ? 1 : 0);</span>
<span class="nc" id="L784">                        break;</span>
                    // case Constants.PUTFIELD:
                    default:
<span class="nc bnc" id="L787" title="All 4 branches missed.">                        size = stackSize + (c == 'D' || c == 'J' ? -3 : -2);</span>
                        break;
                }
                // updates current and max stack sizes
<span class="nc bnc" id="L791" title="All 2 branches missed.">                if (size &gt; maxStackSize) {</span>
<span class="nc" id="L792">                    maxStackSize = size;</span>
                }
<span class="nc" id="L794">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc" id="L798">        code.put12(opcode, i.index);</span>
<span class="fc" id="L799">    }</span>

    public void visitMethodInsn(
        final int opcode,
        final String owner,
        final String name,
        final String desc)
    {
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">        boolean itf = opcode == Opcodes.INVOKEINTERFACE;</span>
<span class="fc" id="L808">        Item i = cw.newMethodItem(owner, name, desc, itf);</span>
<span class="fc" id="L809">        int argSize = i.intVal;</span>
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L811" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L813">                currentBlock.frame.execute(opcode, 0, cw, i);</span>
            } else {
                /*
                 * computes the stack size variation. In order not to recompute
                 * several times this variation for the same Item, we use the
                 * intVal field of this item to store this variation, once it
                 * has been computed. More precisely this intVal field stores
                 * the sizes of the arguments and of the return value
                 * corresponding to desc.
                 */
<span class="fc bfc" id="L823" title="All 2 branches covered.">                if (argSize == 0) {</span>
                    // the above sizes have not been computed yet,
                    // so we compute them...
<span class="fc" id="L826">                    argSize = getArgumentsAndReturnSizes(desc);</span>
                    // ... and we save them in order
                    // not to recompute them in the future
<span class="fc" id="L829">                    i.intVal = argSize;</span>
                }
                int size;
<span class="fc bfc" id="L832" title="All 2 branches covered.">                if (opcode == Opcodes.INVOKESTATIC) {</span>
<span class="fc" id="L833">                    size = stackSize - (argSize &gt;&gt; 2) + (argSize &amp; 0x03) + 1;</span>
                } else {
<span class="fc" id="L835">                    size = stackSize - (argSize &gt;&gt; 2) + (argSize &amp; 0x03);</span>
                }
                // updates current and max stack sizes
<span class="pc bpc" id="L838" title="1 of 2 branches missed.">                if (size &gt; maxStackSize) {</span>
<span class="nc" id="L839">                    maxStackSize = size;</span>
                }
<span class="fc" id="L841">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="pc bpc" id="L845" title="1 of 2 branches missed.">        if (itf) {</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">            if (argSize == 0) {</span>
<span class="nc" id="L847">                argSize = getArgumentsAndReturnSizes(desc);</span>
<span class="nc" id="L848">                i.intVal = argSize;</span>
            }
<span class="nc" id="L850">            code.put12(Opcodes.INVOKEINTERFACE, i.index).put11(argSize &gt;&gt; 2, 0);</span>
        } else {
<span class="fc" id="L852">            code.put12(opcode, i.index);</span>
        }
<span class="fc" id="L854">    }</span>

    public void visitJumpInsn(final int opcode, final Label label) {
<span class="fc" id="L857">        Label nextInsn = null;</span>
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L859" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L861">                currentBlock.frame.execute(opcode, 0, null, null);</span>
                // 'label' is the target of a jump instruction
<span class="nc" id="L863">                label.getFirst().status |= Label.TARGET;</span>
                // adds 'label' as a successor of this basic block
<span class="nc" id="L865">                addSuccessor(Edge.NORMAL, label);</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">                if (opcode != Opcodes.GOTO) {</span>
                    // creates a Label for the next basic block
<span class="nc" id="L868">                    nextInsn = new Label();</span>
                }
            } else {
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">                if (opcode == Opcodes.JSR) {</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">                    if ((label.status &amp; Label.SUBROUTINE) == 0) {</span>
<span class="nc" id="L873">                        label.status |= Label.SUBROUTINE;</span>
<span class="nc" id="L874">                        ++subroutines;</span>
                    }
<span class="nc" id="L876">                    currentBlock.status |= Label.JSR;</span>
<span class="nc" id="L877">                    addSuccessor(stackSize + 1, label);</span>
                    // creates a Label for the next basic block
<span class="nc" id="L879">                    nextInsn = new Label();</span>
                    /*
                     * note that, by construction in this method, a JSR block
                     * has at least two successors in the control flow graph:
                     * the first one leads the next instruction after the JSR,
                     * while the second one leads to the JSR target.
                     */
                } else {
                    // updates current stack size (max stack size unchanged
                    // because stack size variation always negative in this
                    // case)
<span class="fc" id="L890">                    stackSize += Frame.SIZE[opcode];</span>
<span class="fc" id="L891">                    addSuccessor(stackSize, label);</span>
                }
            }
        }
        // adds the instruction to the bytecode of the method
<span class="pc bpc" id="L896" title="1 of 4 branches missed.">        if ((label.status &amp; Label.RESOLVED) != 0</span>
                &amp;&amp; label.position - code.length &lt; Short.MIN_VALUE)
        {
            /*
             * case of a backward jump with an offset &lt; -32768. In this case we
             * automatically replace GOTO with GOTO_W, JSR with JSR_W and IFxxx
             * &lt;l&gt; with IFNOTxxx &lt;l'&gt; GOTO_W &lt;l&gt;, where IFNOTxxx is the
             * &quot;opposite&quot; opcode of IFxxx (i.e., IFNE for IFEQ) and where &lt;l'&gt;
             * designates the instruction just after the GOTO_W.
             */
<span class="nc bnc" id="L906" title="All 2 branches missed.">            if (opcode == Opcodes.GOTO) {</span>
<span class="nc" id="L907">                code.putByte(200); // GOTO_W</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">            } else if (opcode == Opcodes.JSR) {</span>
<span class="nc" id="L909">                code.putByte(201); // JSR_W</span>
            } else {
                // if the IF instruction is transformed into IFNOT GOTO_W the
                // next instruction becomes the target of the IFNOT instruction
<span class="nc bnc" id="L913" title="All 2 branches missed.">                if (nextInsn != null) {</span>
<span class="nc" id="L914">                    nextInsn.status |= Label.TARGET;</span>
                }
<span class="nc bnc" id="L916" title="All 2 branches missed.">                code.putByte(opcode &lt;= 166</span>
                        ? ((opcode + 1) ^ 1) - 1
                        : opcode ^ 1);
<span class="nc" id="L919">                code.putShort(8); // jump offset</span>
<span class="nc" id="L920">                code.putByte(200); // GOTO_W</span>
            }
<span class="nc" id="L922">            label.put(this, code, code.length - 1, true);</span>
        } else {
            /*
             * case of a backward jump with an offset &gt;= -32768, or of a forward
             * jump with, of course, an unknown offset. In these cases we store
             * the offset in 2 bytes (which will be increased in
             * resizeInstructions, if needed).
             */
<span class="fc" id="L930">            code.putByte(opcode);</span>
<span class="fc" id="L931">            label.put(this, code, code.length - 1, false);</span>
        }
<span class="fc bfc" id="L933" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">            if (nextInsn != null) {</span>
                // if the jump instruction is not a GOTO, the next instruction
                // is also a successor of this instruction. Calling visitLabel
                // adds the label of this next instruction as a successor of the
                // current block, and starts a new basic block
<span class="nc" id="L939">                visitLabel(nextInsn);</span>
            }
<span class="fc bfc" id="L941" title="All 2 branches covered.">            if (opcode == Opcodes.GOTO) {</span>
<span class="fc" id="L942">                noSuccessor();</span>
            }
        }
<span class="fc" id="L945">    }</span>

    public void visitLabel(final Label label) {
        // resolves previous forward references to label, if any
<span class="fc" id="L949">        resize |= label.resolve(this, code.length, code.data);</span>
        // updates currentBlock
<span class="fc bfc" id="L951" title="All 2 branches covered.">        if ((label.status &amp; Label.DEBUG) != 0) {</span>
<span class="fc" id="L952">            return;</span>
        }
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">        if (compute == FRAMES) {</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">            if (currentBlock != null) {</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">                if (label.position == currentBlock.position) {</span>
                    // successive labels, do not start a new basic block
<span class="nc" id="L958">                    currentBlock.status |= (label.status &amp; Label.TARGET);</span>
<span class="nc" id="L959">                    label.frame = currentBlock.frame;</span>
<span class="nc" id="L960">                    return;</span>
                }
                // ends current block (with one new successor)
<span class="nc" id="L963">                addSuccessor(Edge.NORMAL, label);</span>
            }
            // begins a new current block
<span class="nc" id="L966">            currentBlock = label;</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">            if (label.frame == null) {</span>
<span class="nc" id="L968">                label.frame = new Frame();</span>
<span class="nc" id="L969">                label.frame.owner = label;</span>
            }
            // updates the basic block list
<span class="nc bnc" id="L972" title="All 2 branches missed.">            if (previousBlock != null) {</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">                if (label.position == previousBlock.position) {</span>
<span class="nc" id="L974">                    previousBlock.status |= (label.status &amp; Label.TARGET);</span>
<span class="nc" id="L975">                    label.frame = previousBlock.frame;</span>
<span class="nc" id="L976">                    currentBlock = previousBlock;</span>
<span class="nc" id="L977">                    return;</span>
                }
<span class="nc" id="L979">                previousBlock.successor = label;</span>
            }
<span class="nc" id="L981">            previousBlock = label;</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">        } else if (compute == MAXS) {</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">            if (currentBlock != null) {</span>
                // ends current block (with one new successor)
<span class="fc" id="L985">                currentBlock.outputStackMax = maxStackSize;</span>
<span class="fc" id="L986">                addSuccessor(stackSize, label);</span>
            }
            // begins a new current block
<span class="fc" id="L989">            currentBlock = label;</span>
            // resets the relative current and max stack sizes
<span class="fc" id="L991">            stackSize = 0;</span>
<span class="fc" id="L992">            maxStackSize = 0;</span>
            // updates the basic block list
<span class="fc bfc" id="L994" title="All 2 branches covered.">            if (previousBlock != null) {</span>
<span class="fc" id="L995">                previousBlock.successor = label;</span>
            }
<span class="fc" id="L997">            previousBlock = label;</span>
        }
<span class="fc" id="L999">    }</span>

    public void visitLdcInsn(final Object cst) {
<span class="fc" id="L1002">        Item i = cw.newConstItem(cst);</span>
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L1004" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="pc bpc" id="L1005" title="1 of 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L1006">                currentBlock.frame.execute(Opcodes.LDC, 0, cw, i);</span>
            } else {
                int size;
                // computes the stack size variation
<span class="pc bpc" id="L1010" title="2 of 4 branches missed.">                if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE)</span>
                {
<span class="nc" id="L1012">                    size = stackSize + 2;</span>
                } else {
<span class="fc" id="L1014">                    size = stackSize + 1;</span>
                }
                // updates current and max stack sizes
<span class="fc bfc" id="L1017" title="All 2 branches covered.">                if (size &gt; maxStackSize) {</span>
<span class="fc" id="L1018">                    maxStackSize = size;</span>
                }
<span class="fc" id="L1020">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc" id="L1024">        int index = i.index;</span>
<span class="pc bpc" id="L1025" title="1 of 4 branches missed.">        if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {</span>
<span class="fc" id="L1026">            code.put12(20 /* LDC2_W */, index);</span>
<span class="fc bfc" id="L1027" title="All 2 branches covered.">        } else if (index &gt;= 256) {</span>
<span class="fc" id="L1028">            code.put12(19 /* LDC_W */, index);</span>
        } else {
<span class="fc" id="L1030">            code.put11(Opcodes.LDC, index);</span>
        }
<span class="fc" id="L1032">    }</span>

    public void visitIincInsn(final int var, final int increment) {
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L1037">                currentBlock.frame.execute(Opcodes.IINC, var, null, null);</span>
            }
        }
<span class="pc bpc" id="L1040" title="1 of 2 branches missed.">        if (compute != NOTHING) {</span>
            // updates max locals
<span class="nc" id="L1042">            int n = var + 1;</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">            if (n &gt; maxLocals) {</span>
<span class="nc" id="L1044">                maxLocals = n;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="pc bpc" id="L1048" title="3 of 6 branches missed.">        if ((var &gt; 255) || (increment &gt; 127) || (increment &lt; -128)) {</span>
<span class="nc" id="L1049">            code.putByte(196 /* WIDE */)</span>
<span class="nc" id="L1050">                    .put12(Opcodes.IINC, var)</span>
<span class="nc" id="L1051">                    .putShort(increment);</span>
        } else {
<span class="fc" id="L1053">            code.putByte(Opcodes.IINC).put11(var, increment);</span>
        }
<span class="fc" id="L1055">    }</span>

    public void visitTableSwitchInsn(
        final int min,
        final int max,
        final Label dflt,
        final Label[] labels)
    {
        // adds the instruction to the bytecode of the method
<span class="fc" id="L1064">        int source = code.length;</span>
<span class="fc" id="L1065">        code.putByte(Opcodes.TABLESWITCH);</span>
<span class="fc" id="L1066">        code.length += (4 - code.length % 4) % 4;</span>
<span class="fc" id="L1067">        dflt.put(this, code, source, true);</span>
<span class="fc" id="L1068">        code.putInt(min).putInt(max);</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="fc" id="L1070">            labels[i].put(this, code, source, true);</span>
        }
        // updates currentBlock
<span class="fc" id="L1073">        visitSwitchInsn(dflt, labels);</span>
<span class="fc" id="L1074">    }</span>

    public void visitLookupSwitchInsn(
        final Label dflt,
        final int[] keys,
        final Label[] labels)
    {
        // adds the instruction to the bytecode of the method
<span class="fc" id="L1082">        int source = code.length;</span>
<span class="fc" id="L1083">        code.putByte(Opcodes.LOOKUPSWITCH);</span>
<span class="fc" id="L1084">        code.length += (4 - code.length % 4) % 4;</span>
<span class="fc" id="L1085">        dflt.put(this, code, source, true);</span>
<span class="fc" id="L1086">        code.putInt(labels.length);</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">        for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="fc" id="L1088">            code.putInt(keys[i]);</span>
<span class="fc" id="L1089">            labels[i].put(this, code, source, true);</span>
        }
        // updates currentBlock
<span class="fc" id="L1092">        visitSwitchInsn(dflt, labels);</span>
<span class="fc" id="L1093">    }</span>

    private void visitSwitchInsn(final Label dflt, final Label[] labels) {
        // Label currentBlock = this.currentBlock;
<span class="pc bpc" id="L1097" title="1 of 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L1099">                currentBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);</span>
                // adds current block successors
<span class="nc" id="L1101">                addSuccessor(Edge.NORMAL, dflt);</span>
<span class="nc" id="L1102">                dflt.getFirst().status |= Label.TARGET;</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">                for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="nc" id="L1104">                    addSuccessor(Edge.NORMAL, labels[i]);</span>
<span class="nc" id="L1105">                    labels[i].getFirst().status |= Label.TARGET;</span>
                }
            } else {
                // updates current stack size (max stack size unchanged)
<span class="nc" id="L1109">                --stackSize;</span>
                // adds current block successors
<span class="nc" id="L1111">                addSuccessor(stackSize, dflt);</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">                for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="nc" id="L1113">                    addSuccessor(stackSize, labels[i]);</span>
                }
            }
            // ends current block
<span class="nc" id="L1117">            noSuccessor();</span>
        }
<span class="fc" id="L1119">    }</span>

    public void visitMultiANewArrayInsn(final String desc, final int dims) {
<span class="nc" id="L1122">        Item i = cw.newClassItem(desc);</span>
        // Label currentBlock = this.currentBlock;
<span class="nc bnc" id="L1124" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L1126">                currentBlock.frame.execute(Opcodes.MULTIANEWARRAY, dims, cw, i);</span>
            } else {
                // updates current stack size (max stack size unchanged because
                // stack size variation always negative or null)
<span class="nc" id="L1130">                stackSize += 1 - dims;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="nc" id="L1134">        code.put12(Opcodes.MULTIANEWARRAY, i.index).putByte(dims);</span>
<span class="nc" id="L1135">    }</span>

    public void visitTryCatchBlock(
        final Label start,
        final Label end,
        final Label handler,
        final String type)
    {
<span class="nc" id="L1143">        ++handlerCount;</span>
<span class="nc" id="L1144">        Handler h = new Handler();</span>
<span class="nc" id="L1145">        h.start = start;</span>
<span class="nc" id="L1146">        h.end = end;</span>
<span class="nc" id="L1147">        h.handler = handler;</span>
<span class="nc" id="L1148">        h.desc = type;</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">        h.type = type != null ? cw.newClass(type) : 0;</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">        if (lastHandler == null) {</span>
<span class="nc" id="L1151">            firstHandler = h;</span>
        } else {
<span class="nc" id="L1153">            lastHandler.next = h;</span>
        }
<span class="nc" id="L1155">        lastHandler = h;</span>
<span class="nc" id="L1156">    }</span>

    public void visitLocalVariable(
        final String name,
        final String desc,
        final String signature,
        final Label start,
        final Label end,
        final int index)
    {
<span class="pc bpc" id="L1166" title="1 of 2 branches missed.">        if (signature != null) {</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">            if (localVarType == null) {</span>
<span class="nc" id="L1168">                localVarType = new ByteVector();</span>
            }
<span class="nc" id="L1170">            ++localVarTypeCount;</span>
<span class="nc" id="L1171">            localVarType.putShort(start.position)</span>
<span class="nc" id="L1172">                    .putShort(end.position - start.position)</span>
<span class="nc" id="L1173">                    .putShort(cw.newUTF8(name))</span>
<span class="nc" id="L1174">                    .putShort(cw.newUTF8(signature))</span>
<span class="nc" id="L1175">                    .putShort(index);</span>
        }
<span class="fc bfc" id="L1177" title="All 2 branches covered.">        if (localVar == null) {</span>
<span class="fc" id="L1178">            localVar = new ByteVector();</span>
        }
<span class="fc" id="L1180">        ++localVarCount;</span>
<span class="fc" id="L1181">        localVar.putShort(start.position)</span>
<span class="fc" id="L1182">                .putShort(end.position - start.position)</span>
<span class="fc" id="L1183">                .putShort(cw.newUTF8(name))</span>
<span class="fc" id="L1184">                .putShort(cw.newUTF8(desc))</span>
<span class="fc" id="L1185">                .putShort(index);</span>
<span class="pc bpc" id="L1186" title="1 of 2 branches missed.">        if (compute != NOTHING) {</span>
            // updates max locals
<span class="nc" id="L1188">            char c = desc.charAt(0);</span>
<span class="nc bnc" id="L1189" title="All 4 branches missed.">            int n = index + (c == 'J' || c == 'D' ? 2 : 1);</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">            if (n &gt; maxLocals) {</span>
<span class="nc" id="L1191">                maxLocals = n;</span>
            }
        }
<span class="fc" id="L1194">    }</span>

    public void visitLineNumber(final int line, final Label start) {
<span class="fc bfc" id="L1197" title="All 2 branches covered.">        if (lineNumber == null) {</span>
<span class="fc" id="L1198">            lineNumber = new ByteVector();</span>
        }
<span class="fc" id="L1200">        ++lineNumberCount;</span>
<span class="fc" id="L1201">        lineNumber.putShort(start.position);</span>
<span class="fc" id="L1202">        lineNumber.putShort(line);</span>
<span class="fc" id="L1203">    }</span>

    public void visitMaxs(final int maxStack, final int maxLocals) {
<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">        if (ClassReader.FRAMES &amp;&amp; compute == FRAMES) {</span>
            // completes the control flow graph with exception handler blocks
<span class="nc" id="L1208">            Handler handler = firstHandler;</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">            while (handler != null) {</span>
<span class="nc" id="L1210">                Label l = handler.start.getFirst();</span>
<span class="nc" id="L1211">                Label h = handler.handler.getFirst();</span>
<span class="nc" id="L1212">                Label e = handler.end.getFirst();</span>
                // computes the kind of the edges to 'h'
<span class="nc bnc" id="L1214" title="All 2 branches missed.">                String t = handler.desc == null</span>
                        ? &quot;java/lang/Throwable&quot;
                        : handler.desc;
<span class="nc" id="L1217">                int kind = Frame.OBJECT | cw.addType(t);</span>
                // h is an exception handler
<span class="nc" id="L1219">                h.status |= Label.TARGET;</span>
                // adds 'h' as a successor of labels between 'start' and 'end'
<span class="nc bnc" id="L1221" title="All 2 branches missed.">                while (l != e) {</span>
                    // creates an edge to 'h'
<span class="nc" id="L1223">                    Edge b = new Edge();</span>
<span class="nc" id="L1224">                    b.info = kind;</span>
<span class="nc" id="L1225">                    b.successor = h;</span>
                    // adds it to the successors of 'l'
<span class="nc" id="L1227">                    b.next = l.successors;</span>
<span class="nc" id="L1228">                    l.successors = b;</span>
                    // goes to the next label
<span class="nc" id="L1230">                    l = l.successor;</span>
<span class="nc" id="L1231">                }</span>
<span class="nc" id="L1232">                handler = handler.next;</span>
<span class="nc" id="L1233">            }</span>

            // creates and visits the first (implicit) frame
<span class="nc" id="L1236">            Frame f = labels.frame;</span>
<span class="nc" id="L1237">            Type[] args = Type.getArgumentTypes(descriptor);</span>
<span class="nc" id="L1238">            f.initInputFrame(cw, access, args, this.maxLocals);</span>
<span class="nc" id="L1239">            visitFrame(f);</span>

            /*
             * fix point algorithm: mark the first basic block as 'changed'
             * (i.e. put it in the 'changed' list) and, while there are changed
             * basic blocks, choose one, mark it as unchanged, and update its
             * successors (which can be changed in the process).
             */
<span class="nc" id="L1247">            int max = 0;</span>
<span class="nc" id="L1248">            Label changed = labels;</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">            while (changed != null) {</span>
                // removes a basic block from the list of changed basic blocks
<span class="nc" id="L1251">                Label l = changed;</span>
<span class="nc" id="L1252">                changed = changed.next;</span>
<span class="nc" id="L1253">                l.next = null;</span>
<span class="nc" id="L1254">                f = l.frame;</span>
                // a reacheable jump target must be stored in the stack map
<span class="nc bnc" id="L1256" title="All 2 branches missed.">                if ((l.status &amp; Label.TARGET) != 0) {</span>
<span class="nc" id="L1257">                    l.status |= Label.STORE;</span>
                }
                // all visited labels are reacheable, by definition
<span class="nc" id="L1260">                l.status |= Label.REACHABLE;</span>
                // updates the (absolute) maximum stack size
<span class="nc" id="L1262">                int blockMax = f.inputStack.length + l.outputStackMax;</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">                if (blockMax &gt; max) {</span>
<span class="nc" id="L1264">                    max = blockMax;</span>
                }
                // updates the successors of the current basic block
<span class="nc" id="L1267">                Edge e = l.successors;</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">                while (e != null) {</span>
<span class="nc" id="L1269">                    Label n = e.successor.getFirst();</span>
<span class="nc" id="L1270">                    boolean change = f.merge(cw, n.frame, e.info);</span>
<span class="nc bnc" id="L1271" title="All 4 branches missed.">                    if (change &amp;&amp; n.next == null) {</span>
                        // if n has changed and is not already in the 'changed'
                        // list, adds it to this list
<span class="nc" id="L1274">                        n.next = changed;</span>
<span class="nc" id="L1275">                        changed = n;</span>
                    }
<span class="nc" id="L1277">                    e = e.next;</span>
<span class="nc" id="L1278">                }</span>
<span class="nc" id="L1279">            }</span>
<span class="nc" id="L1280">            this.maxStack = max;</span>

            // visits all the frames that must be stored in the stack map
<span class="nc" id="L1283">            Label l = labels;</span>
<span class="nc bnc" id="L1284" title="All 2 branches missed.">            while (l != null) {</span>
<span class="nc" id="L1285">                f = l.frame;</span>
<span class="nc bnc" id="L1286" title="All 2 branches missed.">                if ((l.status &amp; Label.STORE) != 0) {</span>
<span class="nc" id="L1287">                    visitFrame(f);</span>
                }
<span class="nc bnc" id="L1289" title="All 2 branches missed.">                if ((l.status &amp; Label.REACHABLE) == 0) {</span>
                    // finds start and end of dead basic block
<span class="nc" id="L1291">                    Label k = l.successor;</span>
<span class="nc" id="L1292">                    int start = l.position;</span>
<span class="nc bnc" id="L1293" title="All 2 branches missed.">                    int end = (k == null ? code.length : k.position) - 1;</span>
                    // if non empty basic block
<span class="nc bnc" id="L1295" title="All 2 branches missed.">                    if (end &gt;= start) {</span>
                        // replaces instructions with NOP ... NOP ATHROW
<span class="nc bnc" id="L1297" title="All 2 branches missed.">                        for (int i = start; i &lt; end; ++i) {</span>
<span class="nc" id="L1298">                            code.data[i] = Opcodes.NOP;</span>
                        }
<span class="nc" id="L1300">                        code.data[end] = (byte) Opcodes.ATHROW;</span>
                        // emits a frame for this unreachable block
<span class="nc" id="L1302">                        startFrame(start, 0, 1);</span>
<span class="nc" id="L1303">                        frame[frameIndex++] = Frame.OBJECT</span>
<span class="nc" id="L1304">                                | cw.addType(&quot;java/lang/Throwable&quot;);</span>
<span class="nc" id="L1305">                        endFrame();</span>
                    }
                }
<span class="nc" id="L1308">                l = l.successor;</span>
            }
<span class="pc bfc" id="L1310" title="All 2 branches covered.">        } else if (compute == MAXS) {</span>
            // completes the control flow graph with exception handler blocks
<span class="fc" id="L1312">            Handler handler = firstHandler;</span>
<span class="pc bpc" id="L1313" title="1 of 2 branches missed.">            while (handler != null) {</span>
<span class="nc" id="L1314">                Label l = handler.start;</span>
<span class="nc" id="L1315">                Label h = handler.handler;</span>
<span class="nc" id="L1316">                Label e = handler.end;</span>
                // adds 'h' as a successor of labels between 'start' and 'end'
<span class="nc bnc" id="L1318" title="All 2 branches missed.">                while (l != e) {</span>
                    // creates an edge to 'h'
<span class="nc" id="L1320">                    Edge b = new Edge();</span>
<span class="nc" id="L1321">                    b.info = Edge.EXCEPTION;</span>
<span class="nc" id="L1322">                    b.successor = h;</span>
                    // adds it to the successors of 'l'
<span class="nc bnc" id="L1324" title="All 2 branches missed.">                    if ((l.status &amp; Label.JSR) == 0) {</span>
<span class="nc" id="L1325">                        b.next = l.successors;</span>
<span class="nc" id="L1326">                        l.successors = b;</span>
                    } else {
                        // if l is a JSR block, adds b after the first two edges
                        // to preserve the hypothesis about JSR block successors
                        // order (see {@link #visitJumpInsn})
<span class="nc" id="L1331">                        b.next = l.successors.next.next;</span>
<span class="nc" id="L1332">                        l.successors.next.next = b;</span>
                    }
                    // goes to the next label
<span class="nc" id="L1335">                    l = l.successor;</span>
<span class="nc" id="L1336">                }</span>
<span class="nc" id="L1337">                handler = handler.next;</span>
<span class="nc" id="L1338">            }</span>

<span class="pc bpc" id="L1340" title="1 of 2 branches missed.">            if (subroutines &gt; 0) {</span>
                // completes the control flow graph with the RET successors
                /*
                 * first step: finds the subroutines. This step determines, for
                 * each basic block, to which subroutine(s) it belongs.
                 */
                // finds the basic blocks that belong to the &quot;main&quot; subroutine
<span class="nc" id="L1347">                int id = 0;</span>
<span class="nc" id="L1348">                labels.visitSubroutine(null, 1, subroutines);</span>
                // finds the basic blocks that belong to the real subroutines
<span class="nc" id="L1350">                Label l = labels;</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">                while (l != null) {</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">                    if ((l.status &amp; Label.JSR) != 0) {</span>
                        // the subroutine is defined by l's TARGET, not by l
<span class="nc" id="L1354">                        Label subroutine = l.successors.next.successor;</span>
                        // if this subroutine has not been visited yet...
<span class="nc bnc" id="L1356" title="All 2 branches missed.">                        if ((subroutine.status &amp; Label.VISITED) == 0) {</span>
                            // ...assigns it a new id and finds its basic blocks
<span class="nc" id="L1358">                            id += 1;</span>
<span class="nc" id="L1359">                            subroutine.visitSubroutine(null, (id / 32L) &lt;&lt; 32</span>
                                    | (1L &lt;&lt; (id % 32)), subroutines);
                        }
                    }
<span class="nc" id="L1363">                    l = l.successor;</span>
                }
                // second step: finds the successors of RET blocks
<span class="nc" id="L1366">                l = labels;</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">                while (l != null) {</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">                    if ((l.status &amp; Label.JSR) != 0) {</span>
<span class="nc" id="L1369">                        Label L = labels;</span>
<span class="nc bnc" id="L1370" title="All 2 branches missed.">                        while (L != null) {</span>
<span class="nc" id="L1371">                            L.status &amp;= ~Label.VISITED;</span>
<span class="nc" id="L1372">                            L = L.successor;</span>
                        }
                        // the subroutine is defined by l's TARGET, not by l
<span class="nc" id="L1375">                        Label subroutine = l.successors.next.successor;</span>
<span class="nc" id="L1376">                        subroutine.visitSubroutine(l, 0, subroutines);</span>
                    }
<span class="nc" id="L1378">                    l = l.successor;</span>
                }
            }

            /*
             * control flow analysis algorithm: while the block stack is not
             * empty, pop a block from this stack, update the max stack size,
             * compute the true (non relative) begin stack size of the
             * successors of this block, and push these successors onto the
             * stack (unless they have already been pushed onto the stack).
             * Note: by hypothesis, the {@link Label#inputStackTop} of the
             * blocks in the block stack are the true (non relative) beginning
             * stack sizes of these blocks.
             */
<span class="fc" id="L1392">            int max = 0;</span>
<span class="fc" id="L1393">            Label stack = labels;</span>
<span class="fc bfc" id="L1394" title="All 2 branches covered.">            while (stack != null) {</span>
                // pops a block from the stack
<span class="fc" id="L1396">                Label l = stack;</span>
<span class="fc" id="L1397">                stack = stack.next;</span>
                // computes the true (non relative) max stack size of this block
<span class="fc" id="L1399">                int start = l.inputStackTop;</span>
<span class="fc" id="L1400">                int blockMax = start + l.outputStackMax;</span>
                // updates the global max stack size
<span class="fc bfc" id="L1402" title="All 2 branches covered.">                if (blockMax &gt; max) {</span>
<span class="fc" id="L1403">                    max = blockMax;</span>
                }
                // analyzes the successors of the block
<span class="fc" id="L1406">                Edge b = l.successors;</span>
<span class="pc bpc" id="L1407" title="1 of 2 branches missed.">                if ((l.status &amp; Label.JSR) != 0) {</span>
                    // ignores the first edge of JSR blocks (virtual successor)
<span class="nc" id="L1409">                    b = b.next;</span>
                }
<span class="fc bfc" id="L1411" title="All 2 branches covered.">                while (b != null) {</span>
<span class="fc" id="L1412">                    l = b.successor;</span>
                    // if this successor has not already been pushed...
<span class="fc bfc" id="L1414" title="All 2 branches covered.">                    if ((l.status &amp; Label.PUSHED) == 0) {</span>
                        // computes its true beginning stack size...
<span class="pc bpc" id="L1416" title="1 of 2 branches missed.">                        l.inputStackTop = b.info == Edge.EXCEPTION ? 1 : start</span>
                                + b.info;
                        // ...and pushes it onto the stack
<span class="fc" id="L1419">                        l.status |= Label.PUSHED;</span>
<span class="fc" id="L1420">                        l.next = stack;</span>
<span class="fc" id="L1421">                        stack = l;</span>
                    }
<span class="fc" id="L1423">                    b = b.next;</span>
                }
<span class="fc" id="L1425">            }</span>
<span class="fc" id="L1426">            this.maxStack = max;</span>
<span class="fc" id="L1427">        } else {</span>
<span class="fc" id="L1428">            this.maxStack = maxStack;</span>
<span class="fc" id="L1429">            this.maxLocals = maxLocals;</span>
        }
<span class="fc" id="L1431">    }</span>

    public void visitEnd() {
<span class="fc" id="L1434">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: control flow analysis algorithm
    // ------------------------------------------------------------------------

    /**
     * Computes the size of the arguments and of the return value of a method.
     * 
     * @param desc the descriptor of a method.
     * @return the size of the arguments of the method (plus one for the
     *         implicit this argument), argSize, and the size of its return
     *         value, retSize, packed into a single int i =
     *         &lt;tt&gt;(argSize &lt;&lt; 2) | retSize&lt;/tt&gt; (argSize is therefore equal
     *         to &lt;tt&gt;i &gt;&gt; 2&lt;/tt&gt;, and retSize to &lt;tt&gt;i &amp; 0x03&lt;/tt&gt;).
     */
    static int getArgumentsAndReturnSizes(final String desc) {
<span class="fc" id="L1451">        int n = 1;</span>
<span class="fc" id="L1452">        int c = 1;</span>
        while (true) {
<span class="fc" id="L1454">            char car = desc.charAt(c++);</span>
<span class="fc bfc" id="L1455" title="All 2 branches covered.">            if (car == ')') {</span>
<span class="fc" id="L1456">                car = desc.charAt(c);</span>
<span class="pc bpc" id="L1457" title="2 of 6 branches missed.">                return n &lt;&lt; 2</span>
                        | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));
<span class="fc bfc" id="L1459" title="All 2 branches covered.">            } else if (car == 'L') {</span>
<span class="fc bfc" id="L1460" title="All 2 branches covered.">                while (desc.charAt(c++) != ';') {</span>
                }
<span class="fc" id="L1462">                n += 1;</span>
<span class="pc bpc" id="L1463" title="1 of 2 branches missed.">            } else if (car == '[') {</span>
<span class="nc bnc" id="L1464" title="All 2 branches missed.">                while ((car = desc.charAt(c)) == '[') {</span>
<span class="nc" id="L1465">                    ++c;</span>
                }
<span class="nc bnc" id="L1467" title="All 4 branches missed.">                if (car == 'D' || car == 'J') {</span>
<span class="nc" id="L1468">                    n -= 1;</span>
                }
<span class="pc bpc" id="L1470" title="1 of 4 branches missed.">            } else if (car == 'D' || car == 'J') {</span>
<span class="fc" id="L1471">                n += 2;</span>
            } else {
<span class="fc" id="L1473">                n += 1;</span>
            }
<span class="fc" id="L1475">        }</span>
    }

    /**
     * Adds a successor to the {@link #currentBlock currentBlock} block.
     * 
     * @param info information about the control flow edge to be added.
     * @param successor the successor block to be added to the current block.
     */
    private void addSuccessor(final int info, final Label successor) {
        // creates and initializes an Edge object...
<span class="fc" id="L1486">        Edge b = new Edge();</span>
<span class="fc" id="L1487">        b.info = info;</span>
<span class="fc" id="L1488">        b.successor = successor;</span>
        // ...and adds it to the successor list of the currentBlock block
<span class="fc" id="L1490">        b.next = currentBlock.successors;</span>
<span class="fc" id="L1491">        currentBlock.successors = b;</span>
<span class="fc" id="L1492">    }</span>

    /**
     * Ends the current basic block. This method must be used in the case where
     * the current basic block does not have any successor.
     */
    private void noSuccessor() {
<span class="pc bpc" id="L1499" title="1 of 2 branches missed.">        if (compute == FRAMES) {</span>
<span class="nc" id="L1500">            Label l = new Label();</span>
<span class="nc" id="L1501">            l.frame = new Frame();</span>
<span class="nc" id="L1502">            l.frame.owner = l;</span>
<span class="nc" id="L1503">            l.resolve(this, code.length, code.data);</span>
<span class="nc" id="L1504">            previousBlock.successor = l;</span>
<span class="nc" id="L1505">            previousBlock = l;</span>
<span class="nc" id="L1506">        } else {</span>
<span class="fc" id="L1507">            currentBlock.outputStackMax = maxStackSize;</span>
        }
<span class="fc" id="L1509">        currentBlock = null;</span>
<span class="fc" id="L1510">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: stack map frames
    // ------------------------------------------------------------------------

    /**
     * Visits a frame that has been computed from scratch.
     * 
     * @param f the frame that must be visited.
     */
    private void visitFrame(final Frame f) {
        int i, t;
<span class="nc" id="L1523">        int nTop = 0;</span>
<span class="nc" id="L1524">        int nLocal = 0;</span>
<span class="nc" id="L1525">        int nStack = 0;</span>
<span class="nc" id="L1526">        int[] locals = f.inputLocals;</span>
<span class="nc" id="L1527">        int[] stacks = f.inputStack;</span>
        // computes the number of locals (ignores TOP types that are just after
        // a LONG or a DOUBLE, and all trailing TOP types)
<span class="nc bnc" id="L1530" title="All 2 branches missed.">        for (i = 0; i &lt; locals.length; ++i) {</span>
<span class="nc" id="L1531">            t = locals[i];</span>
<span class="nc bnc" id="L1532" title="All 2 branches missed.">            if (t == Frame.TOP) {</span>
<span class="nc" id="L1533">                ++nTop;</span>
            } else {
<span class="nc" id="L1535">                nLocal += nTop + 1;</span>
<span class="nc" id="L1536">                nTop = 0;</span>
            }
<span class="nc bnc" id="L1538" title="All 4 branches missed.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="nc" id="L1539">                ++i;</span>
            }
        }
        // computes the stack size (ignores TOP types that are just after
        // a LONG or a DOUBLE)
<span class="nc bnc" id="L1544" title="All 2 branches missed.">        for (i = 0; i &lt; stacks.length; ++i) {</span>
<span class="nc" id="L1545">            t = stacks[i];</span>
<span class="nc" id="L1546">            ++nStack;</span>
<span class="nc bnc" id="L1547" title="All 4 branches missed.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="nc" id="L1548">                ++i;</span>
            }
        }
        // visits the frame and its content
<span class="nc" id="L1552">        startFrame(f.owner.position, nLocal, nStack);</span>
<span class="nc bnc" id="L1553" title="All 2 branches missed.">        for (i = 0; nLocal &gt; 0; ++i, --nLocal) {</span>
<span class="nc" id="L1554">            t = locals[i];</span>
<span class="nc" id="L1555">            frame[frameIndex++] = t;</span>
<span class="nc bnc" id="L1556" title="All 4 branches missed.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="nc" id="L1557">                ++i;</span>
            }
        }
<span class="nc bnc" id="L1560" title="All 2 branches missed.">        for (i = 0; i &lt; stacks.length; ++i) {</span>
<span class="nc" id="L1561">            t = stacks[i];</span>
<span class="nc" id="L1562">            frame[frameIndex++] = t;</span>
<span class="nc bnc" id="L1563" title="All 4 branches missed.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="nc" id="L1564">                ++i;</span>
            }
        }
<span class="nc" id="L1567">        endFrame();</span>
<span class="nc" id="L1568">    }</span>

    /**
     * Starts the visit of a stack map frame.
     * 
     * @param offset the offset of the instruction to which the frame
     *        corresponds.
     * @param nLocal the number of local variables in the frame.
     * @param nStack the number of stack elements in the frame.
     */
    private void startFrame(final int offset, final int nLocal, final int nStack)
    {
<span class="fc" id="L1580">        int n = 3 + nLocal + nStack;</span>
<span class="pc bpc" id="L1581" title="3 of 4 branches missed.">        if (frame == null || frame.length &lt; n) {</span>
<span class="fc" id="L1582">            frame = new int[n];</span>
        }
<span class="fc" id="L1584">        frame[0] = offset;</span>
<span class="fc" id="L1585">        frame[1] = nLocal;</span>
<span class="fc" id="L1586">        frame[2] = nStack;</span>
<span class="fc" id="L1587">        frameIndex = 3;</span>
<span class="fc" id="L1588">    }</span>

    /**
     * Checks if the visit of the current frame {@link #frame} is finished, and
     * if yes, write it in the StackMapTable attribute.
     */
    private void endFrame() {
<span class="fc bfc" id="L1595" title="All 2 branches covered.">        if (previousFrame != null) { // do not write the first frame</span>
<span class="fc bfc" id="L1596" title="All 2 branches covered.">            if (stackMap == null) {</span>
<span class="fc" id="L1597">                stackMap = new ByteVector();</span>
            }
<span class="fc" id="L1599">            writeFrame();</span>
<span class="fc" id="L1600">            ++frameCount;</span>
        }
<span class="fc" id="L1602">        previousFrame = frame;</span>
<span class="fc" id="L1603">        frame = null;</span>
<span class="fc" id="L1604">    }</span>

    /**
     * Compress and writes the current frame {@link #frame} in the StackMapTable
     * attribute.
     */
    private void writeFrame() {
<span class="fc" id="L1611">        int clocalsSize = frame[1];</span>
<span class="fc" id="L1612">        int cstackSize = frame[2];</span>
<span class="pc bpc" id="L1613" title="1 of 2 branches missed.">        if ((cw.version &amp; 0xFFFF) &lt; Opcodes.V1_6) {</span>
<span class="nc" id="L1614">            stackMap.putShort(frame[0]).putShort(clocalsSize);</span>
<span class="nc" id="L1615">            writeFrameTypes(3, 3 + clocalsSize);</span>
<span class="nc" id="L1616">            stackMap.putShort(cstackSize);</span>
<span class="nc" id="L1617">            writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);</span>
<span class="nc" id="L1618">            return;</span>
        }
<span class="fc" id="L1620">        int localsSize = previousFrame[1];</span>
<span class="fc" id="L1621">        int type = FULL_FRAME;</span>
<span class="fc" id="L1622">        int k = 0;</span>
        int delta;
<span class="fc bfc" id="L1624" title="All 2 branches covered.">        if (frameCount == 0) {</span>
<span class="fc" id="L1625">            delta = frame[0];</span>
        } else {
<span class="fc" id="L1627">            delta = frame[0] - previousFrame[0] - 1;</span>
        }
<span class="fc bfc" id="L1629" title="All 2 branches covered.">        if (cstackSize == 0) {</span>
<span class="fc" id="L1630">            k = clocalsSize - localsSize;</span>
<span class="pc bpc" id="L1631" title="3 of 4 branches missed.">            switch (k) {</span>
                case -3:
                case -2:
                case -1:
<span class="nc" id="L1635">                    type = CHOP_FRAME;</span>
<span class="nc" id="L1636">                    localsSize = clocalsSize;</span>
<span class="nc" id="L1637">                    break;</span>
                case 0:
<span class="pc bpc" id="L1639" title="1 of 2 branches missed.">                    type = delta &lt; 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;</span>
<span class="fc" id="L1640">                    break;</span>
                case 1:
                case 2:
                case 3:
<span class="nc" id="L1644">                    type = APPEND_FRAME;</span>
<span class="fc" id="L1645">                    break;</span>
            }
<span class="pc bpc" id="L1647" title="2 of 4 branches missed.">        } else if (clocalsSize == localsSize &amp;&amp; cstackSize == 1) {</span>
<span class="pc bpc" id="L1648" title="1 of 2 branches missed.">            type = delta &lt; 63</span>
                    ? SAME_LOCALS_1_STACK_ITEM_FRAME
                    : SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;
        }
<span class="pc bpc" id="L1652" title="1 of 2 branches missed.">        if (type != FULL_FRAME) {</span>
            // verify if locals are the same
<span class="fc" id="L1654">            int l = 3;</span>
<span class="fc bfc" id="L1655" title="All 2 branches covered.">            for (int j = 0; j &lt; localsSize; j++) {</span>
<span class="pc bpc" id="L1656" title="1 of 2 branches missed.">                if (frame[l] != previousFrame[l]) {</span>
<span class="nc" id="L1657">                    type = FULL_FRAME;</span>
<span class="nc" id="L1658">                    break;</span>
                }
<span class="fc" id="L1660">                l++;</span>
            }
        }
<span class="pc bpc" id="L1663" title="5 of 7 branches missed.">        switch (type) {</span>
            case SAME_FRAME:
<span class="fc" id="L1665">                stackMap.putByte(delta);</span>
<span class="fc" id="L1666">                break;</span>
            case SAME_LOCALS_1_STACK_ITEM_FRAME:
<span class="fc" id="L1668">                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);</span>
<span class="fc" id="L1669">                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);</span>
<span class="fc" id="L1670">                break;</span>
            case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:
<span class="nc" id="L1672">                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)</span>
<span class="nc" id="L1673">                        .putShort(delta);</span>
<span class="nc" id="L1674">                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);</span>
<span class="nc" id="L1675">                break;</span>
            case SAME_FRAME_EXTENDED:
<span class="nc" id="L1677">                stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);</span>
<span class="nc" id="L1678">                break;</span>
            case CHOP_FRAME:
<span class="nc" id="L1680">                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);</span>
<span class="nc" id="L1681">                break;</span>
            case APPEND_FRAME:
<span class="nc" id="L1683">                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);</span>
<span class="nc" id="L1684">                writeFrameTypes(3 + localsSize, 3 + clocalsSize);</span>
<span class="nc" id="L1685">                break;</span>
            // case FULL_FRAME:
            default:
<span class="nc" id="L1688">                stackMap.putByte(FULL_FRAME)</span>
<span class="nc" id="L1689">                        .putShort(delta)</span>
<span class="nc" id="L1690">                        .putShort(clocalsSize);</span>
<span class="nc" id="L1691">                writeFrameTypes(3, 3 + clocalsSize);</span>
<span class="nc" id="L1692">                stackMap.putShort(cstackSize);</span>
<span class="nc" id="L1693">                writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);</span>
        }
<span class="fc" id="L1695">    }</span>

    /**
     * Writes some types of the current frame {@link #frame} into the
     * StackMapTableAttribute. This method converts types from the format used
     * in {@link Label} to the format used in StackMapTable attributes. In
     * particular, it converts type table indexes to constant pool indexes.
     * 
     * @param start index of the first type in {@link #frame} to write.
     * @param end index of last type in {@link #frame} to write (exclusive).
     */
    private void writeFrameTypes(final int start, final int end) {
<span class="fc bfc" id="L1707" title="All 2 branches covered.">        for (int i = start; i &lt; end; ++i) {</span>
<span class="fc" id="L1708">            int t = frame[i];</span>
<span class="fc" id="L1709">            int d = t &amp; Frame.DIM;</span>
<span class="pc bpc" id="L1710" title="1 of 2 branches missed.">            if (d == 0) {</span>
<span class="fc" id="L1711">                int v = t &amp; Frame.BASE_VALUE;</span>
<span class="pc bpc" id="L1712" title="2 of 3 branches missed.">                switch (t &amp; Frame.BASE_KIND) {</span>
                    case Frame.OBJECT:
<span class="nc" id="L1714">                        stackMap.putByte(7)</span>
<span class="nc" id="L1715">                                .putShort(cw.newClass(cw.typeTable[v].strVal1));</span>
<span class="nc" id="L1716">                        break;</span>
                    case Frame.UNINITIALIZED:
<span class="nc" id="L1718">                        stackMap.putByte(8).putShort(cw.typeTable[v].intVal);</span>
<span class="nc" id="L1719">                        break;</span>
                    default:
<span class="fc" id="L1721">                        stackMap.putByte(v);</span>
                }
<span class="fc" id="L1723">            } else {</span>
<span class="nc" id="L1724">                StringBuffer buf = new StringBuffer();</span>
<span class="nc" id="L1725">                d &gt;&gt;= 28;</span>
<span class="nc bnc" id="L1726" title="All 2 branches missed.">                while (d-- &gt; 0) {</span>
<span class="nc" id="L1727">                    buf.append('[');</span>
                }
<span class="nc bnc" id="L1729" title="All 2 branches missed.">                if ((t &amp; Frame.BASE_KIND) == Frame.OBJECT) {</span>
<span class="nc" id="L1730">                    buf.append('L');</span>
<span class="nc" id="L1731">                    buf.append(cw.typeTable[t &amp; Frame.BASE_VALUE].strVal1);</span>
<span class="nc" id="L1732">                    buf.append(';');</span>
                } else {
<span class="nc bnc" id="L1734" title="All 8 branches missed.">                    switch (t &amp; 0xF) {</span>
                        case 1:
<span class="nc" id="L1736">                            buf.append('I');</span>
<span class="nc" id="L1737">                            break;</span>
                        case 2:
<span class="nc" id="L1739">                            buf.append('F');</span>
<span class="nc" id="L1740">                            break;</span>
                        case 3:
<span class="nc" id="L1742">                            buf.append('D');</span>
<span class="nc" id="L1743">                            break;</span>
                        case 9:
<span class="nc" id="L1745">                            buf.append('Z');</span>
<span class="nc" id="L1746">                            break;</span>
                        case 10:
<span class="nc" id="L1748">                            buf.append('B');</span>
<span class="nc" id="L1749">                            break;</span>
                        case 11:
<span class="nc" id="L1751">                            buf.append('C');</span>
<span class="nc" id="L1752">                            break;</span>
                        case 12:
<span class="nc" id="L1754">                            buf.append('S');</span>
<span class="nc" id="L1755">                            break;</span>
                        default:
<span class="nc" id="L1757">                            buf.append('J');</span>
                    }
                }
<span class="nc" id="L1760">                stackMap.putByte(7).putShort(cw.newClass(buf.toString()));</span>
            }
        }
<span class="fc" id="L1763">    }</span>

    private void writeFrameType(final Object type) {
<span class="nc bnc" id="L1766" title="All 2 branches missed.">        if (type instanceof String) {</span>
<span class="nc" id="L1767">            stackMap.putByte(7).putShort(cw.newClass((String) type));</span>
<span class="nc bnc" id="L1768" title="All 2 branches missed.">        } else if (type instanceof Integer) {</span>
<span class="nc" id="L1769">            stackMap.putByte(((Integer) type).intValue());</span>
        } else {
<span class="nc" id="L1771">            stackMap.putByte(8).putShort(((Label) type).position);</span>
        }
<span class="nc" id="L1773">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: dump bytecode array
    // ------------------------------------------------------------------------

    /**
     * Returns the size of the bytecode of this method.
     * 
     * @return the size of the bytecode of this method.
     */
    final int getSize() {
<span class="pc bpc" id="L1785" title="1 of 2 branches missed.">        if (classReaderOffset != 0) {</span>
<span class="nc" id="L1786">            return 6 + classReaderLength;</span>
        }
<span class="pc bpc" id="L1788" title="1 of 2 branches missed.">        if (resize) {</span>
            // replaces the temporary jump opcodes introduced by Label.resolve.
            if (ClassReader.RESIZE) {
<span class="nc" id="L1791">                resizeInstructions();</span>
            } else {
                throw new RuntimeException(&quot;Method code too large!&quot;);
            }
        }
<span class="fc" id="L1796">        int size = 8;</span>
<span class="pc bpc" id="L1797" title="1 of 2 branches missed.">        if (code.length &gt; 0) {</span>
<span class="nc" id="L1798">            cw.newUTF8(&quot;Code&quot;);</span>
<span class="nc" id="L1799">            size += 18 + code.length + 8 * handlerCount;</span>
<span class="nc bnc" id="L1800" title="All 2 branches missed.">            if (localVar != null) {</span>
<span class="nc" id="L1801">                cw.newUTF8(&quot;LocalVariableTable&quot;);</span>
<span class="nc" id="L1802">                size += 8 + localVar.length;</span>
            }
<span class="nc bnc" id="L1804" title="All 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L1805">                cw.newUTF8(&quot;LocalVariableTypeTable&quot;);</span>
<span class="nc" id="L1806">                size += 8 + localVarType.length;</span>
            }
<span class="nc bnc" id="L1808" title="All 2 branches missed.">            if (lineNumber != null) {</span>
<span class="nc" id="L1809">                cw.newUTF8(&quot;LineNumberTable&quot;);</span>
<span class="nc" id="L1810">                size += 8 + lineNumber.length;</span>
            }
<span class="nc bnc" id="L1812" title="All 2 branches missed.">            if (stackMap != null) {</span>
<span class="nc bnc" id="L1813" title="All 2 branches missed.">                boolean zip = (cw.version &amp; 0xFFFF) &gt;= Opcodes.V1_6;</span>
<span class="nc bnc" id="L1814" title="All 2 branches missed.">                cw.newUTF8(zip ? &quot;StackMapTable&quot; : &quot;StackMap&quot;);</span>
<span class="nc" id="L1815">                size += 8 + stackMap.length;</span>
            }
<span class="nc bnc" id="L1817" title="All 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L1818">                size += cattrs.getSize(cw,</span>
                        code.data,
                        code.length,
                        maxStack,
                        maxLocals);
            }
        }
<span class="pc bpc" id="L1825" title="1 of 2 branches missed.">        if (exceptionCount &gt; 0) {</span>
<span class="fc" id="L1826">            cw.newUTF8(&quot;Exceptions&quot;);</span>
<span class="fc" id="L1827">            size += 8 + 2 * exceptionCount;</span>
        }
<span class="pc bpc" id="L1829" title="2 of 4 branches missed.">        if ((access &amp; Opcodes.ACC_SYNTHETIC) != 0</span>
                &amp;&amp; (cw.version &amp; 0xffff) &lt; Opcodes.V1_5)
        {
<span class="fc" id="L1832">            cw.newUTF8(&quot;Synthetic&quot;);</span>
<span class="fc" id="L1833">            size += 6;</span>
        }
<span class="pc bpc" id="L1835" title="1 of 2 branches missed.">        if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {</span>
<span class="fc" id="L1836">            cw.newUTF8(&quot;Deprecated&quot;);</span>
<span class="fc" id="L1837">            size += 6;</span>
        }
<span class="pc bpc" id="L1839" title="1 of 2 branches missed.">        if (ClassReader.SIGNATURES &amp;&amp; signature != null) {</span>
<span class="fc" id="L1840">            cw.newUTF8(&quot;Signature&quot;);</span>
<span class="fc" id="L1841">            cw.newUTF8(signature);</span>
<span class="fc" id="L1842">            size += 8;</span>
        }
<span class="pc bpc" id="L1844" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; annd != null) {</span>
<span class="nc" id="L1845">            cw.newUTF8(&quot;AnnotationDefault&quot;);</span>
<span class="nc" id="L1846">            size += 6 + annd.length;</span>
        }
<span class="pc bpc" id="L1848" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; anns != null) {</span>
<span class="nc" id="L1849">            cw.newUTF8(&quot;RuntimeVisibleAnnotations&quot;);</span>
<span class="nc" id="L1850">            size += 8 + anns.getSize();</span>
        }
<span class="pc bpc" id="L1852" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ianns != null) {</span>
<span class="nc" id="L1853">            cw.newUTF8(&quot;RuntimeInvisibleAnnotations&quot;);</span>
<span class="nc" id="L1854">            size += 8 + ianns.getSize();</span>
        }
<span class="pc bpc" id="L1856" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; panns != null) {</span>
<span class="nc" id="L1857">            cw.newUTF8(&quot;RuntimeVisibleParameterAnnotations&quot;);</span>
<span class="nc" id="L1858">            size += 7 + 2 * (panns.length - synthetics);</span>
<span class="nc bnc" id="L1859" title="All 2 branches missed.">            for (int i = panns.length - 1; i &gt;= synthetics; --i) {</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">                size += panns[i] == null ? 0 : panns[i].getSize();</span>
            }
        }
<span class="pc bpc" id="L1863" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ipanns != null) {</span>
<span class="nc" id="L1864">            cw.newUTF8(&quot;RuntimeInvisibleParameterAnnotations&quot;);</span>
<span class="nc" id="L1865">            size += 7 + 2 * (ipanns.length - synthetics);</span>
<span class="nc bnc" id="L1866" title="All 2 branches missed.">            for (int i = ipanns.length - 1; i &gt;= synthetics; --i) {</span>
<span class="nc bnc" id="L1867" title="All 2 branches missed.">                size += ipanns[i] == null ? 0 : ipanns[i].getSize();</span>
            }
        }
<span class="pc bpc" id="L1870" title="1 of 2 branches missed.">        if (attrs != null) {</span>
<span class="nc" id="L1871">            size += attrs.getSize(cw, null, 0, -1, -1);</span>
        }
<span class="fc" id="L1873">        return size;</span>
    }

    /**
     * Puts the bytecode of this method in the given byte vector.
     * 
     * @param out the byte vector into which the bytecode of this method must be
     *        copied.
     */
    final void put(final ByteVector out) {
<span class="fc" id="L1883">        out.putShort(access).putShort(name).putShort(desc);</span>
<span class="pc bpc" id="L1884" title="1 of 2 branches missed.">        if (classReaderOffset != 0) {</span>
<span class="nc" id="L1885">            out.putByteArray(cw.cr.b, classReaderOffset, classReaderLength);</span>
<span class="nc" id="L1886">            return;</span>
        }
<span class="fc" id="L1888">        int attributeCount = 0;</span>
<span class="pc bpc" id="L1889" title="1 of 2 branches missed.">        if (code.length &gt; 0) {</span>
<span class="nc" id="L1890">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1892" title="1 of 2 branches missed.">        if (exceptionCount &gt; 0) {</span>
<span class="fc" id="L1893">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1895" title="2 of 4 branches missed.">        if ((access &amp; Opcodes.ACC_SYNTHETIC) != 0</span>
                &amp;&amp; (cw.version &amp; 0xffff) &lt; Opcodes.V1_5)
        {
<span class="fc" id="L1898">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1900" title="1 of 2 branches missed.">        if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {</span>
<span class="fc" id="L1901">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1903" title="1 of 2 branches missed.">        if (ClassReader.SIGNATURES &amp;&amp; signature != null) {</span>
<span class="fc" id="L1904">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1906" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; annd != null) {</span>
<span class="nc" id="L1907">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1909" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; anns != null) {</span>
<span class="nc" id="L1910">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1912" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ianns != null) {</span>
<span class="nc" id="L1913">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1915" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; panns != null) {</span>
<span class="nc" id="L1916">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1918" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ipanns != null) {</span>
<span class="nc" id="L1919">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L1921" title="1 of 2 branches missed.">        if (attrs != null) {</span>
<span class="nc" id="L1922">            attributeCount += attrs.getCount();</span>
        }
<span class="fc" id="L1924">        out.putShort(attributeCount);</span>
<span class="pc bpc" id="L1925" title="1 of 2 branches missed.">        if (code.length &gt; 0) {</span>
<span class="nc" id="L1926">            int size = 12 + code.length + 8 * handlerCount;</span>
<span class="nc bnc" id="L1927" title="All 2 branches missed.">            if (localVar != null) {</span>
<span class="nc" id="L1928">                size += 8 + localVar.length;</span>
            }
<span class="nc bnc" id="L1930" title="All 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L1931">                size += 8 + localVarType.length;</span>
            }
<span class="nc bnc" id="L1933" title="All 2 branches missed.">            if (lineNumber != null) {</span>
<span class="nc" id="L1934">                size += 8 + lineNumber.length;</span>
            }
<span class="nc bnc" id="L1936" title="All 2 branches missed.">            if (stackMap != null) {</span>
<span class="nc" id="L1937">                size += 8 + stackMap.length;</span>
            }
<span class="nc bnc" id="L1939" title="All 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L1940">                size += cattrs.getSize(cw,</span>
                        code.data,
                        code.length,
                        maxStack,
                        maxLocals);
            }
<span class="nc" id="L1946">            out.putShort(cw.newUTF8(&quot;Code&quot;)).putInt(size);</span>
<span class="nc" id="L1947">            out.putShort(maxStack).putShort(maxLocals);</span>
<span class="nc" id="L1948">            out.putInt(code.length).putByteArray(code.data, 0, code.length);</span>
<span class="nc" id="L1949">            out.putShort(handlerCount);</span>
<span class="nc bnc" id="L1950" title="All 2 branches missed.">            if (handlerCount &gt; 0) {</span>
<span class="nc" id="L1951">                Handler h = firstHandler;</span>
<span class="nc bnc" id="L1952" title="All 2 branches missed.">                while (h != null) {</span>
<span class="nc" id="L1953">                    out.putShort(h.start.position)</span>
<span class="nc" id="L1954">                            .putShort(h.end.position)</span>
<span class="nc" id="L1955">                            .putShort(h.handler.position)</span>
<span class="nc" id="L1956">                            .putShort(h.type);</span>
<span class="nc" id="L1957">                    h = h.next;</span>
                }
            }
<span class="nc" id="L1960">            attributeCount = 0;</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">            if (localVar != null) {</span>
<span class="nc" id="L1962">                ++attributeCount;</span>
            }
<span class="nc bnc" id="L1964" title="All 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L1965">                ++attributeCount;</span>
            }
<span class="nc bnc" id="L1967" title="All 2 branches missed.">            if (lineNumber != null) {</span>
<span class="nc" id="L1968">                ++attributeCount;</span>
            }
<span class="nc bnc" id="L1970" title="All 2 branches missed.">            if (stackMap != null) {</span>
<span class="nc" id="L1971">                ++attributeCount;</span>
            }
<span class="nc bnc" id="L1973" title="All 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L1974">                attributeCount += cattrs.getCount();</span>
            }
<span class="nc" id="L1976">            out.putShort(attributeCount);</span>
<span class="nc bnc" id="L1977" title="All 2 branches missed.">            if (localVar != null) {</span>
<span class="nc" id="L1978">                out.putShort(cw.newUTF8(&quot;LocalVariableTable&quot;));</span>
<span class="nc" id="L1979">                out.putInt(localVar.length + 2).putShort(localVarCount);</span>
<span class="nc" id="L1980">                out.putByteArray(localVar.data, 0, localVar.length);</span>
            }
<span class="nc bnc" id="L1982" title="All 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L1983">                out.putShort(cw.newUTF8(&quot;LocalVariableTypeTable&quot;));</span>
<span class="nc" id="L1984">                out.putInt(localVarType.length + 2).putShort(localVarTypeCount);</span>
<span class="nc" id="L1985">                out.putByteArray(localVarType.data, 0, localVarType.length);</span>
            }
<span class="nc bnc" id="L1987" title="All 2 branches missed.">            if (lineNumber != null) {</span>
<span class="nc" id="L1988">                out.putShort(cw.newUTF8(&quot;LineNumberTable&quot;));</span>
<span class="nc" id="L1989">                out.putInt(lineNumber.length + 2).putShort(lineNumberCount);</span>
<span class="nc" id="L1990">                out.putByteArray(lineNumber.data, 0, lineNumber.length);</span>
            }
<span class="nc bnc" id="L1992" title="All 2 branches missed.">            if (stackMap != null) {</span>
<span class="nc bnc" id="L1993" title="All 2 branches missed.">                boolean zip = (cw.version &amp; 0xFFFF) &gt;= Opcodes.V1_6;</span>
<span class="nc bnc" id="L1994" title="All 2 branches missed.">                out.putShort(cw.newUTF8(zip ? &quot;StackMapTable&quot; : &quot;StackMap&quot;));</span>
<span class="nc" id="L1995">                out.putInt(stackMap.length + 2).putShort(frameCount);</span>
<span class="nc" id="L1996">                out.putByteArray(stackMap.data, 0, stackMap.length);</span>
            }
<span class="nc bnc" id="L1998" title="All 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L1999">                cattrs.put(cw, code.data, code.length, maxLocals, maxStack, out);</span>
            }
        }
<span class="pc bpc" id="L2002" title="1 of 2 branches missed.">        if (exceptionCount &gt; 0) {</span>
<span class="fc" id="L2003">            out.putShort(cw.newUTF8(&quot;Exceptions&quot;))</span>
<span class="fc" id="L2004">                    .putInt(2 * exceptionCount + 2);</span>
<span class="fc" id="L2005">            out.putShort(exceptionCount);</span>
<span class="fc bfc" id="L2006" title="All 2 branches covered.">            for (int i = 0; i &lt; exceptionCount; ++i) {</span>
<span class="fc" id="L2007">                out.putShort(exceptions[i]);</span>
            }
        }
<span class="pc bpc" id="L2010" title="2 of 4 branches missed.">        if ((access &amp; Opcodes.ACC_SYNTHETIC) != 0</span>
                &amp;&amp; (cw.version &amp; 0xffff) &lt; Opcodes.V1_5)
        {
<span class="fc" id="L2013">            out.putShort(cw.newUTF8(&quot;Synthetic&quot;)).putInt(0);</span>
        }
<span class="pc bpc" id="L2015" title="1 of 2 branches missed.">        if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {</span>
<span class="fc" id="L2016">            out.putShort(cw.newUTF8(&quot;Deprecated&quot;)).putInt(0);</span>
        }
<span class="pc bpc" id="L2018" title="1 of 2 branches missed.">        if (ClassReader.SIGNATURES &amp;&amp; signature != null) {</span>
<span class="fc" id="L2019">            out.putShort(cw.newUTF8(&quot;Signature&quot;))</span>
<span class="fc" id="L2020">                    .putInt(2)</span>
<span class="fc" id="L2021">                    .putShort(cw.newUTF8(signature));</span>
        }
<span class="pc bpc" id="L2023" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; annd != null) {</span>
<span class="nc" id="L2024">            out.putShort(cw.newUTF8(&quot;AnnotationDefault&quot;));</span>
<span class="nc" id="L2025">            out.putInt(annd.length);</span>
<span class="nc" id="L2026">            out.putByteArray(annd.data, 0, annd.length);</span>
        }
<span class="pc bpc" id="L2028" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; anns != null) {</span>
<span class="nc" id="L2029">            out.putShort(cw.newUTF8(&quot;RuntimeVisibleAnnotations&quot;));</span>
<span class="nc" id="L2030">            anns.put(out);</span>
        }
<span class="pc bpc" id="L2032" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ianns != null) {</span>
<span class="nc" id="L2033">            out.putShort(cw.newUTF8(&quot;RuntimeInvisibleAnnotations&quot;));</span>
<span class="nc" id="L2034">            ianns.put(out);</span>
        }
<span class="pc bpc" id="L2036" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; panns != null) {</span>
<span class="nc" id="L2037">            out.putShort(cw.newUTF8(&quot;RuntimeVisibleParameterAnnotations&quot;));</span>
<span class="nc" id="L2038">            AnnotationWriter.put(panns, synthetics, out);</span>
        }
<span class="pc bpc" id="L2040" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ipanns != null) {</span>
<span class="nc" id="L2041">            out.putShort(cw.newUTF8(&quot;RuntimeInvisibleParameterAnnotations&quot;));</span>
<span class="nc" id="L2042">            AnnotationWriter.put(ipanns, synthetics, out);</span>
        }
<span class="pc bpc" id="L2044" title="1 of 2 branches missed.">        if (attrs != null) {</span>
<span class="nc" id="L2045">            attrs.put(cw, null, 0, -1, -1, out);</span>
        }
<span class="fc" id="L2047">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: instruction resizing (used to handle GOTO_W and JSR_W)
    // ------------------------------------------------------------------------

    /**
     * Resizes and replaces the temporary instructions inserted by
     * {@link Label#resolve} for wide forward jumps, while keeping jump offsets
     * and instruction addresses consistent. This may require to resize other
     * existing instructions, or even to introduce new instructions: for
     * example, increasing the size of an instruction by 2 at the middle of a
     * method can increases the offset of an IFEQ instruction from 32766 to
     * 32768, in which case IFEQ 32766 must be replaced with IFNEQ 8 GOTO_W
     * 32765. This, in turn, may require to increase the size of another jump
     * instruction, and so on... All these operations are handled automatically
     * by this method. &lt;p&gt; &lt;i&gt;This method must be called after all the method
     * that is being built has been visited&lt;/i&gt;. In particular, the
     * {@link Label Label} objects used to construct the method are no longer
     * valid after this method has been called.
     */
    private void resizeInstructions() {
<span class="nc" id="L2069">        byte[] b = code.data; // bytecode of the method</span>
        int u, v, label; // indexes in b
        int i, j; // loop indexes
        /*
         * 1st step: As explained above, resizing an instruction may require to
         * resize another one, which may require to resize yet another one, and
         * so on. The first step of the algorithm consists in finding all the
         * instructions that need to be resized, without modifying the code.
         * This is done by the following &quot;fix point&quot; algorithm:
         * 
         * Parse the code to find the jump instructions whose offset will need
         * more than 2 bytes to be stored (the future offset is computed from
         * the current offset and from the number of bytes that will be inserted
         * or removed between the source and target instructions). For each such
         * instruction, adds an entry in (a copy of) the indexes and sizes
         * arrays (if this has not already been done in a previous iteration!).
         * 
         * If at least one entry has been added during the previous step, go
         * back to the beginning, otherwise stop.
         * 
         * In fact the real algorithm is complicated by the fact that the size
         * of TABLESWITCH and LOOKUPSWITCH instructions depends on their
         * position in the bytecode (because of padding). In order to ensure the
         * convergence of the algorithm, the number of bytes to be added or
         * removed from these instructions is over estimated during the previous
         * loop, and computed exactly only after the loop is finished (this
         * requires another pass to parse the bytecode of the method).
         */
<span class="nc" id="L2097">        int[] allIndexes = new int[0]; // copy of indexes</span>
<span class="nc" id="L2098">        int[] allSizes = new int[0]; // copy of sizes</span>
        boolean[] resize; // instructions to be resized
        int newOffset; // future offset of a jump instruction

<span class="nc" id="L2102">        resize = new boolean[code.length];</span>

        // 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done
<span class="nc" id="L2105">        int state = 3;</span>
        do {
<span class="nc bnc" id="L2107" title="All 2 branches missed.">            if (state == 3) {</span>
<span class="nc" id="L2108">                state = 2;</span>
            }
<span class="nc" id="L2110">            u = 0;</span>
<span class="nc bnc" id="L2111" title="All 2 branches missed.">            while (u &lt; b.length) {</span>
<span class="nc" id="L2112">                int opcode = b[u] &amp; 0xFF; // opcode of current instruction</span>
<span class="nc" id="L2113">                int insert = 0; // bytes to be added after this instruction</span>

<span class="nc bnc" id="L2115" title="All 10 branches missed.">                switch (ClassWriter.TYPE[opcode]) {</span>
                    case ClassWriter.NOARG_INSN:
                    case ClassWriter.IMPLVAR_INSN:
<span class="nc" id="L2118">                        u += 1;</span>
<span class="nc" id="L2119">                        break;</span>
                    case ClassWriter.LABEL_INSN:
<span class="nc bnc" id="L2121" title="All 2 branches missed.">                        if (opcode &gt; 201) {</span>
                            // converts temporary opcodes 202 to 217, 218 and
                            // 219 to IFEQ ... JSR (inclusive), IFNULL and
                            // IFNONNULL
<span class="nc bnc" id="L2125" title="All 2 branches missed.">                            opcode = opcode &lt; 218 ? opcode - 49 : opcode - 20;</span>
<span class="nc" id="L2126">                            label = u + readUnsignedShort(b, u + 1);</span>
                        } else {
<span class="nc" id="L2128">                            label = u + readShort(b, u + 1);</span>
                        }
<span class="nc" id="L2130">                        newOffset = getNewOffset(allIndexes, allSizes, u, label);</span>
<span class="nc bnc" id="L2131" title="All 4 branches missed.">                        if (newOffset &lt; Short.MIN_VALUE</span>
                                || newOffset &gt; Short.MAX_VALUE)
                        {
<span class="nc bnc" id="L2134" title="All 2 branches missed.">                            if (!resize[u]) {</span>
<span class="nc bnc" id="L2135" title="All 4 branches missed.">                                if (opcode == Opcodes.GOTO</span>
                                        || opcode == Opcodes.JSR)
                                {
                                    // two additional bytes will be required to
                                    // replace this GOTO or JSR instruction with
                                    // a GOTO_W or a JSR_W
<span class="nc" id="L2141">                                    insert = 2;</span>
                                } else {
                                    // five additional bytes will be required to
                                    // replace this IFxxx &lt;l&gt; instruction with
                                    // IFNOTxxx &lt;l'&gt; GOTO_W &lt;l&gt;, where IFNOTxxx
                                    // is the &quot;opposite&quot; opcode of IFxxx (i.e.,
                                    // IFNE for IFEQ) and where &lt;l'&gt; designates
                                    // the instruction just after the GOTO_W.
<span class="nc" id="L2149">                                    insert = 5;</span>
                                }
<span class="nc" id="L2151">                                resize[u] = true;</span>
                            }
                        }
<span class="nc" id="L2154">                        u += 3;</span>
<span class="nc" id="L2155">                        break;</span>
                    case ClassWriter.LABELW_INSN:
<span class="nc" id="L2157">                        u += 5;</span>
<span class="nc" id="L2158">                        break;</span>
                    case ClassWriter.TABL_INSN:
<span class="nc bnc" id="L2160" title="All 2 branches missed.">                        if (state == 1) {</span>
                            // true number of bytes to be added (or removed)
                            // from this instruction = (future number of padding
                            // bytes - current number of padding byte) -
                            // previously over estimated variation =
                            // = ((3 - newOffset%4) - (3 - u%4)) - u%4
                            // = (-newOffset%4 + u%4) - u%4
                            // = -(newOffset &amp; 3)
<span class="nc" id="L2168">                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);</span>
<span class="nc" id="L2169">                            insert = -(newOffset &amp; 3);</span>
<span class="nc bnc" id="L2170" title="All 2 branches missed.">                        } else if (!resize[u]) {</span>
                            // over estimation of the number of bytes to be
                            // added to this instruction = 3 - current number
                            // of padding bytes = 3 - (3 - u%4) = u%4 = u &amp; 3
<span class="nc" id="L2174">                            insert = u &amp; 3;</span>
<span class="nc" id="L2175">                            resize[u] = true;</span>
                        }
                        // skips instruction
<span class="nc" id="L2178">                        u = u + 4 - (u &amp; 3);</span>
<span class="nc" id="L2179">                        u += 4 * (readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;</span>
<span class="nc" id="L2180">                        break;</span>
                    case ClassWriter.LOOK_INSN:
<span class="nc bnc" id="L2182" title="All 2 branches missed.">                        if (state == 1) {</span>
                            // like TABL_INSN
<span class="nc" id="L2184">                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);</span>
<span class="nc" id="L2185">                            insert = -(newOffset &amp; 3);</span>
<span class="nc bnc" id="L2186" title="All 2 branches missed.">                        } else if (!resize[u]) {</span>
                            // like TABL_INSN
<span class="nc" id="L2188">                            insert = u &amp; 3;</span>
<span class="nc" id="L2189">                            resize[u] = true;</span>
                        }
                        // skips instruction
<span class="nc" id="L2192">                        u = u + 4 - (u &amp; 3);</span>
<span class="nc" id="L2193">                        u += 8 * readInt(b, u + 4) + 8;</span>
<span class="nc" id="L2194">                        break;</span>
                    case ClassWriter.WIDE_INSN:
<span class="nc" id="L2196">                        opcode = b[u + 1] &amp; 0xFF;</span>
<span class="nc bnc" id="L2197" title="All 2 branches missed.">                        if (opcode == Opcodes.IINC) {</span>
<span class="nc" id="L2198">                            u += 6;</span>
                        } else {
<span class="nc" id="L2200">                            u += 4;</span>
                        }
<span class="nc" id="L2202">                        break;</span>
                    case ClassWriter.VAR_INSN:
                    case ClassWriter.SBYTE_INSN:
                    case ClassWriter.LDC_INSN:
<span class="nc" id="L2206">                        u += 2;</span>
<span class="nc" id="L2207">                        break;</span>
                    case ClassWriter.SHORT_INSN:
                    case ClassWriter.LDCW_INSN:
                    case ClassWriter.FIELDORMETH_INSN:
                    case ClassWriter.TYPE_INSN:
                    case ClassWriter.IINC_INSN:
<span class="nc" id="L2213">                        u += 3;</span>
<span class="nc" id="L2214">                        break;</span>
                    case ClassWriter.ITFMETH_INSN:
<span class="nc" id="L2216">                        u += 5;</span>
<span class="nc" id="L2217">                        break;</span>
                    // case ClassWriter.MANA_INSN:
                    default:
<span class="nc" id="L2220">                        u += 4;</span>
                        break;
                }
<span class="nc bnc" id="L2223" title="All 2 branches missed.">                if (insert != 0) {</span>
                    // adds a new (u, insert) entry in the allIndexes and
                    // allSizes arrays
<span class="nc" id="L2226">                    int[] newIndexes = new int[allIndexes.length + 1];</span>
<span class="nc" id="L2227">                    int[] newSizes = new int[allSizes.length + 1];</span>
<span class="nc" id="L2228">                    System.arraycopy(allIndexes,</span>
                            0,
                            newIndexes,
                            0,
                            allIndexes.length);
<span class="nc" id="L2233">                    System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);</span>
<span class="nc" id="L2234">                    newIndexes[allIndexes.length] = u;</span>
<span class="nc" id="L2235">                    newSizes[allSizes.length] = insert;</span>
<span class="nc" id="L2236">                    allIndexes = newIndexes;</span>
<span class="nc" id="L2237">                    allSizes = newSizes;</span>
<span class="nc bnc" id="L2238" title="All 2 branches missed.">                    if (insert &gt; 0) {</span>
<span class="nc" id="L2239">                        state = 3;</span>
                    }
                }
<span class="nc" id="L2242">            }</span>
<span class="nc bnc" id="L2243" title="All 2 branches missed.">            if (state &lt; 3) {</span>
<span class="nc" id="L2244">                --state;</span>
            }
<span class="nc bnc" id="L2246" title="All 2 branches missed.">        } while (state != 0);</span>

        // 2nd step:
        // copies the bytecode of the method into a new bytevector, updates the
        // offsets, and inserts (or removes) bytes as requested.

<span class="nc" id="L2252">        ByteVector newCode = new ByteVector(code.length);</span>

<span class="nc" id="L2254">        u = 0;</span>
<span class="nc bnc" id="L2255" title="All 2 branches missed.">        while (u &lt; code.length) {</span>
<span class="nc" id="L2256">            int opcode = b[u] &amp; 0xFF;</span>
<span class="nc bnc" id="L2257" title="All 10 branches missed.">            switch (ClassWriter.TYPE[opcode]) {</span>
                case ClassWriter.NOARG_INSN:
                case ClassWriter.IMPLVAR_INSN:
<span class="nc" id="L2260">                    newCode.putByte(opcode);</span>
<span class="nc" id="L2261">                    u += 1;</span>
<span class="nc" id="L2262">                    break;</span>
                case ClassWriter.LABEL_INSN:
<span class="nc bnc" id="L2264" title="All 2 branches missed.">                    if (opcode &gt; 201) {</span>
                        // changes temporary opcodes 202 to 217 (inclusive), 218
                        // and 219 to IFEQ ... JSR (inclusive), IFNULL and
                        // IFNONNULL
<span class="nc bnc" id="L2268" title="All 2 branches missed.">                        opcode = opcode &lt; 218 ? opcode - 49 : opcode - 20;</span>
<span class="nc" id="L2269">                        label = u + readUnsignedShort(b, u + 1);</span>
                    } else {
<span class="nc" id="L2271">                        label = u + readShort(b, u + 1);</span>
                    }
<span class="nc" id="L2273">                    newOffset = getNewOffset(allIndexes, allSizes, u, label);</span>
<span class="nc bnc" id="L2274" title="All 2 branches missed.">                    if (resize[u]) {</span>
                        // replaces GOTO with GOTO_W, JSR with JSR_W and IFxxx
                        // &lt;l&gt; with IFNOTxxx &lt;l'&gt; GOTO_W &lt;l&gt;, where IFNOTxxx is
                        // the &quot;opposite&quot; opcode of IFxxx (i.e., IFNE for IFEQ)
                        // and where &lt;l'&gt; designates the instruction just after
                        // the GOTO_W.
<span class="nc bnc" id="L2280" title="All 2 branches missed.">                        if (opcode == Opcodes.GOTO) {</span>
<span class="nc" id="L2281">                            newCode.putByte(200); // GOTO_W</span>
<span class="nc bnc" id="L2282" title="All 2 branches missed.">                        } else if (opcode == Opcodes.JSR) {</span>
<span class="nc" id="L2283">                            newCode.putByte(201); // JSR_W</span>
                        } else {
<span class="nc bnc" id="L2285" title="All 2 branches missed.">                            newCode.putByte(opcode &lt;= 166</span>
                                    ? ((opcode + 1) ^ 1) - 1
                                    : opcode ^ 1);
<span class="nc" id="L2288">                            newCode.putShort(8); // jump offset</span>
<span class="nc" id="L2289">                            newCode.putByte(200); // GOTO_W</span>
                            // newOffset now computed from start of GOTO_W
<span class="nc" id="L2291">                            newOffset -= 3;</span>
                        }
<span class="nc" id="L2293">                        newCode.putInt(newOffset);</span>
                    } else {
<span class="nc" id="L2295">                        newCode.putByte(opcode);</span>
<span class="nc" id="L2296">                        newCode.putShort(newOffset);</span>
                    }
<span class="nc" id="L2298">                    u += 3;</span>
<span class="nc" id="L2299">                    break;</span>
                case ClassWriter.LABELW_INSN:
<span class="nc" id="L2301">                    label = u + readInt(b, u + 1);</span>
<span class="nc" id="L2302">                    newOffset = getNewOffset(allIndexes, allSizes, u, label);</span>
<span class="nc" id="L2303">                    newCode.putByte(opcode);</span>
<span class="nc" id="L2304">                    newCode.putInt(newOffset);</span>
<span class="nc" id="L2305">                    u += 5;</span>
<span class="nc" id="L2306">                    break;</span>
                case ClassWriter.TABL_INSN:
                    // skips 0 to 3 padding bytes
<span class="nc" id="L2309">                    v = u;</span>
<span class="nc" id="L2310">                    u = u + 4 - (v &amp; 3);</span>
                    // reads and copies instruction
<span class="nc" id="L2312">                    newCode.putByte(Opcodes.TABLESWITCH);</span>
<span class="nc" id="L2313">                    newCode.length += (4 - newCode.length % 4) % 4;</span>
<span class="nc" id="L2314">                    label = v + readInt(b, u);</span>
<span class="nc" id="L2315">                    u += 4;</span>
<span class="nc" id="L2316">                    newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2317">                    newCode.putInt(newOffset);</span>
<span class="nc" id="L2318">                    j = readInt(b, u);</span>
<span class="nc" id="L2319">                    u += 4;</span>
<span class="nc" id="L2320">                    newCode.putInt(j);</span>
<span class="nc" id="L2321">                    j = readInt(b, u) - j + 1;</span>
<span class="nc" id="L2322">                    u += 4;</span>
<span class="nc" id="L2323">                    newCode.putInt(readInt(b, u - 4));</span>
<span class="nc bnc" id="L2324" title="All 2 branches missed.">                    for (; j &gt; 0; --j) {</span>
<span class="nc" id="L2325">                        label = v + readInt(b, u);</span>
<span class="nc" id="L2326">                        u += 4;</span>
<span class="nc" id="L2327">                        newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2328">                        newCode.putInt(newOffset);</span>
                    }
                    break;
                case ClassWriter.LOOK_INSN:
                    // skips 0 to 3 padding bytes
<span class="nc" id="L2333">                    v = u;</span>
<span class="nc" id="L2334">                    u = u + 4 - (v &amp; 3);</span>
                    // reads and copies instruction
<span class="nc" id="L2336">                    newCode.putByte(Opcodes.LOOKUPSWITCH);</span>
<span class="nc" id="L2337">                    newCode.length += (4 - newCode.length % 4) % 4;</span>
<span class="nc" id="L2338">                    label = v + readInt(b, u);</span>
<span class="nc" id="L2339">                    u += 4;</span>
<span class="nc" id="L2340">                    newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2341">                    newCode.putInt(newOffset);</span>
<span class="nc" id="L2342">                    j = readInt(b, u);</span>
<span class="nc" id="L2343">                    u += 4;</span>
<span class="nc" id="L2344">                    newCode.putInt(j);</span>
<span class="nc bnc" id="L2345" title="All 2 branches missed.">                    for (; j &gt; 0; --j) {</span>
<span class="nc" id="L2346">                        newCode.putInt(readInt(b, u));</span>
<span class="nc" id="L2347">                        u += 4;</span>
<span class="nc" id="L2348">                        label = v + readInt(b, u);</span>
<span class="nc" id="L2349">                        u += 4;</span>
<span class="nc" id="L2350">                        newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2351">                        newCode.putInt(newOffset);</span>
                    }
                    break;
                case ClassWriter.WIDE_INSN:
<span class="nc" id="L2355">                    opcode = b[u + 1] &amp; 0xFF;</span>
<span class="nc bnc" id="L2356" title="All 2 branches missed.">                    if (opcode == Opcodes.IINC) {</span>
<span class="nc" id="L2357">                        newCode.putByteArray(b, u, 6);</span>
<span class="nc" id="L2358">                        u += 6;</span>
                    } else {
<span class="nc" id="L2360">                        newCode.putByteArray(b, u, 4);</span>
<span class="nc" id="L2361">                        u += 4;</span>
                    }
<span class="nc" id="L2363">                    break;</span>
                case ClassWriter.VAR_INSN:
                case ClassWriter.SBYTE_INSN:
                case ClassWriter.LDC_INSN:
<span class="nc" id="L2367">                    newCode.putByteArray(b, u, 2);</span>
<span class="nc" id="L2368">                    u += 2;</span>
<span class="nc" id="L2369">                    break;</span>
                case ClassWriter.SHORT_INSN:
                case ClassWriter.LDCW_INSN:
                case ClassWriter.FIELDORMETH_INSN:
                case ClassWriter.TYPE_INSN:
                case ClassWriter.IINC_INSN:
<span class="nc" id="L2375">                    newCode.putByteArray(b, u, 3);</span>
<span class="nc" id="L2376">                    u += 3;</span>
<span class="nc" id="L2377">                    break;</span>
                case ClassWriter.ITFMETH_INSN:
<span class="nc" id="L2379">                    newCode.putByteArray(b, u, 5);</span>
<span class="nc" id="L2380">                    u += 5;</span>
<span class="nc" id="L2381">                    break;</span>
                // case MANA_INSN:
                default:
<span class="nc" id="L2384">                    newCode.putByteArray(b, u, 4);</span>
<span class="nc" id="L2385">                    u += 4;</span>
                    break;
            }
<span class="nc" id="L2388">        }</span>

        // recomputes the stack map frames
<span class="nc bnc" id="L2391" title="All 2 branches missed.">        if (frameCount &gt; 0) {</span>
<span class="nc bnc" id="L2392" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L2393">                frameCount = 0;</span>
<span class="nc" id="L2394">                stackMap = null;</span>
<span class="nc" id="L2395">                previousFrame = null;</span>
<span class="nc" id="L2396">                frame = null;</span>
<span class="nc" id="L2397">                Frame f = new Frame();</span>
<span class="nc" id="L2398">                f.owner = labels;</span>
<span class="nc" id="L2399">                Type[] args = Type.getArgumentTypes(descriptor);</span>
<span class="nc" id="L2400">                f.initInputFrame(cw, access, args, maxLocals);</span>
<span class="nc" id="L2401">                visitFrame(f);</span>
<span class="nc" id="L2402">                Label l = labels;</span>
<span class="nc bnc" id="L2403" title="All 2 branches missed.">                while (l != null) {</span>
                    /*
                     * here we need the original label position. getNewOffset
                     * must therefore never have been called for this label.
                     */
<span class="nc" id="L2408">                    u = l.position - 3;</span>
<span class="nc bnc" id="L2409" title="All 6 branches missed.">                    if ((l.status &amp; Label.STORE) != 0 || (u &gt;= 0 &amp;&amp; resize[u]))</span>
                    {
<span class="nc" id="L2411">                        getNewOffset(allIndexes, allSizes, l);</span>
                        // TODO update offsets in UNINITIALIZED values
<span class="nc" id="L2413">                        visitFrame(l.frame);</span>
                    }
<span class="nc" id="L2415">                    l = l.successor;</span>
                }
<span class="nc" id="L2417">            } else {</span>
                /*
                 * Resizing an existing stack map frame table is really hard.
                 * Not only the table must be parsed to update the offets, but
                 * new frames may be needed for jump instructions that were
                 * inserted by this method. And updating the offsets or
                 * inserting frames can change the format of the following
                 * frames, in case of packed frames. In practice the whole table
                 * must be recomputed. For this the frames are marked as
                 * potentially invalid. This will cause the whole class to be
                 * reread and rewritten with the COMPUTE_FRAMES option (see the
                 * ClassWriter.toByteArray method). This is not very efficient
                 * but is much easier and requires much less code than any other
                 * method I can think of.
                 */
<span class="nc" id="L2432">                cw.invalidFrames = true;</span>
            }
        }
        // updates the exception handler block labels
<span class="nc" id="L2436">        Handler h = firstHandler;</span>
<span class="nc bnc" id="L2437" title="All 2 branches missed.">        while (h != null) {</span>
<span class="nc" id="L2438">            getNewOffset(allIndexes, allSizes, h.start);</span>
<span class="nc" id="L2439">            getNewOffset(allIndexes, allSizes, h.end);</span>
<span class="nc" id="L2440">            getNewOffset(allIndexes, allSizes, h.handler);</span>
<span class="nc" id="L2441">            h = h.next;</span>
        }
        // updates the instructions addresses in the
        // local var and line number tables
<span class="nc bnc" id="L2445" title="All 2 branches missed.">        for (i = 0; i &lt; 2; ++i) {</span>
<span class="nc bnc" id="L2446" title="All 2 branches missed.">            ByteVector bv = i == 0 ? localVar : localVarType;</span>
<span class="nc bnc" id="L2447" title="All 2 branches missed.">            if (bv != null) {</span>
<span class="nc" id="L2448">                b = bv.data;</span>
<span class="nc" id="L2449">                u = 0;</span>
<span class="nc bnc" id="L2450" title="All 2 branches missed.">                while (u &lt; bv.length) {</span>
<span class="nc" id="L2451">                    label = readUnsignedShort(b, u);</span>
<span class="nc" id="L2452">                    newOffset = getNewOffset(allIndexes, allSizes, 0, label);</span>
<span class="nc" id="L2453">                    writeShort(b, u, newOffset);</span>
<span class="nc" id="L2454">                    label += readUnsignedShort(b, u + 2);</span>
<span class="nc" id="L2455">                    newOffset = getNewOffset(allIndexes, allSizes, 0, label)</span>
                            - newOffset;
<span class="nc" id="L2457">                    writeShort(b, u + 2, newOffset);</span>
<span class="nc" id="L2458">                    u += 10;</span>
                }
            }
        }
<span class="nc bnc" id="L2462" title="All 2 branches missed.">        if (lineNumber != null) {</span>
<span class="nc" id="L2463">            b = lineNumber.data;</span>
<span class="nc" id="L2464">            u = 0;</span>
<span class="nc bnc" id="L2465" title="All 2 branches missed.">            while (u &lt; lineNumber.length) {</span>
<span class="nc" id="L2466">                writeShort(b, u, getNewOffset(allIndexes,</span>
                        allSizes,
                        0,
<span class="nc" id="L2469">                        readUnsignedShort(b, u)));</span>
<span class="nc" id="L2470">                u += 4;</span>
            }
        }
        // updates the labels of the other attributes
<span class="nc" id="L2474">        Attribute attr = cattrs;</span>
<span class="nc bnc" id="L2475" title="All 2 branches missed.">        while (attr != null) {</span>
<span class="nc" id="L2476">            Label[] labels = attr.getLabels();</span>
<span class="nc bnc" id="L2477" title="All 2 branches missed.">            if (labels != null) {</span>
<span class="nc bnc" id="L2478" title="All 2 branches missed.">                for (i = labels.length - 1; i &gt;= 0; --i) {</span>
<span class="nc" id="L2479">                    getNewOffset(allIndexes, allSizes, labels[i]);</span>
                }
            }
<span class="nc" id="L2482">            attr = attr.next;</span>
<span class="nc" id="L2483">        }</span>

        // replaces old bytecodes with new ones
<span class="nc" id="L2486">        code = newCode;</span>
<span class="nc" id="L2487">    }</span>

    /**
     * Reads an unsigned short value in the given byte array.
     * 
     * @param b a byte array.
     * @param index the start index of the value to be read.
     * @return the read value.
     */
    static int readUnsignedShort(final byte[] b, final int index) {
<span class="nc" id="L2497">        return ((b[index] &amp; 0xFF) &lt;&lt; 8) | (b[index + 1] &amp; 0xFF);</span>
    }

    /**
     * Reads a signed short value in the given byte array.
     * 
     * @param b a byte array.
     * @param index the start index of the value to be read.
     * @return the read value.
     */
    static short readShort(final byte[] b, final int index) {
<span class="nc" id="L2508">        return (short) (((b[index] &amp; 0xFF) &lt;&lt; 8) | (b[index + 1] &amp; 0xFF));</span>
    }

    /**
     * Reads a signed int value in the given byte array.
     * 
     * @param b a byte array.
     * @param index the start index of the value to be read.
     * @return the read value.
     */
    static int readInt(final byte[] b, final int index) {
<span class="nc" id="L2519">        return ((b[index] &amp; 0xFF) &lt;&lt; 24) | ((b[index + 1] &amp; 0xFF) &lt;&lt; 16)</span>
                | ((b[index + 2] &amp; 0xFF) &lt;&lt; 8) | (b[index + 3] &amp; 0xFF);
    }

    /**
     * Writes a short value in the given byte array.
     * 
     * @param b a byte array.
     * @param index where the first byte of the short value must be written.
     * @param s the value to be written in the given byte array.
     */
    static void writeShort(final byte[] b, final int index, final int s) {
<span class="nc" id="L2531">        b[index] = (byte) (s &gt;&gt;&gt; 8);</span>
<span class="nc" id="L2532">        b[index + 1] = (byte) s;</span>
<span class="nc" id="L2533">    }</span>

    /**
     * Computes the future value of a bytecode offset. &lt;p&gt; Note: it is possible
     * to have several entries for the same instruction in the &lt;tt&gt;indexes&lt;/tt&gt;
     * and &lt;tt&gt;sizes&lt;/tt&gt;: two entries (index=a,size=b) and (index=a,size=b')
     * are equivalent to a single entry (index=a,size=b+b').
     * 
     * @param indexes current positions of the instructions to be resized. Each
     *        instruction must be designated by the index of its &lt;i&gt;last&lt;/i&gt;
     *        byte, plus one (or, in other words, by the index of the &lt;i&gt;first&lt;/i&gt;
     *        byte of the &lt;i&gt;next&lt;/i&gt; instruction).
     * @param sizes the number of bytes to be &lt;i&gt;added&lt;/i&gt; to the above
     *        instructions. More precisely, for each i &lt; &lt;tt&gt;len&lt;/tt&gt;,
     *        &lt;tt&gt;sizes&lt;/tt&gt;[i] bytes will be added at the end of the
     *        instruction designated by &lt;tt&gt;indexes&lt;/tt&gt;[i] or, if
     *        &lt;tt&gt;sizes&lt;/tt&gt;[i] is negative, the &lt;i&gt;last&lt;/i&gt; |&lt;tt&gt;sizes[i]&lt;/tt&gt;|
     *        bytes of the instruction will be removed (the instruction size
     *        &lt;i&gt;must not&lt;/i&gt; become negative or null).
     * @param begin index of the first byte of the source instruction.
     * @param end index of the first byte of the target instruction.
     * @return the future value of the given bytecode offset.
     */
    static int getNewOffset(
        final int[] indexes,
        final int[] sizes,
        final int begin,
        final int end)
    {
<span class="nc" id="L2562">        int offset = end - begin;</span>
<span class="nc bnc" id="L2563" title="All 2 branches missed.">        for (int i = 0; i &lt; indexes.length; ++i) {</span>
<span class="nc bnc" id="L2564" title="All 4 branches missed.">            if (begin &lt; indexes[i] &amp;&amp; indexes[i] &lt;= end) {</span>
                // forward jump
<span class="nc" id="L2566">                offset += sizes[i];</span>
<span class="nc bnc" id="L2567" title="All 4 branches missed.">            } else if (end &lt; indexes[i] &amp;&amp; indexes[i] &lt;= begin) {</span>
                // backward jump
<span class="nc" id="L2569">                offset -= sizes[i];</span>
            }
        }
<span class="nc" id="L2572">        return offset;</span>
    }

    /**
     * Updates the offset of the given label.
     * 
     * @param indexes current positions of the instructions to be resized. Each
     *        instruction must be designated by the index of its &lt;i&gt;last&lt;/i&gt;
     *        byte, plus one (or, in other words, by the index of the &lt;i&gt;first&lt;/i&gt;
     *        byte of the &lt;i&gt;next&lt;/i&gt; instruction).
     * @param sizes the number of bytes to be &lt;i&gt;added&lt;/i&gt; to the above
     *        instructions. More precisely, for each i &lt; &lt;tt&gt;len&lt;/tt&gt;,
     *        &lt;tt&gt;sizes&lt;/tt&gt;[i] bytes will be added at the end of the
     *        instruction designated by &lt;tt&gt;indexes&lt;/tt&gt;[i] or, if
     *        &lt;tt&gt;sizes&lt;/tt&gt;[i] is negative, the &lt;i&gt;last&lt;/i&gt; |&lt;tt&gt;sizes[i]&lt;/tt&gt;|
     *        bytes of the instruction will be removed (the instruction size
     *        &lt;i&gt;must not&lt;/i&gt; become negative or null).
     * @param label the label whose offset must be updated.
     */
    static void getNewOffset(
        final int[] indexes,
        final int[] sizes,
        final Label label)
    {
<span class="nc bnc" id="L2596" title="All 2 branches missed.">        if ((label.status &amp; Label.RESIZED) == 0) {</span>
<span class="nc" id="L2597">            label.position = getNewOffset(indexes, sizes, 0, label.position);</span>
<span class="nc" id="L2598">            label.status |= Label.RESIZED;</span>
        }
<span class="nc" id="L2600">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>