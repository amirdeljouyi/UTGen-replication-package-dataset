<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XBUSSystem.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">83_xbus</a> &gt; <a href="index.source.html" class="el_package">net.sf.xbus.base.xbussystem</a> &gt; <span class="el_source">XBUSSystem.java</span></div><h1>XBUSSystem.java</h1><pre class="source lang-java linenums">package net.sf.xbus.base.xbussystem;

import java.io.File;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;

import net.sf.xbus.base.core.Constants;
import net.sf.xbus.base.core.XException;
import net.sf.xbus.base.core.config.Configuration;
import net.sf.xbus.base.core.reflection.ReflectionSupport;
import net.sf.xbus.base.core.strings.XStringSupport;

/**
 * &lt;code&gt;XBUSSystem&lt;/code&gt; is the representation of any neighbor-systems
 * respectively their interfaces. It consists of two informations:
 * &lt;p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;The name of the system is used to identify the system.
 * &lt;li&gt;Additionally an adress might be available.
 * &lt;/ul&gt;
 */
public class XBUSSystem
{
	public static final String FILENAME_WILDCARD = &quot;$WILDCARD$&quot;;
	public static final String FILENAME_WILDCARD_XML = &quot;WILDCARD&quot;;
	private static final String ADDITIONAL_ADDRESS = &quot;AddressImplementation&quot;;
	private static final String TIMESTAMP = &quot;$TIMESTAMP$&quot;;

	/**
	 * Holds all address informations of the neighbor-system. Each address
	 * stored as value against its typ.
	 * &lt;p&gt;
	 * &lt;i&gt;Possible addresses: &lt;/i&gt; &lt;table border&gt;
	 * &lt;tr&gt;
	 * &lt;th&gt;Key&lt;/th&gt;
	 * &lt;th&gt;Value(Example)&lt;/th&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;AddressImplementation&lt;/td&gt;
	 * &lt;td&gt;Test/Wholesale/std$DEALERNUMBER$.cnf&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;WILDCARD&lt;/td&gt;
	 * &lt;td&gt;parts&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;&lt;i&gt;example: &lt;/i&gt;user&lt;/td&gt;
	 * &lt;td&gt;KS&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;/table&gt;
	 */
<span class="nc" id="L55">	private Hashtable mAddresses = new Hashtable();</span>

	/**
	 * Is a braodcast requested for all recorded addtional addresses when
	 * sending data to this system?
	 */
	private boolean mBroadcast;

	/**
	 * Name of the neighbor-system
	 */
<span class="nc" id="L66">	private String mName = null;</span>

	/**
	 * Holds all AdditionalAddress objects of this neighbor-system. Each object
	 * stored as value against the name of this neigbor-system.
	 * &lt;p&gt;
	 * &lt;i&gt;Example: &lt;/i&gt; &lt;table border&gt;
	 * &lt;tr&gt;
	 * &lt;th&gt;Key&lt;/th&gt;
	 * &lt;th&gt;Value&lt;/th&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;PartsOrderAutoline&lt;/td&gt;
	 * &lt;td&gt;new Dealer()&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;/table
	 */
<span class="nc" id="L83">	private static Hashtable mAdditionalAddressImplementations = new Hashtable();</span>

	/**
	 * &lt;code&gt;mMinAge&lt;/code&gt; can be used to filter data sources due to their
	 * age to ignore all those, which are too fresh. This can be used for access
	 * synchronisation: Putting in the maximum time for constructing a file
	 * ensures that the file transfer does not start while during writing the
	 * file. The value is in milliseconds.
	 */
	private int mMinAge;

	/**
	 * &lt;code&gt;mMaxAge&lt;/code&gt; can be used to filter data sources due to their
	 * age to ignore all those, which are too old. This can be used for ignoring
	 * outdated data sources from former failed data transfers. The value is in
	 * milliseconds.
	 */
	private int mMaxAge;

	/**
	 * Constructs the &lt;code&gt;XBUSSystem&lt;/code&gt; without an address.
	 * 
	 * @param name name of the neighbor-system
	 */
	public XBUSSystem(String name) throws XException
<span class="nc" id="L108">	{</span>
<span class="nc" id="L109">		mName = name;</span>

		// Look for the (optional) restrictions to data source age.
<span class="nc" id="L112">		Configuration config = Configuration.getInstance();</span>
<span class="nc" id="L113">		mMinAge = config.getValueAsIntOptional(Constants.CHAPTER_SYSTEM, name,</span>
				&quot;MinAge&quot;) * 1000;
<span class="nc" id="L115">		mMaxAge = config.getValueAsIntOptional(Constants.CHAPTER_SYSTEM, name,</span>
				&quot;MaxAge&quot;) * 1000;
<span class="nc" id="L117">	} // XBUSSystem(String name)</span>

	/**
	 * Constructs the &lt;code&gt;XBUSSystem&lt;/code&gt; from the name fo the
	 * neighbor-system and all address informations for this system
	 * 
	 * @param name name of the neighbor-system
	 * @param addresses name of the address
	 */
	public XBUSSystem(String name, Hashtable addresses) throws XException
	{
<span class="nc" id="L128">		this(name);</span>

<span class="nc" id="L130">		mAddresses = addresses;</span>
<span class="nc" id="L131">	} // XBUSSystem(String name, Hashtable addresses)</span>

	/**
	 * Constructs the &lt;code&gt;XBUSSystem&lt;/code&gt; from the name fo the
	 * neighbor-system and all address informations for this system and the flag
	 * if a broadcast is requested to this system. The addresses do not
	 * necessarily contain the reference to additional address information
	 * necessary for a broadcast.
	 * 
	 * @param name name of the neighbor-system
	 * @param addresses name of the address
	 * @param broadcast is broadcast to be done when sending?
	 */
	public XBUSSystem(String name, Hashtable addresses, boolean broadcast)
			throws XException
	{
<span class="nc" id="L147">		this(name, addresses);</span>

<span class="nc" id="L149">		mBroadcast = broadcast;</span>
<span class="nc" id="L150">	} // XBUSSystem(String name, Hashtable addresses, boolean broadcast)</span>

	/**
	 * Returns the name of the neighbor-system.
	 * 
	 * @return name of the neighbor-system
	 */
	public String getName()
	{
<span class="nc" id="L159">		return mName;</span>
	} // getName()

	/**
	 * Returns all address informations of the neighbor-system. Each address
	 * stored as value against its typ.
	 * &lt;p&gt;
	 * &lt;i&gt;Example: &lt;/i&gt;
	 * &lt;p&gt;
	 * &lt;table border&gt;
	 * &lt;tr&gt;
	 * &lt;th&gt;Key&lt;/th&gt;
	 * &lt;th&gt;Value&lt;/th&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;AddressImplementation&lt;/td&gt;
	 * &lt;td&gt;Test/Wholesale/std$DEALERNUMBER$.cnf&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;WILDCARD&lt;/td&gt;
	 * &lt;td&gt;parts&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;tr&gt;
	 * &lt;td&gt;user&lt;/td&gt;
	 * &lt;td&gt;KS&lt;/td&gt;
	 * &lt;/tr&gt;
	 * &lt;/table&gt;
	 * 
	 * @return all addresses of the neighbor-system
	 */
	public Hashtable getAddresses()
	{
<span class="nc" id="L191">		return mAddresses;</span>
	} // getAddresses()

	/**
	 * Sets all address informations for the neighbor-system.
	 * 
	 * @param addresses Hashtable of the addresses
	 */
	/*
	 * private void setAddresses(Hashtable addresses) { mAddresses = addresses; } //
	 * setAddresses(Hashtable addresses)
	 */
	/**
	 * Sets one address information of the neighbor-system.
	 * 
	 * @param name typ of additional information
	 * @param address additional inrformation eventually containing markers with
	 *            the format &lt;code&gt;$key$&lt;/code&gt;.
	 */
	public void setAddress(String name, String address)
	{
<span class="nc" id="L212">		mAddresses.put(name, address);</span>
<span class="nc" id="L213">	} // setAddress(String name, String address)</span>

	/**
	 * &lt;dl&gt;
	 * &lt;dt&gt;Returns the concatenation of name and all addresses of the
	 * neighbor-system by &lt;b&gt;&quot;_&quot; &lt;/b&gt; separated.
	 * &lt;dd&gt;&lt;i&gt;Example: &lt;/i&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;PartsOrderAutoline_12345
	 * &lt;p&gt;
	 * &lt;dt&gt;If no address information is found, the name of the neighbor-system
	 * will be returned. &lt;br&gt;
	 * &lt;dd&gt;&lt;i&gt;Example: &lt;/i&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;PartsOrderAutoline
	 * &lt;p&gt;
	 * &lt;/dl&gt;
	 * 
	 * @return concatenation of name and all addresses of the neighbor-system or
	 *         only name if addresses are not exist
	 */
	public String getCompleteName()
	{
		String retString;

<span class="nc bnc" id="L234" title="All 2 branches missed.">		if (mAddresses.isEmpty())</span>
		{
<span class="nc" id="L236">			retString = mName;</span>
		}
		else
		{
<span class="nc" id="L240">			StringBuffer retStringBuffer = new StringBuffer(mName);</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">			for (Enumeration e = mAddresses.keys(); e.hasMoreElements();)</span>
			{
<span class="nc" id="L243">				retStringBuffer.append(&quot;_&quot;);</span>
<span class="nc" id="L244">				retStringBuffer.append(mAddresses.get(e.nextElement()));</span>
			}
<span class="nc" id="L246">			retString = retStringBuffer.toString();</span>
		}
<span class="nc" id="L248">		return retString;</span>
	} // getCompleteName()

	/**
	 * Is a braodcast requested for all recorded addtional addresses when
	 * sending data to this system?
	 */
	public boolean getBroadcast()
	{
<span class="nc" id="L257">		return mBroadcast;</span>
	} // getBroadcast()

	/**
	 * Get the maximal age of the data source. The value is in milliseconds.
	 */
	public int getMaxAge()
	{
<span class="nc" id="L265">		return mMaxAge;</span>
	} // getMaxAge()

	/**
	 * Get the minimal age of the data source. The value is in milliseconds.
	 */
	public int getMinAge()
	{
<span class="nc" id="L273">		return mMinAge;</span>
	} // getMinAge()

	/**
	 * The given text may contain place markers which will be replaced with
	 * their actual values. Three types of markers are possible:
	 * &lt;ul&gt;
	 * &lt;li&gt;Additional informations which have been set with the
	 * {@link #setAddress(String, String)}method. The key set there is
	 * interpreted as a marker with the format &lt;code&gt;$key$&lt;/code&gt;.
	 * &lt;li&gt;WILDCARD separator
	 * &lt;li&gt;Markers for informations on the address. These markers will be
	 * replaced with their actual values for the address of the neighbor-system.
	 * &lt;br&gt;
	 * The implementation of this functionality is realized in a dedicated
	 * class, implementing the interface {@link AdditionalAddress}.&lt;br/&gt;A
	 * broadcast is possible in sending using the addtional address information.
	 * That is the reason for the array return type. Withoout braoadcast only
	 * the first array element is filled.
	 * &lt;/ul&gt;
	 * &lt;p&gt;
	 * &lt;b&gt;&lt;i&gt;Note: &lt;/i&gt; &lt;/b&gt;If no marker is found, the text will be returned
	 * without modifications.
	 * 
	 * @param text text containing markers
	 * @return text array with replacements for markers or without modifications
	 *         if no marker is found.
	 * @exception XException if the entry is not found or any error occurs
	 */
	public String[] replaceAllMarkers(String text) throws XException
	{
<span class="nc" id="L304">		text = XStringSupport.replaceAll(text, TIMESTAMP, Constants</span>
<span class="nc" id="L305">				.getDateAsString());</span>

		/*
		 * 1. Search if a marker in the table of additional values is found. If
		 * yes, replace it.
		 */
<span class="nc" id="L311">		String key = null;</span>
<span class="nc" id="L312">		String marker = null;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">		for (Enumeration e = mAddresses.keys(); e.hasMoreElements();)</span>
		{
<span class="nc" id="L315">			key = (String) e.nextElement();</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">			if (!key.equals(ADDITIONAL_ADDRESS)</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">					&amp;&amp; !key.equals(FILENAME_WILDCARD))</span>
			{
<span class="nc" id="L319">				marker = &quot;$&quot; + key + &quot;$&quot;;</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">				if (text.indexOf(marker) &gt;= 0)</span>
				{
<span class="nc" id="L322">					text = text</span>
<span class="nc" id="L323">							.replaceAll(marker, (String) mAddresses.get(key));</span>
				}
			}
		}

		/*
		 * 2. Search if a WILDCARD separator in the table is found. If yes,
		 * replace it
		 */
<span class="nc bnc" id="L332" title="All 2 branches missed.">		if (mAddresses.containsKey(FILENAME_WILDCARD))</span>
		{
<span class="nc bnc" id="L334" title="All 2 branches missed.">			if (text.indexOf(FILENAME_WILDCARD) &gt;= 0)</span>
			{
<span class="nc" id="L336">				text = XStringSupport.replaceAll(text, FILENAME_WILDCARD,</span>
<span class="nc" id="L337">						(String) mAddresses.get(FILENAME_WILDCARD));</span>
			}
		}

		/*
		 * 3. If the XBUSSystem contains an address information, replace markers
		 * for this address.
		 */
<span class="nc bnc" id="L345" title="All 2 branches missed.">		if (mAddresses.containsKey(ADDITIONAL_ADDRESS))</span>
		{

<span class="nc" id="L348">			AdditionalAddress addAddress = getAdditionalAddressImplementation(getName());</span>

<span class="nc bnc" id="L350" title="All 2 branches missed.">			if (addAddress.hasMarker(text))</span>
			{ // The string contains a marker for additional address
				// information.
<span class="nc bnc" id="L353" title="All 2 branches missed.">				if (mBroadcast)</span>
				{ // For broadcast construct one string for each addiotinal
					// address.
<span class="nc" id="L356">					List addAddresses = addAddress.getAddresses();</span>
<span class="nc" id="L357">					int quantAddresses = addAddresses.size();</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">					if (quantAddresses &lt; 1)</span>
					{ // No additional addresses specified in configuration.
<span class="nc" id="L360">						List params = new Vector();</span>
<span class="nc" id="L361">						params.add(mName);</span>
<span class="nc" id="L362">						params.add(text);</span>
<span class="nc" id="L363">						throw new XException(Constants.LOCATION_INTERN,</span>
								Constants.LAYER_BASE,
								Constants.PACKAGE_BASE_XBUSSYSTEM, &quot;5&quot;, params);
					} // if (quantAddresses&lt;1)
<span class="nc" id="L367">					String[] result = new String[quantAddresses];</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">					for (int i = 0; i &lt; quantAddresses; i++)</span>
<span class="nc" id="L369">						result[i] = addAddress.replaceMarker(text,</span>
<span class="nc" id="L370">								(String) addAddresses.get(i));</span>
<span class="nc" id="L371">					return result;</span>
				} // then (mBroadcast)
				else
				{ // Simple addtional address without broadcast.
<span class="nc" id="L375">					String[] result =</span>
<span class="nc" id="L376">					{addAddress.replaceMarker(text, (String) mAddresses</span>
<span class="nc" id="L377">							.get(ADDITIONAL_ADDRESS))};</span>
<span class="nc" id="L378">					return result;</span>
				} // else (mBroadcast)
			} // then addAddress.hasMarker(text)
			else
			{ // No addtional address marker.
<span class="nc" id="L383">				String[] result =</span>
				{text};
<span class="nc" id="L385">				return result;</span>
			} // else (addAddress.hasMarker(text))
		} // then (mAddresses.containsKey(ADDITIONAL_ADDRESS))
		else
		{ // No addtional address at all.
<span class="nc" id="L390">			String[] result =</span>
			{text};
<span class="nc" id="L392">			return result;</span>
		} // else (mAddresses.containsKey(ADDITIONAL_ADDRESS))

	} // replaceAllMarkers(String text)

	/**
	 * Returns the concatenation of name and address of the neighbor-system.
	 * 
	 * @see #getCompleteName()
	 * @return concatenation of name and address of the neighbor-system or only
	 *         name if address is not exist
	 */
	public String toString()
	{
<span class="nc" id="L406">		return getCompleteName();</span>
	} // toString()

	/**
	 * Returns a list of &lt;code&gt;XBUSSystems&lt;/code&gt;, generated through the
	 * replacing of all possible place markers.
	 * &lt;p&gt;
	 * &lt;b&gt;&lt;i&gt;Note: &lt;/i&gt; &lt;/b&gt;If there are no place markers in the given text,
	 * only one system with an empty address is in that list.
	 * 
	 * @param name the name of the system
	 * @param text eventually containing place markers
	 * @return list of &lt;code&gt;XBUSSystems&lt;/code&gt;
	 * @exception XException if any error occurs
	 */
	static public List getSystems(String name, String text) throws XException
	{
		/*
		 * 1. check if the given text contains place markers for informations on
		 * the address, then store list of all configured addresses
		 */

<span class="nc" id="L428">		Vector additionalAddresses = null;</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">		if (hasAdditionalAddressMarker(name, text))</span>
		{
<span class="nc" id="L431">			additionalAddresses = new Vector();</span>

<span class="nc" id="L433">			List addresses = getAdditionalAddresses(name);</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">			for (Iterator it = addresses.iterator(); it.hasNext();)</span>
			{
<span class="nc" id="L436">				additionalAddresses.add(it.next());</span>
			}
		}

		/*
		 * 2. check if the given text contains WILDCARD separator
		 * 
		 */
<span class="nc" id="L444">		List addressVector = null;</span>
<span class="nc" id="L445">		Hashtable addressTable = null;</span>

<span class="nc bnc" id="L447" title="All 2 branches missed.">		if (text.indexOf(XBUSSystem.FILENAME_WILDCARD) &gt;= 0)</span>
		{
			// there is no additional informations yet
<span class="nc bnc" id="L450" title="All 2 branches missed.">			if ((additionalAddresses == null)</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">					|| (additionalAddresses.isEmpty()))</span>
			{
<span class="nc" id="L453">				FileAcceptor acceptor = new FileAcceptor(text);</span>
				// get an array of strings naming the files and directories in
				// the directory
				// denoted by this abstract pathname that were accepted by the
				// FileAcceptor filter.
<span class="nc" id="L458">				String[] dummy = new File(text).getParentFile().list(acceptor);</span>
<span class="nc" id="L459">				String message = &quot;Found files&quot;;</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">				if (dummy != null)</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">					for (int i = 0; i &lt; dummy.length; i++)</span>
<span class="nc" id="L462">						message = message + &quot; &quot; + dummy[i];</span>
				// save all replacements (wildcards) in vector
<span class="nc" id="L464">				addressVector = acceptor.getReplacements();</span>
<span class="nc" id="L465">			}</span>
			else
			{
<span class="nc" id="L468">				addressTable = new Hashtable();</span>
				// get additional address implementation for this system
<span class="nc" id="L470">				AdditionalAddress additionalAddressImpl = getAdditionalAddressImplementation(name);</span>
				// replace place markers in each address
<span class="nc bnc" id="L472" title="All 2 branches missed.">				for (Iterator it = additionalAddresses.iterator(); it.hasNext();)</span>
				{
<span class="nc" id="L474">					String additionalAddress = (String) it.next();</span>
<span class="nc" id="L475">					String filename = additionalAddressImpl.replaceMarker(text,</span>
							additionalAddress);

					// initializte filename filter for this filename
<span class="nc" id="L479">					FileAcceptor acceptor = new FileAcceptor(filename);</span>
					// get an array of strings naming the files and directories
					// in the directory denoted by this abstract pathname that
					// were accepted by the FileAcceptor filter.
<span class="nc" id="L483">					String[] dummy = new File(filename).getParentFile().list(</span>
							acceptor);
<span class="nc" id="L485">					String message = &quot;Found files&quot;;</span>
<span class="nc bnc" id="L486" title="All 4 branches missed.">					for (int i = 0; dummy != null &amp;&amp; i &lt; dummy.length; i++)</span>
<span class="nc" id="L487">						message = message + &quot; &quot; + dummy[i];</span>
<span class="nc" id="L488">					addressTable.put(additionalAddress, acceptor</span>
<span class="nc" id="L489">							.getReplacements());</span>
<span class="nc" id="L490">				}</span>
			}
		}

		/*
		 * 3. construct a system vector a: put each address with its type in
		 * hashtable b: encapsulate this table with name of the system in
		 * XBUSSystem object c: and store this object in vector
		 */
<span class="nc" id="L499">		Vector retSystems = new Vector();</span>
		// there are only wildcards
<span class="nc bnc" id="L501" title="All 2 branches missed.">		if (addressVector != null)</span>
		{
<span class="nc bnc" id="L503" title="All 2 branches missed.">			for (Iterator it = addressVector.iterator(); it.hasNext();)</span>
			{
<span class="nc" id="L505">				Hashtable addresses = new Hashtable();</span>
<span class="nc" id="L506">				addresses.put(FILENAME_WILDCARD, it.next());</span>
<span class="nc" id="L507">				retSystems.add(new XBUSSystem(name, addresses));</span>
<span class="nc" id="L508">			}</span>
		}
		// there are also address implementations
<span class="nc bnc" id="L511" title="All 2 branches missed.">		else if (addressTable != null)</span>
		{
<span class="nc bnc" id="L513" title="All 2 branches missed.">			for (Enumeration e = addressTable.keys(); e.hasMoreElements();)</span>
			{
<span class="nc" id="L515">				String additionalAddress = (String) e.nextElement();</span>
<span class="nc" id="L516">				List wildcardReplacements = (List) addressTable</span>
<span class="nc" id="L517">						.get(additionalAddress);</span>
<span class="nc" id="L518">				for (Iterator it = wildcardReplacements.iterator(); it</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">						.hasNext();)</span>
				{
<span class="nc" id="L521">					Hashtable addresses = new Hashtable();</span>
<span class="nc" id="L522">					addresses.put(ADDITIONAL_ADDRESS, additionalAddress);</span>
<span class="nc" id="L523">					addresses.put(FILENAME_WILDCARD, it.next());</span>
<span class="nc" id="L524">					retSystems.add(new XBUSSystem(name, addresses));</span>
<span class="nc" id="L525">				}</span>

<span class="nc" id="L527">			}</span>
		}
		// if only additional address implementation exist
<span class="nc bnc" id="L530" title="All 2 branches missed.">		else if (additionalAddresses != null)</span>
		{
<span class="nc bnc" id="L532" title="All 2 branches missed.">			for (Iterator it = additionalAddresses.iterator(); it.hasNext();)</span>
			{
<span class="nc" id="L534">				Hashtable addresses = new Hashtable();</span>
<span class="nc" id="L535">				addresses.put(ADDITIONAL_ADDRESS, it.next());</span>
<span class="nc" id="L536">				retSystems.add(new XBUSSystem(name, addresses));</span>
<span class="nc" id="L537">			}</span>
		}
		// there is no addresses exist
		else
		{
<span class="nc" id="L542">			retSystems.add(new XBUSSystem(name));</span>
		}
<span class="nc" id="L544">		return retSystems;</span>
	}

	/**
	 * Tests if the given text contains place markers for informations on the
	 * address.
	 * &lt;p&gt;
	 * The implementation of this functionality is realized in a dedicated
	 * class, implementing the {@link net.sf.xbus.base.AdditionalAddress}
	 * interface.
	 * 
	 * @see #getAdditionalAddressImplementation(String)
	 * @param systemNAme name of the system
	 * @param text text eventually containing markers
	 * @return true if text contains markers; false otherwise
	 * @exception XException if any error occurs
	 */
	static private boolean hasAdditionalAddressMarker(String systemName,
			String text) throws XException
	{
<span class="nc" id="L564">		AdditionalAddress additionalAddressImplementation = getAdditionalAddressImplementation(systemName);</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">		if (additionalAddressImplementation != null)</span>
		{
<span class="nc" id="L567">			return additionalAddressImplementation.hasMarker(text);</span>
		}
		else
		{
<span class="nc" id="L571">			return false;</span>
		}
	} // hasAdditionalAddressMarker(String systemName,String text)

	/**
	 * Returns a list of all configured addresses for the given system name.
	 * &lt;p&gt;
	 * The implementation of this functionality is realized in a dedicated
	 * class, implementing the {@link net.sf.xbus.base.AdditionalAddress}
	 * interface.
	 * 
	 * @see #getAdditionalAddressImplementation(String)
	 * @param systemName the name of the system
	 * @return list of addresses
	 * @exception XException if any error occurs
	 */
	static private List getAdditionalAddresses(String systemName)
			throws XException
	{
<span class="nc" id="L590">		return getAdditionalAddressImplementation(systemName).getAddresses();</span>
	} // getAdditionalAddresses(String systemName)

	/**
	 * Gets the address implementation ({@link AdditionalAddress}) for the
	 * given system name.
	 * &lt;p&gt;
	 * &lt;b&gt;&lt;i&gt;Note: &lt;/i&gt; &lt;/b&gt; If there is no address implementation for the
	 * given system created yet, then creates this method one first. &lt;br&gt;
	 * Address implementation name is read from the configuration: &lt;br&gt;
	 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;b&gt;System_ &lt;/b&gt; &lt;i&gt;SystemName
	 * &lt;/i&gt; &lt;b&gt;_AddressImplementation &lt;/b&gt; &lt;br&gt;
	 * If there is no implementation for the address is provided with this
	 * system, there must be a global entry used.: &lt;br&gt;
	 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
	 * &lt;b&gt;Base_System_AddressImplementation &lt;/b&gt;
	 * 
	 * @param systemName the name of the system
	 * @return address implementation ({@link AdditionalAddress}) for the
	 *         given system name
	 * @exception XException if any error occurs
	 */
	public static AdditionalAddress getAdditionalAddressImplementation(
			String systemName) throws XException
	{
<span class="nc bnc" id="L615" title="All 2 branches missed.">		if (!mAdditionalAddressImplementations.contains(systemName))</span>
		{
			/*
			 * If there is no address implementation for the current system
			 * created yet, we will create it and put it in the Hashtable.
			 */

<span class="nc" id="L622">			Configuration config = Configuration.getInstance();</span>
			/*
			 * If an implementation for the address is provided with the system,
			 * than this implementation is getting used.
			 */

<span class="nc" id="L628">			String addressImplementationNameShort = config.getValueOptional(</span>
					Constants.CHAPTER_SYSTEM, systemName, ADDITIONAL_ADDRESS);

<span class="nc bnc" id="L631" title="All 2 branches missed.">			if (addressImplementationNameShort == null)</span>
			{
				/*
				 * If there is no system specific implementation, there maybe is
				 * a global entry.
				 */
<span class="nc" id="L637">				addressImplementationNameShort = config.getValueOptional(</span>
						&quot;Base&quot;, Constants.CHAPTER_SYSTEM, ADDITIONAL_ADDRESS);

			}

<span class="nc bnc" id="L642" title="All 2 branches missed.">			if (addressImplementationNameShort != null)</span>
			{
<span class="nc" id="L644">				String addressImplementationName = Configuration.getClass(</span>
						&quot;AdressImplementation&quot;, addressImplementationNameShort);

<span class="nc" id="L647">				mAdditionalAddressImplementations.put(systemName,</span>
						ReflectionSupport
<span class="nc" id="L649">								.createObject(addressImplementationName));</span>
			}
		}

<span class="nc" id="L653">		return (AdditionalAddress) mAdditionalAddressImplementations</span>
<span class="nc" id="L654">				.get(systemName);</span>
	} // getAdditionalAddressImplementation(String systemName)

	/**
	 * Check if the given address string does contain a reference to addtional
	 * address information. Update the list of addresses and broadcast flag
	 * accordingly.
	 * 
	 * @param text the address text (e.g. file path)
	 */
	public void getBroadcastData(String text) throws XException
	{
<span class="nc bnc" id="L666" title="All 2 branches missed.">		if (hasAdditionalAddressMarker(mName, text))</span>
			// Reference to additional addresses given.
<span class="nc" id="L668">			mAddresses.put(ADDITIONAL_ADDRESS, &quot;broadcast&quot;);</span>
		else
			// No reference to additional addresses given.
<span class="nc" id="L671">			mBroadcast = false;</span>
<span class="nc" id="L672">	} // getBroadcastData(String text)</span>

} // XBUSSystem

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>