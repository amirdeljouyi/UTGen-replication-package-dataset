<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CSVParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">83_xbus</a> &gt; <a href="index.source.html" class="el_package">net.sf.xbus.protocol.csv</a> &gt; <span class="el_source">CSVParser.java</span></div><h1>CSVParser.java</h1><pre class="source lang-java linenums">/*
 * Created on 04.10.2004
 */

package net.sf.xbus.protocol.csv;

import java.io.File;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import net.sf.xbus.base.core.Constants;
import net.sf.xbus.base.core.XException;
import net.sf.xbus.base.core.config.Configuration;
import net.sf.xbus.base.xml.XDomSupport;

import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 * &lt;p&gt;
 * The &lt;code&gt;CSVParser&lt;/code&gt; class contains all methods necessary for parsing
 * CSV format into an XML representation.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This parser supports all CSV format content which satisfies the rules
 * indicated in &lt;a href=&quot;http://www.edoceo.com/utilis/csv-file-format.php&quot;&gt;this
 * CSV definition &lt;/a&gt;.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The parsing result is a DOM tree with the following structure:
 * &lt;/p&gt;
 * &lt;p&gt;
 * &amp;lt;InterfaceName&amp;gt; &lt;dir&gt;&amp;lt;+ &lt;i&gt;Header &lt;/i&gt;+&amp;gt; &lt;dir&gt;&amp;lt;+ &lt;i&gt;heading
 * &lt;/i&gt;+&amp;gt;+ &lt;b&gt;FieldValue &lt;/b&gt;+&amp;lt;/+ &lt;i&gt;heading &lt;/i&gt;+&amp;gt; &lt;br&gt;
 * ... &lt;/dir&gt; &amp;lt;/+ &lt;i&gt;Header &lt;/i&gt;+&amp;gt; &lt;/dir&gt; &lt;dir&gt;&amp;lt;Records&amp;gt; &lt;dir&gt;&amp;lt;+
 * &lt;i&gt;Record &lt;/i&gt;+&amp;gt; &lt;dir&gt;&amp;lt;+ &lt;i&gt;FieldName &lt;/i&gt;+&amp;gt;+ &lt;b&gt;FieldValue
 * &lt;/b&gt;+&amp;lt;/+ &lt;i&gt;FieldName &lt;/i&gt;+&amp;gt; &lt;br&gt;
 * ... &lt;/dir&gt; &amp;lt;/+ &lt;i&gt;Record &lt;/i&gt;+&amp;gt; &lt;br&gt;
 * ... &lt;/dir&gt; &amp;lt;/Records&amp;gt; &lt;/dir&gt; &amp;lt;/InterfaceName&amp;gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * The header is optional. For every entry a Record tag structure is created.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The information for the names and values of the DOM entities are taken out of
 * the CSV source text and the optional Description file. A description file
 * must be valid (InterfaceSpecCSV.dtd).
 * &lt;/p&gt;
 * &lt;p&gt;
 * The following table gives an overview, how the Header information and the
 * names of the entry tags are selected:
 * &lt;/p&gt;
 * 
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;tr&gt;
 * &lt;td colspan=&quot;2&quot;&gt;&lt;b&gt;CSV file &lt;/b&gt;&lt;/td&gt;
 * &lt;td colspan=&quot;5&quot;&gt;&lt;b&gt;Description file &lt;/b&gt;&lt;/td&gt;
 * &lt;td colspan=&quot;2&quot;&gt;&lt;b&gt;Result &lt;/b&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr  align=&quot;center&quot;&gt;
 * &lt;td&gt;has header&lt;/td&gt;
 * &lt;td&gt;does not contain header&lt;/td&gt;
 * &lt;td&gt;No description file&lt;/td&gt;
 * &lt;td&gt;does not contain any information&lt;/td&gt;
 * &lt;td&gt;contains only Header information&lt;/td&gt;
 * &lt;td&gt;contains only Records information&lt;/td&gt;
 * &lt;td&gt;contains Header and Records information&lt;/td&gt;
 * &lt;td&gt;&lt;b&gt;Header information taken from: &lt;/b&gt;&lt;/td&gt;
 * &lt;td&gt;&lt;b&gt;Tag names of entries taken from: &lt;/b&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr align=&quot;center&quot;&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;CSV header&lt;/td&gt;
 * &lt;td&gt;CSV header&lt;/td&gt;
 * &lt;/tr&gt;
 * 
 * &lt;tr align=&quot;center&quot;&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;CSV header&lt;/td&gt;
 * &lt;td&gt;CSV header&lt;/td&gt;
 * &lt;/tr&gt;
 * 
 * &lt;tr align=&quot;center&quot;&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;Description file&lt;/td&gt;
 * &lt;td&gt;Header information in description file&lt;/td&gt;
 * &lt;/tr&gt;
 * 
 * &lt;tr align=&quot;center&quot;&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;CSV header&lt;/td&gt;
 * &lt;td&gt;Records information in description file&lt;/td&gt;
 * &lt;/tr&gt;
 * 
 * &lt;tr align=&quot;center&quot;&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;Description file&lt;/td&gt;
 * &lt;td&gt;Records information in description file&lt;/td&gt;
 * &lt;/tr&gt;
 * 
 * &lt;tr align=&quot;center&quot;&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;No header&lt;/td&gt;
 * &lt;td&gt;Tag name = &amp;quot;field&amp;quot;&lt;/td&gt;
 * &lt;/tr&gt;
 * 
 * &lt;tr align=&quot;center&quot;&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;No header&lt;/td&gt;
 * &lt;td&gt;Tag name = &amp;quot;field&amp;quot;&lt;/td&gt;
 * &lt;/tr&gt;
 * 
 * &lt;tr align=&quot;center&quot;&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;Description file&lt;/td&gt;
 * &lt;td&gt;Header information in description file&lt;/td&gt;
 * &lt;/tr&gt;
 * 
 * &lt;tr align=&quot;center&quot;&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;No header&lt;/td&gt;
 * &lt;td&gt;Records information in description file&lt;/td&gt;
 * &lt;/tr&gt;
 * 
 * &lt;tr align=&quot;center&quot;&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;&amp;nbsp;&lt;/td&gt;
 * &lt;td&gt;X&lt;/td&gt;
 * &lt;td&gt;Description file&lt;/td&gt;
 * &lt;td&gt;Records information in description file&lt;/td&gt;
 * &lt;/tr&gt;* &lt;/table&gt;
 */
public class CSVParser
{
<span class="nc" id="L201">	private static Hashtable instances = new Hashtable();</span>

<span class="nc" id="L203">	private static final Object classLock = CSVParser.class;</span>

	private String fieldSeparator;

	private String quoteChar;

	private boolean hasHeader;

	private String lineSeparator;

<span class="nc" id="L213">	private Document descriptionTree = null;</span>

<span class="nc" id="L215">	private Vector fieldNames = null;</span>

	/**
	 * @param quoteChar
	 *            The quoteChar to set.
	 */
	public void setQuoteChar(String quoteChar)
	{
<span class="nc" id="L223">		this.quoteChar = quoteChar;</span>
<span class="nc" id="L224">	}</span>

	/**
	 * @return Returns the quoteChar.
	 */
	public String getQuoteChar()
	{
<span class="nc" id="L231">		return quoteChar;</span>
	}

	/**
	 * @return Returns the hasHeader.
	 */
	public boolean isHasHeader()
	{
<span class="nc" id="L239">		return hasHeader;</span>
	}

	/**
	 * @param hasHeader
	 *            The hasHeader to set.
	 */
	public void setHasHeader(boolean hasHeader)
	{
<span class="nc" id="L248">		this.hasHeader = hasHeader;</span>
<span class="nc" id="L249">	}</span>

	/**
	 * @param fieldSeparator
	 *            The fieldSeparator to set.
	 */
	public void setFieldSeparator(String fieldSeparator)
	{
<span class="nc" id="L257">		this.fieldSeparator = fieldSeparator;</span>
<span class="nc" id="L258">	}</span>

	/**
	 * @return Returns the fieldSeparator.
	 */
	public String getFieldSeparator()
	{
<span class="nc" id="L265">		return fieldSeparator;</span>
	}

	/**
	 * @param lineSeparator
	 *            The lineSeparator to set.
	 */
	public void setLineSeparator(String lineSeparator)
	{
<span class="nc" id="L274">		this.lineSeparator = lineSeparator;</span>
<span class="nc" id="L275">	}</span>

	/**
	 * @return Returns the lineSeparator.
	 */
	public String getLineSeparator()
	{
<span class="nc" id="L282">		return lineSeparator;</span>
	}

	/**
	 * @return Returns the descriptionTree.
	 */
	public Document getDescriptionTree()
	{
<span class="nc" id="L290">		return descriptionTree;</span>
	}

	/**
	 * @param descriptionTree
	 *            The descriptionTree to set.
	 */
	public void setDescriptionTree(Document descriptionTree)
	{
<span class="nc" id="L299">		this.descriptionTree = descriptionTree;</span>
<span class="nc" id="L300">	}</span>

	/**
	 * @return Returns the headerArray.
	 */
	public Vector getFieldNames()
	{
<span class="nc" id="L307">		return fieldNames;</span>
	}

	/**
	 * @param fieldNames
	 */
	public void setFieldNames(Vector fieldNames)
	{
<span class="nc" id="L315">		this.fieldNames = fieldNames;</span>
<span class="nc" id="L316">	}</span>

	/**
	 * Adds a value to the field names. The field names are the names of the
	 * tags of an entry. If the passed name is not a valid tagname,
	 * &amp;quot;field&amp;quot; is added to the list of names instead of the passed
	 * name. Namespace tag names are also not allowed and replaced bz
	 * &amp;quot;field&amp;quot;
	 * 
	 * @param fieldName
	 *            The field name to add
	 * @throws XException
	 *             If parser configuration is not valid.
	 */
	private void addFieldName(String fieldName) throws XException
	{
<span class="nc bnc" id="L332" title="All 2 branches missed.">		if (getFieldNames() == null)</span>
		{
<span class="nc" id="L334">			setFieldNames(new Vector());</span>
		}
		try
		{
<span class="nc" id="L338">			DocumentBuilderFactory.newInstance().newDocumentBuilder()</span>
<span class="nc" id="L339">					.newDocument().createElement(fieldName);</span>
		}
<span class="nc" id="L341">		catch (DOMException e)</span>
		{ // if fieldName is not a valid tag name
<span class="nc" id="L343">			fieldName = &quot;Field&quot;;</span>
		}
<span class="nc" id="L345">		catch (ParserConfigurationException parserException)</span>
		{
<span class="nc" id="L347">			Vector error = new Vector();</span>
<span class="nc" id="L348">			error.add(parserException.toString());</span>
<span class="nc" id="L349">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV,
					&quot;10&quot;);
<span class="nc" id="L352">		}</span>
		// we do not allow : otherwise namespace declaration would be necessary
<span class="nc bnc" id="L354" title="All 2 branches missed.">		if (fieldName.indexOf(&quot;:&quot;) &gt;= 0)</span>
		{
<span class="nc" id="L356">			fieldName = &quot;Field&quot;;</span>
		}
<span class="nc" id="L358">		getFieldNames().add(fieldName);</span>
<span class="nc" id="L359">	}</span>

	/**
	 * Constructor of the parser. Starts the initialization which loads the
	 * configuration values.
	 * 
	 * @param system
	 *            the name of the process
	 * @throws XException
	 */
	public CSVParser(String system) throws XException
<span class="nc" id="L370">	{</span>
<span class="nc" id="L371">		initialize(system);</span>
<span class="nc" id="L372">	}</span>

	/**
	 * Returns an instance of &lt;code&gt;CSVParser&lt;/code&gt;
	 * 
	 * @param sourceType
	 *            The name of the process
	 * @return An instance of the CSVSerializer class
	 */
	protected static CSVParser getInstance(String sourceType) throws XException
	{
<span class="nc" id="L383">		synchronized (classLock)</span>
		{
<span class="nc bnc" id="L385" title="All 4 branches missed.">			if (sourceType == null || sourceType.length() == 0)</span>
<span class="nc" id="L386">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_CSV, &quot;1&quot;);

<span class="nc" id="L390">			CSVParser instance = (CSVParser) instances.get(Thread</span>
<span class="nc" id="L391">					.currentThread().getName()</span>
					+ sourceType);
<span class="nc bnc" id="L393" title="All 2 branches missed.">			if (instance == null)</span>
			{ // no suitable instance available yet
<span class="nc" id="L395">				instance = new CSVParser(sourceType);</span>
<span class="nc" id="L396">				instances.put(Thread.currentThread().getName() + sourceType,</span>
						instance);
			} // if (instance==null)
<span class="nc" id="L399">			return instance;</span>
		}
	}

	/**
	 * Initializes a CSVParser object by reading and setting the configuration.
	 * Parameters of CSVparser are: fieldSeparator, quoteChar, hasHeader,
	 * lineSeparator and the description file.
	 * 
	 * @param sectionName
	 *            The name of the process to read the values in the
	 *            configuration file from.
	 * @throws XException
	 */
	private void initialize(String sectionName) throws XException
	{
<span class="nc" id="L415">		Configuration config = Configuration.getInstance();</span>
<span class="nc" id="L416">		Configuration xBusConfig = Configuration.getInstance(&quot;xbus&quot;);</span>
<span class="nc" id="L417">		String tempVariable = null;</span>

		// get Field Separator
<span class="nc bnc" id="L420" title="All 2 branches missed.">		if ((fieldSeparator = config.getValueOptional(Constants.CHAPTER_SYSTEM,</span>
				sectionName, Constants.KEY_CSV_FIELD_SEPARATOR)) == null)
		{
<span class="nc" id="L423">			fieldSeparator = xBusConfig.getValue(&quot;MessageDefaults&quot;,</span>
					&quot;CSVMessage&quot;, Constants.KEY_CSV_FIELD_SEPARATOR);
		}

		// get Quote Character
<span class="nc bnc" id="L428" title="All 2 branches missed.">		if ((quoteChar = config.getValueOptional(Constants.CHAPTER_SYSTEM,</span>
				sectionName, Constants.KEY_CSV_QUOTE_CHAR)) == null)
		{
<span class="nc" id="L431">			quoteChar = xBusConfig.getValue(&quot;MessageDefaults&quot;, &quot;CSVMessage&quot;,</span>
					Constants.KEY_CSV_QUOTE_CHAR);
		}

		// get configuration entry if containing header
<span class="nc bnc" id="L436" title="All 2 branches missed.">		if ((tempVariable = config.getValueOptional(Constants.CHAPTER_SYSTEM,</span>
				sectionName, Constants.KEY_CSV_HAS_HEADER)) == null)
		{
<span class="nc" id="L439">			hasHeader = xBusConfig.getValueAsBoolean(&quot;MessageDefaults&quot;,</span>
					&quot;CSVMessage&quot;, Constants.KEY_CSV_HAS_HEADER);
		}
<span class="nc bnc" id="L442" title="All 2 branches missed.">		else if (tempVariable.equalsIgnoreCase(Constants.CONFIGURATION_TRUE))</span>
		{
<span class="nc" id="L444">			hasHeader = true;</span>
		}
		else
		{
<span class="nc" id="L448">			hasHeader = false;</span>
		}

		// set line separator
<span class="nc" id="L452">		lineSeparator = Constants.LINE_SEPERATOR;</span>
<span class="nc" id="L453">		String platform = config.getValueOptional(Constants.CHAPTER_SYSTEM,</span>
				sectionName, &quot;Platform&quot;);
<span class="nc bnc" id="L455" title="All 2 branches missed.">		if (platform != null)</span>
		{
<span class="nc" id="L457">			lineSeparator = Constants.getLineSeperator(platform);</span>
		}

<span class="nc bnc" id="L460" title="All 2 branches missed.">		if ((tempVariable = config.getValueOptional(Constants.CHAPTER_SYSTEM,</span>
				sectionName, Constants.KEY_CSV_DESCRIPTION_FILE)) == null)
		{
<span class="nc" id="L463">			setDescriptionTree(null);</span>
		}
		else
		{
<span class="nc" id="L467">			String fileName = Constants.XBUS_ETC + &quot;InterfaceDescriptions&quot;</span>
					+ Constants.FILE_SEPERATOR + tempVariable;
<span class="nc" id="L469">			File descriptionFile = new File(fileName);</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">			if (!descriptionFile.exists())</span>
			{
<span class="nc" id="L472">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_CSV, &quot;7&quot;);
			}
			try
			{
<span class="nc" id="L478">				DocumentBuilder builder = DocumentBuilderFactory.newInstance()</span>
<span class="nc" id="L479">						.newDocumentBuilder();</span>

<span class="nc" id="L481">				Document doc = builder.parse(descriptionFile);</span>
<span class="nc" id="L482">				XDomSupport.deleteWhitespaceTextInElementNodesAndComments(doc);</span>
<span class="nc" id="L483">				setDescriptionTree(doc);</span>
			}
<span class="nc" id="L485">			catch (Exception e)</span>
			{
<span class="nc" id="L487">				Vector errors = new Vector();</span>
<span class="nc" id="L488">				errors.add(e.toString());</span>
<span class="nc" id="L489">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_CSV, &quot;8&quot;, errors);
<span class="nc" id="L492">			}</span>
		}

<span class="nc" id="L495">	}</span>

	/**
	 * Parses the passed CSV format text into a DOM tree and returns it.
	 * 
	 * @param text
	 *            The source text to parse. Has to be CSV format.
	 * @param systemName
	 *            The name of the process - used as root tag
	 * @return The parsed DOM tree.
	 * @throws XException
	 */
	public Document parse(String text, String systemName) throws XException
	{
<span class="nc" id="L509">		DocumentBuilder builder = null;</span>
		try
		{
<span class="nc" id="L512">			builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();</span>
		}
<span class="nc" id="L514">		catch (Exception e)</span>
		{
<span class="nc" id="L516">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV,
					&quot;13&quot;);
<span class="nc" id="L519">		}</span>
<span class="nc" id="L520">		Document resultDocument = builder.newDocument();</span>

		// create root node &lt;i&gt;systemName&lt;/i&gt;
<span class="nc" id="L523">		Element root = resultDocument.createElement(systemName);</span>
<span class="nc" id="L524">		resultDocument.appendChild(root);</span>

		// separate the entries
<span class="nc" id="L527">		Vector lines = returnSeparatedEntries(text);</span>
<span class="nc" id="L528">		int lineCounter = 0;</span>

<span class="nc" id="L530">		boolean useHeaderAsTagName = true;</span>
<span class="nc bnc" id="L531" title="All 4 branches missed.">		if ((searchTagInDescriptionFile(&quot;Records&quot;)) &amp;&amp; (fieldNames == null))</span>
		{
<span class="nc" id="L533">			writeFieldNamesOutOfDescriptionFile();</span>
<span class="nc" id="L534">			useHeaderAsTagName = false;</span>
		}
<span class="nc bnc" id="L536" title="All 2 branches missed.">		if (searchTagInDescriptionFile(&quot;Header&quot;))</span>
		{
<span class="nc bnc" id="L538" title="All 4 branches missed.">			writeHeaderInformation(returnHeaderOfDescriptionFile(),</span>
					resultDocument, root, (useHeaderAsTagName &amp;&amp; (fieldNames == null)));
		}
<span class="nc bnc" id="L541" title="All 2 branches missed.">		else if (isHasHeader())</span>
		{// only hasHeader
<span class="nc" id="L543">			Vector headerVector = parseOneLine(lines.get(lineCounter));</span>
<span class="nc" id="L544">			writeHeaderInformation(headerVector, resultDocument, root,</span>
					useHeaderAsTagName);
		}// isHasHeader()

		// first Line is not content - skip!
<span class="nc bnc" id="L549" title="All 2 branches missed.">		if (isHasHeader())</span>
		{
<span class="nc" id="L551">			lineCounter++;</span>
		}

<span class="nc" id="L554">		Element records = resultDocument.createElement(&quot;Records&quot;);</span>
<span class="nc" id="L555">		root.appendChild(records);</span>

		// go through the entries and parse every single one of them
<span class="nc bnc" id="L558" title="All 2 branches missed.">		for (; lineCounter &lt; lines.size(); lineCounter++)</span>
		{
<span class="nc" id="L560">			Vector lineValues = parseOneLine(lines.get(lineCounter));</span>
<span class="nc" id="L561">			writeOneRecord(lineValues, resultDocument, records);</span>
		}

<span class="nc" id="L564">		return resultDocument;</span>
	}

	/**
	 * Writes the header information into the DOM tree.
	 * 
	 * @param contentVector
	 *            The values of the header.
	 * @param document
	 *            The result document
	 * @param root
	 *            The root node of the document (usually systemName)
	 * @param writeFieldNames
	 *            If the header names should also be used as field tag names.
	 * @throws XException
	 */
	private void writeHeaderInformation(Vector contentVector,
			Document document, Node root, boolean writeFieldNames)
			throws XException
	{
<span class="nc" id="L584">		Element header = document.createElement(&quot;Header&quot;);</span>
<span class="nc" id="L585">		root.appendChild(header);</span>
<span class="nc" id="L586">		Enumeration e = contentVector.elements();</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">		while (e.hasMoreElements())</span>
		{
<span class="nc" id="L589">			String element = getStringOutOfObject(e.nextElement());</span>
<span class="nc" id="L590">			Element elem = document.createElement(&quot;Heading&quot;);</span>
<span class="nc" id="L591">			Node textElem = document.createTextNode(element);</span>
<span class="nc" id="L592">			header.appendChild(elem);</span>
<span class="nc" id="L593">			elem.appendChild(textElem);</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">			if (writeFieldNames)</span>
			{
<span class="nc" id="L596">				addFieldName(element);</span>
			}
<span class="nc" id="L598">		}</span>
<span class="nc" id="L599">	}</span>

	/**
	 * Separates the text into CSV entries by using the fieldSeparator as
	 * indicator and sticking together again entries which consist of more than
	 * one line
	 * 
	 * @param sourceText
	 *            The text to separate.
	 * @return A Vector containing the entries.
	 * @throws XException
	 *             If last entry does not end correctly before end of text.
	 *             Usually missing quoteChar.
	 */
	private Vector returnSeparatedEntries(String sourceText) throws XException
	{
<span class="nc" id="L615">		Vector entries = new Vector();</span>
<span class="nc" id="L616">		int lineTokenizer = 0;</span>

		// get rid of empty lines(just spaces) in the beginning and the end
<span class="nc" id="L619">		sourceText = sourceText.trim();</span>
<span class="nc" id="L620">		String[] lines = sourceText.split(getLineSeparator());</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">		while (lineTokenizer &lt; lines.length)</span>
		{
			// are we lucky and the line does not contain any line break in a
			// field
			// an odd number of quoteChars indicates that line is not a complete
			// entry
<span class="nc bnc" id="L627" title="All 2 branches missed.">			if ((countOccurencesOfString(getQuoteChar(), lines[lineTokenizer]) % 2) == 0)</span>
			{
<span class="nc" id="L629">				entries.add(lines[lineTokenizer++]);</span>
<span class="nc" id="L630">				continue;</span>
			}

			// we have a line break in the field!
<span class="nc" id="L634">			int startLine = lineTokenizer;</span>
			// run until we get a line without a line break in a field
			try
			{
<span class="nc bnc" id="L638" title="All 2 branches missed.">				while (((countOccurencesOfString(quoteChar,</span>
						lines[++lineTokenizer])) % 2) == 0)
<span class="nc" id="L640">					;</span>
			}
<span class="nc" id="L642">			catch (ArrayIndexOutOfBoundsException e)</span>
			{
<span class="nc" id="L644">				Vector error = new Vector();</span>
<span class="nc" id="L645">				error.add(Integer.toString(lineTokenizer));</span>
<span class="nc" id="L646">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_CSV, &quot;4&quot;, error);
<span class="nc" id="L649">			}</span>

<span class="nc" id="L651">			String buildEntry = &quot;&quot;;</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">			for (int i = startLine; i &lt;= lineTokenizer; i++)</span>
			{
				// add lineSeparator inside text(lost when spliting)
<span class="nc bnc" id="L655" title="All 2 branches missed.">				if (i != startLine)</span>
				{
<span class="nc" id="L657">					buildEntry += getLineSeparator();</span>
				}
<span class="nc" id="L659">				buildEntry += lines[i];</span>
			}
<span class="nc" id="L661">			entries.add(buildEntry);</span>
<span class="nc" id="L662">			lineTokenizer++;</span>
<span class="nc" id="L663">		}</span>
<span class="nc" id="L664">		return entries;</span>
	}

	/**
	 * Parses one entry into the fields and returns them as Vector.
	 * 
	 * @param lineText
	 *            The source text to parse.
	 * @return The parsed fields as Vector.
	 * @throws XException
	 */
	private Vector parseOneLine(Object lineText) throws XException
	{
<span class="nc" id="L677">		Vector returnVector = new Vector();</span>
<span class="nc" id="L678">		int fieldTokenizer = 0;</span>

		// add a space at the end to successfully parse empty fields at the end
		// of line
		// a; b; c; would be interpreted as 3 fields otherwise
<span class="nc" id="L683">		String[] fields = (getStringOutOfObject(lineText) + &quot; &quot;)</span>
<span class="nc" id="L684">				.split(getFieldSeparator());</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">		while (fieldTokenizer &lt; fields.length)</span>
		{
<span class="nc bnc" id="L687" title="All 2 branches missed.">			if ((countOccurencesOfString(getQuoteChar(), fields[fieldTokenizer]) % 2) == 0)</span>
			{
<span class="nc" id="L689">				returnVector.add(fields[fieldTokenizer++]);</span>
<span class="nc" id="L690">				continue;</span>
			}

			// we have a fieldSeparator in the field!
<span class="nc" id="L694">			int startField = fieldTokenizer;</span>
			// run until we get a field without a fieldSeparator
			try
			{
<span class="nc bnc" id="L698" title="All 2 branches missed.">				while (((countOccurencesOfString(getQuoteChar(),</span>
						fields[++fieldTokenizer])) % 2) == 0)
<span class="nc" id="L700">					;</span>
			}
<span class="nc" id="L702">			catch (ArrayIndexOutOfBoundsException e)</span>
			{
<span class="nc" id="L704">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_CSV, &quot;4&quot;);
<span class="nc" id="L707">			}</span>
<span class="nc" id="L708">			String buildEntry = &quot;&quot;;</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">			for (int i = startField; i &lt;= fieldTokenizer; i++)</span>
			{
				// add lineSeparator inside text(lost when spliting)
<span class="nc bnc" id="L712" title="All 2 branches missed.">				if (i != startField)</span>
				{
<span class="nc" id="L714">					buildEntry += getFieldSeparator();</span>
				}
<span class="nc" id="L716">				buildEntry += fields[i];</span>
			}
<span class="nc" id="L718">			returnVector.add(buildEntry);</span>
<span class="nc" id="L719">			fieldTokenizer++;</span>
<span class="nc" id="L720">		}</span>
<span class="nc" id="L721">		returnVector = cleanFields(returnVector);</span>
<span class="nc" id="L722">		return returnVector;</span>
	}

	/**
	 * Parses one record into a document.
	 * 
	 * @param values
	 *            The entries of the record.
	 * @param document
	 *            The document where the nodes have to be integrated.
	 * @param recordsElement
	 *            The root element of the entry fields.
	 * @throws XException
	 *             If the entry does not have the correct number of fields
	 */
	private void writeOneRecord(Vector values, Document document,
			Node recordsElement) throws XException
	{
<span class="nc" id="L740">		Element record = document.createElement(&quot;Record&quot;);</span>
<span class="nc" id="L741">		recordsElement.appendChild(record);</span>
		// we require same number of fields for every entry
		// could be changed if necessary like done for RecordTypeMessage

		// do we have no field declaration (out of header or description file)?
<span class="nc bnc" id="L746" title="All 2 branches missed.">		if (getFieldNames() == null)</span>
		{
			// first entry defines the number of fields
<span class="nc bnc" id="L749" title="All 2 branches missed.">			for (int i = 0; i &lt; values.size(); i++)</span>
			{
<span class="nc" id="L751">				addFieldName(&quot;Field&quot;);</span>
			}
		}
		// does the entry have the correct number of fields?
<span class="nc bnc" id="L755" title="All 2 branches missed.">		if (values.size() != getFieldNames().size())</span>
		{
<span class="nc" id="L757">			Vector error = new Vector();</span>
<span class="nc" id="L758">			error.add(values.toString());</span>
<span class="nc" id="L759">			error.add(Integer.toString(values.size()));</span>
<span class="nc" id="L760">			error.add(Integer.toString(getFieldNames().size()));</span>
<span class="nc" id="L761">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV,
					&quot;12&quot;, error);
		}
		// create node for every field
<span class="nc bnc" id="L766" title="All 2 branches missed.">		for (int i = 0; i &lt; values.size(); i++)</span>
		{
<span class="nc" id="L768">			Element elem = document</span>
<span class="nc" id="L769">					.createElement(getStringOutOfObject(getFieldNames().get(i)));</span>
<span class="nc" id="L770">			Node textElem = document.createTextNode(getStringOutOfObject(values</span>
<span class="nc" id="L771">					.get(i)));</span>
<span class="nc" id="L772">			record.appendChild(elem);</span>
<span class="nc" id="L773">			elem.appendChild(textElem);</span>
		}

<span class="nc" id="L776">	}</span>

	/**
	 * Fetches the field tag names out of the description file
	 * 
	 * @throws XException
	 */
	private void writeFieldNamesOutOfDescriptionFile() throws XException
	{
<span class="nc" id="L785">		Document descriptionTree = getDescriptionTree();</span>
		// get Records Node
<span class="nc" id="L787">		NodeList nodeList = descriptionTree.getElementsByTagName(&quot;Records&quot;);</span>
		// get Record nodes
<span class="nc" id="L789">		nodeList = nodeList.item(0).getChildNodes(); // get record node</span>
<span class="nc" id="L790">		nodeList = nodeList.item(0).getChildNodes(); // get field nodes</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">		for (int i = 0; i &lt; nodeList.getLength(); i++)</span>
		{
<span class="nc" id="L793">			addFieldName(nodeList.item(i).getAttributes().getNamedItem(&quot;Name&quot;)</span>
<span class="nc" id="L794">					.getNodeValue());</span>
		}
<span class="nc" id="L796">	}</span>

	/**
	 * Reads the header out of the description file and returns it als Vector.
	 * 
	 * @return The Header fields as Vector.
	 * @throws XException
	 */
	private Vector returnHeaderOfDescriptionFile() throws XException
	{
<span class="nc" id="L806">		Vector returnVector = new Vector();</span>
<span class="nc" id="L807">		NodeList nodeList = getDescriptionTree().getElementsByTagName(&quot;Header&quot;);</span>
<span class="nc" id="L808">		Node fileHeaderRoot = null;</span>
		try
		{
<span class="nc" id="L811">			fileHeaderRoot = nodeList.item(0);</span>
		}
<span class="nc" id="L813">		catch (ArrayIndexOutOfBoundsException e)</span>
		{
<span class="nc" id="L815">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV,
					&quot;9&quot;);
<span class="nc" id="L818">		}</span>
<span class="nc" id="L819">		nodeList = fileHeaderRoot.getChildNodes();</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">		for (int i = 0; i &lt; nodeList.getLength(); i++)</span>
		{
			try
			{
<span class="nc" id="L824">				returnVector.add(nodeList.item(i).getAttributes().getNamedItem(</span>
<span class="nc" id="L825">						&quot;Name&quot;).getNodeValue());</span>
			}
<span class="nc" id="L827">			catch (DOMException e)</span>
			{
<span class="nc" id="L829">				Vector error = new Vector();</span>
<span class="nc" id="L830">				error.add(e.toString());</span>
<span class="nc" id="L831">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_CSV, &quot;11&quot;, error);
<span class="nc" id="L834">			}</span>

		}
<span class="nc" id="L837">		return returnVector;</span>
	}

	/**
	 * Returns the number of occurence of a pattern in a String.
	 * 
	 * @param pattern
	 *            The search pattern.
	 * @param baseString
	 *            The String to search in.
	 * @return The number of occurences.
	 */
	private int countOccurencesOfString(String pattern, String baseString)
	{
<span class="nc" id="L851">		int count = 0;</span>
<span class="nc" id="L852">		int currentIndex = 0;</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">		while ((currentIndex = baseString.indexOf(pattern, currentIndex)) != -1)</span>
		{
<span class="nc" id="L855">			currentIndex += pattern.length();</span>
<span class="nc" id="L856">			count++;</span>
		}
<span class="nc" id="L858">		return count;</span>
	}

	/**
	 * Cleans the fields from all the unnecessary dust and tests if unallowed
	 * characters exist. Removes leading and trailing white spaces, removes
	 * quoting of fields and replaces double quoteChars with a single.
	 * 
	 * @param sourceVector
	 *            The Vector containing the dirty fields.
	 * @return A Vector with the cleaned entries.
	 * @throws XException
	 *             If unallowed characters exist in fields.
	 */
	private Vector cleanFields(Vector sourceVector) throws XException
	{
<span class="nc" id="L874">		Vector resultVector = new Vector();</span>
<span class="nc" id="L875">		Enumeration e = sourceVector.elements();</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">		while (e.hasMoreElements())</span>
		{
<span class="nc" id="L878">			String fieldString = getStringOutOfObject(e.nextElement());</span>

<span class="nc" id="L880">			fieldString = fieldString.trim();</span>

			// is this a quoted field
<span class="nc bnc" id="L883" title="All 2 branches missed.">			if (fieldString.indexOf(getQuoteChar()) == 0)</span>
			{
				// is there also a quote in the end of the string
<span class="nc" id="L886">				if (fieldString.lastIndexOf(getQuoteChar()) != fieldString</span>
<span class="nc" id="L887">						.length()</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">						- getQuoteChar().length())</span>
				{
<span class="nc" id="L890">					Vector error = new Vector();</span>
<span class="nc" id="L891">					error.add(fieldString);</span>
<span class="nc" id="L892">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_CSV, &quot;14&quot;, error);
				}
<span class="nc" id="L896">				fieldString = fieldString.substring(getQuoteChar().length(),</span>
<span class="nc" id="L897">						fieldString.length() - getQuoteChar().length());</span>
<span class="nc" id="L898">				fieldString = fieldString.replaceAll(getQuoteChar()</span>
<span class="nc" id="L899">						+ getQuoteChar(), getQuoteChar());</span>
			}
			else
			{
				// are unallowed values in field even it has not been quoted?
<span class="nc bnc" id="L904" title="All 2 branches missed.">				if (fieldString.indexOf(getLineSeparator()) &gt;= 0</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">						|| fieldString.indexOf(getQuoteChar()) &gt;= 0)</span>
				{
<span class="nc" id="L907">					Vector error = new Vector();</span>
<span class="nc" id="L908">					error.add(fieldString);</span>
<span class="nc" id="L909">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_CSV, &quot;6&quot;, error);
				}
			}
<span class="nc" id="L914">			resultVector.add(fieldString);</span>
<span class="nc" id="L915">		}</span>
<span class="nc" id="L916">		return resultVector;</span>
	}

	/**
	 * Converts a passed object into a String.
	 * 
	 * @param content
	 *            The object to convert
	 * @return The converted String representation.
	 * @throws XException
	 *             If passed object is not a String.
	 */
	private String getStringOutOfObject(Object content) throws XException
	{
<span class="nc bnc" id="L930" title="All 2 branches missed.">		if (!(content instanceof String))</span>
		{
<span class="nc" id="L932">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV,
					&quot;5&quot;);
		}
<span class="nc" id="L936">		return (String) content;</span>
	}

	/**
	 * Searches for a tag with the name of the passed parameter.
	 * 
	 * @param tag
	 *            The tag name to search for
	 * @return true if tag name found
	 * @return false if tag name not found
	 */
	private boolean searchTagInDescriptionFile(String tag)
	{
<span class="nc bnc" id="L949" title="All 2 branches missed.">		if (getDescriptionTree() == null</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">				|| (getDescriptionTree().getElementsByTagName(tag)).getLength() == 0)</span>
		{
<span class="nc" id="L952">			return false;</span>
		}
<span class="nc" id="L954">		return true;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>