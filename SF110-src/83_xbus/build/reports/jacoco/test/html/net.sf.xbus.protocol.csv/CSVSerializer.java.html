<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CSVSerializer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">83_xbus</a> &gt; <a href="index.source.html" class="el_package">net.sf.xbus.protocol.csv</a> &gt; <span class="el_source">CSVSerializer.java</span></div><h1>CSVSerializer.java</h1><pre class="source lang-java linenums">package net.sf.xbus.protocol.csv;

import java.util.Hashtable;

import net.sf.xbus.base.core.Constants;
import net.sf.xbus.base.core.XException;
import net.sf.xbus.base.core.config.Configuration;
import net.sf.xbus.base.xml.XDomSupport;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 * &lt;code&gt;CSVSerializer&lt;/code&gt; serves for serializing records stored in a DOM
 * tree according to a CSV type message
 * &lt;p&gt;
 * The DOM tree structure is described in the
 * {@link net.sf.xbus.protocol.csv.CSVParser CSVParser} documentation.
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;The serialization result is a String.&lt;/li&gt;
 * &lt;li&gt;Every record is serialized into one line&lt;/li&gt;
 * &lt;li&gt;The fields are separated by the FieldSeparator which is set in the
 * configuration. (default value in xbus.conf, overwritting possible for every
 * process&lt;/li&gt;
 * &lt;li&gt;The QuoteChar is surrounding fields which contain the QuoteChar
 * character, a line break, a FieldSeparator or spaces. Which character is used
 * is indicated in xbus.conf of in the process configuration. &lt;/li&gt;
 * &lt;li&gt;The HasHeader configuration key indicates if an header should be written
 * into the CSV file&lt;/li&gt;
 * &lt;li&gt;If AlwaysQuote is set true in the configuration, all fields are
 * surrounded by the QuoteChar&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * @author Stephan Duwel, Wolfgang Kooppl
 */
public class CSVSerializer
{

<span class="nc" id="L41">	private static Hashtable instances = new Hashtable();</span>
<span class="nc" id="L42">	private static final Object classLock = CSVSerializer.class;</span>

	private String fieldSeparator;
	private String quoteChar;
	private String quotePair;
	private boolean alwaysQuote;
	private boolean hasHeader;
	private String lineSeparator;

	/**
	 * @param system the name of the process
	 * @throws XException
	 */
	public CSVSerializer(String system) throws XException
<span class="nc" id="L56">	{</span>
<span class="nc" id="L57">		readConfig(system);</span>
<span class="nc" id="L58">	}</span>

	/**
	 * @param sourceType the name of the process
	 * @return an instance of the CSVSerializer class
	 */
	protected static CSVSerializer getInstance(String sourceType)
			throws XException
	{
<span class="nc" id="L67">		synchronized (classLock)</span>
		{
<span class="nc bnc" id="L69" title="All 4 branches missed.">			if (sourceType == null || sourceType.length() == 0)</span>
<span class="nc" id="L70">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_CSV, &quot;1&quot;);

<span class="nc" id="L74">			CSVSerializer instance = (CSVSerializer) instances.get(Thread</span>
<span class="nc" id="L75">					.currentThread().getName()</span>
					+ sourceType);
<span class="nc bnc" id="L77" title="All 2 branches missed.">			if (instance == null)</span>
			{ // no suitable instance available yet
<span class="nc" id="L79">				instance = new CSVSerializer(sourceType);</span>
<span class="nc" id="L80">				instances.put(Thread.currentThread().getName() + sourceType,</span>
						instance);
			} // if (instance==null)
<span class="nc" id="L83">			return instance;</span>
		}
	}

	/**
	 * @return Returns the lineSeparator.
	 */
	public String getLineSeparator()
	{
<span class="nc" id="L92">		return lineSeparator;</span>
	}

	/**
	 * Serializes a DOM tree into a CSV message.
	 * 
	 * @param doc The information that is parsed into CSV format. Has to be a
	 *            DOM tree.
	 * @return The String of the serialized document.
	 */
	protected String serialize(Document doc) throws XException
	{
<span class="nc" id="L104">		String result = &quot;&quot;;</span>
		// delete all the gaps(spaces) between the tags
		try
		{
<span class="nc" id="L108">			XDomSupport.deleteWhitespaceTextInElementNodesAndComments(doc);</span>
		}
<span class="nc" id="L110">		catch (Exception e)</span>
		{
<span class="nc" id="L112">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV,
					&quot;3&quot;);
<span class="nc" id="L115">		}</span>

		// do we want to write out a header?
<span class="nc bnc" id="L118" title="All 2 branches missed.">		if (hasHeader)</span>
		{
<span class="nc" id="L120">			result = returnSerializedHeader(doc);</span>
		}// if(hasHeder)

<span class="nc" id="L123">		Node recordsNode = doc.getElementsByTagName(&quot;Records&quot;).item(0);</span>
<span class="nc" id="L124">		NodeList recordsList = recordsNode.getChildNodes();</span>

		// go through all records and process every single of them
<span class="nc bnc" id="L127" title="All 2 branches missed.">		for (int i = 0; i &lt; recordsList.getLength(); i++)</span>
		{
<span class="nc" id="L129">			result += serializeOneLine(recordsList.item(i).getChildNodes());</span>
		}
<span class="nc" id="L131">		return result;</span>
	}

	/**
	 * Returns the serialized header line. The headers for the fields are the
	 * tag names inside the &lt;Header&gt;-Tags
	 * 
	 * @param doc The document containing the header information.
	 * @return The header String
	 * @throws XException
	 */
	private String returnSerializedHeader(Document doc) throws XException
	{
<span class="nc" id="L144">		String header = null;</span>
<span class="nc" id="L145">		Node headerNode = doc.getElementsByTagName(&quot;Header&quot;).item(0);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">		if (headerNode != null)</span>
		{
<span class="nc" id="L148">			NodeList headerElements = headerNode.getChildNodes();</span>
<span class="nc" id="L149">			header = serializeOneLine(headerElements);</span>
<span class="nc" id="L150">		}</span>
		else
		{
<span class="nc" id="L153">			Node firstRecord = doc.getElementsByTagName(&quot;Records&quot;).item(0)</span>
<span class="nc" id="L154">					.getFirstChild();</span>
<span class="nc" id="L155">			NodeList fields = firstRecord.getChildNodes();</span>
<span class="nc" id="L156">			StringBuffer line = new StringBuffer();</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">			for (int i = 0; i &lt; fields.getLength(); i++)</span>
			{
<span class="nc" id="L159">				String fieldName = fields.item(i).getNodeName();</span>
				// doubleQuote all quoteChars
<span class="nc bnc" id="L161" title="All 2 branches missed.">				if (fieldName.indexOf(quoteChar) &gt;= 0)</span>
<span class="nc" id="L162">					fieldName = fieldName.replaceAll(quoteChar, quotePair);</span>

				// do we always quote or have quote, fieldSeparator, lineBreak
				// or
				// space in the field
<span class="nc bnc" id="L167" title="All 4 branches missed.">				if (alwaysQuote || fieldName.indexOf(quoteChar) &gt;= 0</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">						|| fieldName.indexOf(lineSeparator) &gt;= 0</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">						|| fieldName.indexOf(fieldSeparator) &gt;= 0)</span>
				{
<span class="nc" id="L171">					line.append(quoteChar);</span>
<span class="nc" id="L172">					line.append(fieldName);</span>
<span class="nc" id="L173">					line.append(quoteChar);</span>
				} // then (alwaysQuote || fieldName.indexOf(quoteChar) &gt;= 0 ||
					// fieldName.indexOf(lineSeparator) &gt;= 0 ||
					// fieldName.indexOf(fieldSeparator) &gt;= 0)
				else
<span class="nc" id="L178">					line.append(fieldName);</span>

				// last field?
<span class="nc bnc" id="L181" title="All 2 branches missed.">				if (i &lt; fields.getLength() - 1)</span>
<span class="nc" id="L182">					line.append(fieldSeparator);</span>
				else
<span class="nc" id="L184">					line.append(lineSeparator);</span>
			} // for (int i=0; i&lt;fields.getLength(); i++)
<span class="nc bnc" id="L186" title="All 2 branches missed.">			if (line.length() &gt; 0)</span>
<span class="nc" id="L187">				header = line.toString();</span>
		} // else (headerNode != null)
<span class="nc bnc" id="L189" title="All 2 branches missed.">		if (header == null)</span>
<span class="nc" id="L190">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV,
					&quot;2&quot;);
<span class="nc" id="L193">		return header;</span>
	} // returnSerializedHeader(Document doc)

	/**
	 * Parses one set of fields (one record or one header) into a CSV entry
	 * 
	 * @param lineElements The elements of the entry. Every node in the list is
	 *            one field in the entry.
	 * @return The String of the serialized entry in CSV format.
	 */
	private String serializeOneLine(NodeList lineElements)
	{
<span class="nc" id="L205">		StringBuffer text = new StringBuffer();</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">		for (int i = 0; i &lt; lineElements.getLength(); i++)</span>
		{
<span class="nc" id="L208">			Node currentNode = lineElements.item(i);</span>
<span class="nc" id="L209">			StringBuffer currentText = new StringBuffer();</span>
<span class="nc" id="L210">			NodeList textNodes = currentNode.getChildNodes();</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">			for (int j = 0; j &lt; textNodes.getLength(); j++)</span>
			{
<span class="nc" id="L213">				currentText.append(textNodes.item(j).getNodeValue());</span>
			}

<span class="nc" id="L216">			String fieldValue = currentText.toString();</span>
			// doubleQuote all quoteChars
<span class="nc bnc" id="L218" title="All 2 branches missed.">			if (fieldValue.indexOf(quoteChar) &gt;= 0)</span>
			{
<span class="nc" id="L220">				fieldValue = fieldValue.replaceAll(quoteChar, quotePair);</span>
			}

			// do we always quote or have quote, fieldSeparator, lineBreak or
			// space in the field
<span class="nc bnc" id="L225" title="All 4 branches missed.">			if (alwaysQuote || fieldValue.indexOf(quoteChar) &gt;= 0</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">					|| fieldValue.indexOf(lineSeparator) &gt;= 0</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">					|| fieldValue.indexOf(fieldSeparator) &gt;= 0</span>
			/* || currentText.indexOf(&quot; &quot;) &gt;= 0 */)
			{
<span class="nc" id="L230">				text.append(quoteChar);</span>
<span class="nc" id="L231">				text.append(fieldValue);</span>
<span class="nc" id="L232">				text.append(quoteChar);</span>
			}
			else
			{
<span class="nc" id="L236">				text.append(currentText);</span>
			}
			// last field?
<span class="nc bnc" id="L239" title="All 2 branches missed.">			if (i &lt; lineElements.getLength() - 1)</span>
			{
<span class="nc" id="L241">				text.append(fieldSeparator);</span>
			}
			else
			{
<span class="nc" id="L245">				text.append(lineSeparator);</span>
			}
		}
<span class="nc" id="L248">		return text.toString();</span>
	}

	/**
	 * Reads out the configuration entries for the Serialization. Defaults
	 * values are set as MessageDefaults_CSVMessage_Key in xbus.conf. These can
	 * be overwritten for every process.
	 * 
	 * @param sectionName The name of the process.
	 * @throws XException
	 */
	private void readConfig(String sectionName) throws XException
	{
<span class="nc" id="L261">		Configuration config = Configuration.getInstance();</span>
<span class="nc" id="L262">		Configuration xBusConfig = Configuration.getInstance(&quot;xbus&quot;);</span>
<span class="nc" id="L263">		String tempVariable = null;</span>

		// get Field Separator
<span class="nc bnc" id="L266" title="All 2 branches missed.">		if ((fieldSeparator = config.getValueOptional(Constants.CHAPTER_SYSTEM,</span>
				sectionName, Constants.KEY_CSV_FIELD_SEPARATOR)) == null)
		{
<span class="nc" id="L269">			fieldSeparator = xBusConfig.getValue(&quot;MessageDefaults&quot;,</span>
					&quot;CSVMessage&quot;, Constants.KEY_CSV_FIELD_SEPARATOR);
		}

		// get Quote Character
<span class="nc bnc" id="L274" title="All 2 branches missed.">		if ((quoteChar = config.getValueOptional(Constants.CHAPTER_SYSTEM,</span>
				sectionName, Constants.KEY_CSV_QUOTE_CHAR)) == null)
		{
<span class="nc" id="L277">			quoteChar = xBusConfig.getValue(&quot;MessageDefaults&quot;, &quot;CSVMessage&quot;,</span>
					Constants.KEY_CSV_QUOTE_CHAR);
		}

<span class="nc bnc" id="L281" title="All 4 branches missed.">		if (quoteChar == null || fieldSeparator == null</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">				|| quoteChar.equals(fieldSeparator))</span>
<span class="nc" id="L283">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV,
					&quot;15&quot;);

<span class="nc" id="L287">		quotePair = quoteChar + quoteChar;</span>

		// get configuration entry if containing header
<span class="nc bnc" id="L290" title="All 2 branches missed.">		if ((tempVariable = config.getValueOptional(Constants.CHAPTER_SYSTEM,</span>
				sectionName, Constants.KEY_CSV_HAS_HEADER)) == null)
		{
<span class="nc" id="L293">			hasHeader = xBusConfig.getValueAsBoolean(&quot;MessageDefaults&quot;,</span>
					&quot;CSVMessage&quot;, Constants.KEY_CSV_HAS_HEADER);
		}
<span class="nc bnc" id="L296" title="All 2 branches missed.">		else if (tempVariable.equalsIgnoreCase(Constants.CONFIGURATION_TRUE))</span>
		{
<span class="nc" id="L298">			hasHeader = true;</span>
		}
		else
		{
<span class="nc" id="L302">			hasHeader = false;</span>
		}

		// get configuration if all fields should be quoted
<span class="nc bnc" id="L306" title="All 2 branches missed.">		if ((tempVariable = config.getValueOptional(Constants.CHAPTER_SYSTEM,</span>
				sectionName, Constants.KEY_CSV_ALWAYS_QUOTE)) == null)
		{
<span class="nc" id="L309">			alwaysQuote = xBusConfig.getValueAsBoolean(&quot;MessageDefaults&quot;,</span>
					&quot;CSVMessage&quot;, Constants.KEY_CSV_ALWAYS_QUOTE);
		}
<span class="nc bnc" id="L312" title="All 2 branches missed.">		else if (tempVariable.equalsIgnoreCase(Constants.CONFIGURATION_TRUE))</span>
		{
<span class="nc" id="L314">			alwaysQuote = true;</span>
		}
		else
		{
<span class="nc" id="L318">			alwaysQuote = false;</span>
		}

		// set line separator
<span class="nc" id="L322">		lineSeparator = Constants.LINE_SEPERATOR;</span>
<span class="nc" id="L323">		String platform = config.getValueOptional(Constants.CHAPTER_SYSTEM,</span>
				sectionName, &quot;Platform&quot;);
<span class="nc bnc" id="L325" title="All 2 branches missed.">		if (platform != null)</span>
		{
<span class="nc" id="L327">			lineSeparator = Constants.getLineSeperator(platform);</span>
		}
<span class="nc" id="L329">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>