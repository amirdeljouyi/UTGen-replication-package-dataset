<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XMLHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">83_xbus</a> &gt; <a href="index.source.html" class="el_package">net.sf.xbus.base.xml</a> &gt; <span class="el_source">XMLHelper.java</span></div><h1>XMLHelper.java</h1><pre class="source lang-java linenums">package net.sf.xbus.base.xml;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import net.sf.xbus.base.core.Constants;
import net.sf.xbus.base.core.XException;
import net.sf.xbus.base.core.config.Configuration;

import org.apache.xerces.parsers.DOMParser;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;


/**
 * &lt;code&gt;XMLHelper&lt;/code&gt; offers some support for treating XML structures.
 * 
 * @author Stefan Fleckenstein
 */
<span class="nc" id="L38">public class XMLHelper</span>
{
	private static final String DOUBLELINEFEED = &quot;\n\n&quot;;

<span class="nc" id="L42">	private static final String DOUBLELINESEPARATOR = Constants.LINE_SEPERATOR</span>
			+ Constants.LINE_SEPERATOR;

	/**
	 * &lt;code&gt;getTagAttribute&lt;/code&gt; gets the text of the attribute named
	 * &lt;code&gt;attr&lt;/code&gt; in the first occurence of the &lt;code&gt;tag&lt;/code&gt; in
	 * the given &lt;code&gt;org.w3c.dom.Document&lt;/code&gt;.
	 * 
	 * @param doc
	 *            the document in which to search
	 * @param tag
	 *            the tag to serch for
	 * @param attr
	 *            the attribute name to search for
	 * @return the attribute value or &lt;code&gt;null&lt;/code&gt; if the no
	 *         &lt;code&gt;tag&lt;/code&gt; node exists or if the first &lt;code&gt;tag&lt;/code&gt;
	 *         node does not contain the attribute &lt;code&gt;attr&lt;/code&gt;.
	 */
	static public String getTagAttribute(Document doc, String tag, String attr)
	{
<span class="nc" id="L62">		String retText = null;</span>
		// for the result

<span class="nc" id="L65">		NodeList children = doc.getElementsByTagName(tag);</span>
		// all nodes with the specified tag
		Node currentTag;
<span class="nc bnc" id="L68" title="All 2 branches missed.">		if (children.getLength() &gt; 0)</span>
		{ // some nodes with searched tag found
<span class="nc" id="L70">			currentTag = children.item(0);</span>
			// first occurence of searched tag
<span class="nc" id="L72">			retText = getAttribute(currentTag, attr);</span>
		} // if (children.getLength() &gt; 0)
<span class="nc" id="L74">		return retText;</span>
	} // getTagAttribute(Document doc, String tag, String attr)

	/**
	 * Returns the value of the attribute.
	 * 
	 * @param node
	 *            the node which shall contain the attribute
	 * @param attr
	 *            the attribute name to search for
	 * @return the attribute value or &lt;code&gt;null&lt;/code&gt; if the node does not
	 *         contain the attribute &lt;code&gt;attr&lt;/code&gt;.
	 */
	public static String getAttribute(Node node, String attr)
	{
<span class="nc" id="L89">		String retText = null;</span>

<span class="nc" id="L91">		NamedNodeMap attributes = node.getAttributes();</span>
		// its attributes
<span class="nc" id="L93">		boolean textFound = false;</span>
		// for terminating search loop
<span class="nc bnc" id="L95" title="All 4 branches missed.">		for (int j = 0; (!textFound) &amp;&amp; (j &lt; attributes.getLength()); j++)</span>
		{ // loop over attributes
<span class="nc bnc" id="L97" title="All 2 branches missed.">			if (attributes.item(j).getNodeName().equals(attr))</span>
			{ // searched attribute found
<span class="nc" id="L99">				retText = attributes.item(j).getNodeValue();</span>
				// return its value
<span class="nc" id="L101">				textFound = true;</span>
			} // if (attributes.item(j).getNodeName().equals(attr))
		} // for (int j = 0;(!textFound) &amp;&amp; (j &lt; attributes.getLength()); j++)

<span class="nc" id="L105">		return retText;</span>
	}

	/**
	 * &lt;code&gt;getTagCDATA&lt;/code&gt; gets the content of the first CDATA section in
	 * the first occurence of the &lt;code&gt;tag&lt;/code&gt; in the given
	 * &lt;code&gt;org.w3c.dom.Document&lt;/code&gt;.
	 * &lt;p&gt;
	 * 
	 * @param doc
	 *            the document in which to search
	 * @param tag
	 *            the tag to serch for
	 * @return the CDATA section value or &lt;code&gt;null&lt;/code&gt; if the no
	 *         &lt;code&gt;tag&lt;/code&gt; node exists or if the first &lt;code&gt;tag&lt;/code&gt;
	 *         node does not contain a CDATA section labelled with
	 *         &lt;code&gt;tag&lt;/code&gt; exists.
	 */
	static public String getTagCDATA(Document doc, String tag)
	{
<span class="nc" id="L125">		String retText = null;</span>
		// for the result

<span class="nc" id="L128">		NodeList children = doc.getElementsByTagName(tag);</span>
		// all nodes with the specified tag
		Node currentTag;
<span class="nc bnc" id="L131" title="All 2 branches missed.">		if (children.getLength() &gt; 0)</span>
		{ // some nodes with searched tag found
<span class="nc" id="L133">			currentTag = children.item(0);</span>
			// first occurence of searched tag
<span class="nc" id="L135">			NodeList grandchildren = currentTag.getChildNodes();</span>
			// its child nodes
<span class="nc" id="L137">			boolean textFound = false;</span>
			// for terminating search loop
<span class="nc bnc" id="L139" title="All 4 branches missed.">			for (int j = 0; (!textFound) &amp;&amp; j &lt; grandchildren.getLength(); j++)</span>
			{ // loop over child nodes
<span class="nc bnc" id="L141" title="All 2 branches missed.">				if (grandchildren.item(j).getNodeType() == Node.CDATA_SECTION_NODE)</span>
				{ // CDATA section found
<span class="nc" id="L143">					retText = grandchildren.item(j).getNodeValue();</span>
					// return its value
<span class="nc" id="L145">					textFound = true;</span>
				} // if
				// (grandchildren.item(j).getNodeType()==Node.CDATA_SECTION_NODE)
			} // for (int j = 0;(!textFound) &amp;&amp; j &lt; grandchildren.getLength();
			// j++)
		} // if (children.getLength() &gt; 0)

		/*
		 * Workaround, since the Serializer disturbs the linefeeds of the CDATA
		 */
<span class="nc bnc" id="L155" title="All 2 branches missed.">		if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED))</span>
		{
<span class="nc" id="L157">			retText = retText.replaceAll(DOUBLELINEFEED,</span>
					Constants.LINE_SEPERATOR);
		} // if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED))
<span class="nc" id="L160">		return retText;</span>
	} // getTagCDATA(Document doc, String tag)

	/**
	 * Gets the text of the first occurence of the &lt;code&gt;tag&lt;/code&gt; in the
	 * given &lt;code&gt;org.w3c.dom.Document&lt;/code&gt;. Exactly spoken, it retrieves
	 * the value of the first text node of that occurence.
	 * 
	 * @param doc
	 *            the document in which to search
	 * @param tag
	 *            the tag to serch for
	 * @return the text value or &lt;code&gt;null&lt;/code&gt; if no &lt;code&gt;tag&lt;/code&gt;
	 *         node exists of if the first one does nor contain text.
	 */
	static public String getTagText(Document doc, String tag)
	{
<span class="nc" id="L177">		String retText = null;</span>
		// for the result

<span class="nc" id="L180">		NodeList children = doc.getElementsByTagName(tag);</span>
		// all nodes with the specified tag
		Node foundTag;
<span class="nc bnc" id="L183" title="All 2 branches missed.">		if (children.getLength() &gt; 0)</span>
		{ // some nodes with searched tag found
<span class="nc" id="L185">			foundTag = children.item(0);</span>
			// first occurence of searched tag
<span class="nc" id="L187">			retText = getNodeText(foundTag);</span>
		} // if (children.getLength() &gt; 0)
<span class="nc" id="L189">		return retText;</span>
	} // getTagText(Document doc, String tag)

	public static String getNodeText(Node tag)
	{
<span class="nc" id="L194">		String retText = null;</span>
<span class="nc" id="L195">		NodeList children = tag.getChildNodes();</span>
<span class="nc" id="L196">		boolean textFound = false;</span>
<span class="nc bnc" id="L197" title="All 4 branches missed.">		for (int j = 0; (!textFound) &amp;&amp; j &lt; children.getLength(); j++)</span>
		{
<span class="nc bnc" id="L199" title="All 2 branches missed.">			if (children.item(j).getNodeType() == Node.TEXT_NODE)</span>
			{
<span class="nc" id="L201">				retText = children.item(j).getNodeValue();</span>
<span class="nc" id="L202">				textFound = true;</span>
			}
		}
<span class="nc" id="L205">		return retText;</span>
	}

	/**
	 * Gets the name/value list composed by the child element nodes of the first
	 * occurence of the &lt;code&gt;tag&lt;/code&gt; in the given
	 * &lt;code&gt;org.w3c.dom.Document&lt;/code&gt;. The mentioned name is the tag of
	 * the child node and the value in the name/value pair just the node value.
	 * Child nodes other than element nodes are ignored. The value is extracted
	 * from the first child node of the element node - if this one is a text
	 * node. All other child nodes are ignored.
	 * 
	 * @param doc
	 *            the document in which to search
	 * @param tag
	 *            the tag to serch for
	 * @return the text value or &lt;code&gt;null&lt;/code&gt; if no &lt;code&gt;tag&lt;/code&gt;
	 *         node exists of if the first one does nor contain text.
	 * @throws XException
	 *             if one of the examined element nodes for a name/value pair
	 *             has no child or another node than a text node as first child
	 */
	static public Hashtable getTagTextList(Document doc, String tag)
			throws XException
	{
<span class="nc" id="L230">		Hashtable retTable = null;</span>
		// for return object

<span class="nc" id="L233">		NodeList children = doc.getElementsByTagName(tag);</span>
		// all nodes with the specified tag
		Node foundTag;
<span class="nc bnc" id="L236" title="All 2 branches missed.">		if (children.getLength() &gt; 0)</span>
		{ // some nodes with searched tag found
<span class="nc" id="L238">			retTable = new Hashtable();</span>
<span class="nc" id="L239">			foundTag = children.item(0);</span>
			// first occurence of searched tag

<span class="nc" id="L242">			NodeList grandchildren = foundTag.getChildNodes();</span>
			// its child nodes

<span class="nc bnc" id="L245" title="All 2 branches missed.">			for (int j = 0; j &lt; grandchildren.getLength(); j++)</span>
			{ // loop over child nodes
<span class="nc" id="L247">				Node grand = grandchildren.item(j);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">				if (grand.getNodeType() == Node.ELEMENT_NODE)</span>
				{ // element node found
<span class="nc" id="L250">					Node grand2 = grandchildren.item(j).getFirstChild();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">					if ((grand2 != null)</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">							&amp;&amp; (grand2.getNodeType() == Node.TEXT_NODE))</span>
					{ // text node found to read the value
<span class="nc" id="L254">						String nodeName = grandchildren.item(j).getNodeName();</span>
<span class="nc" id="L255">						String nodeValue = grand2.getNodeValue();</span>
<span class="nc" id="L256">						retTable.put(nodeName, nodeValue);</span>
<span class="nc" id="L257">					} // then ((grand2 != null) &amp;&amp; (grand2.getNodeType() ==</span>
					// Node.TEXT_NODE))
					else
					{ // no child or one of wrong node type
<span class="nc" id="L261">						throw new XException(Constants.LOCATION_INTERN,</span>
								Constants.LAYER_COREBASE,
								Constants.PACKAGE_COREBASE_XML, &quot;1&quot;);
					} // else ((grand2 != null) &amp;&amp; (grand2.getNodeType() ==
					// Node.TEXT_NODE))
				} // if (grand.getNodeType() == Node.ELEMENT_NODE)
			} // for (int j = 0; j &lt; grandchildren.getLength(); j++)
		} // if (children.getLength() &gt; 0)
<span class="nc" id="L269">		return retTable;</span>
	} // getTagTextList(Document doc, String tag)

	/**
	 * &lt;code&gt;setTagTextList&lt;/code&gt; stotes a list of name/value pairs in the
	 * first occurence of the &lt;code&gt;tag&lt;/code&gt; in the given
	 * &lt;code&gt;org.w3c.dom.Document&lt;/code&gt;. Each pair makes up an element node
	 * with the given name as tag and the given value as node value (in a text
	 * node). If the &lt;code&gt;tag&lt;/code&gt; doesn't exist, nothing happens. If
	 * &lt;code&gt;tag&lt;/code&gt; exists, its previous content is replaced by the list
	 * of text nodes.
	 * 
	 * @param doc
	 *            the &lt;code&gt;org.w3c.dom.Document&lt;/code&gt; containing the tag
	 * @param tag
	 *            name of the tag that should be replaced
	 * @param entries
	 *            contains the data for the list of text nodes. Both keys and
	 *            elements must be of type &lt;code&gt;String&lt;/code&gt;. The keys are
	 *            treated as tag names, the elements are treated as values for
	 *            the text nodes.
	 */
	static public void setTagTextList(Document doc, String tag,
			Hashtable entries)
	{
<span class="nc" id="L294">		NodeList children = doc.getElementsByTagName(tag);</span>
		// all nodes with the specified tag
<span class="nc bnc" id="L296" title="All 2 branches missed.">		if (children.getLength() &gt; 0)</span>
		{ // some nodes with searched tag found
<span class="nc" id="L298">			Element newElement = doc.createElement(tag);</span>
			// The old tag node will just be replaced.
<span class="nc bnc" id="L300" title="All 2 branches missed.">			for (Enumeration e = entries.keys(); e.hasMoreElements();)</span>
			{ // loop over name/value pairs
<span class="nc" id="L302">				String key = (String) e.nextElement();</span>
<span class="nc" id="L303">				Element child = doc.createElement(key);</span>
				// the element node from the name ...
<span class="nc" id="L305">				child</span>
<span class="nc" id="L306">						.appendChild(doc.createTextNode((String) entries</span>
<span class="nc" id="L307">								.get(key)));</span>
				// ... plus the text node for the value
<span class="nc" id="L309">				newElement.appendChild(child);</span>
				// to the tag node
<span class="nc" id="L311">			} // for (Enumeration enum = entries.keys();</span>
			// enum.hasMoreElements();)

<span class="nc" id="L314">			Node oldTag = children.item(0);</span>
			// Replace the first tag occurence ...
<span class="nc" id="L316">			Node father = oldTag.getParentNode();</span>
			// ... in its parent node ...
<span class="nc" id="L318">			father.replaceChild(newElement, oldTag);</span>
			// by the newly constructed node containg the name/value pairs
		} // if (children.getLength() &gt; 0)
<span class="nc" id="L321">	} // setTagTextList(Document doc, String tag, Hashtable entries)</span>

	/**
	 * &lt;code&gt;setTagText&lt;/code&gt; sets the &lt;code&gt;text&lt;/code&gt; in the first
	 * occurence of the &lt;code&gt;tag&lt;/code&gt; in the given
	 * &lt;code&gt;org.w3c.dom.Document&lt;/code&gt;. If the &lt;code&gt;tag&lt;/code&gt; doesn't
	 * exist, nothing happens, otherwise the corresponding node is completely
	 * replaced.
	 */
	static public void setTagText(Document doc, String tag, String text)
	{
<span class="nc" id="L332">		NodeList children = doc.getElementsByTagName(tag);</span>
		// all nodes with the specified tag
<span class="nc bnc" id="L334" title="All 2 branches missed.">		if (children.getLength() &gt; 0)</span>
		{ // some nodes with searched tag found
<span class="nc" id="L336">			Element newElement = doc.createElement(tag);</span>
			// The old tag node will just be replaced.
<span class="nc" id="L338">			newElement.appendChild(doc.createTextNode(text));</span>
			// the value to store
<span class="nc" id="L340">			Node oldTag = children.item(0);</span>
			// Replace the first tag occurence ...
<span class="nc" id="L342">			Node father = oldTag.getParentNode();</span>
			// ... in its parent node ...
<span class="nc" id="L344">			father.replaceChild(newElement, oldTag);</span>
			// by the newly constructed node
		} // if (children.getLength() &gt; 0)
<span class="nc" id="L347">	} // setTagText(Document doc, String tag, String text)</span>

	/**
	 * &lt;code&gt;setTagCDATA&lt;/code&gt; sets the &lt;code&gt;text&lt;/code&gt; in the first
	 * occurence of the &lt;code&gt;tag&lt;/code&gt; in the given
	 * &lt;code&gt;org.w3c.dom.Document&lt;/code&gt; as CDATA section. If the
	 * &lt;code&gt;tag&lt;/code&gt; doesn't exist, nothing happens, otherwise the
	 * corresponding node is completely replaced.
	 */
	static public void setTagCDATA(Document doc, String tag, String text)
	{
<span class="nc" id="L358">		NodeList children = doc.getElementsByTagName(tag);</span>
		// all nodes with the specified tag
<span class="nc bnc" id="L360" title="All 2 branches missed.">		if (children.getLength() &gt; 0)</span>
		{ // some nodes with searched tag found
<span class="nc" id="L362">			Element newElement = doc.createElement(tag);</span>
			// The old tag node will just be replaced.
<span class="nc" id="L364">			newElement.appendChild(doc.createCDATASection(text));</span>
			// the value to store
<span class="nc" id="L366">			Node oldTag = children.item(0);</span>
			// Replace the first tag occurence ...
<span class="nc" id="L368">			Node father = oldTag.getParentNode();</span>
			// ... in its parent node ...
<span class="nc" id="L370">			father.replaceChild(newElement, oldTag);</span>
			// by the newly constructed node
		} // if (children.getLength() &gt; 0)

<span class="nc" id="L374">	} // setTagCDATA(Document doc, String tag, String text)</span>

	/**
	 * Deletes the first occurance of the &lt;code&gt;tag&lt;/code&gt; in the given
	 * &lt;code&gt;org.w3c.dom.Document&lt;/code&gt;.
	 * &lt;p&gt;
	 * Does nothing if the &lt;code&gt;tag&lt;/code&gt; doesn't exist.
	 */
	static public void deleteTag(Document doc, String tag)
	{
<span class="nc" id="L384">		NodeList children = doc.getElementsByTagName(tag);</span>
		// all nodes with the specified tag
		Node foundTag;
<span class="nc bnc" id="L387" title="All 2 branches missed.">		if (children.getLength() &gt; 0)</span>
		{
<span class="nc" id="L389">			foundTag = children.item(0);</span>
			// the first tag occurence ...
<span class="nc" id="L391">			Node father = foundTag.getParentNode();</span>
			// its parent node
<span class="nc" id="L393">			father.removeChild(foundTag);</span>
		} // if (children.getLength() &gt; 0)
<span class="nc" id="L395">	} // deleteTag(Document doc, String tag)</span>

	/**
	 * Parses the given XML string.
	 */
	static public Document parseXML(String xml, String messageName,
			String system) throws XException
	{
<span class="nc" id="L403">		Document retDocument = null;</span>

<span class="nc bnc" id="L405" title="All 2 branches missed.">		if (messageName == null)</span>
		{
<span class="nc" id="L407">			messageName = &quot;Default&quot;;</span>
		}

<span class="nc bnc" id="L410" title="All 4 branches missed.">		if ((xml != null) &amp;&amp; (xml.length() &gt; 0))</span>
		{
			try
			{
<span class="nc" id="L414">				ByteArrayInputStream xmlStream = new ByteArrayInputStream(xml</span>
<span class="nc" id="L415">						.getBytes(Constants.getXMLEncoding()));</span>
<span class="nc" id="L416">				InputSource inputSource = new InputSource(xmlStream);</span>
<span class="nc" id="L417">				String systemString = new StringBuffer().append(</span>
<span class="nc" id="L418">						Constants.XBUS_ETC).append(&quot;dtd&quot;).append(</span>
<span class="nc" id="L419">						Constants.FILE_SEPERATOR).toString();</span>

<span class="nc" id="L421">				String systemId = new File(systemString).toURL().toString();</span>
<span class="nc" id="L422">				inputSource.setSystemId(systemId);</span>

<span class="nc" id="L424">				DOMParser parser = new DOMParser();</span>

<span class="nc" id="L426">				parser.setFeature(&quot;http://xml.org/sax/features/validation&quot;,</span>
<span class="nc" id="L427">						getValidating(messageName, system));</span>
<span class="nc" id="L428">				parser.setFeature(&quot;http://xml.org/sax/features/namespaces&quot;,</span>
<span class="nc" id="L429">						getNamespaceAware(messageName, system));</span>
<span class="nc" id="L430">				String schema = getXMLSchema(messageName, system);</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">				if (schema != null)</span>
				{
<span class="nc" id="L433">					parser.setFeature(&quot;http://xml.org/sax/features/namespaces&quot;,</span>
							true);
<span class="nc" id="L435">					parser.setFeature(&quot;http://xml.org/sax/features/validation&quot;,</span>
							true);
<span class="nc" id="L437">					parser.setFeature(</span>
							&quot;http://apache.org/xml/features/validation/schema&quot;,
							true);
<span class="nc" id="L440">					parser</span>
<span class="nc" id="L441">							.setProperty(</span>
									&quot;http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation&quot;,
<span class="nc" id="L443">									new StringBuffer().append(</span>
											Constants.XBUS_ETC)
<span class="nc" id="L445">											.append(&quot;Schema&quot;).append(</span>
													Constants.FILE_SEPERATOR)
<span class="nc" id="L447">											.append(schema).toString());</span>
				}
<span class="nc" id="L449">				parser.setErrorHandler(new XParserErrorHandler());</span>

<span class="nc" id="L451">				parser.parse(inputSource);</span>
<span class="nc" id="L452">				retDocument = parser.getDocument();</span>
			}
<span class="nc" id="L454">			catch (Exception e)</span>
			{
<span class="nc" id="L456">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_COREBASE,
						Constants.PACKAGE_COREBASE_XML, &quot;0&quot;, e);
<span class="nc" id="L459">			}</span>
		}
<span class="nc" id="L461">		return retDocument;</span>
	}

	/**
	 * Returns a &lt;code&gt;DocumentBuilder&lt;/code&gt; needed for parsing. For better
	 * performance, &lt;code&gt;DocumentBuilders&lt;/code&gt; are cached per thread. Due
	 * to the message type the parser may be instructed
	 * &lt;ul&gt;
	 * &lt;li&gt;to ignore whitespace in elements,&lt;/li&gt;
	 * &lt;li&gt;to ignore comments,&lt;/li&gt;
	 * &lt;li&gt;to validate the xml document against its DTD.&lt;/li&gt;
	 * &lt;/ul&gt;
	 * Configuration keys control these options.
	 * 
	 * @return a {@link javax.xml.parsers.DocumentBuilder DocumentBuilder}
	 *         object for xml parsing
	 * @throws XException
	 *             in case that any problem with instantiating the
	 *             &lt;code&gt;DocumentBuilder&lt;/code&gt; object arises
	 */
	static public DocumentBuilder getDocumentBuilder(String messageName,
			String system) throws XException
	{
		DocumentBuilder docBuilder;

<span class="nc bnc" id="L486" title="All 2 branches missed.">		if (messageName == null)</span>
		{
<span class="nc" id="L488">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML,
					&quot;2&quot;);
		}

		try
		// to cast to XException
		{
			DocumentBuilderFactory factory = DocumentBuilderFactory
<span class="nc" id="L497">					.newInstance();</span>
<span class="nc" id="L498">			factory</span>
<span class="nc" id="L499">					.setIgnoringComments(getIgnoringComments(messageName,</span>
							system));
<span class="nc" id="L501">			factory</span>
<span class="nc" id="L502">					.setIgnoringElementContentWhitespace(getIgnoringElementContentWhitespace(</span>
							messageName, system));
<span class="nc" id="L504">			factory.setValidating(getValidating(messageName, system));</span>
<span class="nc" id="L505">			factory.setNamespaceAware(getNamespaceAware(messageName, system));</span>

<span class="nc" id="L507">			docBuilder = factory.newDocumentBuilder();</span>
<span class="nc" id="L508">			docBuilder.setErrorHandler(new XParserErrorHandler());</span>
		} // try
<span class="nc" id="L510">		catch (ParserConfigurationException e)</span>
		{
<span class="nc" id="L512">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML,
					&quot;0&quot;, e);
<span class="nc" id="L515">		} // catch</span>
<span class="nc" id="L516">		return docBuilder;</span>
	} // getDocumentBuilder()

	private static boolean getIgnoringComments(String messageName, String system)
			throws XException
	{
<span class="nc" id="L522">		Configuration standConf = Configuration.getInstance();</span>
<span class="nc" id="L523">		Configuration xbusConf = Configuration.getInstance(&quot;xbus&quot;);</span>

<span class="nc" id="L525">		boolean setIgnoringComments = xbusConf.getValueAsBoolean(</span>
				&quot;ParserSettings&quot;, messageName, &quot;IgnoringComments&quot;);
<span class="nc bnc" id="L527" title="All 2 branches missed.">		if (system != null)</span>
		{
<span class="nc bnc" id="L529" title="All 2 branches missed.">			setIgnoringComments = setIgnoringComments</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">					|| standConf.getValueAsBooleanOptional(</span>
							Constants.CHAPTER_SYSTEM, system,
							&quot;IgnoringComments&quot;);
		}
<span class="nc" id="L534">		return setIgnoringComments;</span>
	}

	private static boolean getIgnoringElementContentWhitespace(
			String messageName, String system) throws XException
	{
<span class="nc" id="L540">		Configuration standConf = Configuration.getInstance();</span>
<span class="nc" id="L541">		Configuration xbusConf = Configuration.getInstance(&quot;xbus&quot;);</span>

<span class="nc" id="L543">		boolean setIgnoringElementContentWhitespace = xbusConf</span>
<span class="nc" id="L544">				.getValueAsBoolean(&quot;ParserSettings&quot;, messageName,</span>
						&quot;IgnoringElementContentWhitespace&quot;);
<span class="nc bnc" id="L546" title="All 2 branches missed.">		if (system != null)</span>
		{
<span class="nc bnc" id="L548" title="All 2 branches missed.">			setIgnoringElementContentWhitespace = setIgnoringElementContentWhitespace</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">					|| standConf.getValueAsBooleanOptional(</span>
							Constants.CHAPTER_SYSTEM, system,
							&quot;IgnoringElementContentWhitespace&quot;);
		}
<span class="nc" id="L553">		return setIgnoringElementContentWhitespace;</span>
	}

	private static boolean getValidating(String messageName, String system)
			throws XException
	{
<span class="nc" id="L559">		Configuration standConf = Configuration.getInstance();</span>
<span class="nc" id="L560">		Configuration xbusConf = Configuration.getInstance(&quot;xbus&quot;);</span>

<span class="nc" id="L562">		boolean setValidating = xbusConf.getValueAsBoolean(&quot;ParserSettings&quot;,</span>
				messageName, &quot;XMLValidating&quot;);
<span class="nc bnc" id="L564" title="All 2 branches missed.">		if (system != null)</span>
		{
<span class="nc bnc" id="L566" title="All 2 branches missed.">			setValidating = setValidating</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">					|| standConf.getValueAsBooleanOptional(</span>
							Constants.CHAPTER_SYSTEM, system, &quot;XMLValidating&quot;);
		}
<span class="nc" id="L570">		return setValidating;</span>
	}

	private static String getXMLSchema(String messageName, String system)
			throws XException
	{
<span class="nc" id="L576">		Configuration standConf = Configuration.getInstance();</span>
<span class="nc" id="L577">		Configuration xbusConf = Configuration.getInstance(&quot;xbus&quot;);</span>

<span class="nc" id="L579">		String schema = null;</span>

<span class="nc bnc" id="L581" title="All 2 branches missed.">		if (system != null)</span>
		{
<span class="nc" id="L583">			schema = standConf.getValueOptional(Constants.CHAPTER_SYSTEM,</span>
					system, &quot;XMLSchema&quot;);
		}
<span class="nc bnc" id="L586" title="All 2 branches missed.">		if (schema == null)</span>
		{
<span class="nc" id="L588">			schema = xbusConf.getValueOptional(&quot;ParserSettings&quot;, messageName,</span>
					&quot;XMLSchema&quot;);
		}
<span class="nc" id="L591">		return schema;</span>
	}

	private static boolean getNamespaceAware(String messageName, String system)
			throws XException
	{
<span class="nc" id="L597">		Configuration standConf = Configuration.getInstance();</span>
<span class="nc" id="L598">		Configuration xbusConf = Configuration.getInstance(&quot;xbus&quot;);</span>

<span class="nc" id="L600">		boolean setNamespaceAware = xbusConf.getValueAsBoolean(</span>
				&quot;ParserSettings&quot;, messageName, &quot;NamespaceAware&quot;);
<span class="nc bnc" id="L602" title="All 2 branches missed.">		if (system != null)</span>
		{
<span class="nc bnc" id="L604" title="All 2 branches missed.">			setNamespaceAware = setNamespaceAware</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">					|| standConf.getValueAsBooleanOptional(</span>
							Constants.CHAPTER_SYSTEM, system, &quot;NamespaceAware&quot;);
		}
<span class="nc" id="L608">		return setNamespaceAware;</span>
	}

	/**
	 * Serializes a XML document.
	 * 
	 * @param doc
	 *            the given &lt;code&gt;org.w3c.dom.Document&lt;/code&gt; to be serialized
	 * @param systemID
	 *            reference to the DTD of the XML document
	 * @return the content of the XML document in its string representation
	 */
	static public String serializeXML(Document doc, String systemID)
			throws XException
	{
<span class="nc" id="L623">		String xmlData = null;</span>

<span class="nc bnc" id="L625" title="All 2 branches missed.">		if (doc != null)</span>
		{
<span class="nc" id="L627">			Transformer serializer = getSerializer(systemID);</span>
<span class="nc" id="L628">			ByteArrayOutputStream outStream = new ByteArrayOutputStream();</span>

			try
			{
<span class="nc" id="L632">				serializer.transform(new DOMSource(doc), new StreamResult(</span>
						outStream));
<span class="nc" id="L634">				xmlData = outStream.toString(Constants.getXMLEncoding());</span>
<span class="nc" id="L635">				outStream.close();</span>

				// The serializer contains a bug and replaces DOS line breaks
				// &quot;\r\n&quot; by &quot;\r\r\n&quot; within any element text.
				// This is corrected in the follwing instruction.
<span class="nc" id="L640">				xmlData = xmlData.replaceAll(&quot;\r\r\n&quot;, &quot;\r\n&quot;);</span>
			}
<span class="nc" id="L642">			catch (TransformerException e)</span>
			{
<span class="nc" id="L644">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_COREBASE,
						Constants.PACKAGE_COREBASE_XML, &quot;0&quot;, e);
			}
<span class="nc" id="L648">			catch (IOException e)</span>
			{
<span class="nc" id="L650">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_COREBASE,
						Constants.PACKAGE_COREBASE_XML, &quot;0&quot;, e);
<span class="nc" id="L653">			}</span>
		}
<span class="nc" id="L655">		return xmlData;</span>
	}

	/**
	 * Returns a &lt;code&gt;Serializer&lt;/code&gt; needed for serializing XML documents.
	 */
	static private Transformer getSerializer(String systemID) throws XException
	{
<span class="nc" id="L663">		setTransformerProperties();</span>

		Transformer serializer;
<span class="nc" id="L666">		TransformerFactory tfactory = TransformerFactory.newInstance();</span>
		// This creates a transformer that does a simple identity transform,
		// and thus can be used for all intents and purposes as a serializer.
		try
		{
<span class="nc" id="L671">			serializer = tfactory.newTransformer();</span>
<span class="nc" id="L672">			serializer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span>
<span class="nc" id="L673">			serializer.setOutputProperty(OutputKeys.METHOD, &quot;xml&quot;);</span>
<span class="nc" id="L674">			serializer.setOutputProperty(OutputKeys.ENCODING, Constants</span>
<span class="nc" id="L675">					.getXMLEncoding());</span>
<span class="nc bnc" id="L676" title="All 4 branches missed.">			if ((systemID != null) &amp;&amp; (systemID.length() &gt; 0))</span>
			{
<span class="nc" id="L678">				serializer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM,</span>
						systemID);
			}
		}
<span class="nc" id="L682">		catch (Throwable e)</span>
		{
<span class="nc" id="L684">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML,
					&quot;0&quot;, e);
<span class="nc" id="L687">		}</span>
<span class="nc" id="L688">		return serializer;</span>
	}

	/**
	 * 
	 */
	public static void setTransformerProperties() throws XException
	{
<span class="nc bnc" id="L696" title="All 2 branches missed.">		if (System.getProperty(&quot;java.version&quot;).startsWith(&quot;1.5&quot;))</span>
		{
<span class="nc" id="L698">			System</span>
<span class="nc" id="L699">					.setProperty(&quot;javax.xml.transform.TransformerFactory&quot;,</span>
							&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl&quot;);
		}

<span class="nc" id="L703">		String transformerProperty = Configuration.getInstance()</span>
<span class="nc" id="L704">				.getValueOptional(Constants.CHAPTER_BASE, &quot;XML&quot;,</span>
						&quot;TransformerFactory&quot;);
<span class="nc bnc" id="L706" title="All 2 branches missed.">		if (transformerProperty != null)</span>
		{
<span class="nc" id="L708">			System.setProperty(&quot;javax.xml.transform.TransformerFactory&quot;,</span>
					transformerProperty);
		}
<span class="nc" id="L711">	}</span>
} // XMLHelper
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>