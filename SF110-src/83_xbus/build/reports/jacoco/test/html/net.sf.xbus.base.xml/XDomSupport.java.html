<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XDomSupport.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">83_xbus</a> &gt; <a href="index.source.html" class="el_package">net.sf.xbus.base.xml</a> &gt; <span class="el_source">XDomSupport.java</span></div><h1>XDomSupport.java</h1><pre class="source lang-java linenums">package net.sf.xbus.base.xml;

import java.util.LinkedList;
import java.util.List;

import net.sf.xbus.base.core.XException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 * &lt;code&gt;XDomSupport&lt;/code&gt; is a collection of operations on DOM trees. It
 * extends the possibilities offered in the &lt;code&gt;org.w3c.dom&lt;/code&gt; package.
 * 
 * @author Stephan Duwel
 */
<span class="nc" id="L19">public abstract class XDomSupport</span>
{

	/**
	 * &lt;code&gt;getChildNodesByAttrValue&lt;/code&gt; retrieves child nodes selected by
	 * a certain value of a certain attribute. Child nodes without the specified
	 * attribute are not selected.
	 * 
	 * @param parent the node for which children are searched
	 * @param attrName the attribute to check
	 * @param attrValue the attribute's value to search for
	 * @param nodeTag the tag name for the searched child nodes, if
	 *            &lt;code&gt;null&lt;/code&gt; or empty string the tag name is not used
	 *            for the selection
	 * @return the list of selected child nodes
	 * @throws IllegalArgumentException in case that &lt;code&gt;parent&lt;/code&gt;,
	 *             &lt;code&gt;attrName&lt;/code&gt; or &lt;code&gt;attrValue&lt;/code&gt; are
	 *             &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;attrName&lt;/code&gt; is empty
	 */
	public static List getChildNodesByAttrValue(Node parent, String attrName,
			String attrValue, String nodeTag) throws IllegalArgumentException
	{
<span class="nc bnc" id="L41" title="All 2 branches missed.">		if (parent == null)</span>
<span class="nc" id="L42">			throw new IllegalArgumentException(&quot;Parent node may not be null&quot;);</span>
<span class="nc bnc" id="L43" title="All 4 branches missed.">		if (attrName == null || attrName.length() == 0)</span>
<span class="nc" id="L44">			throw new IllegalArgumentException(</span>
					&quot;Attribute name may not be empty&quot;);
<span class="nc bnc" id="L46" title="All 2 branches missed.">		if (attrValue == null)</span>
<span class="nc" id="L47">			throw new IllegalArgumentException(</span>
					&quot;Attribute value may not be null&quot;);

<span class="nc" id="L50">		LinkedList result = new LinkedList();</span>
<span class="nc" id="L51">		NodeList children = parent.getChildNodes();</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">		for (int i = 0; i &lt; children.getLength(); i++)</span>
		{ // Check all children
<span class="nc" id="L54">			Node child = children.item(i);</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">			if (child.getNodeType() == Node.ELEMENT_NODE</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">					&amp;&amp; ((Element) child).getAttribute(attrName).equals(</span>
							attrValue))
<span class="nc bnc" id="L58" title="All 4 branches missed.">				if (nodeTag != null &amp;&amp; nodeTag.length() &gt; 0)</span>
					// Tag name must be checked
<span class="nc bnc" id="L60" title="All 2 branches missed.">					if (child.getNodeName().equals(nodeTag))</span>
<span class="nc" id="L61">						result.add(child);</span>
					else
<span class="nc" id="L63">						result.add(child);</span>
		} // for (int i=0; i&lt;children.getLength(); i++)
<span class="nc" id="L65">		return result;</span>
	} // getChildNodesByAttrValue (Node parent, String attrName, String
	// attrValue, String nodeTag)

	public static String getNodeText(Node node)
	{
		// The value is stored in child nodes of type Text
<span class="nc" id="L72">		NodeList children = node.getChildNodes();</span>
<span class="nc" id="L73">		String foundValue = &quot;&quot;;</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">		for (int j = 0; j &lt; children.getLength(); j++)</span>
		{ // Check all children
<span class="nc" id="L76">			Node child = children.item(j);</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">			if (child.getNodeType() == Node.TEXT_NODE)</span>
			{ // Concatenate all text node contents
<span class="nc" id="L79">				foundValue = foundValue.concat(child.getNodeValue());</span>
			} // if (child.getNodeType()==Node.TEXT_NODE)
		} // for (int j=0; j&lt;children.getLength(); j++)
<span class="nc" id="L82">		return foundValue;</span>
	} // getNodeText(Node node)

	/**
	 * &lt;code&gt;getTrimedNodeText&lt;/code&gt; retrieves the value for a node
	 * representing the corresponding xml tag.
	 * 
	 * @param node the node representing the xml tag
	 * @return the value stored within the xml tag, the string is trimed for
	 *         leading and ending white space
	 */
	public static String getTrimedNodeText(Node node)
	{
		// The value is stored in child nodes of type Text
<span class="nc" id="L96">		NodeList children = node.getChildNodes();</span>
<span class="nc" id="L97">		String foundValue = &quot;&quot;;</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">		for (int j = 0; j &lt; children.getLength(); j++)</span>
		{ // Check all children
<span class="nc" id="L100">			Node child = children.item(j);</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">			if (child.getNodeType() == Node.TEXT_NODE)</span>
			{ // Concatenate all text node contents
<span class="nc" id="L103">				foundValue = foundValue.concat(child.getNodeValue());</span>
<span class="nc" id="L104">				foundValue = foundValue.trim();</span>
				// trim in between
			} // if (child.getNodeType()==Node.TEXT_NODE)
		} // for (int j=0; j&lt;children.getLength(); j++)
<span class="nc" id="L108">		return foundValue;</span>
	} // getTrimedNodeText(Node node)

	/**
	 * &lt;code&gt;getChildElementsByValue&lt;/code&gt; retrieves child nodes of type
	 * element selected by a certain for the value stored with them.
	 * 
	 * @param parent the node for which children are searched
	 * @param value the value to search for
	 * @param nodeTag the tag name for the searched child nodes, if
	 *            &lt;code&gt;null&lt;/code&gt; or empty string the tag name is not used
	 *            for the selection
	 * @return the list of selected child nodes
	 * @throws IllegalArgumentException in case that &lt;code&gt;parent&lt;/code&gt; or
	 *             &lt;code&gt;value&lt;/code&gt; are &lt;code&gt;null&lt;/code&gt;
	 */
	public static List getChildElementsByValue(Node parent, String value,
			String nodeTag) throws IllegalArgumentException
	{
<span class="nc bnc" id="L127" title="All 2 branches missed.">		if (parent == null)</span>
<span class="nc" id="L128">			throw new IllegalArgumentException(&quot;Parent node may not be null&quot;);</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">		if (value == null)</span>
<span class="nc" id="L130">			throw new IllegalArgumentException(&quot;Value may not be null&quot;);</span>

<span class="nc" id="L132">		LinkedList result = new LinkedList();</span>
<span class="nc" id="L133">		NodeList children = parent.getChildNodes();</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">		for (int i = 0; i &lt; children.getLength(); i++)</span>
		{ // Check all children
<span class="nc" id="L136">			Node child = children.item(i);</span>
<span class="nc bnc" id="L137" title="All 4 branches missed.">			if (child.getNodeType() == Node.ELEMENT_NODE</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">					&amp;&amp; (nodeTag == null || nodeTag.length() == 0 || child</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">							.getNodeName().equals(nodeTag))</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">					&amp;&amp; value.equals(getTrimedNodeText(child)))</span>
<span class="nc" id="L141">				result.add(child);</span>
		} // for (int i=0; i&lt;children.getLength(); i++)
<span class="nc" id="L143">		return result;</span>
	} // getChildElementsByValue (Node parent, String value, String nodeTag)

	/**
	 * &lt;code&gt;getNextNodeIndexIgnoringFormatingText&lt;/code&gt; retrieves the
	 * position of the next node after the position &lt;code&gt;startPos&lt;/code&gt;
	 * within the list &lt;code&gt;nodes&lt;/code&gt; which is not a text node only
	 * containing whitespace.
	 * 
	 * @param nodes the node list
	 * @param startPos the position to start from
	 * @return the position; -1 if no node was found
	 */
	public static int getNextNodeIndexIgnoringFormatingText(NodeList nodes,
			int startPos)
	{
		int pos;
<span class="nc" id="L160">		boolean nodeNotFound = true;</span>
<span class="nc bnc" id="L161" title="All 4 branches missed.">		for (pos = startPos; pos &lt; nodes.getLength() &amp;&amp; nodeNotFound; pos++)</span>
		{ // Search all nodes afetr position &lt;startpos&gt;
<span class="nc" id="L163">			Node node = nodes.item(pos);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">			if (node != null</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">					&amp;&amp; (node.getNodeType() != Node.TEXT_NODE || node</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">							.getNodeValue().trim().length() &gt; 0))</span>
<span class="nc" id="L167">				nodeNotFound = false;</span>
		}
<span class="nc bnc" id="L169" title="All 2 branches missed.">		if (nodeNotFound)</span>
<span class="nc" id="L170">			pos = -1;</span>
		else
<span class="nc" id="L172">			pos--; // &lt;pos&gt; incremented once in for loop after finding the node</span>
<span class="nc" id="L173">		return pos;</span>
	} // getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos)

	/**
	 * &lt;code&gt;deleteWhitespaceTextInElementNodes&lt;/code&gt; deletes all text nodes
	 * containing only whitespace within xml tags. This operation is useful to
	 * get rid of formatting information in a parsed xml file.
	 * 
	 * @param doc the DOM tree to clean
	 * @throws XException only for syntactical reasons (use of a generic
	 *             traversal method)
	 */
	public static void deleteWhitespaceTextInElementNodes(Document doc)
			throws XException
	{
<span class="nc" id="L188">		IteratedWhitespaceInElementDeletion itop = new IteratedWhitespaceInElementDeletion();</span>
<span class="nc" id="L189">		traversePreOrder(doc, itop);</span>
<span class="nc" id="L190">	} // deleteWhitespaceTextInElementNodes(Document doc)</span>

	/**
	 * &lt;code&gt;deleteWhitespaceTextInElementNodesAndComments&lt;/code&gt; deletes all
	 * text nodes containing only whitespace within xml tags and all comment
	 * nodes. This operation is useful to get rid of formatting and editor
	 * information in a parsed xml file.
	 * 
	 * @param doc the DOM tree to clean
	 * @throws XException only for syntactical reasons (use of a generic
	 *             traversal method)
	 */
	public static void deleteWhitespaceTextInElementNodesAndComments(
			Document doc) throws XException
	{
<span class="nc" id="L205">		IteratedWhitespaceInElementAndCommentDeletion itop = new IteratedWhitespaceInElementAndCommentDeletion();</span>
<span class="nc" id="L206">		traversePreOrder(doc, itop);</span>
<span class="nc" id="L207">	} // deleteWhitespaceTextInElementNodesAndComments(Document doc)</span>

	/**
	 * &lt;code&gt;traversePreOrder&lt;/code&gt; traverses a DOM tree in pre-order and
	 * executes the specified operation on each node. The traversal may treat
	 * dynamically deleted nodes but no extensions.
	 * 
	 * @param doc the DOM tree to traverse
	 * @param itop the operation to execute
	 * @throws XException in case that &lt;code&gt;itop&lt;/code&gt; throws one
	 */
	public static void traversePreOrder(Document doc, IteratedNodeOperation itop)
			throws XException
	{
		// Start at root
<span class="nc" id="L222">		Element root = null;</span>
<span class="nc" id="L223">		root = doc.getDocumentElement();</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">		if (root != null)</span>
			// Continue recursively.
<span class="nc" id="L226">			recursivePreOrder(root, itop);</span>
<span class="nc" id="L227">	} // traversePreOrder(Document doc, IteratedNodeOperation itop)</span>

	/**
	 * &lt;code&gt;recursivePreOrder&lt;/code&gt; is the recursive heart of DOM tree
	 * pre-order traversal. It executes the specified operation on the specified
	 * node and proceeds to its children. The traversal may treat dynamically
	 * deleted nodes but no extensions.
	 * 
	 * @param node the actual node
	 * @param itop the operation to execute
	 * @throws XException in case that &lt;code&gt;itop&lt;/code&gt; throws one
	 */
	private static void recursivePreOrder(Node node, IteratedNodeOperation itop)
			throws XException
	{
<span class="nc" id="L242">		itop.iteratedProcedure(node);</span>
		// Process the actual node ...
<span class="nc bnc" id="L244" title="All 2 branches missed.">		if (node.hasChildNodes())</span>
		{ // ... and then all its children
<span class="nc" id="L246">			NodeList children = node.getChildNodes();</span>
<span class="nc" id="L247">			int childCount = children.getLength();</span>
			// Save it for the case of node deletion.
<span class="nc bnc" id="L249" title="All 2 branches missed.">			for (int i = 0; i &lt; childCount; i++)</span>
<span class="nc" id="L250">				recursivePreOrder(children.item(i - childCount</span>
<span class="nc" id="L251">						+ children.getLength()), itop);</span>
			// with correction for node deletion
		} // if (node.hasChildNodes())
<span class="nc" id="L254">	} // recursivePreOrder(Node node, IteratedNodeOperation itop)</span>

	/**
	 * &lt;code&gt;traversePostOrder&lt;/code&gt; traverses a DOM tree in post-order and
	 * executes the specified operation on each node. The traversal may treat
	 * dynamically deleted nodes but no extensions.
	 * 
	 * @param doc the DOM tree to traverse
	 * @param itop the operation to execute
	 * @throws XException in case that &lt;code&gt;itop&lt;/code&gt; throws one
	 */
	public static void traversePostOrder(Document doc,
			IteratedNodeOperation itop) throws XException
	{
		// Start at root
<span class="nc" id="L269">		Element root = null;</span>
<span class="nc" id="L270">		root = doc.getDocumentElement();</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">		if (root != null)</span>
			// Continue recursively.
<span class="nc" id="L273">			recursivePostOrder(root, itop);</span>
<span class="nc" id="L274">	} // traversePostOrder(Document doc, IteratedNodeOperation itop)</span>

	/**
	 * &lt;code&gt;recursivePostOrder&lt;/code&gt; is the recursive heart of DOM tree
	 * pre-order traversal. It proceeds on all children of the specified node
	 * and then executes the specified operation on the node itself. The
	 * traversal may treat dynamically deleted nodes but no extensions.
	 * 
	 * @param node the actual node
	 * @param itop the operation to execute
	 * @throws XException in case that &lt;code&gt;itop&lt;/code&gt; throws one
	 */
	public static void recursivePostOrder(Node node, IteratedNodeOperation itop)
			throws XException
	{
<span class="nc bnc" id="L289" title="All 2 branches missed.">		if (node.hasChildNodes())</span>
		{ // Process all children of the actual node ...
<span class="nc" id="L291">			NodeList children = node.getChildNodes();</span>
<span class="nc" id="L292">			int childCount = children.getLength();</span>
			// Save it for the case of node deletion.
<span class="nc bnc" id="L294" title="All 2 branches missed.">			for (int i = 0; i &lt; childCount; i++)</span>
<span class="nc" id="L295">				recursivePostOrder(children.item(i - childCount</span>
<span class="nc" id="L296">						+ children.getLength()), itop);</span>
			// with correction for node deletion
		} // if (node.hasChildNodes())
<span class="nc" id="L299">		itop.iteratedProcedure(node);</span>
		// ... and then the actual node itself
<span class="nc" id="L301">	} // recursivePostOrder(Node node, IteratedNodeOperation itop)</span>

	/**
	 * &lt;code&gt;isValidTagName&lt;/code&gt; checks if a string conforms to the
	 * conventions for xml tag names.
	 * 
	 * @param name the string to check
	 * @return &lt;code&gt;true&lt;/code&gt; if the string is a well-formed tag name,
	 *         otherwise &lt;code&gt;false&lt;/code&gt;
	 */
	public static boolean isValidTagName(String name)
	{
<span class="nc bnc" id="L313" title="All 4 branches missed.">		boolean result = (name.length() &gt; 0 &amp;&amp; (Character.isLetter(name</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">				.charAt(0)) || name.charAt(0) == '_'));</span>
<span class="nc bnc" id="L315" title="All 4 branches missed.">		for (int i = 1; i &lt; name.length() &amp;&amp; result; i++)</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">			result = (Character.isLetter(name.charAt(i))</span>
<span class="nc bnc" id="L317" title="All 4 branches missed.">					|| Character.isDigit(name.charAt(i)) || name.charAt(i) == '_');</span>
<span class="nc" id="L318">		return result;</span>
	} // isValidTagName(String name)

	/**
	 * Removes invalid characters from tag names.
	 * 
	 * @param name the name of the tag
	 * @return the name of the tag without invalid characters
	 */
	public static String makeTagNameValid(String name)
	{
<span class="nc" id="L329">		StringBuffer retBuffer = new StringBuffer();</span>

<span class="nc bnc" id="L331" title="All 2 branches missed.">		for (int i = 0; i &lt; name.length(); i++)</span>
		{
<span class="nc bnc" id="L333" title="All 2 branches missed.">			if ((Character.isLetter(name.charAt(i))</span>
<span class="nc bnc" id="L334" title="All 4 branches missed.">					|| Character.isDigit(name.charAt(i)) || name.charAt(i) == '_'))</span>
			{
<span class="nc" id="L336">				retBuffer.append(name.charAt(i));</span>
			}
		}

<span class="nc" id="L340">		return retBuffer.toString();</span>
	}

} // XDomSupport
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>