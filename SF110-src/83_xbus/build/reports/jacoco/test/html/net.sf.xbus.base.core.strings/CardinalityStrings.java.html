<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CardinalityStrings.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">83_xbus</a> &gt; <a href="index.source.html" class="el_package">net.sf.xbus.base.core.strings</a> &gt; <span class="el_source">CardinalityStrings.java</span></div><h1>CardinalityStrings.java</h1><pre class="source lang-java linenums">package net.sf.xbus.base.core.strings;

import net.sf.xbus.base.core.Constants;
import net.sf.xbus.base.core.XException;

/**
 * &lt;code&gt;CardinalityStrings&lt;/code&gt; offers some methods for treating
 * cardinality strings like &quot;1..*&quot;. Allowed cardinality string consist
 * &lt;ul&gt;
 * &lt;li&gt;only of a single strictly positive integer - fixed cardinality&lt;/li&gt;
 * &lt;li&gt;of an interval with &quot;..&quot; - variable cardinality&lt;/li&gt;
 * &lt;/ul&gt;
 * In case of an interval the lower bound must be a positive integer (including
 * zero) and the upper bound must be a strictly positive integer or &quot;*&quot;. &quot;*&quot;
 * means &quot;arbitrary&quot;.
 * 
 * @author Stephan Duwel
 */
<span class="nc" id="L19">public class CardinalityStrings</span>
{

	/**
	 * &lt;code&gt;isCardinalityValid&lt;/code&gt; checks if a string is a well-formed
	 * cardinality.
	 * 
	 * @param card the string to check
	 * @return &lt;code&gt;true&lt;/code&gt; for well-formed cardinality string, otherwise
	 *         &lt;code&gt;false&lt;/code&gt;
	 */
	public static boolean isCardinalityValid(String card)
	{
<span class="nc" id="L32">		int dots = card.indexOf(&quot;..&quot;);</span>
		// Search for interval dots
<span class="nc bnc" id="L34" title="All 2 branches missed.">		if (dots == -1)</span>
			// no interval
<span class="nc" id="L36">			dots = card.length();</span>
		// to check everything till the end
<span class="nc" id="L38">		boolean result = true;</span>
<span class="nc bnc" id="L39" title="All 2 branches missed.">		if (dots + 2 == card.length())</span>
			// Dots must be followed by a number or &quot;*&quot;.
<span class="nc" id="L41">			result = false;</span>
		else
		{ // No dots or something behind the dots.
			try
			// for conversions to numbers
			{
				// A single value or a lower bound must be positive integers.
<span class="nc" id="L48">				int low = Integer.parseInt(card.substring(0, dots));</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">				if (low &lt; 0)</span>
<span class="nc" id="L50">					result = false;</span>
<span class="nc bnc" id="L51" title="All 4 branches missed.">				else if (dots == card.length() &amp;&amp; low == 0)</span>
					// A single - not interval - value is zero but should be
					// strictly positive.
<span class="nc" id="L54">					result = false;</span>
				else
				{ // Look if there is something behind dots.
<span class="nc bnc" id="L57" title="All 4 branches missed.">					if (dots &lt; card.length() - 3 || dots == card.length() - 3</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">							&amp;&amp; card.charAt(dots + 2) != '*')</span>
					{ // Just &quot;*&quot; would be fine, but otherwise it must be an
						// integer
						// not smaller than the lower bound.
<span class="nc" id="L62">						int high = Integer.parseInt(card.substring(dots + 2));</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">						if (low &gt; high)</span>
<span class="nc" id="L64">							result = false;</span>
<span class="nc" id="L65">					} // if (dots&lt;card.length()-3 || card.charAt(dots+2)!='*')</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">					else if (dots == card.length() - 2)</span>
						// The dots are the last characters in the string.
<span class="nc" id="L68">						result = false;</span>
				} // else (low&lt;0)
			} // try
<span class="nc" id="L71">			catch (NumberFormatException e)</span>
			{ // Single value, lower or upper bound no numbers (upper bound
				// not &quot;*&quot;)
<span class="nc" id="L74">				result = false;</span>
<span class="nc" id="L75">			} // catch</span>
		} // else (dots+2==card.length())
<span class="nc" id="L77">		return result;</span>
	} // isCardinalityValid(String card)

	/**
	 * &lt;code&gt;isCardinalityInterval&lt;/code&gt; checks if a given string is a
	 * cardinatily interval like &quot;1..*&quot;.
	 * 
	 * @param card the string to check
	 * @param isKnownAsValidCardinality Is the string already known as a
	 *            well-formed cardinality specification? Otherwise this fact
	 *            will be checked.
	 * @return &lt;code&gt;true&lt;/code&gt; for a well-formed cardinality interval,
	 *         otherwise &lt;code&gt;false&lt;/code&gt;
	 */
	public static boolean isCardinalityInterval(String card,
			boolean isKnownAsValidCardinality)
	{
<span class="nc bnc" id="L94" title="All 2 branches missed.">		if (!isKnownAsValidCardinality)</span>
<span class="nc" id="L95">			isKnownAsValidCardinality = isCardinalityValid(card);</span>
		// Ensure that the string is a well-formed cardinality string.
<span class="nc bnc" id="L97" title="All 2 branches missed.">		if (isKnownAsValidCardinality)</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">			isKnownAsValidCardinality = (card.indexOf(&quot;..&quot;) &gt; -1);</span>
		// It is an interval iff it contains dots.
<span class="nc" id="L100">		return isKnownAsValidCardinality;</span>
	} // isCardinalityInterval(String card, boolean isKnownAsValidCardinality)

	/**
	 * &lt;code&gt;getCardinalityLow&lt;/code&gt; extracts the lower bound from a
	 * cardinality string like &quot;1..*&quot;.
	 * 
	 * @param card the cardinality string
	 * @param isKnownAsCardinalityInterval Is the cardinality string already
	 *            known as a well-formed interval specification? Otherwise this
	 *            fact will be checked.
	 * @return the extracted lower bound which must be an positive integer
	 * @throws XException in case of a mal-formed cardinality string or a
	 *             negative lower bound
	 */
	public static int getCardinalityLow(String card,
			boolean isKnownAsCardinalityInterval) throws XException
	{
<span class="nc bnc" id="L118" title="All 2 branches missed.">		if (!isKnownAsCardinalityInterval)</span>
<span class="nc" id="L119">			isKnownAsCardinalityInterval = isCardinalityInterval(card, false);</span>
		// Ensure that the string is a cardinality interval.
<span class="nc" id="L121">		int result = -1;</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">		if (isKnownAsCardinalityInterval)</span>
			// NumberFormatException already checked
<span class="nc" id="L124">			result = Integer.parseInt(card.substring(0, card.indexOf(&quot;..&quot;)));</span>
		else
		{
<span class="nc" id="L127">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_COREBASE,
					Constants.PACKAGE_COREBASE_STRINGS, &quot;1&quot;);
		}
<span class="nc" id="L131">		return result;</span>
	} // getCardinalityLow(String card, boolean isKnownAsCardinalityInterval)

	/**
	 * &lt;code&gt;getCardinalityHigh&lt;/code&gt; extracts the upper bound from a
	 * cardinality string like &quot;1..*&quot;.
	 * 
	 * @param card the cardinality string
	 * @param isKnownAsCardinalityInterval Is the cardinality string already
	 *            known as a well-formed interval specification? Otherwise this
	 *            fact will be checked.
	 * @return the extracted upper bound which must be an positive integer,
	 *         &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; in case of a &quot;*&quot;
	 * @throws XException in case of a mal-formed cardinality string or a
	 *             negative upper bound
	 */
	public static int getCardinalityHigh(String card,
			boolean isKnownAsCardinalityInterval) throws XException
	{
<span class="nc bnc" id="L150" title="All 2 branches missed.">		if (!isKnownAsCardinalityInterval)</span>
<span class="nc" id="L151">			isKnownAsCardinalityInterval = isCardinalityInterval(card, false);</span>
		// Ensure that the string is a cardinality interval.
<span class="nc" id="L153">		int result = -1;</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">		if (isKnownAsCardinalityInterval)</span>
		{
<span class="nc" id="L156">			int dots = card.indexOf(&quot;..&quot;);</span>
<span class="nc bnc" id="L157" title="All 4 branches missed.">			if (dots == card.length() - 3 &amp;&amp; card.charAt(dots + 2) == '*')</span>
				// no upper limit
<span class="nc" id="L159">				result = Integer.MAX_VALUE;</span>
			else
				// NumberFormatException already checked
<span class="nc" id="L162">				result = Integer.parseInt(card.substring(dots + 2));</span>
<span class="nc" id="L163">		} // then (isKnownAsCardinalityInterval)</span>
		else
<span class="nc" id="L165">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_COREBASE,
					Constants.PACKAGE_COREBASE_STRINGS, &quot;1&quot;);
<span class="nc" id="L168">		return result;</span>
	} // getCardinalityHigh(String card, boolean isKnownAsCardinalityInterval)

} // CardinalityStrings
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>