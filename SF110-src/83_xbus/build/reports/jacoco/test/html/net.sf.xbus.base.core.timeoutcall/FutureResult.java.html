<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FutureResult.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">83_xbus</a> &gt; <a href="index.source.html" class="el_package">net.sf.xbus.base.core.timeoutcall</a> &gt; <span class="el_source">FutureResult.java</span></div><h1>FutureResult.java</h1><pre class="source lang-java linenums">/*
 * Originally written by Doug Lea and released into the public domain. This may
 * be used for any purposes whatsoever without acknowledgment. Thanks for the
 * assistance and support of Sun Microsystems Labs, and everyone contributing,
 * testing, and using this code.
 */
package net.sf.xbus.base.core.timeoutcall;
import java.lang.reflect.InvocationTargetException;

import net.sf.xbus.base.core.Constants;
import net.sf.xbus.base.core.XException;

/**
 * A class maintaining a single reference variable serving as the result of an
 * operation. The result cannot be accessed until it has been set.
 * &lt;p&gt;
 * &lt;b&gt;Sample Usage&lt;/b&gt;
 * &lt;p&gt;
 * 
 * &lt;pre&gt;
 *  class ImageRenderer { Image render(byte[] raw); }
 *  class App {
 *    Executor executor = ...
 *    ImageRenderer renderer = ...
 *    void display(byte[] rawimage) {
 *      try {
 *        FutureResult futureImage = new FutureResult();
 *        Runnable command = futureImage.setter(new Callable() {
 *           public Object call() { return renderer.render(rawImage); }
 *        });
 *        executor.execute(command);
 *        drawBorders();             // do other things while executing
 *        drawCaption();
 *        drawImage((Image)(futureImage.get())); // use future
 *      }
 *      catch (InterruptedException ex) { return; }
 *      catch (InvocationTargetException ex) { cleanup(); return; }
 *    }
 *  }
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;[&lt;a
 * href=&quot;http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html&quot;&gt;
 * Introduction to this package. &lt;/a&gt;]
 */
public class FutureResult
{
	/** The result of the operation * */
<span class="nc" id="L49">	protected Object value_ = null;</span>

	/** Status -- true after first set * */
<span class="nc" id="L52">	protected boolean ready_ = false;</span>

	/** the exception encountered by operation producing result * */
	// protected InvocationTargetException exception_ = null;
<span class="nc" id="L56">	protected XException exception_ = null;</span>

	/**
	 * Create an initially unset FutureResult
	 */
	public FutureResult()
<span class="nc" id="L62">	{</span>
		/*
		 * do nothing
		 */
<span class="nc" id="L66">	}</span>

	/**
	 * Return a Runnable object that, when run, will set the result value.
	 * 
	 * @param function - a Callable object whose result will be held by this
	 *            FutureResult.
	 * @return A Runnable object that, when run, will call the function and
	 *         (eventually) set the result.
	 */

	public Runnable setter(final Callable function)
	{
<span class="nc" id="L79">		return new Runnable()</span>
<span class="nc" id="L80">		{</span>
			public void run()
			{
				try
				{
<span class="nc" id="L85">					set(function.call());</span>
				}
<span class="nc" id="L87">				catch (Throwable ex)</span>
				{
<span class="nc" id="L89">					setException(ex);</span>
<span class="nc" id="L90">				}</span>
<span class="nc" id="L91">			}</span>
		};
	}

	/** internal utility: either get the value or throw the exception * */
	protected Object doGet() throws XException
	{
<span class="nc bnc" id="L98" title="All 2 branches missed.">		if (exception_ != null)</span>
<span class="nc" id="L99">			throw exception_;</span>
		else
<span class="nc" id="L101">			return value_;</span>
	}

	/**
	 * Access the reference, waiting if necessary until it is ready.
	 * 
	 * @return current value
	 * @exception InterruptedException if current thread has been interrupted
	 * @exception InvocationTargetException if the operation producing the value
	 *                encountered an exception.
	 */
	public synchronized Object get() throws InterruptedException, XException
	{
<span class="nc bnc" id="L114" title="All 2 branches missed.">		while (!ready_)</span>
<span class="nc" id="L115">			wait();</span>
<span class="nc" id="L116">		return doGet();</span>
	}

	/**
	 * Wait at most msecs to access the reference.
	 * 
	 * @return current value
	 * @exception TimeoutException if not ready after msecs
	 * @exception InterruptedException if current thread has been interrupted
	 * @exception InvocationTargetException if the operation producing the value
	 *                encountered an exception.
	 */
	public synchronized Object timedGet(long msecs) throws TimeoutException,
			InterruptedException, XException
	{
<span class="nc bnc" id="L131" title="All 2 branches missed.">		long startTime = (msecs &lt;= 0) ? 0 : System.currentTimeMillis();</span>
<span class="nc" id="L132">		long waitTime = msecs;</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">		if (ready_)</span>
<span class="nc" id="L134">			return doGet();</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">		else if (waitTime &lt;= 0)</span>
<span class="nc" id="L136">			throw new TimeoutException(msecs);</span>
		else
		{
			for (;;)
			{
<span class="nc" id="L141">				wait(waitTime);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">				if (ready_)</span>
<span class="nc" id="L143">					return doGet();</span>
				else
				{
<span class="nc" id="L146">					waitTime = msecs - (System.currentTimeMillis() - startTime);</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">					if (waitTime &lt;= 0)</span>
<span class="nc" id="L148">						throw new TimeoutException(msecs);</span>
				}
			}
		}
	}

	/**
	 * Set the reference, and signal that it is ready. It is not considered an
	 * error to set the value more than once, but it is not something you would
	 * normally want to do.
	 * 
	 * @param newValue The value that will be returned by a subsequent get();
	 */
	public synchronized void set(Object newValue)
	{
<span class="nc" id="L163">		value_ = newValue;</span>
<span class="nc" id="L164">		ready_ = true;</span>
<span class="nc" id="L165">		notifyAll();</span>
<span class="nc" id="L166">	}</span>

	/**
	 * Set the exception field, also setting ready status.
	 * 
	 * @param ex The exception. It will be reported out wrapped within an
	 *            InvocationTargetException
	 */
	public synchronized void setException(Throwable ex)
	{
		// exception_ = new InvocationTargetException(ex);
<span class="nc" id="L177">		exception_ = new XException(Constants.LOCATION_INTERN,</span>
				Constants.LAYER_COREBASE,
				Constants.PACKAGE_COREBASE_TIMEOUTCALL, &quot;2&quot;, ex);
<span class="nc" id="L180">		ready_ = true;</span>
<span class="nc" id="L181">		notifyAll();</span>
<span class="nc" id="L182">	}</span>

	/**
	 * Get the exception, or null if there isn't one (yet). This does not wait
	 * until the future is ready, so should ordinarily only be called if you
	 * know it is.
	 * 
	 * @return the exception encountered by the operation setting the future,
	 *         wrapped in an InvocationTargetException
	 */
	public synchronized XException getException()
	{
<span class="nc" id="L194">		return exception_;</span>
	}

	/**
	 * Return whether the reference or exception have been set.
	 * 
	 * @return true if has been set. else false
	 */
	public synchronized boolean isReady()
	{
<span class="nc" id="L204">		return ready_;</span>
	}

	/**
	 * Access the reference, even if not ready
	 * 
	 * @return current value
	 */
	public synchronized Object peek()
	{
<span class="nc" id="L214">		return value_;</span>
	}

	/**
	 * Clear the value and exception and set to not-ready, allowing this
	 * FutureResult to be reused. This is not particularly recommended and must
	 * be done only when you know that no other object is depending on the
	 * properties of this FutureResult.
	 */
	public synchronized void clear()
	{
<span class="nc" id="L225">		value_ = null;</span>
<span class="nc" id="L226">		exception_ = null;</span>
<span class="nc" id="L227">		ready_ = false;</span>
<span class="nc" id="L228">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>