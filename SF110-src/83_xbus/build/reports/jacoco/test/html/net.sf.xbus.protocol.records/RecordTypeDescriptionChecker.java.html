<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RecordTypeDescriptionChecker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">83_xbus</a> &gt; <a href="index.source.html" class="el_package">net.sf.xbus.protocol.records</a> &gt; <span class="el_source">RecordTypeDescriptionChecker.java</span></div><h1>RecordTypeDescriptionChecker.java</h1><pre class="source lang-java linenums">package net.sf.xbus.protocol.records;

import java.util.Hashtable;
import java.util.LinkedList;
import java.util.List;
import java.util.TreeMap;
import java.util.Vector;

import net.sf.xbus.base.core.Constants;
import net.sf.xbus.base.core.XException;
import net.sf.xbus.base.core.strings.CardinalityStrings;
import net.sf.xbus.base.xml.XDomSupport;

import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 * &lt;code&gt;RecordTypeDescriptionChecker&lt;/code&gt; checks the xml description of a
 * record type interface. This description explains the structure of the used
 * interface files.
 * 
 * @author Stephan Duwel
 */
<span class="nc" id="L25">class RecordTypeDescriptionChecker</span>
{

	/**
	 * &lt;code&gt;instances&lt;/code&gt; stores the instances of the checker by thread.
	 */
<span class="nc" id="L31">	private static Hashtable instances = new Hashtable();</span>

	/**
	 * &lt;code&gt;getInstance&lt;/code&gt; returns a
	 * &lt;code&gt;RecordTypeDescriptionChecker&lt;/code&gt; to work with.
	 * 
	 * @return a checker instance
	 */
	public static RecordTypeDescriptionChecker getInstance()
	{ // Instances are stored by thread.
<span class="nc" id="L41">		RecordTypeDescriptionChecker instance = (RecordTypeDescriptionChecker) instances</span>
<span class="nc" id="L42">				.get(Thread.currentThread().getName());</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">		if (instance == null)</span>
		{ // No checker initialised yet
<span class="nc" id="L45">			instance = new RecordTypeDescriptionChecker();</span>
<span class="nc" id="L46">			instances.put(Thread.currentThread().getName(), instance);</span>
		} // if (instance==null)
<span class="nc" id="L48">		return instance;</span>
	} // getInstance()

	// ///////////////////////////////////////////////////
	// Checking the structrue description top level
	// ///////////////////////////////////////////////////

	/**
	 * &lt;code&gt;checkHeaderSpecification&lt;/code&gt; checks the consistency of the
	 * file header desription.
	 * 
	 * @param headerSpec
	 *            the structure description for the header
	 * @param groupsSpec
	 *            the list of field group specifications to check group
	 *            references
	 * @param validated
	 *            Is the xml already validated?
	 * @throws XException -
	 *             in case of a inconsistency
	 */
	public void checkHeaderSpecification(Element headerSpec, Node groupsSpec,
			boolean validated) throws XException
	{
<span class="nc bnc" id="L72" title="All 4 branches missed.">		if (!validated &amp;&amp; headerSpec.getAttribute(&quot;Name&quot;).length() == 0)</span>
		{
<span class="nc" id="L74">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;1&quot;);
		}
		// Now the single fields in the header
<span class="nc" id="L79">		checkFieldsAndGroupRefs(headerSpec, groupsSpec, null, validated);</span>
<span class="nc" id="L80">	} // checkHeaderSpecification(Element headerSpec, Node groupsSpec, boolean</span>

	// validated)

	/**
	 * &lt;code&gt;checkLinesSpecification&lt;/code&gt; checks the consistency of the
	 * lines section. The lines section lists all record types, declares their
	 * order in the file and specifies how to identify them in the file.
	 * Furthermore is fills the &lt;code&gt;recordTypeNames&lt;/code&gt; and
	 * &lt;code&gt;existanceIndicators&lt;/code&gt; arrays to prepare checking the
	 * consistency + of the record type declarations and the specifications
	 * afterwards.
	 * 
	 * @param linesSpec
	 *            the lines section of the structure description
	 * @param validated
	 *            Is the xml already validated?
	 * @return an array with 2 elements, the first is the array of all record
	 *         type names, the second is an array of existance indicators (&lt;code&gt;null&lt;/code&gt;
	 *         if record identification method is &quot;TypeIdentifier&quot;)
	 * @throws XException
	 *             in case of an inconsistency
	 */
	public Object[] checkLinesSpecification(Element linesSpec, boolean validated)
			throws XException
	{
		// In which order to find the records
<span class="nc" id="L107">		String recOrder = linesSpec.getAttribute(&quot;RecordOrder&quot;);</span>

<span class="nc bnc" id="L109" title="All 2 branches missed.">		if (!validated)</span>
		{ // Errors in the xml?
<span class="nc bnc" id="L111" title="All 2 branches missed.">			if (recOrder.length() == 0)</span>
			{
<span class="nc" id="L113">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;2&quot;);
			}
<span class="nc bnc" id="L117" title="All 4 branches missed.">			if (!recOrder.equals(&quot;Arbitrary&quot;) &amp;&amp; !recOrder.equals(&quot;Ordered&quot;)</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">					&amp;&amp; !recOrder.equals(&quot;Structured&quot;))</span>
			{
<span class="nc" id="L120">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;3&quot;);
			}
		} // if (!validated)

		// How to identify the records
<span class="nc" id="L127">		String recIdentMethod = linesSpec.getAttribute(&quot;RecordIdentification&quot;);</span>

<span class="nc bnc" id="L129" title="All 2 branches missed.">		if (!validated)</span>
		{ // Errors in the xml?
<span class="nc bnc" id="L131" title="All 2 branches missed.">			if (recIdentMethod.length() == 0)</span>
			{
<span class="nc" id="L133">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;4&quot;);
			}
<span class="nc bnc" id="L137" title="All 2 branches missed.">			if (!recIdentMethod.equals(&quot;TypeIdentifier&quot;)</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">					&amp;&amp; !recIdentMethod.equals(&quot;RecordOrder&quot;))</span>
			{
<span class="nc" id="L140">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;5&quot;);
			}
		} // if (!validated)

<span class="nc bnc" id="L146" title="All 2 branches missed.">		if (recOrder.equals(&quot;Arbitrary&quot;)</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">				&amp;&amp; !recIdentMethod.equals(&quot;TypeIdentifier&quot;))</span>
		{
			// forbidden combination
<span class="nc" id="L150">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;6&quot;);
		}
		// the record type declarations or ...
		// ... the list of record groups, if &lt;recOrder&gt;=&quot;Structured&quot;
<span class="nc" id="L156">		NodeList recordTypes = linesSpec.getChildNodes();</span>
<span class="nc" id="L157">		int numOfRecordTypes = recordTypes.getLength();</span>
		// only ok if &lt;recOrder&gt;!=&quot;Structured&quot; because otherwise this computes
		// the number of record groups!!!!!!!!!

<span class="nc bnc" id="L161" title="All 2 branches missed.">		if (recordTypes.getLength() == 0)</span>
		{
			// Extension if no prior DTD validating
<span class="nc" id="L164">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;7&quot;);
		}
		// Loop will run over record types, but the identification of record
		// record groups above is important, as well.
		// If &lt;recOrder&gt;!=&quot;Structured&quot;, the parent node is just the Lines node.
<span class="nc" id="L171">		Node recordGroup = linesSpec;</span>

		// Now some corrections to the setting so far if record groups must be
		// treated.
<span class="nc bnc" id="L175" title="All 2 branches missed.">		if (recOrder.equals(&quot;Structured&quot;))</span>
		{
<span class="nc bnc" id="L177" title="All 2 branches missed.">			if (!recIdentMethod.equals(&quot;TypeIdentifier&quot;)</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">					&amp;&amp; recordTypes.getLength() &gt; 1)</span>
			{
				// Several record groups are only allowed if the record types
				// can
				// be identiifed by type identifiers.
				// Attention: &lt;recordTypes&gt; contains the record groups - not the
				// types!
<span class="nc" id="L185">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;8&quot;);
			}
<span class="nc" id="L189">			numOfRecordTypes = 0;</span>
			// For counting the record types a loop over the record groups is
			// necessary.
<span class="nc bnc" id="L192" title="All 2 branches missed.">			for (int i = 0; i &lt; recordTypes.getLength(); i++)</span>
			{ // loop over record groups
<span class="nc bnc" id="L194" title="All 2 branches missed.">				if (!recordTypes.item(i).getNodeName().equals(&quot;RecordGroup&quot;))</span>
				{
<span class="nc" id="L196">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;9&quot;);
				}
<span class="nc" id="L200">				numOfRecordTypes += recordTypes.item(i).getChildNodes()</span>
<span class="nc" id="L201">						.getLength();</span>

				// the number of records in that group
			} // for (int i=0; i&lt;recordTypes.getLength(); i++)

<span class="nc" id="L206">			recordGroup = recordTypes.item(0);</span>
			// for loop over record groups
<span class="nc" id="L208">			recordTypes = recordGroup.getChildNodes();</span>
			// the record types one level deeper now, thus really to record
			// types
		} // if (recOrder.equals(&quot;Structured&quot;))

<span class="nc" id="L213">		TreeMap[] existanceIndicators = null;</span>
		// for record types which's occurrence depends on a certain value in the
		// record before

<span class="nc bnc" id="L217" title="All 2 branches missed.">		if (recIdentMethod.equals(&quot;TypeIdentifier&quot;))</span>
		{ // type identification by type identifier is easy but needs some
			// values
			// where to find the identifier within the records
<span class="nc" id="L221">			String idPos = linesSpec.getAttribute(&quot;IdentifierPos&quot;);</span>
			// Where does the identifier start in the record string?
<span class="nc bnc" id="L223" title="All 2 branches missed.">			if (idPos.length() == 0)</span>
			{
<span class="nc" id="L225">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;10&quot;);
			}
<span class="nc" id="L229">			String idLength = linesSpec.getAttribute(&quot;IdentifierLength&quot;);</span>
			// How long is the type identifier?
<span class="nc bnc" id="L231" title="All 2 branches missed.">			if (idLength.length() == 0)</span>
			{
<span class="nc" id="L233">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;11&quot;);
			}
			try
			{ // The position must be a positive integer.
<span class="nc" id="L239">				int num = Integer.parseInt(idPos);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">				if (num &lt; 0)</span>
				{
<span class="nc" id="L242">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;12&quot;);
				}
				// The length as well must be positive integer.
				// Length 0 is permitted for having a simple handling of files
				// with
				// only one record type.
<span class="nc" id="L250">				num = Integer.parseInt(idLength);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">				if (num &lt; 0)</span>
				{
<span class="nc" id="L253">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;13&quot;);
				}
			} // try
<span class="nc" id="L258">			catch (ClassCastException e)</span>
			{
<span class="nc" id="L260">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L263">			} // catch</span>
<span class="nc" id="L264">		} // then (recIdentMethod.equals(&quot;TypeIdentifier&quot;))</span>
		else
		// Without type identifiers everything gets more complicated ...
		// ... but the primary value are already set.
		{ // Indicators for successors may be important.
<span class="nc" id="L269">			existanceIndicators = new TreeMap[numOfRecordTypes];</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">			for (int i = 0; i &lt; existanceIndicators.length; i++)</span>
<span class="nc" id="L271">				existanceIndicators[i] = null;</span>
			// Will be filled when going through the single record type
			// declarations.
		} // else (recIdentMethod.equals(&quot;TypeIdentifier&quot;))

<span class="nc" id="L276">		String[] recordTypeNames = new String[numOfRecordTypes];</span>
		// Storing the names for consistency check gainst the record type
		// specification section.
<span class="nc" id="L279">		LinkedList typeIds = new LinkedList();</span>
<span class="nc" id="L280">		LinkedList typeIdIntervals = new LinkedList();</span>
		// Record type identifier may be single values or intervals.
		// They are stored to check their unique reference to a record type.
<span class="nc" id="L283">		int recordTypesCount = recordTypes.getLength();</span>
		// the number of record types in the current record group or at all
		// (wihtout grouping) - at least if no bad nodes are included in a
		// errorprone specification
<span class="nc" id="L287">		int recordTypesBefore = 0;</span>
		// number of record type declarations checked in other record groups
		// before - used as offset to datermine the position in the record type
		// array
<span class="nc bnc" id="L291" title="All 2 branches missed.">		while (recordGroup != null)</span>
		{ // loop over record groups
			// - only one loop if &lt;recOrder&gt;!=&quot;Structured&quot; because of missing
			// record groups
<span class="nc bnc" id="L295" title="All 2 branches missed.">			for (int i = 0; i &lt; recordTypesCount; i++)</span>
			{ // Loop over all record type declarations of the record group
<span class="nc" id="L297">				Node rType = recordTypes.item(i);</span>

				// Extension if no DTD validating
<span class="nc bnc" id="L300" title="All 2 branches missed.">				if (rType.getNodeType() != Node.ELEMENT_NODE</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">						|| !rType.getNodeName().equals(&quot;RecordType&quot;))</span>
				{
<span class="nc" id="L303">					List params = new Vector();</span>
<span class="nc" id="L304">					params.add(rType.getNodeName());</span>
<span class="nc" id="L305">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;15&quot;, params);
				}
				// Check the consistency of this single record type declaration.
				// If its occurrence depends on values in the prececeeding
				// record
				// the information about this value is stored in
				// &lt;dependenceOnPredecessor&gt;.
<span class="nc" id="L314">				String[] dependenceOnPredecessor = checkRecordTypeDeclaration(</span>
						rType, recordTypesCount, recordTypesBefore + i,
						recIdentMethod, recOrder, recordTypeNames, typeIds,
						typeIdIntervals, existanceIndicators);

<span class="nc bnc" id="L319" title="All 4 branches missed.">				if (existanceIndicators != null</span>
						&amp;&amp; dependenceOnPredecessor != null)
				{ // Existance records are expected in general and an
					// existance
					// indicator is defined for the last cheched record type.
					// To ensure that the identification via existance
					// indicators
					// is possible, the information about them is analysed the
					// other
					// way round. Originally the information was attached as
					// &lt;dependenceOnPredecessor&gt; to the dependent record type.
					// Now it will be attached as &lt;existanceIndicators&gt; to its
					// possible predecessors.
<span class="nc" id="L332">					String occurrences = ((Element) recordTypes.item(i))</span>
<span class="nc" id="L333">							.getAttribute(&quot;Occurrences&quot;);</span>
					// Cardinality of the record type.
<span class="nc" id="L335">					boolean isOptional = CardinalityStrings</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">							.isCardinalityInterval(occurrences, true)</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">							&amp;&amp; CardinalityStrings.getCardinalityLow(</span>
									occurrences, true) == 0;
<span class="nc bnc" id="L339" title="All 4 branches missed.">					for (int j = i - 1; j &gt; -1 &amp;&amp; isOptional; j++)</span>
					{ // Backwards loop to the beginning of the record types
						// starting at the predecessor of the examined record
						// type.
						// As long as a record type is optional, its predecessor
						// is
						// added to the list of possible predecessors for the
						// originally
						// checked record type.
						// Stops at the first record type because this one may
						// not be optional.

						// Now information attached to the predecessor.
<span class="nc bnc" id="L352" title="All 2 branches missed.">						if (existanceIndicators[j] == null)</span>
						{ // The predecessor does not yet have identified
							// successor
							// which depend on an existnace indicator.
<span class="nc" id="L356">							existanceIndicators[j] = new TreeMap();</span>
<span class="nc" id="L357">							existanceIndicators[j].put(</span>
									dependenceOnPredecessor[0],
									dependenceOnPredecessor[1]);
						} // then (existanceIndicators[j]==null)
						else
						{ // The predecessor already has information about
							// successors.
							// Existance indicator value for the existance
							// indicator
							// field stated in the examined record type, but
							// used for
							// another record type !?
<span class="nc" id="L369">							String value = (String) existanceIndicators[j]</span>
<span class="nc" id="L370">									.get(dependenceOnPredecessor[0]);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">							if (value != null)</span>
								// Existance indicator values in the same field
								// for different record types.
<span class="nc" id="L374">								if (value.length() != dependenceOnPredecessor[1]</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">										.length())</span>
								{
<span class="nc" id="L377">									throw new XException(</span>
											Constants.LOCATION_INTERN,
											Constants.LAYER_PROTOCOL,
											Constants.PACKAGE_PROTOCOL_RECORDS,
											&quot;16&quot;);
								}
								else
									// No other use of the existance indicator
									// field yet.
									// Store the new value.
<span class="nc" id="L387">									existanceIndicators[j].put(</span>
											dependenceOnPredecessor[0],
											dependenceOnPredecessor[1]);
						} // else (existanceIndicators[j]==null)
<span class="nc" id="L391">						occurrences = ((Element) recordTypes.item(j))</span>
<span class="nc" id="L392">								.getAttribute(&quot;Occurrences&quot;);</span>
						// Cardinality of the last checked record type
<span class="nc bnc" id="L394" title="All 2 branches missed.">						isOptional = CardinalityStrings.isCardinalityInterval(</span>
								occurrences, true)
<span class="nc bnc" id="L396" title="All 2 branches missed.">								&amp;&amp; CardinalityStrings.getCardinalityLow(</span>
										occurrences, true) == 0;
					} // for (int j=i-1; j&gt;-1 &amp;&amp; isOptional; j++)
				} // if (existanceIndicators!=null &amp;&amp;
				// dependenceOnPredecessor!=null)
			} // for (int i=0; i&lt;recordTypes.getLength(); i++)

<span class="nc" id="L403">			recordTypesBefore += recordTypesCount;</span>
			// Correct the number of checked record types in the so far
			// examined record groups

<span class="nc bnc" id="L407" title="All 2 branches missed.">			if (recordGroup.getNodeName().equals(&quot;RecordGroup&quot;))</span>
			{ // record groups really present
<span class="nc" id="L409">				recordGroup = recordGroup.getNextSibling();</span>
				// Choose next record group
<span class="nc bnc" id="L411" title="All 2 branches missed.">				if (recordGroup != null)</span>
				{ // there is a next record group
<span class="nc" id="L413">					recordTypes = recordGroup.getChildNodes();</span>
<span class="nc" id="L414">					recordTypesCount = recordTypes.getLength();</span>
					// Next check the record types in the new group
				} // if (recordGroup != null)
			} // if (recordGroup.getNodeName().equals(&quot;RecordGroup&quot;))
			else
				// no real record group loop but record declarations directly
				// in lines section, terminate loop by setting ...
<span class="nc" id="L421">				recordGroup = null;</span>
		} // while (recordGroup!=null) - record group loop

		// Check record type names for uniqueness.
<span class="nc bnc" id="L425" title="All 2 branches missed.">		for (int i = 0; i &lt; recordTypeNames.length; i++)</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">			for (int j = i + 1; j &lt; recordTypeNames.length; j++)</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">				if (recordTypeNames[i].equals(recordTypeNames[j]))</span>
				{
<span class="nc" id="L429">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;17&quot;);
				}
		// Checks on the type identifier
		// First check their length
		// If the record type identification is not done by type identifiers,
		// the two type id lists are empty.
<span class="nc" id="L437">		int identifierLength = 0;</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">		if (typeIds.size() &gt; 0)</span>
			// Some single value id's
<span class="nc" id="L440">			identifierLength = ((String) typeIds.get(0)).length();</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">		else if (typeIdIntervals.size() &gt; 0)</span>
			// No single value id but some id intervals
<span class="nc" id="L443">			identifierLength = ((String[]) typeIdIntervals.get(0))[0].length();</span>
		// All id's must have the same length.
		// First the single value id's
<span class="nc bnc" id="L446" title="All 2 branches missed.">		for (int i = 1; i &lt; typeIds.size(); i++)</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">			if (((String) typeIds.get(0)).length() != identifierLength)</span>
			{
<span class="nc" id="L449">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;18&quot;);
			}
		// Second the id intervals
<span class="nc bnc" id="L454" title="All 2 branches missed.">		for (int i = 1; i &lt; typeIdIntervals.size(); i++)</span>
			// Attention: two values!
<span class="nc bnc" id="L456" title="All 2 branches missed.">			if (((String[]) typeIdIntervals.get(0))[0].length() != identifierLength</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">					|| ((String[]) typeIdIntervals.get(0))[1].length() != identifierLength)</span>
			{
<span class="nc" id="L459">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;18&quot;);
			}
		// Second, check the id uniqueness in sense of identification of only
		// one
		// record type
<span class="nc bnc" id="L466" title="All 2 branches missed.">		if (!typeIdsAreUnique(typeIds, typeIdIntervals))</span>
		{
<span class="nc" id="L468">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;20&quot;);
		}

		// Return the found record type names and existance indicators.
<span class="nc" id="L474">		Object[] checkInfos = new Object[2];</span>
<span class="nc" id="L475">		checkInfos[0] = recordTypeNames;</span>
<span class="nc" id="L476">		checkInfos[1] = existanceIndicators;</span>
<span class="nc" id="L477">		return checkInfos;</span>
	} // checkLinesSpecification(Element linesSpec, boolean validated)

	/**
	 * &lt;code&gt;checkRecordTypesSpecification&lt;/code&gt; checks the section of record
	 * type specifications for consistency. In particular it checks for
	 * existance of the record types and fields named in the lines section.
	 * 
	 * @param recordTypesSpec
	 *            the record type specifications section
	 * @param groupsSpec
	 *            the list of field group specifications to check group
	 *            references
	 * @param checkInfos
	 *            record type names and existance indicators found in the lines
	 *            section
	 * @param validated
	 *            Is the xml already validated?
	 * @throws XException
	 *             in case of an inconsistency
	 */
	public void checkRecordTypesSpecification(Node recordTypesSpec,
			Node groupsSpec, Object[] checkInfos, boolean validated)
			throws XException
	{
		try
		// for casting to XException
		{
<span class="nc" id="L505">			NodeList recordTypes = recordTypesSpec.getChildNodes();</span>
			// Here we have no record groups!
<span class="nc bnc" id="L507" title="All 2 branches missed.">			for (int i = 0; i &lt; recordTypes.getLength(); i++)</span>
			{ // loop over record type specifications
<span class="nc" id="L509">				Element recordType = (Element) recordTypes.item(i);</span>

				// Extension if no prior validating
<span class="nc bnc" id="L512" title="All 2 branches missed.">				if (!recordType.getNodeName().equals(&quot;RecordTypeSpec&quot;))</span>
				{
<span class="nc" id="L514">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;21&quot;);
				}
<span class="nc" id="L518">				String recTypeName = recordType.getAttribute(&quot;Name&quot;);</span>
				// Extension if no prior validating
<span class="nc bnc" id="L520" title="All 2 branches missed.">				if (recTypeName == null</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">						|| !XDomSupport.isValidTagName(recTypeName))</span>
				{
<span class="nc" id="L523">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;22&quot;);
				}
				// Search record type name in the name array from
				// the record type (Lines) section.
<span class="nc" id="L529">				boolean nameSearched = true;</span>
				// Still searching?
<span class="nc" id="L531">				int pos = 0;</span>
<span class="nc bnc" id="L532" title="All 4 branches missed.">				for (; pos &lt; ((String[]) checkInfos[0]).length &amp;&amp; nameSearched; pos++)</span>
					// loop over record type names from the lines section
<span class="nc bnc" id="L534" title="All 2 branches missed.">					if (recTypeName.equals(((String[]) checkInfos[0])[pos]))</span>
					{ // name found
<span class="nc" id="L536">						((String[]) checkInfos[0])[pos] = null;</span>
						// deleted for avoiding more hits
<span class="nc" id="L538">						nameSearched = false;</span>
						// search loop ended for this record type
					} // if
				// (recTypeName.equals(((String[])checkInfos[0])[pos]))
<span class="nc bnc" id="L542" title="All 2 branches missed.">				if (nameSearched)</span>
				{
					// Record type not declared in lines section
<span class="nc" id="L545">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;23&quot;);
				}
				// Now the single fields in the record type
<span class="nc" id="L550">				TreeMap existanceIndicators = null;</span>
				// With the found position in the checkInfos array
				// the correct existance indicator map is retrieved ...
<span class="nc bnc" id="L553" title="All 2 branches missed.">				if (checkInfos[1] != null)</span>
					// Because pos was augmented once to much in the for loop,
					// now
					// use pos-1.
<span class="nc" id="L557">					existanceIndicators = ((TreeMap[]) checkInfos[1])[pos - 1];</span>
				// ... and feeded to field checking
<span class="nc" id="L559">				checkFieldsAndGroupRefs(recordType, groupsSpec,</span>
						existanceIndicators, validated);
			} // for (int i=0; i&lt;recordTypes.getLength(); i++)
		} // try
<span class="nc" id="L563">		catch (ClassCastException e)</span>
		{
<span class="nc" id="L565">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L568">		} // catch</span>
<span class="nc" id="L569">	} // checkRecordTypesSpecification(Node recordTypesSpec, Node groupsSpec,</span>

	// Object[] checkInfos, boolean validated)

	/**
	 * &lt;code&gt;checkTrailerSpecification&lt;/code&gt; checks the consistency of the
	 * file trailer desription.
	 * 
	 * @param trailerSpec
	 *            the structure description for the trailer
	 * @param groupsSpec
	 *            the list of field group specifications to check group
	 *            references
	 * @param validated
	 *            Is the xml already validated?
	 * @throws XException
	 *             in case of a inconsistency
	 */
	public void checkTrailerSpecification(Element trailerSpec, Node groupsSpec,
			boolean validated) throws XException
	{
		// Extension if no prior DTD validating
<span class="nc bnc" id="L591" title="All 2 branches missed.">		if (trailerSpec.getAttribute(&quot;Name&quot;).length() == 0)</span>
		{
<span class="nc" id="L593">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;1&quot;);
		}
		// Now the single fields in the header
<span class="nc" id="L598">		checkFieldsAndGroupRefs(trailerSpec, groupsSpec, null, validated);</span>
<span class="nc" id="L599">	} // checkTrailerSpecification(Element trailerSpec, Node groupsSpec,</span>

	// boolean validated)

	/**
	 * &lt;code&gt;checkGroupsSpecification&lt;/code&gt; checks the consistency of each
	 * field group specification.
	 * 
	 * @param groupsSpec
	 *            the list of field group specifications
	 * @param validated
	 *            Is the xml already validated?
	 * @throws XException
	 *             in case of an inconsistency
	 */
	public void checkGroupsSpecification(Node groupsSpec, boolean validated)
			throws XException
	{
<span class="nc" id="L617">		NodeList groups = groupsSpec.getChildNodes();</span>

<span class="nc bnc" id="L619" title="All 2 branches missed.">		if (!validated)</span>
		{ // Extension if no prior DTD validating
			try
			// for casting to XException
			{
<span class="nc bnc" id="L624" title="All 2 branches missed.">				for (int i = 0; i &lt; groups.getLength(); i++)</span>
					// consistency check on each single group specification
					// (redundant to validating against DTD)
<span class="nc" id="L627">					checkGroupSpecification((Element) groups.item(i));</span>
			} // try
<span class="nc" id="L629">			catch (ClassCastException e)</span>
			{
<span class="nc" id="L631">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L634">			} // catch</span>
		} // if (!validated)

		// Check for the uniqueness of group names
<span class="nc bnc" id="L638" title="All 2 branches missed.">		for (int i = 0; i &lt; groups.getLength() - 1; i++)</span>
		{
<span class="nc" id="L640">			String groupName = ((Element) groups.item(i)).getAttribute(&quot;Name&quot;);</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">			for (int j = i + 1; j &lt; groups.getLength(); j++)</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">				if (groupName.equals(((Element) groups.item(j))</span>
<span class="nc" id="L643">						.getAttribute(&quot;Name&quot;)))</span>
				{
<span class="nc" id="L645">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;27&quot;);
				}
		} // for (int i=0; i&lt;groups.getLength()-1; i++)
<span class="nc" id="L650">	} // checkGroupsSpecification(Node groupsSpec, boolean validated)</span>

	// //////////////////////////////////////////////
	// Structrue checking on some deeper level
	// //////////////////////////////////////////////

	/**
	 * &lt;code&gt;checkRecordTypeDeclaration&lt;/code&gt; checks a record type
	 * declaration for consistency. Furthermore is fills the
	 * &lt;code&gt;recordTypeNames&lt;/code&gt; and &lt;code&gt;existanceIndicators&lt;/code&gt; to
	 * check consistency with the record type specifications afterwards.
	 * 
	 * @param recTypeDecl
	 *            the DOM node of the declaration
	 * @param recordTypesCount
	 *            the number of record types in the actual record group or the
	 *            whole file (wihtout grouping)
	 * @param pos
	 *            the position in the list of declarations (starts at 0)
	 * @param recIdentMethod
	 *            the method to identify record types
	 * @param recOrder
	 *            the order of records in the file
	 * @param recordTypeNames
	 *            array of record type names, filled at position
	 *            &lt;code&gt;pos&lt;/code&gt; right here
	 * @param typeIds
	 *            the list of single-value type id's, a found id will be added
	 * @param typeIdIntervals
	 *            the list of type id intervals, a found interval will be added
	 * @param existanceIndicators
	 *            array of existance indicator maps, potentially filled with
	 *            self reference at position &lt;code&gt;pos&lt;/code&gt; right here
	 * @return field/value pair for an existance indicator in the record type
	 * @throws XException
	 *             in case of an inconsistency
	 */
	public String[] checkRecordTypeDeclaration(Node recTypeDecl,
			int recordTypesCount, int pos, String recIdentMethod,
			String recOrder, String[] recordTypeNames, LinkedList typeIds,
			LinkedList typeIdIntervals, TreeMap[] existanceIndicators)
			throws XException
	{
<span class="nc" id="L693">		String[] precedingIndicator = null;</span>
		// for returning exstistance indicator information for predecessors

		try
		// for casting to XException
		{
<span class="nc bnc" id="L699" title="All 2 branches missed.">			if (recIdentMethod.equals(&quot;TypeIdentifier&quot;))</span>
			{ // Record types are identified by an id
<span class="nc" id="L701">				String id = ((Element) recTypeDecl).getAttribute(&quot;Identifier&quot;);</span>
				// a single-value id
<span class="nc" id="L703">				String[] idLoHi = new String[2];</span>
<span class="nc" id="L704">				idLoHi[0] = ((Element) recTypeDecl)</span>
<span class="nc" id="L705">						.getAttribute(&quot;IdentifierLow&quot;);</span>
<span class="nc" id="L706">				idLoHi[1] = ((Element) recTypeDecl)</span>
<span class="nc" id="L707">						.getAttribute(&quot;IdentifierHigh&quot;);</span>
				// an id interval
<span class="nc bnc" id="L709" title="All 2 branches missed.">				if (id.length() == 0)</span>
				{ // No single-value id
<span class="nc bnc" id="L711" title="All 4 branches missed.">					if (idLoHi[0].length() == 0 || idLoHi[1].length() == 0)</span>
					{
						// Something must be specified: single value or
						// interval.
<span class="nc" id="L715">						throw new XException(Constants.LOCATION_INTERN,</span>
								Constants.LAYER_PROTOCOL,
								Constants.PACKAGE_PROTOCOL_RECORDS, &quot;28&quot;);
					}
<span class="nc" id="L719">					typeIdIntervals.add(idLoHi);</span>
				} // then (id.length()==0)
				else
				{ // Single-value id found
<span class="nc bnc" id="L723" title="All 4 branches missed.">					if (idLoHi[0].length() &gt; 0 || idLoHi[1].length() &gt; 0)</span>
					{
						// Any interval specification conflicts.
<span class="nc" id="L726">						throw new XException(Constants.LOCATION_INTERN,</span>
								Constants.LAYER_PROTOCOL,
								Constants.PACKAGE_PROTOCOL_RECORDS, &quot;28&quot;);
					}
<span class="nc" id="L730">					typeIds.add(id);</span>
				} // else (id.length()==0)
			} // if (recIdentMethod.equals(&quot;TypeIdentifier&quot;))

<span class="nc" id="L734">			recordTypeNames[pos] = XDomSupport.getTrimedNodeText(recTypeDecl);</span>
			// the record type name
<span class="nc bnc" id="L736" title="All 2 branches missed.">			if (!XDomSupport.isValidTagName(recordTypeNames[pos]))</span>
			{
				// It must be a legal xml tag name.
<span class="nc" id="L739">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;30&quot;);
			}
			// Now look for record identification features, in particular the
			// cardinality
			// and existance indicator
<span class="nc bnc" id="L746" title="All 4 branches missed.">			if (recOrder.equals(&quot;Ordered&quot;) || recOrder.equals(&quot;Structured&quot;))</span>
			{ // Records are listed in the record type order or in groups.
				// The cardinality must be specified.
<span class="nc" id="L749">				String occurrences = ((Element) recTypeDecl)</span>
<span class="nc" id="L750">						.getAttribute(&quot;Occurrences&quot;);</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">				if (occurrences.length() == 0)</span>
				{
<span class="nc" id="L753">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;31&quot;);
				}
<span class="nc bnc" id="L757" title="All 2 branches missed.">				if (!CardinalityStrings.isCardinalityValid(occurrences))</span>
				{
<span class="nc" id="L759">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;32&quot;);
				}

				// The first record in a record group must have cardinality 1.
<span class="nc bnc" id="L765" title="All 4 branches missed.">				if (recOrder.equals(&quot;Structured&quot;) &amp;&amp; pos == 0)</span>
				{
					try
					{
<span class="nc" id="L769">						int occurrNum = Integer.parseInt(occurrences);</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">						if (occurrNum != 1)</span>
						{
<span class="nc" id="L772">							throw new XException(Constants.LOCATION_INTERN,</span>
									Constants.LAYER_PROTOCOL,
									Constants.PACKAGE_PROTOCOL_RECORDS, &quot;33&quot;);
						}
					} // try
<span class="nc" id="L777">					catch (NumberFormatException e)</span>
					{
<span class="nc" id="L779">						throw new XException(Constants.LOCATION_INTERN,</span>
								Constants.LAYER_PROTOCOL,
								Constants.PACKAGE_PROTOCOL_RECORDS, &quot;33&quot;);
<span class="nc" id="L782">					} // catch</span>
				} // if (recOrder.equals(&quot;Structured&quot;) &amp;&amp; pos==0)

				// If the record type is not given by an id but the cardinality
				// is specified as an
				// interval and there are also other record types, there must be
				// an existance indicator
				// refering the preceding record.
<span class="nc bnc" id="L790" title="All 2 branches missed.">				if (recordTypesCount &gt; 1</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">						&amp;&amp; !recIdentMethod.equals(&quot;TypeIdentifier&quot;)</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">						&amp;&amp; CardinalityStrings.isCardinalityInterval(</span>
								occurrences, true))
				{
<span class="nc" id="L795">					String existIndField = ((Element) recTypeDecl)</span>
<span class="nc" id="L796">							.getAttribute(&quot;ExistIndicatorField&quot;);</span>
					// Indicator field specified by name
<span class="nc bnc" id="L798" title="All 2 branches missed.">					if (existIndField.length() == 0)</span>
					{
<span class="nc" id="L800">						throw new XException(Constants.LOCATION_INTERN,</span>
								Constants.LAYER_PROTOCOL,
								Constants.PACKAGE_PROTOCOL_RECORDS, &quot;35&quot;);
					}
<span class="nc" id="L804">					String existIndValue = ((Element) recTypeDecl)</span>
<span class="nc" id="L805">							.getAttribute(&quot;ExistIndicatorValue&quot;);</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">					if (existIndValue.length() == 0)</span>
					{
<span class="nc" id="L808">						throw new XException(Constants.LOCATION_INTERN,</span>
								Constants.LAYER_PROTOCOL,
								Constants.PACKAGE_PROTOCOL_RECORDS, &quot;36&quot;);
					}
<span class="nc" id="L812">					precedingIndicator = new String[2];</span>
<span class="nc" id="L813">					precedingIndicator[0] = existIndField;</span>
<span class="nc" id="L814">					precedingIndicator[1] = existIndValue;</span>
					// If the record type may occurr more than once, it may be
					// its
					// predecessor itself.
<span class="nc" id="L818">					if (CardinalityStrings</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">							.getCardinalityHigh(occurrences, true) &gt; 1)</span>
					{
<span class="nc" id="L821">						existanceIndicators[pos] = new TreeMap();</span>
<span class="nc" id="L822">						existanceIndicators[pos].put(precedingIndicator[0],</span>
								precedingIndicator[1]);
					} // if (getCardinalityHigh(occurrences,true)&gt;1)
				} // if (!recIdentMethod.equals(&quot;TypeIdentifier&quot;) &amp;&amp;
				// isCardinalityInterval(occurrences,true))
			} // if (recOrder.equals(&quot;Ordered&quot;) ||
			// recOrder.equals(&quot;Structured&quot;))
		} // try
<span class="nc" id="L830">		catch (ClassCastException e)</span>
		{
<span class="nc" id="L832">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L835">		} // catch</span>
<span class="nc" id="L836">		return precedingIndicator;</span>
		// Group starting record type found?
	} // checkRecordTypeDeclaration(Node recTypeDecl, int pos, String

	// recIdentMethod, String recOrder, String[] recordTypeNames, LinkedList
	// typeIds, LinkedList typeIdIntervals, TreeMap[] existanceIndicators)

	/**
	 * &lt;code&gt;checkFieldsAndGroupRefs&lt;/code&gt; checks the fields and group
	 * references within an record type (including header and trailer) for
	 * consistency.
	 * 
	 * @param parent
	 *            the record type specification node
	 * @param groupsSpec
	 *            the list of field group specifications
	 * @param existanceIndicators
	 *            existance indicator map for the surrounding record type,
	 *            references to fields will be marked
	 * @param validated
	 *            Is the xml already validated?
	 * @throws XException
	 *             in case of an inconsistency
	 */
	private void checkFieldsAndGroupRefs(Node parent, Node groupsSpec,
			TreeMap existanceIndicators, boolean validated) throws XException
	{
		try
		// try-catch block for casting standard exceptions to XException
		{
<span class="nc" id="L866">			NodeList fieldSpecs = parent.getChildNodes();</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">			for (int i = 0; i &lt; fieldSpecs.getLength(); i++)</span>
			{
<span class="nc" id="L869">				Element fieldSpec = (Element) fieldSpecs.item(i);</span>
				// Two alternatives: field or group
<span class="nc bnc" id="L871" title="All 2 branches missed.">				if (fieldSpec.getNodeName().equals(&quot;Field&quot;))</span>
<span class="nc" id="L872">					checkFieldSpecification(fieldSpec, existanceIndicators,</span>
							validated);
<span class="nc bnc" id="L874" title="All 2 branches missed.">				else if (fieldSpec.getNodeName().equals(&quot;Group&quot;))</span>
<span class="nc" id="L875">					checkGroupReference(fieldSpec, groupsSpec,</span>
							existanceIndicators);
				else
				// Extension if no prior DTD validating
				{
<span class="nc" id="L880">					List params = new Vector();</span>
<span class="nc" id="L881">					params.add(fieldSpec.getNodeName());</span>
<span class="nc" id="L882">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;38&quot;, params);
				}
			} // for (int i=0; i&lt;fieldSpecs.getLength(); i++)
		} // try
<span class="nc" id="L888">		catch (ClassCastException e)</span>
		{
<span class="nc" id="L890">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L893">		} // catch</span>
<span class="nc" id="L894">	} // checkFieldsAndGroupRefs(Node parent, Node groupsSpec, TreeMap</span>

	// existanceIndicators)

	/**
	 * &lt;code&gt;checkGroupReference&lt;/code&gt; checks the consistency of a reference
	 * to a field group.
	 * 
	 * @param groupRef
	 *            the DOM node for the group reference
	 * @param groupsSpec
	 *            the list of field group specifications to check group
	 *            references
	 * @param existanceIndicators
	 *            existance indicator map for the surrounding record type,
	 *            references to group fields will be marked
	 * @throws XException
	 *             in case of an inconsistency
	 */
	public void checkGroupReference(Element groupRef, Node groupsSpec,
			TreeMap existanceIndicators) throws XException
	{
		try
		{
<span class="nc" id="L918">			String groupName = groupRef.getAttribute(&quot;Name&quot;);</span>

			// Extension if no prior DTD validating
<span class="nc bnc" id="L921" title="All 2 branches missed.">			if (groupName.length() == 0)</span>
			{
<span class="nc" id="L923">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;40&quot;);
			}
			// Search for the group specification.
<span class="nc bnc" id="L928" title="All 2 branches missed.">			if (groupsSpec == null)</span>
			{
<span class="nc" id="L930">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;41&quot;);
			}
<span class="nc" id="L934">			List groups = XDomSupport.getChildNodesByAttrValue(groupsSpec,</span>
					&quot;Name&quot;, groupName, &quot;GroupSpec&quot;);
<span class="nc bnc" id="L936" title="All 4 branches missed.">			if (groups == null || groups.size() == 0)</span>
			{
<span class="nc" id="L938">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;42&quot;);
			}
<span class="nc bnc" id="L942" title="All 2 branches missed.">			if (groups.size() &gt; 1)</span>
			{
<span class="nc" id="L944">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;43&quot;);
			}
			// Group specification found

			// some existance indicators to search for
<span class="nc bnc" id="L951" title="All 2 branches missed.">			if (existanceIndicators != null)</span>
			{
<span class="nc" id="L953">				NodeList fields = ((Node) groups.get(0)).getChildNodes();</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">				for (int i = 0; i &lt; fields.getLength(); i++)</span>
				{
<span class="nc" id="L956">					String name = ((Element) fields.item(i))</span>
<span class="nc" id="L957">							.getAttribute(&quot;Name&quot;);</span>
<span class="nc" id="L958">					String value = (String) existanceIndicators.get(name);</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">					if (value != null)</span>
					{
<span class="nc bnc" id="L961" title="All 2 branches missed.">						if (value.equals(&quot;Found&quot;))</span>
						{
							// Will always occurr if a record type contains more
							// than one instance of
							// a group. Thus, existance indicators in group
							// should not occurr.
<span class="nc" id="L967">							throw new XException(Constants.LOCATION_INTERN,</span>
									Constants.LAYER_PROTOCOL,
									Constants.PACKAGE_PROTOCOL_RECORDS, &quot;44&quot;);
						}
<span class="nc" id="L971">						int length = Integer</span>
<span class="nc" id="L972">								.parseInt(((Element) fields.item(i))</span>
<span class="nc" id="L973">										.getAttribute(&quot;Length&quot;));</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">						if (value.length() != length)</span>
						{
<span class="nc" id="L976">							throw new XException(Constants.LOCATION_INTERN,</span>
									Constants.LAYER_PROTOCOL,
									Constants.PACKAGE_PROTOCOL_RECORDS, &quot;45&quot;);
						}
						// Mark as found.
<span class="nc" id="L981">						existanceIndicators.put(name, &quot;Found&quot;);</span>
					} // if (value!=null)
				} // for (int i=0; i&lt;fields.getLength(); i++)
			} // if (existanceIndicators!=null)
		} // try
<span class="nc" id="L986">		catch (ClassCastException e)</span>
		{
<span class="nc" id="L988">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
		}
<span class="nc" id="L992">		catch (NumberFormatException e)</span>
		{
<span class="nc" id="L994">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L997">		}</span>
<span class="nc" id="L998">	} // checkGroupReference(Element groupRef, Node groupsSpec, TreeMap</span>

	// existanceIndicators)

	/**
	 * &lt;code&gt;checkFieldSpecification&lt;/code&gt; checks the consistency of a field
	 * specification.
	 * 
	 * @param fieldSpec
	 *            the DOM node for the field specification
	 * @param existanceIndicators
	 *            existance indicator map for the surrounding record type,
	 *            references to field will be marked
	 * @param validated
	 *            Is the xml already validated?
	 * @throws XException
	 *             in case of an inconsistency
	 */
	private void checkFieldSpecification(Element fieldSpec,
			TreeMap existanceIndicators, boolean validated) throws XException
	{
		try
		{ // Field name
<span class="nc" id="L1021">			String name = fieldSpec.getAttribute(&quot;Name&quot;);</span>
			// Field length
<span class="nc" id="L1023">			String length = fieldSpec.getAttribute(&quot;Length&quot;);</span>
			// Field format
<span class="nc" id="L1025">			String format = fieldSpec.getAttribute(&quot;Format&quot;);</span>

<span class="nc bnc" id="L1027" title="All 2 branches missed.">			if (!validated)</span>
			{ // Extension if no prior DTD validating
<span class="nc bnc" id="L1029" title="All 2 branches missed.">				if (name.length() == 0)</span>
				{
<span class="nc" id="L1031">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;48&quot;);
				}
<span class="nc bnc" id="L1035" title="All 2 branches missed.">				if (length.length() == 0)</span>
				{
<span class="nc" id="L1037">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;49&quot;);
				}
<span class="nc bnc" id="L1041" title="All 2 branches missed.">				if (format.length() == 0)</span>
				{
<span class="nc" id="L1043">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;50&quot;);
				}
			} // if (!validated)

			// For dates further format infoamtion is mandatory.
<span class="nc bnc" id="L1050" title="All 2 branches missed.">			if (format.equals(&quot;date&quot;)</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">					&amp;&amp; fieldSpec.getAttribute(&quot;DateFormat&quot;).length() == 0)</span>
			{
<span class="nc" id="L1053">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;51&quot;);
			}

			// The length must be an strictly positive integer
<span class="nc" id="L1059">			int lengthNum = Integer.parseInt(length);</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">			if (lengthNum &lt; 1)</span>
			{
<span class="nc" id="L1062">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;52&quot;);
			}
			// Constant values must be bound to a value.
<span class="nc bnc" id="L1067" title="All 2 branches missed.">			if (format.equals(&quot;const&quot;))</span>
			{
<span class="nc" id="L1069">				String value = fieldSpec.getAttribute(&quot;Value&quot;);</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">				if (value.length() == 0)</span>
				{
<span class="nc" id="L1072">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;53&quot;);
				}
<span class="nc bnc" id="L1076" title="All 2 branches missed.">				else if (value.length() != lengthNum)</span>
				{
<span class="nc" id="L1078">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;54&quot;);
				}
			} // if (fieldSpec.getAttribute(&quot;Format&quot;).equals(&quot;const&quot;))

			// some existance indicators to search for
<span class="nc bnc" id="L1085" title="All 2 branches missed.">			if (existanceIndicators != null)</span>
			{
<span class="nc" id="L1087">				String value = (String) existanceIndicators.get(name);</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">				if (value != null)</span>
				{ // existance indicator defined for this field
<span class="nc bnc" id="L1090" title="All 2 branches missed.">					if (value.equals(&quot;Found&quot;))</span>
					{
						// Already found for other field
<span class="nc" id="L1093">						throw new XException(Constants.LOCATION_INTERN,</span>
								Constants.LAYER_PROTOCOL,
								Constants.PACKAGE_PROTOCOL_RECORDS, &quot;44&quot;);
					}
<span class="nc bnc" id="L1097" title="All 2 branches missed.">					if (value.length() != lengthNum)</span>
					{
<span class="nc" id="L1099">						throw new XException(Constants.LOCATION_INTERN,</span>
								Constants.LAYER_PROTOCOL,
								Constants.PACKAGE_PROTOCOL_RECORDS, &quot;45&quot;);
					}
					// Mark as found.
<span class="nc" id="L1104">					existanceIndicators.put(name, &quot;Found&quot;);</span>
				} // if (value!=null)
			} // if (existanceIndicators!=null)
		} // try
<span class="nc" id="L1108">		catch (NumberFormatException e)</span>
		{
<span class="nc" id="L1110">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
		} // catch
<span class="nc" id="L1114">		catch (ClassCastException e)</span>
		{
<span class="nc" id="L1116">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L1119">		} // catch</span>
<span class="nc" id="L1120">	} // checkFieldSpecification(Element fieldSpec, TreeMap</span>

	// existanceIndicators, boolean validated)

	/**
	 * &lt;code&gt;checkGroupSpecification&lt;/code&gt; checks the consistency of a single
	 * field group specification. Extension if no prior DTD validating because
	 * otherwise completely redundant.
	 * 
	 * @param groupSpec
	 *            the group specification to check as DOM node
	 * @throws XException
	 *             in case of an inconsistency
	 */
	public void checkGroupSpecification(Element groupSpec) throws XException
	{
<span class="nc bnc" id="L1136" title="All 2 branches missed.">		if (groupSpec.getAttribute(&quot;Name&quot;).length() == 0)</span>
		{
<span class="nc" id="L1138">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;59&quot;);
		}
		try
		// for casting to XException
		{
<span class="nc" id="L1145">			NodeList fieldSpecs = groupSpec.getChildNodes();</span>
			// fields in the group
<span class="nc bnc" id="L1147" title="All 2 branches missed.">			for (int i = 0; i &lt; fieldSpecs.getLength(); i++)</span>
			{ // Loop over all group fields
<span class="nc bnc" id="L1149" title="All 2 branches missed.">				if (!((Element) fieldSpecs.item(i)).getNodeName().equals(</span>
						&quot;Field&quot;))
				{
<span class="nc" id="L1152">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;60&quot;);
				}
			} // for (int i=0; i&lt;fieldSpecs.getLength(); i++)
		} // try
<span class="nc" id="L1158">		catch (ClassCastException e)</span>
		{
<span class="nc" id="L1160">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L1163">		} // catch</span>
<span class="nc" id="L1164">	} // checkGroupSpecification(Node groupSpec)</span>

	// ///////////////////////
	// Auxiliary functions
	// ///////////////////////

	/**
	 * &lt;code&gt;typeIdsAreUnique&lt;/code&gt; checks if each declared record type id
	 * refers uniquely to only one record type.
	 * 
	 * @param typeIds
	 *            single-value id's as found in the record type declarations
	 * @param typeIdIntervals
	 *            intervals of id's (used as counters) as found in the record
	 *            type declarations
	 * @return &lt;code&gt;true&lt;/code&gt; if all id's are unique, false if an id refers
	 *         to two record types
	 */
	public boolean typeIdsAreUnique(LinkedList typeIds,
			LinkedList typeIdIntervals)
	{
<span class="nc" id="L1185">		boolean result = true;</span>
<span class="nc bnc" id="L1186" title="All 4 branches missed.">		for (int i = 0; i &lt; typeIds.size() &amp;&amp; result; i++)</span>
		{ // Loop over all single-value id's
<span class="nc bnc" id="L1188" title="All 4 branches missed.">			for (int j = i + 1; j &lt; typeIds.size() &amp;&amp; result; j++)</span>
				// Loop over rest of single-value id's
<span class="nc bnc" id="L1190" title="All 2 branches missed.">				result = !((String) typeIds.get(i)).equals((typeIds.get(j)));</span>
			// Repeated id?
<span class="nc bnc" id="L1192" title="All 4 branches missed.">			for (int j = 0; j &lt; typeIdIntervals.size() &amp;&amp; result; j++)</span>
				// Loop over all id intervals
<span class="nc" id="L1194">				result = (((String) typeIds.get(i))</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">						.compareTo(((String[]) typeIdIntervals.get(j))[0]) &lt; 0)</span>
<span class="nc" id="L1196">						|| (((String) typeIds.get(i))</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">								.compareTo(((String[]) typeIdIntervals.get(j))[1]) &gt; 0);</span>
			// Or member of one of the intervals?
		} // for (int i=0; i&lt;typeIds.size() &amp;&amp; result; i++)
<span class="nc bnc" id="L1200" title="All 4 branches missed.">		for (int i = 0; i &lt; typeIdIntervals.size() &amp;&amp; result; i++)</span>
			// Loop over all id intervals
<span class="nc bnc" id="L1202" title="All 4 branches missed.">			for (int j = i + 1; j &lt; typeIdIntervals.size() &amp;&amp; result; j++)</span>
				// Loop over rest of intervals
<span class="nc" id="L1204">				result = (((String[]) typeIdIntervals.get(i))[0]</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">						.compareTo(((String[]) typeIdIntervals.get(j))[1]) &gt; 0)</span>
<span class="nc" id="L1206">						|| (((String[]) typeIdIntervals.get(i))[1]</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">								.compareTo(((String[]) typeIdIntervals.get(j))[0]) &lt; 0);</span>
		// Do the two intervals intersect?
<span class="nc" id="L1209">		return result;</span>
	} // typeIdsAreUnique(LinkedList typeIds, LinkedList typeIdIntervals)

	/**
	 * &lt;code&gt;computeRecordLength&lt;/code&gt; calculates the string length for a
	 * record type - including header and trailer.
	 * 
	 * @param spec
	 *            the record type specification
	 * @param groupsSpec
	 *            the list of group specifications
	 * @return the total length including filler
	 * @throws XException
	 *             in case of a mal-specified length
	 */
	protected static int computeRecordLength(Node spec, Node groupsSpec)
			throws XException
	{
<span class="nc" id="L1227">		int fieldLengthSum = 0;</span>
		// for the result
<span class="nc" id="L1229">		NodeList fieldSpecs = spec.getChildNodes();</span>
		try
		// to cast to XException
		{
<span class="nc bnc" id="L1233" title="All 2 branches missed.">			for (int i = 0; i &lt; fieldSpecs.getLength(); i++)</span>
			{
<span class="nc" id="L1235">				Element fieldSpec = (Element) fieldSpecs.item(i);</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">				if (fieldSpec.getNodeName().equals(&quot;Field&quot;))</span>
<span class="nc" id="L1237">					fieldLengthSum += Integer.parseInt(fieldSpec</span>
<span class="nc" id="L1238">							.getAttribute(&quot;Length&quot;));</span>
<span class="nc bnc" id="L1239" title="All 2 branches missed.">				else if (fieldSpec.getNodeName().equals(&quot;Group&quot;))</span>
<span class="nc" id="L1240">					fieldLengthSum += computeGroupLength(fieldSpec, groupsSpec);</span>
			} // for (int i=0; i&lt;fieldSpecs.getLength(); i++)
		}
<span class="nc" id="L1243">		catch (NumberFormatException e)</span>
		{
<span class="nc" id="L1245">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L1248">		}</span>
<span class="nc" id="L1249">		return fieldLengthSum;</span>
	} // computeRecordLength(Element spec)

	/**
	 * &lt;code&gt;computeGroupLength&lt;/code&gt; calculates the string length for a
	 * field group.
	 * 
	 * @param groupRef
	 *            a refernce to the group
	 * @param groupsSpec
	 *            the list of group specifications
	 * @return the total length including filler
	 * @throws XException
	 *             in case of a mal-specified length or missing group
	 *             specification
	 */
	protected static int computeGroupLength(Element groupRef, Node groupsSpec)
			throws XException
	{
<span class="nc" id="L1268">		int groupLengthSum = 0;</span>
		// for the result
<span class="nc" id="L1270">		NodeList fieldSpecs = getGroupSpec(groupRef.getAttribute(&quot;Name&quot;),</span>
<span class="nc" id="L1271">				groupsSpec).getChildNodes();</span>
		// the group specification
		try
		// for casting to XException
		{
<span class="nc bnc" id="L1276" title="All 2 branches missed.">			for (int i = 0; i &lt; fieldSpecs.getLength(); i++)</span>
			{
<span class="nc" id="L1278">				Element fieldSpec = (Element) fieldSpecs.item(i);</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">				if (fieldSpec.getNodeName().equals(&quot;Field&quot;))</span>
<span class="nc" id="L1280">					groupLengthSum += Integer.parseInt(fieldSpec</span>
<span class="nc" id="L1281">							.getAttribute(&quot;Length&quot;));</span>
				else
				{
<span class="nc" id="L1284">					throw new XException(Constants.LOCATION_INTERN,</span>
							Constants.LAYER_PROTOCOL,
							Constants.PACKAGE_PROTOCOL_RECORDS, &quot;63&quot;);
				}
			} // for (int i=0; i&lt;fieldSpecs.getLength(); i++)
		} // try
<span class="nc" id="L1290">		catch (NumberFormatException e)</span>
		{
<span class="nc" id="L1292">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L1295">		} // catch</span>
<span class="nc" id="L1296">		return groupLengthSum;</span>
	} // computeGroupLength(Element groupRef, Node groupsSpec)

	/**
	 * &lt;code&gt;getGroupSpec&lt;/code&gt; selects the group specification node by the
	 * group name.
	 * 
	 * @param groupName
	 *            the name of the field group
	 * @param groupsSpec
	 *            the list of group specifications
	 * @return the group specification node
	 * @throws XException
	 *             in case that the group specification cannot be retrieved
	 */
	protected static Node getGroupSpec(String groupName, Node groupsSpec)
			throws XException
	{
<span class="nc" id="L1314">		Node result = null;</span>
		try
		// for casting to XException
		{
<span class="nc" id="L1318">			List groups = XDomSupport.getChildNodesByAttrValue(groupsSpec,</span>
					&quot;Name&quot;, groupName, &quot;GroupSpec&quot;);
<span class="nc bnc" id="L1320" title="All 2 branches missed.">			if (groups.size() != 1)</span>
			{
<span class="nc" id="L1322">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;65&quot;);
			}
<span class="nc" id="L1326">			result = (Node) groups.get(0);</span>
		} // try
<span class="nc" id="L1328">		catch (ClassCastException e)</span>
		{
<span class="nc" id="L1330">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L1333">		} // catch</span>
<span class="nc" id="L1334">		return result;</span>
	} // getGroupSpec(String groupName, Node groupsSpec)

} // RecordTypeDescriptionChecker
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>