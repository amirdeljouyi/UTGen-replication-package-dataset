<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RecordTypeMessage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">83_xbus</a> &gt; <a href="index.source.html" class="el_package">net.sf.xbus.protocol.records</a> &gt; <span class="el_source">RecordTypeMessage.java</span></div><h1>RecordTypeMessage.java</h1><pre class="source lang-java linenums">package net.sf.xbus.protocol.records;

import javax.xml.parsers.DocumentBuilder;

import net.sf.xbus.base.bytearraylist.ByteArrayList;
import net.sf.xbus.base.core.Constants;
import net.sf.xbus.base.core.XException;
import net.sf.xbus.base.xbussystem.XBUSSystem;
import net.sf.xbus.protocol.ObjectMessage;
import net.sf.xbus.protocol.TextMessage;
import net.sf.xbus.protocol.XMLMessage;
import net.sf.xbus.protocol.xml.XMLMessageAbstract;

import org.w3c.dom.Document;

/**
 * &lt;code&gt;RecordTypeMessage&lt;/code&gt; is used in the xBus to transport and convert
 * file contents structured by record types.
 * &lt;p&gt;
 * The structure is described by a xml file - in particular the contained record
 * types, their order within the string and how to identify them during parsing.
 * Such describing files are of document type &lt;code&gt;InterfaceSpec&lt;/code&gt;
 * declared in &quot;InterfaceSpec.dtd&quot;.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The records are internally stored in a DOM tree. Thus
 * &lt;code&gt;RecordTypeMessage&lt;/code&gt; extends
 * {@link net.sf.xbus.protocol.xml.XMLMessageAbstract}to use some of xml its
 * features.
 * &lt;/p&gt;
 * 
 * @author Stephan Duwel
 */
public class RecordTypeMessage extends XMLMessageAbstract
		implements
			TextMessage,
			ObjectMessage,
			XMLMessage
{

	private XBUSSystem mResponseSystem;

	/**
	 * This constructor stores the &lt;code&gt;source&lt;/code&gt;, creates an unique
	 * identifier for the message and initializes the requestTimestamp. It is
	 * used when constructing a new &lt;code&gt;RecordTypeMessage&lt;/code&gt; from the
	 * data of a receiver.
	 * 
	 * @param source the source of the data
	 */
	public RecordTypeMessage(XBUSSystem source)
	{
<span class="nc" id="L53">		super(source);</span>
<span class="nc" id="L54">		setShortname(&quot;RecordTypeMessage&quot;);</span>
<span class="nc" id="L55">	} // RecordTypeMessage(XBUSSystem source)</span>

	/**
	 * This constructor initializes the new &lt;code&gt;RecordTypeMessage&lt;/code&gt;
	 * with the given parameters. It is used when constructing a new
	 * &lt;code&gt;RecordTypeMessage&lt;/code&gt; by converting it from another
	 * {@link net.sf.xbus.protocol.Message Message}.
	 * 
	 * @param function the function to be executed by the destination system
	 * @param source the source of the data
	 * @param id the message id
	 */
	public RecordTypeMessage(String function, XBUSSystem source, String id)
	{
<span class="nc" id="L69">		super(function, source, id);</span>
<span class="nc" id="L70">		setShortname(&quot;RecordTypeMessage&quot;);</span>
<span class="nc" id="L71">	} // RecordTypeMessage(String function, XBUSSystem source, String id)</span>

	/**
	 * &lt;code&gt;setRequestText&lt;/code&gt; sets the text of the incoming message.
	 * After parsing due to the interface file and record type specification,
	 * the information is stored in a
	 * {@link org.w3c.dom.Document org.w3c.dom.Document}. This operation is
	 * used to work with strings.
	 * 
	 * @see #setRequestObject(Object, net.sf.xbus.base.xbussystem.XBUSSystem)
	 * @param text the data string
	 * @throws XException in case that the specifed string cannot be parsed
	 */
	public void setRequestText(String text, XBUSSystem source)
			throws XException
	{
<span class="nc bnc" id="L87" title="All 2 branches missed.">		if (text == null)</span>
<span class="nc" id="L88">			setRequestDocument(null, source);</span>
		else
<span class="nc" id="L90">			setRequestDocument(parseRecordsFromString(text, source), source);</span>
<span class="nc" id="L91">	} // setRequestText(String text)</span>

	/**
	 * Gets the text of the incoming message. It is the result of the
	 * serialization of a {@link org.w3c.dom.Document org.w3c.dom.Document}due
	 * to the interface file and record type specification. This operation is
	 * used to work with strings.
	 * 
	 * @see #getRequestObject(XBUSSystem)
	 * @param system reference to the system for which the message is meant -
	 *            used in finding specifications for serialising the message
	 *            content
	 * @return the message text as string
	 * @throws XException in case that the content cannot be serialised
	 */
	public String getRequestText(XBUSSystem system) throws XException
	{
<span class="nc" id="L108">		Document doc = getRequestDocument(system);</span>
<span class="nc" id="L109">		String result = null;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">		if (doc != null)</span>
<span class="nc" id="L111">			result = serializeRecordsToString(doc, system);</span>
<span class="nc" id="L112">		return result;</span>
	} // getRequestText()

	/**
	 * &lt;code&gt;setResponseText&lt;/code&gt; sets the text of the incoming message.
	 * After parsing due to the interface file and record type specification,
	 * the information is stored in a
	 * {@link org.w3c.dom.Document org.w3c.dom.Document}. This operation is
	 * used to work with strings.
	 * 
	 * @see #setResponseText(String, XBUSSystem)
	 * @param text the data string
	 * @throws XException in case that the specifed string cannot be parsed
	 */
	public void setResponseText(String text, XBUSSystem destination)
			throws XException
	{
<span class="nc" id="L129">		setReturncode(Constants.RC_OK);</span>
<span class="nc" id="L130">		setErrorcode(0);</span>
<span class="nc" id="L131">		setErrortext(null);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">		if (text == null)</span>
<span class="nc" id="L133">			setResponseDocument(null, destination);</span>
		else
<span class="nc" id="L135">			setResponseDocument(parseRecordsFromString(text, destination),</span>
					destination);
<span class="nc" id="L137">	} // setResponseText(String text)</span>

	/**
	 * Gets the text of the response message. It is the result of the
	 * serialization of a {@link org.w3c.dom.Document org.w3c.dom.Document}due
	 * to the interface file and record type specification. This operation is
	 * used to work with strings.
	 * 
	 * @see #getResponseText()
	 * @return the message text as string
	 * @throws XException in case that the content cannot be serialised
	 */
	public String getResponseText() throws XException
	{
<span class="nc" id="L151">		Document doc = getResponseDocument();</span>
<span class="nc" id="L152">		String response = null;</span>
<span class="nc bnc" id="L153" title="All 4 branches missed.">		if (doc != null &amp;&amp; mResponseSystem != null)</span>
<span class="nc" id="L154">			response = serializeRecordsToString(doc, mResponseSystem);</span>
<span class="nc" id="L155">		return response;</span>
	} // getResponseText()

	/**
	 * &lt;code&gt;setRequestObject&lt;/code&gt; sets the text of the incoming message.
	 * After parsing due to the interface file and record type specification,
	 * the information is stored in a
	 * {@link org.w3c.dom.Document org.w3c.dom.Document}. This operation is
	 * used to work with byte array lists.
	 * 
	 * @see #setRequestObject(Object, net.sf.xbus.base.xbussystem.XBUSSystem)
	 * @param obj the data in form of a
	 *            {@link net.sf.xbus.base.bytearraylist.ByteArrayList}
	 * @throws XException in case that the specifed string cannot be parsed
	 */
	public void setRequestObject(Object obj, XBUSSystem source)
			throws XException
	{
<span class="nc bnc" id="L173" title="All 2 branches missed.">		if (obj == null)</span>
<span class="nc" id="L174">			setRequestDocument(null, source);</span>
		else
		{
			try
			// for casting to XException
			{
<span class="nc" id="L180">				ByteArrayList bal = (ByteArrayList) obj;</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">				if (bal.length() == 0)</span>
<span class="nc" id="L182">					setRequestDocument(null, source);</span>
				else
<span class="nc" id="L184">					setRequestDocument(parseRecordsFromByteArrayList(bal,</span>
							source), source);
			} // try
<span class="nc" id="L187">			catch (ClassCastException e)</span>
			{
<span class="nc" id="L189">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L192">			} // catch</span>
		} // else (obj==null)
<span class="nc" id="L194">	} // setRequestObject(Object obj)</span>

	/**
	 * Gets the text of the incoming message as a
	 * {@link net.sf.xbus.base.bytearraylist.ByteArrayList}. It is the result
	 * of the serialization of a
	 * {@link org.w3c.dom.Document org.w3c.dom.Document}due to the interface
	 * file and record type specification. This operation is used to work with
	 * byte array lists.
	 * 
	 * @see #getRequestText(XBUSSystem)
	 * @param system reference to the system for which the message is meant -
	 *            used in finding specifications for serialising the message
	 *            content
	 * @return the message text as
	 *         {@link net.sf.xbus.base.bytearraylist.ByteArrayList}
	 * @throws XException in case that the content cannot be serialised
	 */
	public Object getRequestObject(XBUSSystem system) throws XException
	{
<span class="nc" id="L214">		Document doc = getRequestDocument(system);</span>
<span class="nc" id="L215">		Object result = null;</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">		if (doc != null)</span>
<span class="nc" id="L217">			result = serializeRecordsToByteArrayList(doc, system);</span>
<span class="nc" id="L218">		return result;</span>
	} // getRequestObject()

	/**
	 * &lt;code&gt;setResponseObject&lt;/code&gt; sets the text of the incoming message.
	 * After parsing due to the interface file and record type specification,
	 * the information is stored in a
	 * {@link org.w3c.dom.Document org.w3c.dom.Document}. This operation is
	 * used to work with byte array lists.
	 * 
	 * @see #setResponseText(String, XBUSSystem)
	 * @param obj the data in form of a
	 *            {@link net.sf.xbus.base.bytearraylist.ByteArrayList}
	 * @throws XException in case that the specifed string cannot be parsed
	 */
	public void setResponseObject(Object obj, XBUSSystem destination)
			throws XException
	{
<span class="nc" id="L236">		setReturncode(Constants.RC_OK);</span>
<span class="nc" id="L237">		setErrorcode(0);</span>
<span class="nc" id="L238">		setErrortext(null);</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">		if (obj == null)</span>
<span class="nc" id="L240">			setResponseDocument(null, destination);</span>
		else
		{
			try
			// for casting to XException
			{
<span class="nc" id="L246">				ByteArrayList bal = (ByteArrayList) obj;</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">				if (bal.length() == 0)</span>
<span class="nc" id="L248">					setRequestDocument(null, destination);</span>
				else
<span class="nc" id="L250">					setResponseDocument(parseRecordsFromByteArrayList(bal,</span>
							destination), destination);
			} // try
<span class="nc" id="L253">			catch (ClassCastException e)</span>
			{
<span class="nc" id="L255">				throw new XException(Constants.LOCATION_INTERN,</span>
						Constants.LAYER_PROTOCOL,
						Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L258">			} // catch</span>
		} // else (obj==null)
<span class="nc" id="L260">	} // setResponseObject(Object obj)</span>

	/**
	 * Gets the text of the response message as a
	 * {@link net.sf.xbus.base.bytearraylist.ByteArrayList}. It is the result
	 * of the serialization of a
	 * {@link org.w3c.dom.Document org.w3c.dom.Document}due to the interface
	 * file and record type specification. This operation is used to work with
	 * byte array lists.
	 * 
	 * @see #getResponseText()
	 * @return the message text as
	 *         {@link net.sf.xbus.base.bytearraylist.ByteArrayList}
	 * @throws XException in case that the content cannot be serialised
	 */
	public Object getResponseObject() throws XException
	{
<span class="nc" id="L277">		Document doc = getResponseDocument();</span>
<span class="nc" id="L278">		Object response = null;</span>
<span class="nc bnc" id="L279" title="All 4 branches missed.">		if (doc != null &amp;&amp; mResponseSystem != null)</span>
<span class="nc" id="L280">			response = serializeRecordsToByteArrayList(doc, mResponseSystem);</span>
<span class="nc" id="L281">		return response;</span>
	} // getResponseObject()

	public void setResponseDocument(Document doc, XBUSSystem destination)
			throws XException
	{
<span class="nc" id="L287">		mResponseSystem = destination;</span>

<span class="nc" id="L289">		super.setResponseDocument(doc, destination);</span>
<span class="nc" id="L290">	}</span>

	/**
	 * Gets the text of the message as xml document. It is the result of the
	 * standard serialization of a
	 * {@link org.w3c.dom.Document org.w3c.dom.Document}.
	 * 
	 * @param system reference to the system for which the message is meant -
	 *            used in finding specifications for serialising the message
	 *            content
	 * @return the serialised document in XML format
	 * @throws XException in case that the content cannot be serialised
	 */
	public String getRequestTextAsXML(XBUSSystem system) throws XException
	{
<span class="nc" id="L305">		return super.getRequestText(system);</span>
	} // getRequestTextAsXML()

	/**
	 * Empty method.
	 */
	protected void synchronizeRequestFields(XBUSSystem system)
<span class="nc" id="L312">	{} // synchronizeRequestFields()</span>

	/**
	 * Empty method.
	 */
	protected void synchronizeResponseFields(XBUSSystem system)
	{
<span class="nc" id="L319">		setReturncode(Constants.RC_OK);</span>
<span class="nc" id="L320">	} // synchronizeResponseFields()</span>

	/**
	 * Parses the given string due to the interface file and record type
	 * specification. This operation is used to work with strings.
	 * 
	 * @param interfaceContent the string to parse
	 * @return a DOM tree, &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;interfaceContent&lt;/code&gt;
	 *         is empty
	 * @throws XException in case of a parser error
	 */
	private Document parseRecordsFromString(String interfaceContent,
			XBUSSystem system) throws XException
	{
<span class="nc" id="L334">		Document retDocument = null;</span>
		// for the result
<span class="nc bnc" id="L336" title="All 2 branches missed.">		if (interfaceContent != null)</span>
		{ // There is something to parse
<span class="nc" id="L338">			retDocument = parseRecords(interfaceContent,</span>
					Constants.IFCONTENTCLASS_STRING, system);
		} // if ((interfaceContent != null) &amp;&amp; (interfaceContent.length() &gt;
			// 0))
<span class="nc" id="L342">		return retDocument;</span>
	} // parseRecordsFromString(String interfaceContent)

	/**
	 * &lt;code&gt;parseRecordsFromByteArrayList&lt;/code&gt; parses the given bytearray
	 * due to the interface file and record type specification.
	 * 
	 * @param interfaceContent the &lt;code&gt;ByteArrayList&lt;/code&gt; to parse
	 * @return a DOM tree, &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;interfaceContent&lt;/code&gt;
	 *         is empty
	 * @throws XException in case of a parser error
	 */
	private Document parseRecordsFromByteArrayList(
			ByteArrayList interfaceContent, XBUSSystem system)
			throws XException
	{
<span class="nc" id="L358">		Document retDocument = null;</span>
		// for the result
<span class="nc bnc" id="L360" title="All 2 branches missed.">		if (interfaceContent != null)</span>
		{ // There is something to parse
<span class="nc" id="L362">			retDocument = parseRecords(interfaceContent,</span>
					Constants.IFCONTENTCLASS_BYTEARRAYLIST, system);
		} // if ((interfaceContent != null) &amp;&amp; (interfaceContent.length() &gt;
			// 0))
<span class="nc" id="L366">		return retDocument;</span>
	} // parseRecordsFromByteArrayList(ByteArrayList interfaceContent)

	/**
	 * &lt;code&gt;parseRecords&lt;/code&gt; is the parsing kernel common for working
	 * modes &quot;string&quot; and &quot;byte array list&quot;.
	 * 
	 * @param interfaceContent the data to parse
	 * @param interfaceContentClass indicator for working mode -
	 *            {@link java.lang.String}or
	 *            {@link net.sf.xbus.base.bytearraylist.ByteArrayList}
	 * @return a DOM tree, &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;interfaceContent&lt;/code&gt;
	 *         is empty
	 * @throws XException in case of a parser error
	 */
	private Document parseRecords(Object interfaceContent,
			int interfaceContentClass, XBUSSystem system) throws XException
	{
		Document retDocument;
<span class="nc" id="L385">		DocumentBuilder builder = getDocumentBuilder(system);</span>
<span class="nc" id="L386">		retDocument = builder.newDocument();</span>
		// for the parsed content
<span class="nc" id="L388">		RecordTypeParser rtParser = RecordTypeParser.getInstance(getSource()</span>
<span class="nc" id="L389">				.getName(), interfaceContentClass);</span>
		// Get a parser object

<span class="nc bnc" id="L392" title="All 2 branches missed.">		if (rtParser.getSourceType() == null</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">				|| !rtParser.getSourceType().equals(getSource().getName())</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">				|| rtParser.getInterfaceContentClass() != interfaceContentClass)</span>
		{ // Parser is not yet initialised for the correct interface file
			// type
<span class="nc" id="L397">			rtParser.initialize(getSource().getName(), interfaceContentClass,</span>
					builder);
		} // if (rtParser.getSourceType()==null ||
		// !rtParser.getSourceType().equals(getSource().getName()))

		// Now the parser is initialised, let's go.
<span class="nc" id="L403">		rtParser.parse(interfaceContent, retDocument);</span>
<span class="nc" id="L404">		return retDocument;</span>
	} // parseRecords(String interfaceContent)

	/**
	 * &lt;code&gt;serializeRecordsToString&lt;/code&gt; translates the dom tree for the
	 * parsed records to a string conforming to the interface file and record
	 * type specification. This operation is used to work with strings.
	 * 
	 * @param doc the DOM tree
	 * @param system reference to the system for which the message is meant -
	 *            used in finding specifications for serialising the message
	 *            content
	 * @return the serialised data as string, &lt;code&gt;null&lt;/code&gt; for an empty
	 *         &lt;code&gt;doc&lt;/code&gt;
	 */
	private String serializeRecordsToString(Document doc, XBUSSystem system)
			throws XException
	{
<span class="nc" id="L422">		String records = null;</span>
		// for the result
		try
		{
<span class="nc" id="L426">			records = (String) serializeRecords(doc, system,</span>
					Constants.IFCONTENTCLASS_STRING);
		} // try
<span class="nc" id="L429">		catch (ClassCastException e)</span>
		{
<span class="nc" id="L431">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L434">		} // catch</span>
<span class="nc" id="L435">		return records;</span>
	} // serializeRecordsToString(Document doc)

	/**
	 * &lt;code&gt;serializeRecordsToByteArrayList&lt;/code&gt; translates the dom tree
	 * for the parsed records to a byte array list conforming to the interface
	 * file and record type specification. This operation is used to work with
	 * byte array lists.
	 * 
	 * @param doc the DOM tree
	 * @param system reference to the system for which the message is meant -
	 *            used in finding specifications for serialising the message
	 *            content
	 * @return the serialised data as
	 *         {@link net.sf.xbus.base.bytearraylist.ByteArrayList},
	 *         &lt;code&gt;null&lt;/code&gt; for an empty &lt;code&gt;doc&lt;/code&gt;
	 */
	private ByteArrayList serializeRecordsToByteArrayList(Document doc,
			XBUSSystem system) throws XException
	{
<span class="nc" id="L455">		ByteArrayList records = null;</span>
		try
		{
<span class="nc" id="L458">			records = (ByteArrayList) serializeRecords(doc, system,</span>
					Constants.IFCONTENTCLASS_BYTEARRAYLIST);
		} // try
<span class="nc" id="L461">		catch (ClassCastException e)</span>
		{
<span class="nc" id="L463">			throw new XException(Constants.LOCATION_INTERN,</span>
					Constants.LAYER_PROTOCOL,
					Constants.PACKAGE_PROTOCOL_RECORDS, &quot;0&quot;, e);
<span class="nc" id="L466">		} // catch</span>
<span class="nc" id="L467">		return records;</span>
	} // serializeRecordsToByteArrayList(Document doc)

	/**
	 * &lt;code&gt;serializeRecords&lt;/code&gt; is the serializing kernel common for
	 * working modes &quot;string&quot; and &quot;byte array list&quot;.
	 * 
	 * @param doc the DOM tree to serialize
	 * @param system reference to the system for which the message is meant -
	 *            used in finding specifications for serialising the message
	 *            content
	 * @param interfaceContentClass indicator for working mode -
	 *            {@link java.lang.String}or
	 *            {@link net.sf.xbus.base.bytearraylist.ByteArrayList}
	 * @return a DOM tree, &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;interfaceContent&lt;/code&gt;
	 *         is empty
	 * @throws XException in case of a parser error
	 */
	private Object serializeRecords(Document doc, XBUSSystem system,
			int interfaceContentClass) throws XException
	{
<span class="nc" id="L488">		Object records = null;</span>
		// for the result
<span class="nc bnc" id="L490" title="All 2 branches missed.">		if (doc != null)</span>
		{ // There is a document to serialize.
			String sourceType;

			// the interface file type
<span class="nc bnc" id="L495" title="All 2 branches missed.">			if (system != null)</span>
<span class="nc" id="L496">				sourceType = system.getName();</span>
			else
<span class="nc" id="L498">				sourceType = doc.getDocumentElement().getNodeName();</span>

			// Get a serializer object
<span class="nc" id="L501">			RecordTypeSerializer rtSerializer = RecordTypeSerializer</span>
<span class="nc" id="L502">					.getInstance(sourceType, interfaceContentClass);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">			if (rtSerializer.getSourceType() == null</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">					|| !rtSerializer.getSourceType().equals(sourceType)</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">					|| rtSerializer.getInterfaceContentClass() != interfaceContentClass)</span>
			{ // Serializer is not yet initialised for the correct interface
				// file type
<span class="nc" id="L508">				DocumentBuilder builder = getDocumentBuilder(system);</span>
<span class="nc" id="L509">				rtSerializer.initialize(sourceType, interfaceContentClass,</span>
						builder);
			} // if (rtSerializer.getSourceType()==null ||
			// !rtSerializer.getSourceType().equals(contentType))
			// Serializer is initialized, so let's go.
<span class="nc" id="L514">			records = rtSerializer.serialize(doc);</span>
		} // if (doc != null)

<span class="nc" id="L517">		return records;</span>
	} // serializeRecords(Document doc, int interfaceContentClass)

} // RecordTypeMessage
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>