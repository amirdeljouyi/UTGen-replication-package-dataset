<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>bcGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">72_battlecry</a> &gt; <a href="index.source.html" class="el_package">bcry</a> &gt; <span class="el_source">bcGenerator.java</span></div><h1>bcGenerator.java</h1><pre class="source lang-java linenums">/* Battlecry V0.1
 * Copyright (C) 2003  Marek &quot;Wansti&quot; Moeckel
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package bcry;

import java.util.*;
import java.util.List.*;

/* THE BATTLECRY GENERATOR
 * This class is the main part of Battlecry.
 * It initializes a module and generates the lyrics with its information.
 */
class bcGenerator {

<span class="fc" id="L30">   private final String GRAMMAR_START = &quot;START&quot;;</span>
<span class="fc" id="L31">   private final String GRAMMAR_TITLE = &quot;TITLE&quot;;</span>
   
<span class="fc" id="L33">   private Random r = new Random();</span>
<span class="fc" id="L34">   private int currentSyllables = 0;</span>
<span class="fc" id="L35">   private String rSeg = &quot;&quot;;</span>
   
   private bcModule module;
   private bcVoice voice;

   
   /* CLASS CONSTRUCTOR */
<span class="fc" id="L42">   public bcGenerator(bcModule m, bcVoice v) {</span>
<span class="fc" id="L43">      voice = v;</span>
<span class="fc" id="L44">      module = m;</span>
<span class="fc" id="L45">   }</span>

   // ---------------- LYRICS CREATION METHODS ----------------

   /* parseGrammar
    * Parses the information stores in the grammar properties and
    * generates a random string which then can be parsed by fill() to
    * create a line of lyrics.
    */
   private String parseGrammar(String segment) {

<span class="nc" id="L56">      String output = &quot;&quot;;</span>
      try {
         String[] temp;
         
         //Get segment from Properties and look for brackets
<span class="nc" id="L61">         String seg = replaceBrackets(module.getGrammar().getProperty(segment,segment));</span>
            
         //Split between semicolons
<span class="nc bnc" id="L64" title="All 2 branches missed.">         if (seg.indexOf(&quot;;&quot;) == -1) {</span>
<span class="nc" id="L65">            temp = new String[1];</span>
<span class="nc" id="L66">            temp[0] = seg.substring(1,seg.length()-1);</span>
         }
         else {
<span class="nc" id="L69">            temp = seg.substring(1,seg.length()-1).split(&quot;;&quot;);</span>
         }

<span class="nc bnc" id="L72" title="All 2 branches missed.">         for (int i = 0; i &lt; temp.length; i++) {</span>
            //LOOK FOR &quot;OR&quot;, randomize if found
<span class="nc bnc" id="L74" title="All 2 branches missed.">            if (temp[i].indexOf(&quot;#&quot;) != -1) {</span>
<span class="nc" id="L75">               String[] temp2 = temp[i].split(&quot;#&quot;);</span>
<span class="nc" id="L76">               temp[i] = temp2[r.nextInt(temp2.length)];</span>
            }
            //FOUND BRACKETED SUBSEGMENT; change back the AND's and OR's and parse recursively
<span class="nc bnc" id="L79" title="All 4 branches missed.">            if ((temp[i].startsWith(&quot;(&quot;)) &amp;&amp; (temp[i].endsWith(&quot;)&quot;))) {</span>
<span class="nc" id="L80">               temp[i] = temp[i].replace('&amp;',';');</span>
<span class="nc" id="L81">               temp[i] = temp[i].replace('|','#');</span>
<span class="nc" id="L82">               temp[i] = &quot;{&quot; + temp[i].substring(1,temp[i].length()-1) + &quot;}&quot;;</span>
<span class="nc" id="L83">               output += parseGrammar(temp[i]);</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">               if (i &lt; temp.length-1) {output += &quot;@&quot;;}</span>
            }
            //FOUND OPTIONAL BRACKETED SUBSEGMENT; change back the AND's and OR's and parse recursively
<span class="nc bnc" id="L87" title="All 4 branches missed.">            else if ((temp[i].startsWith(&quot;*(&quot;)) &amp;&amp; (temp[i].endsWith(&quot;)&quot;))) {</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">               if (r.nextInt(2) == 1) {</span>
<span class="nc" id="L89">                 temp[i] = temp[i].replace('&amp;',';');</span>
<span class="nc" id="L90">                 temp[i] = temp[i].replace('|','#');</span>
<span class="nc" id="L91">                 temp[i] = &quot;{&quot; + temp[i].substring(2,temp[i].length()-1) + &quot;}&quot;;</span>
<span class="nc" id="L92">                 output += parseGrammar(temp[i]);</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">                 if (i &lt; temp.length-1) {output += &quot;@&quot;;}</span>
               }
            }
            //FOUND STRING
<span class="nc bnc" id="L97" title="All 4 branches missed.">            else if ((temp[i].startsWith(&quot;'&quot;)) &amp;&amp; (temp[i].endsWith(&quot;'&quot;))) {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">               if (isWord(temp[i].substring(1,temp[i].length()-1))) {</span>
<span class="nc" id="L99">                  currentSyllables += getWordFromLists(temp[i].substring(1,temp[i].length()-1)).getSyllables();</span>
               }
<span class="nc" id="L101">               output += temp[i];</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">               if (i &lt; temp.length-1) {output += &quot;@&quot;;}</span>
               
            }
            //FOUND OPTIONAL STRING
<span class="nc bnc" id="L106" title="All 4 branches missed.">            else if ((temp[i].startsWith(&quot;*'&quot;)) &amp;&amp; (temp[i].endsWith(&quot;'&quot;))) {</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">               if (r.nextInt(2) == 1) {</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">                 if (isWord(temp[i].substring(2,temp[i].length()-1))) {</span>
<span class="nc" id="L109">                    currentSyllables += getWordFromLists(temp[i].substring(2,temp[i].length()-1)).getSyllables();</span>
                 }
<span class="nc" id="L111">                 output += temp[i].substring(1,temp[i].length());</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">                 if (i &lt; temp.length-1) {output += &quot;@&quot;;}                </span>
               }
            }
            //FOUND SEGMENT; parse recursively
<span class="nc bnc" id="L116" title="All 4 branches missed.">            else if ((temp[i].startsWith(&quot;[&quot;)) &amp;&amp; (temp[i].endsWith(&quot;]&quot;))) {</span>
<span class="nc" id="L117">               output += parseGrammar(temp[i].substring(1,temp[i].length()-1));</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">               if (i &lt; temp.length-1) {output += &quot;@&quot;;}</span>
            }
            //FOUND OPTIONAL SEGMENT
<span class="nc bnc" id="L121" title="All 4 branches missed.">            else if ((temp[i].startsWith(&quot;*[&quot;)) &amp;&amp; (temp[i].endsWith(&quot;]&quot;))) {</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">               if (r.nextInt(2) == 1) {</span>
<span class="nc" id="L123">                  output += parseGrammar(temp[i].substring(2,temp[i].length()-1));</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">                  if (i &lt; temp.length-1) {output += &quot;@&quot;;}</span>
               }
            }
            //FOUND OPTIONAL WORD FROM A LIST
<span class="nc bnc" id="L128" title="All 2 branches missed.">            else if (temp[i].startsWith(&quot;*&quot;)) {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">               if (r.nextInt(2) == 1) {</span>
<span class="nc" id="L130">                  output += temp[i].substring(1,temp[i].length());</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">                  if (i &lt; temp.length-1) {output += &quot;@&quot;;}</span>
               }
            }
            //FOUND WORD FROM A LIST
            else {
<span class="nc" id="L136">               output += temp[i].substring(0,temp[i].length());</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">               if (i &lt; temp.length-1) {output += &quot;@&quot;;}</span>
            }
         }
      }
<span class="nc" id="L141">      catch (Exception e) {</span>
<span class="nc" id="L142">         voice.sysout(&quot;Error: Missing or illegal expression in grammar.dat - Segment:&quot;+segment);</span>
<span class="nc" id="L143">         voice.sysout(e.toString());</span>
<span class="nc" id="L144">      }</span>
      //cut &quot;@&quot; at the end of string
<span class="nc bnc" id="L146" title="All 2 branches missed.">      if (output.endsWith(&quot;@&quot;)) {output = output.substring(0,output.length()-1);}</span>
<span class="nc" id="L147">      return output;</span>
   }

   /* parseLayout
    * Determines the song's structure according to the layout data and
    * generates the lyrics.
    */
   private void parseLayout() {

      String[] temp;
<span class="nc" id="L157">      String[] chorus = null;</span>
      int lines;

<span class="nc bnc" id="L160" title="All 2 branches missed.">      for (int i = 0; i &lt; module.getLayout().size(); i++) {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">         if (!(((String)module.getLayout().get(i)).indexOf(&quot;:&quot;) == -1)) {</span>
<span class="nc" id="L162">            temp = ((String)module.getLayout().get(i)).split(&quot;:&quot;);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">            if (temp[0].equals(&quot;lines&quot;)) {</span>
<span class="nc" id="L164">               lines = Integer.parseInt(temp[1]);</span>
<span class="nc" id="L165">               voice.sing(makeLines(lines));</span>
            }
<span class="nc bnc" id="L167" title="All 2 branches missed.">            else if (temp[0].equals(&quot;verse&quot;)) {</span>
<span class="nc" id="L168">               voice.sing(makeChorus(temp[1]));</span>
            }
<span class="nc bnc" id="L170" title="All 2 branches missed.">            else if (temp[0].equals(&quot;chorus&quot;)) {</span>
<span class="nc" id="L171">               voice.sing(&quot;[Chorus]&quot;);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">               if (chorus == null) {</span>
<span class="nc" id="L173">                  chorus = makeChorus(temp[1]);</span>
               }
<span class="nc" id="L175">               voice.sing(chorus);</span>
            }
<span class="nc bnc" id="L177" title="All 2 branches missed.">            else if (temp[0].equals(&quot;bridge&quot;)) {</span>
<span class="nc" id="L178">               lines = Integer.parseInt(temp[1]);</span>
<span class="nc" id="L179">               voice.sing(makeBridge(lines));</span>
            }
         }
         else {
<span class="nc" id="L183">            voice.sing(fill(parseGrammar((String)module.getLayout().get(i))));</span>
         }
      }
<span class="nc" id="L186">   }</span>

   /* xLiner
    * Creates two or three random rhyming lines with the same syllable count (more or less)
    * and returns them as an array.
    * &quot;number&quot; can be either 2 or 3.
    */
   private String[] xLiner(int number) { 
      
      //first, make sure we have a valid argument
<span class="nc bnc" id="L196" title="All 2 branches missed.">      if (number &lt;= 2) {number = 2;} else {number = 3;}</span>
      
<span class="nc" id="L198">      String[] result = new String[number];</span>
<span class="nc" id="L199">      String[] lastSegs = new String[number-1];</span>
<span class="nc" id="L200">      String lastWord = &quot;&quot;;</span>
<span class="nc" id="L201">      String tempWord = &quot;&quot;;      </span>
<span class="nc" id="L202">      int[] tempSyls = new int[number];</span>
<span class="nc" id="L203">      int tempSyl = 0;</span>
      boolean match;
<span class="nc" id="L205">      bcWordList lst = null;</span>
<span class="nc" id="L206">      bcWord current = null;</span>
      
      //first loop: first and second line; second loop: second and third line (if there is one)
<span class="nc bnc" id="L209" title="All 2 branches missed.">      for (int l=0; l&lt;=number-2; l++) {         </span>
         do {
<span class="nc" id="L211">            match = true;</span>
                 
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (l == 0) {</span>
               //Generate the first line of text, only in the first run of the l-loop
<span class="nc" id="L215">               currentSyllables = 0;</span>
<span class="nc" id="L216">               result[0] = fill(parseGrammar(GRAMMAR_START));</span>
<span class="nc" id="L217">               lastWord = getLastWord(result[0]);</span>
<span class="nc" id="L218">               tempSyls[0] = currentSyllables;</span>
<span class="nc" id="L219">               currentSyllables = 0;</span>
            }
            else {
<span class="nc" id="L222">               lastWord = getLastWord(result[1]);</span>
            }
         
            //Get a second line from parseGrammar and cut off their last word, which is left blank
<span class="nc" id="L226">            result[l+1] = parseGrammar(GRAMMAR_START);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if (result[l+1].indexOf(&quot;@&quot;) == -1) {</span>
               //last word is only word
<span class="nc" id="L229">               lastSegs[l] = result[l+1];</span>
<span class="nc" id="L230">               result[l+1] = &quot;&quot;;</span>
<span class="nc" id="L231">               tempSyls[l+1] = currentSyllables = 0;</span>
            }
            else {
               //find last word and cut it off
<span class="nc bnc" id="L235" title="All 2 branches missed.">               for (int j = result[l+1].length()-1; j &gt;= 0; j--) {</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">                  if (result[l+1].charAt(j) == '@') {</span>
<span class="nc" id="L237">                     lastSegs[l] = result[l+1].substring(j+1);</span>
<span class="nc" id="L238">                     result[l+1] = fill(result[l+1].substring(0,j));</span>
<span class="nc" id="L239">                     tempSyls[l+1] = currentSyllables;</span>
<span class="nc" id="L240">                     currentSyllables = 0;</span>
<span class="nc" id="L241">                     break;</span>
                  }
               }
            }        
            
            //finish second line
<span class="nc bnc" id="L247" title="All 4 branches missed.">            if (lastSegs[l].startsWith(&quot;'&quot;) &amp;&amp; lastSegs[l].endsWith(&quot;'&quot;)) {</span>
               //last word is a string, test if it rhymes with first line
<span class="nc" id="L249">               tempWord = lastSegs[l].substring(1,lastSegs[l].length()-1);</span>
<span class="nc" id="L250">               tempSyl = getWordFromLists(tempWord).getSyllables();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">               if ((rhyming(tempWord,lastWord) &lt; 1) ||</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">                 !(tempSyl+tempSyls[l+1] &lt;= tempSyls[0]+module.getSyllableTolerance()) ||</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">                 !(tempSyl+tempSyls[l+1] &gt;= tempSyls[0]-module.getSyllableTolerance())) {</span>
<span class="nc" id="L254">                  match = false;</span>
               }
               else {
                  //complete second line
<span class="nc" id="L258">                  result[l+1] += &quot; &quot; + tempWord;</span>
<span class="nc" id="L259">                  tempSyls[l+1] += tempSyl;</span>
               }
            }
            else {
               //create list of possible last words, choose one at random
<span class="nc" id="L264">               lst = module.getWordList(lastSegs[l]);            </span>
<span class="nc" id="L265">               List possibleMatches = new LinkedList();</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">               for (int j = 0; j &lt; lst.getNumberOfWords(); j++) {</span>
<span class="nc" id="L267">                  current = lst.getItem(j);</span>
<span class="nc" id="L268">                  tempWord = current.getWord();</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">                  if ((rhyming(tempWord,lastWord) == 1) &amp;&amp;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">                      (current.getSyllables()+tempSyls[l+1] &lt;= tempSyls[0]+module.getSyllableTolerance()) &amp;&amp;</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">                      (current.getSyllables()+tempSyls[l+1] &gt;= tempSyls[0]-module.getSyllableTolerance())) {</span>
<span class="nc" id="L272">                     possibleMatches.add(current);</span>
                  }
               }
<span class="nc bnc" id="L275" title="All 2 branches missed.">               if (possibleMatches.size() == 0) {</span>
                  //no word from the list can make a match
<span class="nc" id="L277">                  match = false;              </span>
               }
               else {
                  //one or more possible matches found, choose one at random
<span class="nc" id="L281">                  current = (bcWord)possibleMatches.get(r.nextInt(possibleMatches.size()));</span>
<span class="nc" id="L282">                  tempWord = current.getWord();</span>
<span class="nc" id="L283">                  result[l+1] += &quot; &quot; + tempWord;</span>
<span class="nc" id="L284">                  tempSyls[l+1] += current.getSyllables();</span>
               }
            }
<span class="nc bnc" id="L287" title="All 6 branches missed.">            if ((module.getSyllableTolerance() == 0) &amp;&amp; (!result[l+1].equals(&quot;&quot;)) &amp;&amp; (!metricMatch(result[0], result[l+1]))) {</span>
               //Only test metrum if Syllable Tolerance is zero
               //TODO: Find out why result[l] can be empty string
<span class="nc" id="L290">               match = false;</span>
            }
         } //end do
<span class="nc bnc" id="L293" title="All 2 branches missed.">         while (!match);</span>
      } //end for    
<span class="nc" id="L295">      return result;</span>
   } 

   /* makeBridge
    * Creates a bunch of rhyming TwoLiners according to the given chorus length in the layout
    * file. Odd line numbers will be increased by 1.
    */
   private String[] makeBridge(int lines) {

<span class="nc" id="L304">      String[] result = new String[lines];</span>
      String[] temp;
<span class="nc bnc" id="L306" title="All 2 branches missed.">      if (lines % 2 != 0) {lines += 1;}</span>
      int i;
<span class="nc bnc" id="L308" title="All 2 branches missed.">      for (i = 0; i &lt; lines; i++) {</span>
<span class="nc" id="L309">         temp = xLiner(2);</span>
<span class="nc" id="L310">         result[i] = temp[0];</span>
<span class="nc" id="L311">         i++;</span>
<span class="nc" id="L312">         result[i] = temp[1];</span>
      }
<span class="nc" id="L314">      return result;</span>
   }

   /* makeChorus
    * It generates a bunch of rhyming lines according to a given scheme,
    * for example &quot;aabb&quot; or &quot;ababcdcd&quot;.
    * Letters a-e can be used; each letter must not appear more than three times.
    * If you use complex schemes, make sure you have enough rhyming words!
    */
   private String[] makeChorus(String scheme) {

<span class="nc" id="L325">      String[] result = new String[scheme.length()];</span>
<span class="nc" id="L326">      String[][] schemes = new String[5][3];</span>
<span class="nc" id="L327">      scheme = scheme.toLowerCase();</span>
<span class="nc" id="L328">      int[] count = new int[5];</span>
      boolean rhyming;
      
<span class="nc bnc" id="L331" title="All 2 branches missed.">      for (int i = 0; i &lt; 5; i++) {</span>
<span class="nc" id="L332">         schemes[i] = new String[3];</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">         for (int j = 0; j &lt; 3; j++) {schemes[i][j] = &quot;&quot;;}</span>
<span class="nc" id="L334">         count[i] = 0;</span>
      }
      
      //Count letters a-e
<span class="nc bnc" id="L338" title="All 2 branches missed.">      for (int i = 0; i &lt; scheme.length(); i++) {</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">         if (scheme.substring(i).startsWith(&quot;a&quot;)) {count[0]++;}</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">         else if (scheme.substring(i).startsWith(&quot;b&quot;)) {count[1]++;}</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">         else if (scheme.substring(i).startsWith(&quot;c&quot;)) {count[2]++;}</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">         else if (scheme.substring(i).startsWith(&quot;d&quot;)) {count[3]++;}</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">         else if (scheme.substring(i).startsWith(&quot;e&quot;)) {count[4]++;}</span>
      }
      
      //Start building a scheme
      do {
<span class="nc" id="L348">         rhyming = false;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">         for (int i = 0; i &lt; 5; i++) {</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">            if (count[i] == 1) {</span>
<span class="nc" id="L351">               schemes[i][0] = fill(parseGrammar(GRAMMAR_START));</span>
            }
<span class="nc bnc" id="L353" title="All 2 branches missed.">            else if (count[i] &gt;= 2) {</span>
<span class="nc" id="L354">               schemes[i] = xLiner(count[i]);</span>
            }
<span class="nc bnc" id="L356" title="All 2 branches missed.">            for (int j = 0; j &lt;= i; j++) {</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">               if ((i != j) &amp;&amp; </span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">                  ((rhyming(getLastWord(schemes[i][0]),schemes[j][0]) == 1) || </span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">                  (rhyming(getLastWord(schemes[i][0]),schemes[j][0]) == -2))) {</span>
<span class="nc" id="L360">                  rhyming = true;</span>
               }
            }
         }       
<span class="nc" id="L364">         voice.progressBarDot(&quot;.&quot;);</span>
      }
<span class="nc bnc" id="L366" title="All 2 branches missed.">      while (rhyming);</span>
      
      //Good scheme found, now arrange it
<span class="nc bnc" id="L369" title="All 2 branches missed.">      for (int i = 0; i &lt; 5; i++) {count[i] = 0;}</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">      for (int i = 0; i &lt; scheme.length(); i++) {</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">         if (scheme.substring(i).startsWith(&quot;a&quot;)) {result[i] = schemes[0][count[0]]; count[0]++;}</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">         else if (scheme.substring(i).startsWith(&quot;b&quot;)) {result[i] = schemes[1][count[1]]; count[1]++;}</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">         else if (scheme.substring(i).startsWith(&quot;c&quot;)) {result[i] = schemes[2][count[2]]; count[2]++;}</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">         else if (scheme.substring(i).startsWith(&quot;d&quot;)) {result[i] = schemes[3][count[3]]; count[3]++;}</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">         else if (scheme.substring(i).startsWith(&quot;e&quot;)) {result[i] = schemes[4][count[4]]; count[4]++;}</span>
      }
<span class="nc" id="L377">      return result;</span>
   }



   /* makeLines
    * Creates a bunch of (non-rhyming) random lines.
    */
   private String[] makeLines(int lines) {

<span class="nc" id="L387">      String[] result = new String[lines];</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">      for (int i = 0; i &lt; lines; i++) {</span>
<span class="nc" id="L389">         currentSyllables = 0;</span>
<span class="nc" id="L390">         result[i] = fill(parseGrammar(GRAMMAR_START));</span>
      }
<span class="nc" id="L392">      return result;</span>
   }
   

   // ---------------- AUXILIARY METHODS ----------------

   /* fill()
    * Fills the string generated by parseGrammar with words.
    */
   private String fill(String seg) {
<span class="nc" id="L402">      String result = &quot;&quot;;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">      if (seg.indexOf(&quot;@&quot;) == -1) {</span>
<span class="nc bnc" id="L404" title="All 4 branches missed.">         if (seg.startsWith(&quot;'&quot;) &amp;&amp; seg.endsWith(&quot;'&quot;)) {</span>
<span class="nc" id="L405">            result = seg.substring(1,seg.length()-1);</span>
         }
         else {
<span class="nc" id="L408">            result = getRandomWord(seg);</span>
         }
      }
      else {
<span class="nc" id="L412">         String[] segs = seg.split(&quot;@&quot;);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">         for (int i=0; i&lt;segs.length; i++) {</span>
<span class="nc bnc" id="L414" title="All 4 branches missed.">            if (segs[i].startsWith(&quot;'&quot;) &amp;&amp; segs[i].endsWith(&quot;'&quot;)) {</span>
<span class="nc" id="L415">               result += segs[i].substring(1,segs[i].length()-1);</span>
            }
            else {
<span class="nc bnc" id="L418" title="All 2 branches missed.">               if (!segs[i].equals(&quot;&quot;)) {result += getRandomWord(segs[i]);}</span>
            }
<span class="nc bnc" id="L420" title="All 2 branches missed.">            if (i&lt;segs.length-1) {result += &quot; &quot;;}  </span>
         }
      }
<span class="nc" id="L423">      return result;</span>
   }

   /* getRandomWord
    * Returns a random word from the given word list.
    * Warning: Used by parseGrammar only; might f**k up the syllable count if used elsewhere!
    */
   private String getRandomWord(String listName) {

<span class="nc" id="L432">      String result = &quot;[LIST NOT FOUND]&quot;;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">      for (int i = 0; i &lt; module.getWordLists().size(); i++) {</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">         if (((bcWordList)module.getWordLists().get(i)).getFileName().equals(listName)) {</span>
<span class="nc" id="L435">            result = ((bcWordList)module.getWordLists().get(i)).getRandomItem().getWord();</span>
<span class="nc" id="L436">            currentSyllables += getWordFromLists(result).getSyllables();</span>
<span class="nc" id="L437">            break;</span>
         }
      }
<span class="nc bnc" id="L440" title="All 2 branches missed.">      if (result.equals(&quot;[LIST NOT FOUND]&quot;)) {voice.sysout(&quot;Error: Word list '&quot;+listName+&quot;' not found, check data files!&quot;);}</span>
<span class="nc" id="L441">      return result;</span>
   }
   
   /* getWordFromLists
    * Returns a given word from any of the word lists.
    * This returns a bcWord object, not just a string!
    */
   private bcWord getWordFromLists(String word) {      
<span class="nc" id="L449">      bcWord result = null;</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">      for (int i = 0; i &lt; module.getWordLists().size(); i++) {</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">         if (((bcWordList)module.getWordLists().get(i)).getItem(word) != null) {</span>
<span class="nc" id="L452">            result = ((bcWordList)module.getWordLists().get(i)).getItem(word);</span>
<span class="nc" id="L453">            break;</span>
         }
      }
<span class="nc bnc" id="L456" title="All 2 branches missed.">      if (result == null) voice.sysout(&quot;Warning: Word not listed: '&quot;+word+&quot;'&quot;);</span>
<span class="nc" id="L457">      return result;</span>
   }

   /* getLast Word
    * Analyzes a line of text and returns its last word
    * This is needed to find out if two lines are rhyming.
    */
   private String getLastWord(String line) {
<span class="nc" id="L465">      String result = line;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">      if (line.indexOf(&quot; &quot;) &gt; 0) {</span>
<span class="nc" id="L467">         String[] temp = line.split(&quot; &quot;);</span>
<span class="nc" id="L468">         int i = 0;</span>
<span class="nc" id="L469">         do {i++; result = temp[temp.length-i];}</span>
<span class="nc bnc" id="L470" title="All 6 branches missed.">            while (((result.equals(&quot;!&quot;)) || (result.equals(&quot;&quot;))) &amp;&amp; (i &gt;= temp.length));</span>
      }
<span class="nc" id="L472">      return result;</span>
   }

   /* rhyming
    * Checks if two lines rhyme
    * returns 0 if they don't rhyme, 1 if they do; -1 if last words are not found in list or empty, -2 if they are equal
    */
   private int rhyming(String lineA, String lineB) {

      //TODO: Don't rhyme equal words set in word lists
<span class="nc" id="L482">      int result = 0;</span>
<span class="nc" id="L483">      lineA = getLastWord(lineA.toLowerCase());</span>
<span class="nc" id="L484">      lineB = getLastWord(lineB.toLowerCase());</span>
<span class="nc bnc" id="L485" title="All 4 branches missed.">      if ((lineA.equals(&quot;&quot;)) || (lineB.equals(&quot;&quot;))) {</span>
<span class="nc" id="L486">         result = -1;</span>
      }
<span class="nc bnc" id="L488" title="All 2 branches missed.">      else if (lineA.equals(lineB)) {</span>
<span class="nc" id="L489">         result = -2;</span>
      }
<span class="nc bnc" id="L491" title="All 2 branches missed.">      else if (rhymingAux(lineA,lineB)) {</span>
<span class="nc" id="L492">         result = 1;</span>
      }
      else {
<span class="nc" id="L495">         result = 0;   </span>
      }
<span class="nc" id="L497">      return result;</span>
   }
   
   /* rhymingAux
    * sub-method of rhyming, used only there
    */
   private boolean rhymingAux(String wordA, String wordB) {
<span class="nc" id="L504">      boolean last = false;</span>
<span class="nc" id="L505">      bcWord A = getWordFromLists(wordA);</span>
<span class="nc" id="L506">      bcWord B = getWordFromLists(wordB);</span>
<span class="nc bnc" id="L507" title="All 4 branches missed.">      if ((A.getSyllables() == 1) || (B.getSyllables() == 1)) {</span>
<span class="nc" id="L508">         last = true;</span>
      }
      //replace some phonemes that are commonly accepted as rhyming
<span class="nc" id="L511">      wordA = A.getRhymeKey(last).replaceAll(&quot;AE&quot;,&quot;EH&quot;);</span>
<span class="nc" id="L512">      wordB = B.getRhymeKey(last).replaceAll(&quot;AE&quot;,&quot;EH&quot;);</span>
<span class="nc" id="L513">      return wordA.equals(wordB);</span>
      
   }
   
   /* metricMatch()
    * Checks if two lines of text have the same metric scheme
    * TODO: implement properly to make it less restrictive
    */
   private boolean metricMatch(String lineA, String lineB) {
<span class="nc" id="L522">      boolean result = true;</span>
<span class="nc" id="L523">      int count = 0;</span>
      char A;
      char B;
<span class="nc" id="L526">      lineA = metricCode(lineA);</span>
<span class="nc" id="L527">      lineB = metricCode(lineB);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">      if (lineA.length() == lineB.length()) {</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">         for (int i = 0; i &lt; lineA.length(); i++) {           </span>
<span class="nc" id="L530">            A = lineA.charAt(i);</span>
<span class="nc" id="L531">            B = lineB.charAt(i);</span>
<span class="nc bnc" id="L532" title="All 8 branches missed.">            if (((A=='0') &amp;&amp; (B=='1')) || ((A=='1') &amp;&amp; (B=='0'))) {</span>
<span class="nc" id="L533">               result = false;</span>
            }
            else {
<span class="nc bnc" id="L536" title="All 20 branches missed.">               if (  ((A=='O') &amp;&amp; ((B=='1') || (B=='I')))</span>
                  || ((A=='I') &amp;&amp; ((B=='0') || (B=='O')))
                  || ((A=='0') &amp;&amp;  (B=='I'))
                  || ((A=='1') &amp;&amp;  (B=='O'))) {
<span class="nc" id="L540">                  count++;</span>
               }
            }
         }
<span class="nc bnc" id="L544" title="All 2 branches missed.">         if (count &gt; module.getMetricTolerance()) result = false;</span>
      }
<span class="nc" id="L546">      else {result = false;}</span>
<span class="nc" id="L547">      return result;  </span>
   }
   
   /* metricCode()
    * returns the metric code of one or more words
    */
   private String metricCode(String line) {
<span class="nc" id="L554">      String metrum = &quot;&quot;;</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">      if (line.indexOf(&quot; &quot;) == -1) {</span>
<span class="nc" id="L556">         metrum += getWordFromLists(line).getMetricCode();</span>
      }
      else {
<span class="nc" id="L559">         String[] temp = line.split(&quot; &quot;);</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">         for (int j = 0; j &lt; temp.length; j++) {</span>
<span class="nc" id="L561">            metrum += getWordFromLists(temp[j]).getMetricCode();</span>
         }
      }
<span class="nc" id="L564">      return metrum;</span>
   }

   /* replaceBrackets
    * Used by parseGrammar to handle brackets in grammatical segments
    * This method replaces AND's and OR's inside brackets so they won't get split
    * I know it's a little hackish, I'll think of a better way to do it.
    */
   private String replaceBrackets(String segment) {
<span class="nc bnc" id="L573" title="All 4 branches missed.">      if ((segment.indexOf(&quot;(&quot;) != -1) &amp;&amp; (segment.indexOf(&quot;)&quot;) != -1)) {</span>
<span class="nc" id="L574">         String brk1 = segment.substring(0,segment.indexOf(&quot;(&quot;));</span>
<span class="nc" id="L575">         String brk2 = segment.substring(segment.indexOf(&quot;(&quot;),segment.indexOf(&quot;)&quot;));</span>
<span class="nc" id="L576">         String brk3 = segment.substring(segment.indexOf(&quot;)&quot;)+1,segment.length());</span>
<span class="nc" id="L577">         brk2 = brk2.replace(';','&amp;');</span>
<span class="nc" id="L578">         brk2 = brk2.replace('#','|');</span>
<span class="nc" id="L579">         segment = brk1+brk2+&quot;)&quot;+replaceBrackets(brk3);</span>
      }
<span class="nc" id="L581">      return segment;</span>
   }
   
   /* isWord
    * determines if a string is a valid word without commas, brackets, etc
    */
   private boolean isWord(String word) {
<span class="nc bnc" id="L588" title="All 2 branches missed.">      return ((word.indexOf(&quot;,&quot;) == -1) &amp;&amp; </span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">              (word.indexOf(&quot;;&quot;) == -1) &amp;&amp; </span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">              (word.indexOf(&quot;.&quot;) == -1) &amp;&amp; </span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">              (word.indexOf(&quot;(&quot;) == -1) &amp;&amp;</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">              (word.indexOf(&quot;)&quot;) == -1) &amp;&amp; </span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">              (word.indexOf(&quot;'&quot;) == -1) &amp;&amp; </span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">              (word.indexOf(&quot;*&quot;) == -1));</span>
   }
   
   // ---------------- PUBLIC METHODS ----------------


   /* getLyrics
    * Creates a random set of lyrics as defined by the data file and
    * returns them as a List.
    */
   public List getLyrics() {
<span class="pc bpc" id="L605" title="3 of 4 branches missed.">      if ((module != null) &amp;&amp; (module.isInitialized())) {</span>
<span class="nc" id="L606">         voice.progressBarStart(&quot;Generating, please wait...&quot;);</span>
<span class="nc" id="L607">         voice.resetLyrics();</span>
<span class="nc" id="L608">         voice.verboseLineFeed();</span>
<span class="nc" id="L609">         voice.sing(&quot;*******************************************&quot;);</span>
<span class="nc" id="L610">         voice.sing(&quot;*             &quot;+fill(parseGrammar(GRAMMAR_TITLE))+&quot;             *&quot;);</span>
<span class="nc" id="L611">         voice.sing(&quot;*******************************************&quot;);</span>
<span class="nc" id="L612">         parseLayout();</span>
<span class="nc" id="L613">         voice.sing(&quot;*******************************************&quot;);</span>
<span class="nc" id="L614">         voice.progressBarEnd(&quot;done.&quot;);</span>
      }
      else {
<span class="fc" id="L617">         voice.sysout(&quot;Error: Battlecry has not been initialized.&quot;);</span>
      }
<span class="fc" id="L619">      return voice.getLyrics();     </span>
   }

   /* getModuleInfo
    * Prints the information from the module's info.dat file.
    */
   public void getModuleInfo() {
<span class="pc bpc" id="L626" title="3 of 4 branches missed.">      if ((module != null) &amp;&amp; (module.isInitialized())) {</span>
<span class="nc" id="L627">         voice.sysout(&quot;Module Name: &quot;+module.getInfo().getProperty(&quot;NAME&quot;));</span>
<span class="nc" id="L628">         voice.sysout(&quot;Author: &quot;+module.getInfo().getProperty(&quot;AUTHOR&quot;));</span>
<span class="nc" id="L629">         voice.sysout(&quot;Version: &quot;+module.getInfo().getProperty(&quot;VERSION&quot;));</span>
<span class="nc" id="L630">         voice.sysout(&quot;Comment: &quot;+module.getInfo().getProperty(&quot;COMMENT&quot;));</span>
      }
      else {
<span class="fc" id="L633">         voice.sysout(&quot;Error: Battlecry has not been initialized.&quot;);</span>
      }
<span class="fc" id="L635">   }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>