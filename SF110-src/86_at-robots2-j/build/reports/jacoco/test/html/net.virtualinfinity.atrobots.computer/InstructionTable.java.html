<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InstructionTable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">86_at-robots2-j</a> &gt; <a href="index.source.html" class="el_package">net.virtualinfinity.atrobots.computer</a> &gt; <span class="el_source">InstructionTable.java</span></div><h1>InstructionTable.java</h1><pre class="source lang-java linenums">package net.virtualinfinity.atrobots.computer;

import net.virtualinfinity.atrobots.atsetup.AtRobotInstruction;
import static net.virtualinfinity.atrobots.atsetup.AtRobotInstruction.*;

/**
 * Provides a mapping between instruction values and implementations.
 *
 * @author Daniel Pitts
 */
<span class="nc" id="L11">public class InstructionTable {</span>
<span class="nc" id="L12">    private final Instruction invalidMicrocodeInstruction = new InvalidMicrocodeInstruction(1);</span>
<span class="nc" id="L13">    private final Instruction[] instructions = new Instruction[47];</span>
<span class="nc" id="L14">    private final Instruction numberedLabelInstruction = new NoOperationInstruction(0);</span>
<span class="nc" id="L15">    private static final Instruction UNKNOWN_INSTRUCTION = new UnknownInstruction(1);</span>

    {
<span class="nc" id="L18">        mapInstruction(NOP, new NoOperationInstruction(1));</span>
<span class="nc" id="L19">        mapInstruction(ADD, new AddInstruction(1));</span>
<span class="nc" id="L20">        mapInstruction(SUB, new SubtractInstruction(1));</span>
<span class="nc" id="L21">        mapInstruction(OR, new BitwiseOrInstruction(1));</span>
<span class="nc" id="L22">        mapInstruction(AND, new BitwiseAndInstruction(1));</span>
<span class="nc" id="L23">        mapInstruction(XOR, new BitwiseExclusiveOrInstruction(1));</span>
<span class="nc" id="L24">        mapInstruction(NOT, new BitwiseNegationInstruction(1));</span>
<span class="nc" id="L25">        mapInstruction(MPY, new MultiplyInstruction(10));</span>
<span class="nc" id="L26">        mapInstruction(DIV, new DivideInstruction(10));</span>
<span class="nc" id="L27">        mapInstruction(MOD, new ModuloInstruction(10));</span>
<span class="nc" id="L28">        mapInstruction(RET, new PopInstructionPointerInstruction(1));</span>
<span class="nc" id="L29">        mapInstruction(CALL, new CallInstruction(1));</span>
<span class="nc" id="L30">        mapInstruction(JMP, new JumpInstruction(1));</span>
<span class="nc" id="L31">        mapInstruction(JLS, new JumpWhenLessInstruction(0));</span>
<span class="nc" id="L32">        mapInstruction(JGR, new JumpWhenGreaterInstruction(0));</span>
<span class="nc" id="L33">        mapInstruction(JNE, new JumpWhenNotEqualInstruction(0));</span>
<span class="nc" id="L34">        mapInstruction(JEQ, new JumpWhenEqualInstruction(0));</span>
<span class="nc" id="L35">        mapInstruction(XCHG, new SwapInstruction(3));</span>
<span class="nc" id="L36">        mapInstruction(DO, new SetCXInstruction(1));</span>
<span class="nc" id="L37">        mapInstruction(LOOP, new LoopInstruction(1));</span>
<span class="nc" id="L38">        mapInstruction(CMP, new CompareInstruction(1));</span>
//        mapInstruction(TEST, new TestInstruction(2));
<span class="nc" id="L40">        mapInstruction(MOV, new MoveInstruction(1));</span>
<span class="nc" id="L41">        mapInstruction(LOC, new AddressInstruction(2));</span>
<span class="nc" id="L42">        mapInstruction(GET, new GetInstruction(2));</span>
<span class="nc" id="L43">        mapInstruction(PUT, new PutInstruction(2));</span>
<span class="nc" id="L44">        mapInstruction(INT, new CallInterruptInstruction(0));</span>
<span class="nc" id="L45">        mapInstruction(IPO, new ReadPortInstruction(4));</span>
<span class="nc" id="L46">        mapInstruction(OPO, new WritePortInstruction(4));</span>
<span class="nc" id="L47">        mapInstruction(DEL, new DelayInstruction(0));</span>
<span class="nc" id="L48">        mapInstruction(PUSH, new PushInstruction(1));</span>
<span class="nc" id="L49">        mapInstruction(POP, new PopInstruction(1));</span>
<span class="nc" id="L50">        mapInstruction(ERR, new ErrorInstruction(0));</span>
<span class="nc" id="L51">        mapInstruction(INC, new IncrementInstruction(1));</span>
<span class="nc" id="L52">        mapInstruction(DEC, new DecrementInstruction(1));</span>
<span class="nc" id="L53">        mapInstruction(SHL, new BitShiftLeftInstruction(1));</span>
<span class="nc" id="L54">        mapInstruction(SHR, new BitShiftRightInstruction(1));</span>
<span class="nc" id="L55">        mapInstruction(ROL, new BitRotateLeftInstruction(1));</span>
<span class="nc" id="L56">        mapInstruction(ROR, new BitRotateRightInstruction(1));</span>
<span class="nc" id="L57">        mapInstruction(JZ, new JumpWhenZeroInstruction(0));</span>
<span class="nc" id="L58">        mapInstruction(JNZ, new JumpWhenNotZeroInstruction(0));</span>
<span class="nc" id="L59">        mapInstruction(JGE, new JumpWhenGreaterOrEqualInstruction(0));</span>
<span class="nc" id="L60">        mapInstruction(JLE, new JumpWhenLessOrEqualInstruction(0));</span>
<span class="nc" id="L61">        mapInstruction(SAL, new BitShiftLeftInstruction(1));</span>
<span class="nc" id="L62">        mapInstruction(SAR, new SignedBitShiftRightInstruction(1));</span>
<span class="nc" id="L63">        mapInstruction(NEG, new NegateInstruction(1));</span>
<span class="nc" id="L64">        mapInstruction(JTL, new SetInstructionPointerInstruction(1));</span>
<span class="nc" id="L65">    }</span>

    private void mapInstruction(AtRobotInstruction instructionName, Instruction instructionHandler) {
<span class="nc" id="L68">        instructions[instructionName.value] = instructionHandler;</span>
<span class="nc" id="L69">    }</span>

    public Instruction getInvalidMicrocodeInstruction() {
<span class="nc" id="L72">        return invalidMicrocodeInstruction;</span>
    }

    public Instruction getInstruction(short value) {
<span class="nc bnc" id="L76" title="All 4 branches missed.">        return value &gt;= 0 &amp;&amp; value &lt; instructions.length ? instructions[value] : UNKNOWN_INSTRUCTION;</span>
    }

    public Instruction getNumberedLabelInstruction() {
<span class="nc" id="L80">        return numberedLabelInstruction;</span>
    }
}

/*
NoOperation              1  NOP           NOP        Simply wastes a clock-cycle.
Add                      1  ADD           ADD V N    Adds      V+N, result stored in V
Subtract                 1  SUB           SUB V N    Subtracts V-N, result stored in V
BitwiseOr                1  OR            OR  V N    Bitwise OR,  V or  N, result stored in V
BitwiseAnd               1  AND           AND V N    Bitwise AND, V and N, result stored in V
BitwiseExclusiveOr       1  XOR           XOR V N    Bitwise XOR, V xor N, result stored in V
BitwiseNegation          1  NOT           NOT V      Bitwise NOT, not(V),  result stored in V
Multiply                10  MPY           MPY V N    Mulitplies V*N, result stored in V
Divide                  10  DIV           DIV V N    Divides    V/N, result stored in V (integer)
Modulo                  10  MOD           MOD V N    MOD's    V &amp; N, result stored in V (modulus)
Return                   1  RET  RETURN   RET        Returns from a subroutine (pops the ip)
Call                     1  CALL GSB      CALL N     Calls subroutine at label #N (pushes ip)
Jump                     1  JMP  GOTO     JMP N      Jumps program (ip) to label #N
JumpWhenLess             0  JLS  JB       JLS N      Jumps to label N if last compare was &lt;
JumpWhenGreater          0  JGR  JA       JGR N      Jumps to label N if last compare was &gt;
JumpWhenNotEqual         0  JNE           JNE N      Jumps to label N if last compare was &lt;&gt;
JumpWhenEqual            0  JEQ  JE       JEQ N      Jumps to label N if last compare was =
Swap                     3  XCHG SWAP     XCHG V V   Exchanges the values of two variables
SetCX                    1  DO            DO N       Sets CX = N
Loop                     1  LOOP          LOOP N     Decrements CX, If CX&gt;0 then Jumps to label N
Compare                  1  CMP           CMP N N    Compares two numbers, results in flags reg.
Test                     2  TEST          TEST N N   Ands two numbers, result not stored, flags set
Move                     1  MOV  SET      MOV V N    Sets V = N
Address                  2  LOC  ADDR     LOC V V    Sets first V = memory address of second V
Get                      2  GET           GET V N    Sets V = number from memory location N
Put                      2  PUT           PUT N1 N2  Sets memory location N2 = N1
CallInterrupt            0  INT           INT N      Executes interrupt number N
ReadPort                 4  IPO  IN       IPO N V    Inputs number from port N, result into V
WritePort                4  OPO  OUT      OPO N1 N2  Outputs N2 to port N1
Delay                    0  DEL  DELAY    DEL N      Equivelant to N NOPS.
Push                     1  PUSH          PUSH N     Puts N onto the stack (sp incremented)
Pop                      1  POP           POP  V     Removes a number from the stack, into V
Error                    0  ERR  ERROR    ERR N      Generate an error code, useful for debugging
Increment                1  INC           INC V      Increments V, (v=v+1)
Decrement                1  DEC           DEC V      Decrements V, (v=v-1)
BitShiftLeft             1  SHL           SHL V N    Bit-shifts  V left  N bit positions
BitShiftRight            1  SHR           SHR V N    Bit-shifts  V right N bit positions
BitRotateLeft            1  ROL           ROL V N    Bit-rotates V left  N bit positions
BitRotateRight           1  ROR           ROR V N    Bit-rotates V right N bit positions
JumpWhenZero             0  JZ            JZ  N      Jumps to label N if last compare was 0
JumpWhenNotZero          0  JNZ           JNZ N      Jumps to label N if last compare was not 0
JumpWhenNotLess          0  JAE  JGE      JAE N      Jumps to label N if last compare was &gt;=
JumpWhenNotGreater       0  JBE  JLE      JBE N      Jumps to label N if last compare was &lt;=
BitShiftLeft             1  SAL           SAL V N    Bit-Shifts, same as SHL
SignedBitShiftRight      1  SAR           SAR V N    Same as SHR, except preserves bit 15.
Negate                   1  NEG           NEG V      Negates V:   V = 0-V  (aka &quot;two's compliment&quot;)
SetInstructionPointer    1  JTL           JTL N      Jumps to line N of compiled program.
 */
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>