<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlotYAxis.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">29_apbsmem</a> &gt; <a href="index.source.html" class="el_package">jahuwaldt.plot</a> &gt; <span class="el_source">PlotYAxis.java</span></div><h1>PlotYAxis.java</h1><pre class="source lang-java linenums">/*
*   PlotYAxis  -- Represents a vertical or Y plot axis.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt &lt;jhuwaldt@knology.net&gt;.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.*;
import java.text.*;
import java.util.*;
import java.awt.image.*;


/**
*  &lt;p&gt; This class represents a vertical or Y axis
*      on a plot.
*  &lt;/p&gt;
*  &lt;p&gt;  Modified by:  Joseph A. Huwaldt  &lt;/p&gt;
*
*  @author  Joseph A. Huwaldt   Date:  September 13, 2000
*  @version April 25, 2002
**/
public class PlotYAxis extends PlotAxis {

	
	//-------------------------------------------------------------------------
	/**
	*  Create a new Y axis using the default settings.
	**/
<span class="nc" id="L41">	public PlotYAxis() { }</span>
	
	/**
	*  Create a Y axis with the label, axis scale transformation,
	*  number format and grid style specified.
	*
	*  @param label      The label to place on this axis.  If null is passed
	*                    no label is drawn.
	*  @param scale      Object indicating if the axis scale type.
	*  @param nf         The object used to format the axis numbers.
	*                    If null is passed, the default decimal format is used.
	*  @param gridStyle  The grid style to use.  Should be one of the constants
	*                    provided by this class.
	**/
	public PlotYAxis( String label, PlotAxisScale scale, NumberFormat nf, int gridStyle ) {
<span class="nc" id="L56">		super(label, scale, nf, gridStyle);</span>
<span class="nc" id="L57">	}</span>

	//-------------------------------------------------------------------------
	/**
	*  Automatically set the upper and lower bounds for this
	*  Y axis based on the data in the runs input.
	**/
	public void setAxisBounds(PlotRunList runs) {
		
<span class="nc bnc" id="L66" title="All 4 branches missed.">		if (manualLB &amp;&amp; manualUB)	return;</span>

<span class="nc bnc" id="L68" title="All 2 branches missed.">		if (!manualLB)</span>
<span class="nc" id="L69">			aLB = Double.MAX_VALUE;</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">		if (!manualUB)</span>
<span class="nc" id="L71">			aUB = Double.MIN_VALUE;</span>
		
		
<span class="nc" id="L74">		AxisLimitData buffer = new AxisLimitData();		//	Buffer for passing data between objects.</span>
<span class="nc" id="L75">		boolean dataFound = false;</span>
		
<span class="nc bnc" id="L77" title="All 4 branches missed.">		if (runs != null &amp;&amp; runs.size() &gt; 0) {</span>
			//	Loop over all the runs.
<span class="nc bnc" id="L79" title="All 2 branches missed.">			for (Iterator i=runs.iterator(); i.hasNext();) {</span>
		
				//	Extract the current run.
<span class="nc" id="L82">				PlotRun run = (PlotRun)i.next();</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">				if (run.size() &gt; 0) {</span>
				
					//	The runs contain data.
<span class="nc" id="L86">					dataFound = true;</span>
					
					//	Loop over all the data points.
<span class="nc bnc" id="L89" title="All 2 branches missed.">					for (Iterator j=run.iterator(); j.hasNext();) {</span>
<span class="nc" id="L90">						PlotDatum datum = (PlotDatum)j.next();</span>
						
<span class="nc bnc" id="L92" title="All 2 branches missed.">						if (datum.hasErrorBar()) {</span>
						
							//	This data point has an error bar.
							//	Adjust upper and lower bounds to allow room for error bars.
<span class="nc" id="L96">							scale.adjustForErrorBars(datum, aUB, aLB, buffer);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">							if (!manualLB)</span>
<span class="nc" id="L98">								aLB = buffer.lb;</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">							if (!manualUB)</span>
<span class="nc" id="L100">								aUB = buffer.ub;</span>
							
						} else {
							//	No error bars.
							
							//	Find axis bounds for Y axis.
<span class="nc bnc" id="L106" title="All 2 branches missed.">							if (!manualLB)</span>
<span class="nc" id="L107">								aLB = Math.min(aLB, datum.y);</span>
						
<span class="nc bnc" id="L109" title="All 2 branches missed.">							if (!manualUB)</span>
<span class="nc" id="L110">								aUB = Math.max(aUB, datum.y);</span>
						}
<span class="nc" id="L112">					}</span>
				}
<span class="nc" id="L114">			}</span>
		
		}
		
<span class="nc bnc" id="L118" title="All 4 branches missed.">		if (!dataFound || aLB == aUB) {</span>
			//	If no data found, set default scales.
<span class="nc bnc" id="L120" title="All 2 branches missed.">			if (!manualLB)</span>
<span class="nc" id="L121">				aLB = scale.lowerBounds();</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">			if (!manualUB)</span>
<span class="nc" id="L123">				aUB = scale.upperBounds();</span>
		}
		
<span class="nc" id="L126">	}</span>
	
	/**
	*  Scale this axis so that it fits inside of the specified
	*  plot frame rectangle.  Vertical axes must fit inside
	*  the height of the frame.
	*
	*  @param  plotFrame  The bounding rectangle for the data area
	*                     of the plot (overall bounds minus area for
	*                     titles, labels, etc).
	**/
	protected void resizeAxis(Rectangle plotFrame) {
		
		//	Top edge of axis in screen coordinates.
<span class="nc" id="L140">		int topy = plotFrame.y;</span>
		
		//	Bottom edge of axis in screen coordinates.
<span class="nc" id="L143">		int boty = plotFrame.y + plotFrame.height;</span>
<span class="nc" id="L144">		int edge = topy - boty;</span>
		
		//	Set scaling factors in class variables.
		
		//	xA = (Scrn Height)/(Data Height)
<span class="nc" id="L149">		xA = (double)edge/(scale.func(aUB) - scale.func(aLB));</span>
<span class="nc" id="L150">		xB = boty - scale.func(aLB)*xA + 0.5;</span>
		
<span class="nc" id="L152">	}</span>
	
	/**
	*  Renders this plot axis and grid (based on grid
	*  style) into the specified graphics context.
	*
	*  @param  gc      The graphics context we are drawing into.
	*  @param  comp    The component that we are drawing into.
	*  @param  bounds  The bounding rectangle for the data area
	*                  of the plot (overall bounds minus area for titles,
	*                  labels, etc).
	**/
	public void draw(Graphics gc, Component comp, Rectangle bounds) {

		//	Extract information on the current font.
<span class="nc" id="L167">		FontMetrics fm = gc.getFontMetrics();</span>
<span class="nc" id="L168">		int textHeight = fm.getHeight();</span>
<span class="nc" id="L169">		int textWidth = 0;</span>
<span class="nc" id="L170">		int xPos = 0, yPos = 0;</span>
<span class="nc" id="L171">		String str = null;</span>
		
<span class="nc" id="L173">		int topPos = bounds.y;</span>
<span class="nc" id="L174">		int botPos = topPos + bounds.height;</span>
<span class="nc" id="L175">		int left = bounds.x;</span>
<span class="nc" id="L176">		int right = left + bounds.width;</span>

<span class="nc bnc" id="L178" title="All 2 branches missed.">		if (gridStyle != kNoGrid) {</span>
		
<span class="nc" id="L180">			Color foreColor = gc.getColor();</span>
		
			//	Create tick marks on this axis.
<span class="nc" id="L183">			TickMarkData ticks = scale.calcTickMarks(quantum, aLB, aUB, xA, xB);</span>
<span class="nc" id="L184">			int[] mark = ticks.mark;</span>
<span class="nc" id="L185">			int[] lmark = ticks.lmark;</span>
<span class="nc" id="L186">			float[] markValue = ticks.markValue;</span>
<span class="nc" id="L187">			int yn = mark.length;</span>
		
			//	Draw label on the first tick mark.
<span class="nc" id="L190">			str = nf.format(2*markValue[0] - markValue[1]);</span>
<span class="nc" id="L191">			textWidth = fm.stringWidth(str);</span>
<span class="nc" id="L192">			int ascent = fm.getAscent();</span>
<span class="nc" id="L193">			int descent = fm.getDescent();</span>
			
<span class="nc" id="L195">			yPos = botPos + ascent - (ascent + descent)/2;</span>
<span class="nc" id="L196">			xPos = left - textWidth - 2;</span>
<span class="nc" id="L197">			gc.drawString(str, xPos, yPos);</span>
		
			//	Draw intermediate tick marks and labels.
<span class="nc bnc" id="L200" title="All 2 branches missed.">			for (int i=0; i &lt; yn; ++i) {</span>
<span class="nc" id="L201">				yPos = mark[i];</span>
			
				//	Draw full grid at major tick mark if requested.
<span class="nc bnc" id="L204" title="All 4 branches missed.">				if (lmark[i] == 3*kTick &amp;&amp; gridStyle == kMajorGrid) {</span>
<span class="nc" id="L205">					gc.setColor(Color.gray);</span>
<span class="nc" id="L206">					gc.drawLine(left, yPos, right, yPos);</span>
<span class="nc" id="L207">					gc.setColor(foreColor);</span>
				}
			
				//	Draw tick marks.
<span class="nc" id="L211">				gc.drawLine(left, yPos, left + lmark[i], yPos);</span>
<span class="nc" id="L212">				gc.drawLine(right - lmark[i], yPos, right, yPos);</span>
				
				//	Draw numeric labels next to major tick marks.
<span class="nc bnc" id="L215" title="All 2 branches missed.">				if (lmark[i] == 3*kTick) {</span>
<span class="nc" id="L216">					str = nf.format(markValue[i]);</span>
<span class="nc" id="L217">					textWidth = fm.stringWidth(str);</span>
				
<span class="nc" id="L219">					yPos += ascent - (ascent + descent)/2;</span>
<span class="nc" id="L220">					xPos = left - textWidth - 2;</span>
<span class="nc" id="L221">					gc.drawString(str, xPos, yPos);</span>
				}
			}
		
			//	Draw label on last tick mark.
<span class="nc" id="L226">			str = nf.format(2*markValue[yn-1] - markValue[yn-2]);</span>
<span class="nc" id="L227">			textWidth = fm.stringWidth(str);</span>
		
<span class="nc" id="L229">			yPos = topPos + ascent - (ascent + descent)/2;</span>
<span class="nc" id="L230">			xPos = left - textWidth - 2;</span>
<span class="nc" id="L231">			gc.drawString(str, xPos, yPos);</span>
		}
		
		
		//	Draw the axis label.

<span class="nc bnc" id="L237" title="All 2 branches missed.">		if (label != null) {</span>
	    	//	Center label beside axis.
		    //	Figure out where the label should go.
<span class="nc bnc" id="L240" title="All 2 branches missed.">		    str = nf.format((float)(aUB &gt; 0 ? -aUB : aUB));</span>
<span class="nc" id="L241">	    	int tmp1 = fm.stringWidth(str);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">	    	str = nf.format((float)(aLB &gt; 0 ? -aLB : aLB));</span>
<span class="nc" id="L243">	    	int tmp2 = fm.stringWidth(str);</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">	    	if (tmp2 &gt; tmp1)	tmp1 = tmp2;</span>
		
<span class="nc" id="L246">		    textWidth = fm.stringWidth(label);</span>
<span class="nc" id="L247">		    xPos = left - tmp1 - 2 - textHeight + fm.getAscent();</span>
<span class="nc" id="L248">		    yPos = (botPos + topPos)/2 + textWidth/2;</span>
		
		    //	Draw the label vertically.
<span class="nc" id="L251">		    drawRotString(gc, comp, label, xPos, yPos, 90*Math.PI/180);</span>
		}
		
<span class="nc" id="L254">	}</span>
	
	/**
	*  Draws a string to the specified graphics context rotated by the
	*  specified angle in degrees.
	*
	*  @param  gc    The graphics context to draw into.
	*  @param  comp  The component that we are drawing into.
	*  @param  str   The string to be drawn.
	*  @param  x     The x coordinate.
	*  @param  y     The y coordinate.
	*  @param  angle The angle to rotate the string through in radians.
	**/
	private void drawRotString(Graphics gc, Component comp, String str, int x, int y, double angle) {
		
		//	Extract information on the current font.
<span class="nc" id="L270">		FontMetrics fm = gc.getFontMetrics();</span>
<span class="nc" id="L271">		int textHeight = fm.getHeight();</span>
<span class="nc" id="L272">		int textWidth = fm.stringWidth(str);</span>
<span class="nc" id="L273">		int ascent = fm.getAscent();</span>
		
		//	Create an offscreen image the width and height of the string to be rotated.
<span class="nc" id="L276">		Image img = comp.createImage(textWidth, textHeight);</span>
		
		//	Get a graphics context for the image so we can draw to it.
<span class="nc" id="L279">		Graphics imggc = img.getGraphics();</span>
<span class="nc" id="L280">		imggc.setFont(gc.getFont());</span>
<span class="nc" id="L281">		imggc.setColor(comp.getBackground());</span>
<span class="nc" id="L282">		imggc.fillRect(0,0,textWidth, textHeight);</span>
<span class="nc" id="L283">		imggc.setColor(gc.getColor());</span>
		
		//	Draw the string into the offscreen buffer.
<span class="nc" id="L286">		imggc.drawString(str, 0, ascent);</span>
		
		//	Create an image filter to rotate the offscreen image.
<span class="nc" id="L289">		ImageFilter filter = new RotateFilter(angle);</span>
<span class="nc" id="L290">		ImageProducer producer = new FilteredImageSource( img.getSource(), filter);</span>
<span class="nc" id="L291">		Image resultImage = Toolkit.getDefaultToolkit().createImage(producer);</span>
		
		//	Finally, draw the image to the supplied graphics context.
<span class="nc" id="L294">		x -= ascent;</span>
<span class="nc" id="L295">		y -= textWidth;</span>
<span class="nc" id="L296">		gc.drawImage(resultImage, x, y, null);</span>
<span class="nc" id="L297">	}</span>
	
	//	This is used only by RotateFilter, but can't be inside of RotateFilter
	//  since it's static.
<span class="nc" id="L301">    private static ColorModel defaultRGB = ColorModel.getRGBdefault();</span>
    
	/**
	*  An image filter that will rotate an image by a specified angle in radians.
	*
	*  Written by Sun Microsystems.
	**/
	class RotateFilter extends ImageFilter {
	
    	private double angle;
    	private double sin;
   		private double cos;
<span class="nc" id="L313">    	private double coord[] = new double[2];</span>

    	private int raster[];
    	private int xoffset, yoffset;
    	private int srcW, srcH;
    	private int dstW, dstH;

<span class="nc" id="L320">    	public RotateFilter(double angle) {</span>
<span class="nc" id="L321">        	this.angle = angle;</span>
<span class="nc" id="L322">        	sin = Math.sin(angle);</span>
<span class="nc" id="L323">        	cos = Math.cos(angle);</span>
<span class="nc" id="L324">    	}</span>

    	public void transform(double x, double y, double[] retcoord) {
        	// Remember that the coordinate system is upside down so apply
        	// the transform as if the angle were negated.
        	// cos(-angle) =  cos(angle)
        	// sin(-angle) = -sin(angle)
<span class="nc" id="L331">        	retcoord[0] = cos * x + sin * y;</span>
<span class="nc" id="L332">        	retcoord[1] = cos * y - sin * x;</span>
<span class="nc" id="L333">    	}</span>

   		public void itransform(double x, double y, double[] retcoord) {
        	// Remember that the coordinate system is upside down so apply
        	// the transform as if the angle were negated.  Since inverting
        	// the transform is also the same as negating the angle, itransform
        	// is calculated the way you would expect to calculate transform.
<span class="nc" id="L340">        	retcoord[0] = cos * x - sin * y;</span>
<span class="nc" id="L341">        	retcoord[1] = cos * y + sin * x;</span>
<span class="nc" id="L342">    	}</span>

    	public void transformBBox(Rectangle rect) {
<span class="nc" id="L345">        	double minx = Double.POSITIVE_INFINITY;</span>
<span class="nc" id="L346">        	double miny = Double.POSITIVE_INFINITY;</span>
<span class="nc" id="L347">        	double maxx = Double.NEGATIVE_INFINITY;</span>
<span class="nc" id="L348">        	double maxy = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        	for (int y = 0; y &lt;= 1; y++) {</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">            	for (int x = 0; x &lt;= 1; x++) {</span>
<span class="nc" id="L351">                	transform(rect.x + x * rect.width, rect.y + y * rect.height, coord);</span>
<span class="nc" id="L352">                	minx = Math.min(minx, coord[0]);</span>
<span class="nc" id="L353">                	miny = Math.min(miny, coord[1]);</span>
<span class="nc" id="L354">                	maxx = Math.max(maxx, coord[0]);</span>
<span class="nc" id="L355">                	maxy = Math.max(maxy, coord[1]);</span>
            	}
        	}
<span class="nc" id="L358">        	rect.x = (int) Math.floor(minx);</span>
<span class="nc" id="L359">        	rect.y = (int) Math.floor(miny);</span>
<span class="nc" id="L360">        	rect.width = (int) Math.ceil(maxx) - rect.x + 1;</span>
<span class="nc" id="L361">        	rect.height = (int) Math.ceil(maxy) - rect.y + 1;</span>
<span class="nc" id="L362">    	}</span>

    	public void setDimensions(int width, int height) {
<span class="nc" id="L365">        	Rectangle rect = new Rectangle(0, 0, width, height);</span>
<span class="nc" id="L366">        	transformBBox(rect);</span>
<span class="nc" id="L367">        	xoffset = -rect.x;</span>
<span class="nc" id="L368">        	yoffset = -rect.y;</span>
<span class="nc" id="L369">        	srcW = width;</span>
<span class="nc" id="L370">        	srcH = height;</span>
<span class="nc" id="L371">        	dstW = rect.width;</span>
<span class="nc" id="L372">        	dstH = rect.height;</span>
<span class="nc" id="L373">        	raster = new int[srcW * srcH];</span>
<span class="nc" id="L374">        	consumer.setDimensions(dstW, dstH);</span>
<span class="nc" id="L375">    	}</span>

    	public void setColorModel(ColorModel model) {
<span class="nc" id="L378">        	consumer.setColorModel(defaultRGB);</span>
<span class="nc" id="L379">    	}</span>

    	public void setHints(int hintflags) {
<span class="nc" id="L382">        	consumer.setHints(TOPDOWNLEFTRIGHT</span>
                          | COMPLETESCANLINES
                          | SINGLEPASS
                          | (hintflags &amp; SINGLEFRAME));
<span class="nc" id="L386">    	}</span>

    	public void setPixels(int x, int y, int w, int h, ColorModel model,
                          byte pixels[], int off, int scansize) {
<span class="nc" id="L390">        	int srcoff = off;</span>
<span class="nc" id="L391">        	int dstoff = y * srcW + x;</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">        	for (int yc = 0; yc &lt; h; yc++) {</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">            	for (int xc = 0; xc &lt; w; xc++) {</span>
<span class="nc" id="L394">                	raster[dstoff++] = model.getRGB(pixels[srcoff++] &amp; 0xff);</span>
            	}
<span class="nc" id="L396">            	srcoff += (scansize - w);</span>
<span class="nc" id="L397">            	dstoff += (srcW - w);</span>
        	}
<span class="nc" id="L399">    	}</span>

    	public void setPixels(int x, int y, int w, int h, ColorModel model,
                          int pixels[], int off, int scansize) {
<span class="nc" id="L403">        	int srcoff = off;</span>
<span class="nc" id="L404">        	int dstoff = y * srcW + x;</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        	if (model == defaultRGB) {</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            	for (int yc = 0; yc &lt; h; yc++) {</span>
<span class="nc" id="L407">                	System.arraycopy(pixels, srcoff, raster, dstoff, w);</span>
<span class="nc" id="L408">                	srcoff += scansize;</span>
<span class="nc" id="L409">                	dstoff += srcW;</span>
            	}
        	} else {
<span class="nc bnc" id="L412" title="All 2 branches missed.">            	for (int yc = 0; yc &lt; h; yc++) {</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                	for (int xc = 0; xc &lt; w; xc++) {</span>
<span class="nc" id="L414">                    	raster[dstoff++] = model.getRGB(pixels[srcoff++]);</span>
                	}
<span class="nc" id="L416">                	srcoff += (scansize - w);</span>
<span class="nc" id="L417">                	dstoff += (srcW - w);</span>
            	}
        	}
<span class="nc" id="L420">    	}</span>

    	public void imageComplete(int status) {
<span class="nc bnc" id="L423" title="All 4 branches missed.">        	if (status == IMAGEERROR || status == IMAGEABORTED) {</span>
<span class="nc" id="L424">            	consumer.imageComplete(status);</span>
<span class="nc" id="L425">            	return;</span>
        	}
<span class="nc" id="L427">        	int pixels[] = new int[dstW];</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">        	for (int dy = 0; dy &lt; dstH; dy++) {</span>
<span class="nc" id="L429">            	itransform(0 - xoffset, dy - yoffset, coord);</span>
<span class="nc" id="L430">            	double x1 = coord[0];</span>
<span class="nc" id="L431">            	double y1 = coord[1];</span>
<span class="nc" id="L432">            	itransform(dstW - xoffset, dy - yoffset, coord);</span>
<span class="nc" id="L433">            	double x2 = coord[0];</span>
<span class="nc" id="L434">            	double y2 = coord[1];</span>
<span class="nc" id="L435">            	double xinc = (x2 - x1) / dstW;</span>
<span class="nc" id="L436">            	double yinc = (y2 - y1) / dstW;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            	for (int dx = 0; dx &lt; dstW; dx++) {</span>
<span class="nc" id="L438">                	int sx = (int) Math.round(x1);</span>
<span class="nc" id="L439">                	int sy = (int) Math.round(y1);</span>
<span class="nc bnc" id="L440" title="All 8 branches missed.">                	if (sx &lt; 0 || sy &lt; 0 || sx &gt;= srcW || sy &gt;= srcH) {</span>
<span class="nc" id="L441">                    	pixels[dx] = 0;</span>
                	} else {
<span class="nc" id="L443">                    	pixels[dx] = raster[sy * srcW + sx];</span>
                	}
<span class="nc" id="L445">                	x1 += xinc;</span>
<span class="nc" id="L446">                	y1 += yinc;</span>
            	}
<span class="nc" id="L448">            	consumer.setPixels(0, dy, dstW, 1, defaultRGB, pixels, 0, dstW);</span>
        	}
<span class="nc" id="L450">        	consumer.imageComplete(status);</span>
<span class="nc" id="L451">    	}</span>
	}
	
}


</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>