<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ContourGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">29_apbsmem</a> &gt; <a href="index.source.html" class="el_package">jahuwaldt.plot</a> &gt; <span class="el_source">ContourGenerator.java</span></div><h1>ContourGenerator.java</h1><pre class="source lang-java linenums">/*
*   ContourGenerator  -- Used to generate 2D contour paths from gridded 3D data.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt &lt;jhuwaldt@knology.net&gt;.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.util.*;


/**
*  &lt;p&gt; An object used to generate a list of contour lines
*      or paths from a set of gridded three dimensional data.
*  &lt;/p&gt;
*
*  &lt;p&gt; Based on contour_plot.c from NeXTcontour1.4 by Thomas H. Pulliam,
*      pulliam@rft29.nas.nasa.gov, MS 202A-1 NASA Ames Research Center,
*      Moffett Field, CA 94035.
*      I don't know how the original Fortran code looked like or where it came from,
*      other than that NeXTcontour1.4 is based on Pieter Bunings' PLOT3D package
*      for Computational Fluid Dynamics.
*  &lt;/p&gt;
*
*  &lt;p&gt; Ported from C to Java by Joseph A. Huwaldt, November 16, 2000.  &lt;/p&gt;
*
*  &lt;p&gt;  Modified by:  Joseph A. Huwaldt  &lt;/p&gt;
*
*  @author  Joseph A. Huwaldt   Date:  November 11, 2000
*  @version November 23, 2000
**/
public class ContourGenerator {

	//	Debug flag.
	private static final boolean DEBUG = false;
	
	//	Error messages.
	private static final String kCancelMsg = &quot;Method ContourGenerator.getContours() canceled by user.&quot;;
	private static final String kInconsistantArrMsg = &quot;Inconsistant array sizes.&quot;;
	private static final String kArrSizeMsg = &quot;Data arrays must have more than one row or column.&quot;;
	private static final String kNegLogDataMsg = &quot;Function data must be &gt; 0 for logarithmic intervals.&quot;;
	
	//	Path buffer size.
	private static final int kBufSize = 1000;
	
	//	The minimum number of points allowed in a contour path.
	private static final int kMinNumPoints = 3;
	
	//	A list of contour paths.
<span class="nc" id="L60">	private List pathList = new ArrayList();</span>
	
	//	A flag to indicate that the contours have been computed or not.
<span class="nc" id="L63">	private boolean cCalculated = false;</span>
	
	//	Data arrays used for generating the contours.
	private double[][] xArray, yArray, funcArray;
	
	//	Data arrays used when generating contours for 1D X &amp; Y arrays.
	private double[] xArr1D, yArr1D;
	
	//	Array of contour attributes, one for each contour level.
	private ContourAttrib[] cAttr;
	
	//	The fraction of the task that is completed.
<span class="nc" id="L75">	private float fracComplete = 0;</span>

	/**
	*  Used to indicate that the user wishes to cancel the calculation
	*  of contours.
	**/
<span class="nc" id="L81">	private boolean isCanceled = false;</span>
	
	
	//	Variables in the original FORTRAN program.
	private double[] pathbufxt, pathbufyt;
	private int[] pathbufia;
	private int lnstrt;				//	lnstrt=1 indicates starting a new line.
	private int ignext;
	private int icont;				//	Current contour level index.
	private double cont;			//	The current contour level.
	private int iss, iee, jss, jee;	//	i &amp; j start and end index values.
	private int ima;				//	ima tells which boundary region we are on.
	private int iae;				//	Index to last element in the IA list.
	private int ibeg, jbeg;
	private int gi, gj;				//	Indexes into data arrays.
	private double fij;				//	Data value at i,j in data array.
	private int idir;				//	Indicates current direction.
<span class="nc" id="L98">	private int np=0;				//	Number of points in current contour line.</span>
<span class="nc" id="L99">	private double wx=0, wy=0;		//	Starting point of a contour line.</span>
	
	
	/**
	*  Construct a ContourGenerator object using the specified data arrays
	*  and the specified attribute array.  This constructor allows you
	*  to use data on an uneven X, Y grid.
	*
	*  @param  xArr   2D array containing the grid x coordinate data.
	*  @param  yArr   2D array containing the grid y coordinate data.
	*  @param  fArr   2D array containing the grid function (z) data.
	*  @param  cAttr  Array containing attributes of the contour levels.
	**/
<span class="nc" id="L112">	public ContourGenerator(double[][] xArr, double[][] yArr, double[][] fArr, ContourAttrib[] cAttr) {</span>

		//	Make sure input data is reasonable.
<span class="nc bnc" id="L115" title="All 4 branches missed.">		if (yArr.length != xArr.length || yArr.length != fArr.length)</span>
<span class="nc" id="L116">			throw new IllegalArgumentException(kInconsistantArrMsg);</span>
<span class="nc bnc" id="L117" title="All 4 branches missed.">		if (yArr[0].length != xArr[0].length || yArr[0].length != fArr[0].length)</span>
<span class="nc" id="L118">			throw new IllegalArgumentException(kInconsistantArrMsg);</span>
<span class="nc bnc" id="L119" title="All 4 branches missed.">		if (xArr.length &lt;= 1 || xArr[0].length &lt;= 1)</span>
<span class="nc" id="L120">			throw new IllegalArgumentException(kArrSizeMsg);</span>

<span class="nc" id="L122">		this.cAttr = cAttr;</span>
<span class="nc" id="L123">		xArray = xArr;</span>
<span class="nc" id="L124">		yArray = yArr;</span>
<span class="nc" id="L125">		funcArray = fArr;</span>
		
<span class="nc" id="L127">	}</span>
	
	/**
	*  Construct a ContourGenerator object using the specified data arrays
	*  and the specified attribute array.  This constructor allows you
	*  to use data on an evenly spaced grid where &quot;X&quot; values are invarient
	*  with &quot;Y&quot; and &quot;Y&quot; values are invarient with &quot;X&quot;.  This often occures
	*  where the data is on an evenly spaced cartesian grid.
	*
	*  @param  xArr   1D array containing the grid x coordinate data.
	*  @param  yArr   1D array containing the grid y coordinate data.
	*  @param  fArr   2D array containing the grid function (z) data.
	*  @param  cAttr  Array containing attributes of the contour levels.
	**/
<span class="nc" id="L141">	public ContourGenerator(double[] xArr, double[] yArr, double[][] fArr, ContourAttrib[] cAttr) {</span>

		//	Make sure input data is reasonable.
<span class="nc bnc" id="L144" title="All 4 branches missed.">		if (yArr.length != fArr.length || xArr.length != fArr[0].length)</span>
<span class="nc" id="L145">			throw new IllegalArgumentException(kInconsistantArrMsg);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">		if (xArr.length &lt;= 1)</span>
<span class="nc" id="L147">			throw new IllegalArgumentException(kArrSizeMsg);</span>

<span class="nc" id="L149">		this.cAttr = cAttr;</span>
<span class="nc" id="L150">		xArr1D = xArr;</span>
<span class="nc" id="L151">		yArr1D = yArr;</span>
<span class="nc" id="L152">		funcArray = fArr;</span>
<span class="nc" id="L153">	}</span>
	
	/**
	*  Construct a ContourGenerator object using the specified data arrays.
	*  Contour attributes, including the interval, are generated
	*  automatically.  This constructor allows you to use data on an
	*  uneven X, Y grid.
	*
	*  @param  xArr   2D array containing the grid x coordinate data.
	*  @param  yArr   2D array containing the grid y coordinate data.
	*  @param  fArr   2D array containing the grid function (z) data.
	*  @param  nc     The number of contour levels to generate.
	*  @param  logInterval  Uses a logarithmic contour interval if true, and
	*                       uses a linear interval if false.
	**/
	public ContourGenerator(double[][] xArr, double[][] yArr, double[][] fArr,
<span class="nc" id="L169">								int nc, boolean logInterval) {</span>
		
		//	Make sure input data is reasonable.
<span class="nc bnc" id="L172" title="All 4 branches missed.">		if (yArr.length != xArr.length || yArr.length != fArr.length)</span>
<span class="nc" id="L173">			throw new IllegalArgumentException(kInconsistantArrMsg);</span>
<span class="nc bnc" id="L174" title="All 4 branches missed.">		if (yArr[0].length != xArr[0].length || yArr[0].length != fArr[0].length)</span>
<span class="nc" id="L175">			throw new IllegalArgumentException(kInconsistantArrMsg);</span>
<span class="nc bnc" id="L176" title="All 4 branches missed.">		if (xArr.length &lt;= 1 || xArr[0].length &lt;= 1)</span>
<span class="nc" id="L177">			throw new IllegalArgumentException(kArrSizeMsg);</span>

<span class="nc" id="L179">		xArray = xArr;</span>
<span class="nc" id="L180">		yArray = yArr;</span>
<span class="nc" id="L181">		funcArray = fArr;</span>
		
<span class="nc bnc" id="L183" title="All 2 branches missed.">		if (logInterval)</span>
<span class="nc" id="L184">			findLogIntervals(nc);</span>
		else
<span class="nc" id="L186">			findLinearIntervals(nc);</span>
<span class="nc" id="L187">	}</span>
	
	/**
	*  Construct a ContourGenerator object using the specified data arrays.
	*  Contour attributes, including the interval, are generated
	*  automatically.  This constructor allows you
	*  to use data on an evenly spaced grid where &quot;X&quot; values are invarient
	*  with &quot;Y&quot; and &quot;Y&quot; values are invarient with &quot;X&quot;.  This often occures
	*  where the data is on an evenly spaced cartesian grid.
	*
	*  @param  xArr   1D array containing the grid x coordinate data.
	*  @param  yArr   1D array containing the grid y coordinate data.
	*  @param  fArr   2D array containing the grid function (z) data.
	*  @param  nc     The number of contour levels to generate.
	*  @param  logInterval  Uses a logarithmic contour interval if true, and
	*                       uses a linear interval if false.
	**/
	public ContourGenerator(double[] xArr, double[] yArr, double[][] fArr,
<span class="nc" id="L205">								int nc, boolean logInterval) {</span>
		
		//	Make sure input data is reasonable.
<span class="nc bnc" id="L208" title="All 4 branches missed.">		if (yArr.length != fArr.length || xArr.length != fArr[0].length)</span>
<span class="nc" id="L209">			throw new IllegalArgumentException(kInconsistantArrMsg);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">		if (xArr.length &lt;= 1)</span>
<span class="nc" id="L211">			throw new IllegalArgumentException(kArrSizeMsg);</span>

<span class="nc" id="L213">		xArr1D = xArr;</span>
<span class="nc" id="L214">		yArr1D = yArr;</span>
<span class="nc" id="L215">		funcArray = fArr;</span>
		
<span class="nc bnc" id="L217" title="All 2 branches missed.">		if (logInterval)</span>
<span class="nc" id="L218">			findLogIntervals(nc);</span>
		else
<span class="nc" id="L220">			findLinearIntervals(nc);</span>
<span class="nc" id="L221">	}</span>
	
	
	/**
	*  Generate the contour paths and return them as an array
	*  of ContourPath objects. If there is a lot of data, this method
	*  method may take a long time, so be patient.  Progress can be
	*  checked from another thread by calling &quot;getProgress()&quot;.
	*
	*  @return An array of contour path objects.
	*  @throws InterruptedException if the user cancels this process
	*          (by calling &quot;cancel()&quot; from another thread).
	**/
	public ContourPath[] getContours() throws InterruptedException {
		
<span class="nc bnc" id="L236" title="All 2 branches missed.">		if (!cCalculated) {</span>
<span class="nc" id="L237">			isCanceled = false;</span>
<span class="nc" id="L238">			pathList.clear();</span>
			
			//	Go off an compute the contour paths.
<span class="nc" id="L241">			computeContours();</span>
			
			//	Now turn loose all our data arrays to be garbage collected.
<span class="nc" id="L244">			cAttr = null;</span>
<span class="nc" id="L245">			xArray = yArray = funcArray = null;</span>
<span class="nc" id="L246">			xArr1D = yArr1D = null;</span>
			
			//	Set our &quot;done&quot; flags.
<span class="nc" id="L249">			cCalculated = true;</span>
<span class="nc" id="L250">			fracComplete = 1;</span>
		}
		
		//	Turn our pathList into an array and return the array.
<span class="nc" id="L254">		int size = pathList.size();</span>
<span class="nc" id="L255">		ContourPath[] arr = new ContourPath[size];</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">		for (int i=0; i &lt; size; ++i)</span>
<span class="nc" id="L257">			arr[i] = (ContourPath)pathList.get(i);</span>
				
<span class="nc" id="L259">		return arr;</span>
	}
	
	/**
	*  Returns true if the contour generation process is done.  False if it is not.
	**/
	public boolean done() {
<span class="nc" id="L266">		return cCalculated;</span>
	}
	
	/**
	*  Call this method to cancel the generation of contours.
	**/
	public void cancel() {
<span class="nc" id="L273">		isCanceled = true;</span>
<span class="nc" id="L274">	}</span>
	
	/**
	*  Returns the progress of the currently executing contour generation
	*  process: 0.0 (just starting) to 1.0 (done).
	**/
	public float getProgress() {
<span class="nc" id="L281">		return fracComplete;</span>
	}
	

	/**
	*  Find contour intervals that are linearly spaced through the data.
	**/
	private void findLinearIntervals(int nc) {
	
		//	Find min and max Z values.
<span class="nc" id="L291">		double zMin = Double.MAX_VALUE;	</span>
<span class="nc" id="L292">		double zMax = -zMin;</span>
<span class="nc" id="L293">		int ni = funcArray.length;</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">		for (int i=0; i &lt; ni; ++i) {</span>
<span class="nc" id="L295">			int nj = funcArray[i].length;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">			for (int j=0; j &lt; nj; ++j) {</span>
<span class="nc" id="L297">				double zVal = funcArray[i][j];</span>
<span class="nc" id="L298">				zMin = Math.min(zMin, zVal);</span>
<span class="nc" id="L299">				zMax = Math.max(zMax, zVal);</span>
			}
		}
		
		//	Allocate memory for contour attribute array.
<span class="nc" id="L304">		cAttr = new ContourAttrib[nc];</span>
		
		//	Determine contour levels.
<span class="nc" id="L307">		double delta = (zMax-zMin)/(nc+1);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">		for (int i=0; i &lt; nc; i++) {</span>
<span class="nc" id="L309">			cAttr[i] = new ContourAttrib( zMin + (i+1)*delta );</span>
			if (DEBUG)
				System.out.println(&quot;level[&quot; + i + &quot;] = &quot; + (zMin + (i+1)*delta));
		}

<span class="nc" id="L314">	}</span>
	
	/**
	*  Find contour intervals that are logarithmically spaced through the data.
	**/
	private void findLogIntervals(int nc) {
	
		//	Find min and max Z values.
<span class="nc" id="L322">		double zMin = Double.MAX_VALUE;	</span>
<span class="nc" id="L323">		double zMax = -zMin;</span>
<span class="nc" id="L324">		int ni = funcArray.length;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">		for (int i=0; i &lt; ni; ++i) {</span>
<span class="nc" id="L326">			int nj = funcArray[i].length;</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">			for (int j=0; j &lt; nj; ++j) {</span>
<span class="nc" id="L328">				double zVal = funcArray[i][j];</span>
<span class="nc" id="L329">				zMin = Math.min(zMin, zVal);</span>
<span class="nc" id="L330">				zMax = Math.max(zMax, zVal);</span>
			}
		}
		
<span class="nc bnc" id="L334" title="All 2 branches missed.">		if (zMin &lt; 0)</span>
<span class="nc" id="L335">			throw new IllegalArgumentException(kNegLogDataMsg);</span>

		//	Allocate memory for contour attribute array.
<span class="nc" id="L338">		cAttr = new ContourAttrib[nc];</span>
		
		//	Determine contour levels.
<span class="nc" id="L341">		double temp = Math.log(zMin);</span>
<span class="nc" id="L342">		double delta = (Math.log(zMax) - temp)/(nc+1);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">		for (int i=0; i &lt; nc; i++)</span>
<span class="nc" id="L344">			cAttr[i] = new ContourAttrib( Math.exp(temp + (i+1)*delta) );</span>
		
<span class="nc" id="L346">	}</span>
	

	/**
	*  Computes contour lines for gridded data and stores information about
	*  those contours.  The result of this routine is a list of contour lines
	*  or paths.
	**/
	private void computeContours() throws InterruptedException {

<span class="nc" id="L356">		int ncont = cAttr.length;		//	Number of contour levels.</span>
		
		//	Find the number of data points in &quot;I&quot; and &quot;J&quot; directions.
<span class="nc" id="L359">		int nx=0, ny=0;</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">		if (xArray != null) {</span>
<span class="nc" id="L361">			ny = xArray.length;</span>
<span class="nc" id="L362">			nx = xArray[0].length;</span>
		} else {
<span class="nc" id="L364">			nx = xArr1D.length;</span>
<span class="nc" id="L365">			ny = yArr1D.length;</span>
		}
		
		//	Allocate temporary storage space for path buffers.
<span class="nc" id="L369">		pathbufxt = new double[kBufSize];</span>
<span class="nc" id="L370">		pathbufyt = new double[kBufSize];</span>
<span class="nc" id="L371">		pathbufia = new int[kBufSize*3];</span>

		//	lnstrt=1 (line start) means we're starting a new line.
<span class="nc" id="L374">		lnstrt = 1;</span>
<span class="nc" id="L375">		ignext = 0;</span>

		//	Loop through each contour level.
<span class="nc bnc" id="L378" title="All 2 branches missed.">		for (icont = 0; icont &lt; ncont; ++icont) {</span>

			//	Check to see if the user has canceled.
<span class="nc bnc" id="L381" title="All 2 branches missed.">			if (isCanceled)</span>
<span class="nc" id="L382">				throw new InterruptedException(kCancelMsg);</span>

			//	Begin working on this contour level.
<span class="nc" id="L385">			cont = cAttr[icont].getLevel();</span>
<span class="nc" id="L386">			iss = 1;</span>
<span class="nc" id="L387">			iee = nx;</span>
<span class="nc" id="L388">			jss = 1;</span>
<span class="nc" id="L389">			jee = ny;</span>

<span class="nc" id="L391">			boolean subDivFlg = false;</span>
/*L110*/	do {
				//	Find where function increases through the contour level.
<span class="nc" id="L394">				FlagContourPassings();</span>

<span class="nc" id="L396">				boolean L10flg = false;</span>
/*L210*/		do {

<span class="nc bnc" id="L399" title="All 2 branches missed.">					if (!L10flg) {</span>
						/*	Search along the boundaries for contour line starts.
						*	IMA tells which boundary of the region we're on.
						*/
<span class="nc" id="L403">						ima = 1;</span>
<span class="nc" id="L404">						ibeg = iss - 1;</span>
<span class="nc" id="L405">						jbeg = jss;</span>
					}

/*L6*/				imaLoop:
					do {

<span class="nc bnc" id="L411" title="All 2 branches missed.">						if (!L10flg) {</span>
<span class="nc" id="L412">							boolean imb = false;</span>
<span class="nc" id="L413">							boolean doneFlg = false;</span>
							do {
							
<span class="nc bnc" id="L416" title="All 6 branches missed.">								switch(ima) {</span>
									case 1:
<span class="nc" id="L418">										++ibeg;</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">										if (ibeg == iee)</span>
<span class="nc" id="L420">											ima = 2;</span>
										break;
									
									case 2:
<span class="nc" id="L424">										++jbeg;</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">										if (jbeg == jee)</span>
<span class="nc" id="L426">											ima = 3;</span>
										break;
										
									case 3:
<span class="nc" id="L430">										--ibeg;</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">										if (ibeg == iss)</span>
<span class="nc" id="L432">											ima = 4;</span>
										break;
										
									case 4:
<span class="nc" id="L436">										--jbeg;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">										if (jbeg == jss)</span>
<span class="nc" id="L438">											ima = 5;</span>
										break;
										
									case 5:
<span class="nc" id="L442">										continue imaLoop;</span>
								}
							
<span class="nc bnc" id="L445" title="All 2 branches missed.">								if (funcArray[jbeg -1][ibeg -1] &lt;= cont) {</span>
<span class="nc" id="L446">									imb = true;</span>
<span class="nc" id="L447">									doneFlg = false;</span>
									
<span class="nc bnc" id="L449" title="All 2 branches missed.">								} else if (imb == true)</span>
<span class="nc" id="L450">									doneFlg = true;</span>
								
<span class="nc bnc" id="L452" title="All 2 branches missed.">							} while (!doneFlg);</span>
							
							//	Got a start point.
<span class="nc" id="L455">							gi = ibeg;							//	x index of starting point.</span>
<span class="nc" id="L456">							gj = jbeg;							//	y index of starting point.</span>
<span class="nc" id="L457">							fij = funcArray[jbeg -1][ibeg -1];	//	z value of starting point.</span>

							//	Round the corner if necessary.
							/*	Look different directions to see which way the contour line
							*	went:
							*			  4
							*			1-|-3
							*			  2
							*/
<span class="nc bnc" id="L466" title="All 6 branches missed.">							switch (ima) {</span>
								case 1:
<span class="nc" id="L468">									Routine_L21();</span>
<span class="nc" id="L469">									break;</span>
									
								case 2:
<span class="nc bnc" id="L472" title="All 2 branches missed.">									if (gj != jss) {</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">										if (!Routine_L31())</span>
<span class="nc" id="L474">											Routine_L21();</span>
									} else
<span class="nc" id="L476">										Routine_L21();</span>
<span class="nc" id="L477">									break;</span>

								case 3:
<span class="nc bnc" id="L480" title="All 2 branches missed.">									if (gi != iee) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">										if (!Routine_L41())</span>
<span class="nc" id="L482">											Routine_L21();</span>
									} else {
<span class="nc bnc" id="L484" title="All 2 branches missed.">										if (!Routine_L31())</span>
<span class="nc" id="L485">											Routine_L21();</span>
									}
									break;

								case 4:
<span class="nc bnc" id="L490" title="All 2 branches missed.">									if (gj != jee) {</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">										if (!Routine_L51())</span>
<span class="nc" id="L492">											Routine_L21();</span>
									} else {
<span class="nc bnc" id="L494" title="All 2 branches missed.">										if (!Routine_L41())</span>
<span class="nc" id="L495">											Routine_L21();</span>
									}
									break;

								case 5:
<span class="nc bnc" id="L500" title="All 2 branches missed.">									if (!Routine_L51())</span>
<span class="nc" id="L501">										Routine_L21();</span>
									break;
							}
							
						}	//	end if(!L10flg)
					

						//	This is the end of a contour line.  After this, we'll start a
						//	new line.
<span class="nc" id="L510">						L10flg = false;</span>
<span class="nc" id="L511">/*L90*/					lnstrt = 1;						//	Contour line start flag.</span>
<span class="nc" id="L512">						ignext = 0;</span>
<span class="nc" id="L513">						accumContour(np, icont, pathbufxt, pathbufyt, cAttr[icont]);</span>
						
						//	If we're not done looking along the boundaries,
						//	go look there some more.
<span class="nc bnc" id="L517" title="All 2 branches missed.">					} while (ima != 5);</span>
					
					
					//	Otherwise, get the next start out of IA.
<span class="nc bnc" id="L521" title="All 2 branches missed.">/*L91*/				if (iae != 0) {</span>
<span class="nc" id="L522">						int ntmp3 = iae;</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">						for (int iia = 1; iia &lt;= ntmp3; ++iia) {</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">							if (pathbufia[iia -1] != 0) {</span>
								//	This is how we start in the middle of the region, using IA.
<span class="nc" id="L526">								gi = pathbufia[iia - 1]/1000;</span>
<span class="nc" id="L527">								gj = pathbufia[iia - 1] - gi*1000;</span>
<span class="nc" id="L528">								fij = funcArray[gj -1][gi -1];</span>
<span class="nc" id="L529">								pathbufia[iia - 1] = 0;</span>
								
<span class="nc" id="L531">								Routine_L21();</span>
								
<span class="nc" id="L533">								L10flg = true;</span>
<span class="nc" id="L534">								break;</span>
							}
						}
					}
					
<span class="nc bnc" id="L539" title="All 2 branches missed.">				} while ( L10flg );</span>
				
				/*	And if there are no more of these, we're done with this region.
				*   If we've subdivided, update the region pointers and go back for more.
				*/
<span class="nc" id="L544">				subDivFlg = false;</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">				if (iee == nx) {</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">					if (jee != ny) {</span>
<span class="nc" id="L547">						jss = jee;</span>
<span class="nc" id="L548">						jee = ny;</span>
<span class="nc" id="L549">						subDivFlg = true;</span>
					}
				} else {
<span class="nc" id="L552">					iss = iee;</span>
<span class="nc" id="L553">					iee = nx;</span>
<span class="nc" id="L554">					subDivFlg = true;</span>
				}
				
<span class="nc bnc" id="L557" title="All 2 branches missed.">			} while (subDivFlg);</span>


			//	Update progress information.
<span class="nc" id="L561">			fracComplete = (float)(icont+1)/(float)(ncont);</span>
			
			//	Loop back for the next contour level.
		}	// Next icont


		//	Turn loose temporary arrays used to generate contours.
<span class="nc" id="L568">		pathbufxt = null;</span>
<span class="nc" id="L569">		pathbufyt = null;</span>
<span class="nc" id="L570">		pathbufia = null;		</span>
		
<span class="nc" id="L572">	}</span>


	/**
	*  Flag points in IA where the the function increases through the contour
	*  level, not including the boundaries.  This is so we have a list of at least
	*  one point on each contour line that doesn't intersect a boundary.
	**/
	private void FlagContourPassings() {

<span class="nc" id="L582">		iae = 0;</span>
<span class="nc" id="L583">		int ntmp2 = jee - 1;</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">		for (int j=jss + 1; j &lt;= ntmp2; ++j) {</span>
<span class="nc" id="L585">			boolean imb = false;</span>
<span class="nc" id="L586">			int iaend = iae;</span>
<span class="nc" id="L587">			int ntmp3 = iee;</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">			for (int i=iss; i &lt;= ntmp3; ++i) {</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">				if (funcArray[j -1][i -1] &lt;= cont)</span>
<span class="nc" id="L590">					imb = true;</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">				else if (imb == true) {</span>
<span class="nc" id="L592">					++iae;</span>
<span class="nc" id="L593">					pathbufia[iae - 1] = i*1000 + j;</span>
<span class="nc" id="L594">					imb = false;</span>

					/*  Check if the IA array is full.  If so, the subdividing
					*   algorithm goes like this:  if we've marked at least one
					*   J row, drop back to the last completed J and call that
					*   the region.  If we haven't even finished one J row, our
					*   region just extends to this I location.
					*/
<span class="nc bnc" id="L602" title="All 2 branches missed.">					if (iae == kBufSize*3) {</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">						if (j &gt; jss + 1) {</span>
<span class="nc" id="L604">							iae = iaend;</span>
<span class="nc" id="L605">							jee = j;</span>
						} else {
							//	Compute minimum.
<span class="nc" id="L608">							jee = Math.min(j+1, jee);</span>
<span class="nc" id="L609">							iee = i;</span>
						}
						
						//	Break out of i &amp; j loops.
<span class="nc" id="L613">						return;</span>
					}
				}
			}	//	Next i
		}	//	Next j

<span class="nc" id="L619">	}</span>

	/**
	*  This function represents the block of code in the original
	*  FORTRAN program that comes after line 21.
	**/
	private void Routine_L21() {
		while (true) {
<span class="nc" id="L627">			--gi;</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">			if (gi &lt; iss)</span>
<span class="nc" id="L629">				return;						//	Goto L90.</span>

<span class="nc" id="L631">			idir = 1;</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">			if (funcArray[gj -1][gi -1] &lt;= cont) {</span>
				//	Wipe this point out of IA if it's in the list.
<span class="nc bnc" id="L634" title="All 2 branches missed.">/*L52*/			if (iae != 0) {</span>
<span class="nc" id="L635">					int ij = gi*1000 + gj + 1000;</span>
<span class="nc" id="L636">					int ntmp3 = iae;</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">					for (int iia = 1; iia &lt;= ntmp3; ++iia) {</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">						if (pathbufia[iia - 1] == ij) {</span>
<span class="nc" id="L639">							pathbufia[iia - 1] = 0;</span>
<span class="nc" id="L640">							break;</span>
						}
					}
				}
<span class="nc" id="L644">				doInterpolation();</span>
<span class="nc" id="L645">				return;						//	Goto L90.</span>
			}

<span class="nc" id="L648">			fij = funcArray[gj -1][gi -1];</span>

<span class="nc bnc" id="L650" title="All 2 branches missed.">			if (Routine_L31())	return;		//	Goto L90</span>
		}
	}

	/**
	*  This function represents the block of code in the original
	*  FORTRAN program that comes after line 31.
	**/
	private boolean Routine_L31() {
<span class="nc" id="L659">		--gj;</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">		if (gj &lt; jss)</span>
<span class="nc" id="L661">			return true;</span>

<span class="nc" id="L663">		idir = 2;</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">		if (funcArray[gj -1][gi -1] &lt;= cont) {</span>
<span class="nc" id="L665">			doInterpolation();</span>
<span class="nc" id="L666">			return true;</span>
		}

<span class="nc" id="L669">		fij = funcArray[gj -1][gi -1];</span>

<span class="nc" id="L671">		return (Routine_L41());</span>
	}

	/**
	*  This function represents the block of code in the original
	*  FORTRAN program that comes after line 41.
	**/
	private boolean Routine_L41() {
<span class="nc" id="L679">		++gi;</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">		if (gi &gt; iee)</span>
<span class="nc" id="L681">			return true;</span>

<span class="nc" id="L683">		idir = 3;</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">		if (funcArray[gj -1][gi -1] &lt;= cont) {</span>
<span class="nc" id="L685">			doInterpolation();</span>
<span class="nc" id="L686">			return true;</span>
		}

<span class="nc" id="L689">		fij = funcArray[gj -1][gi -1];</span>

<span class="nc" id="L691">		return (Routine_L51());</span>
	}

	/**
	*  This function represents the block of code in the original
	*  FORTRAN program that comes after line 51.
	**/
	private boolean Routine_L51() {
<span class="nc" id="L699">		++gj;</span>
<span class="nc" id="L700">		idir = 4;</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">		if (gj &gt; jee)</span>
<span class="nc" id="L702">			return true;</span>

<span class="nc bnc" id="L704" title="All 2 branches missed.">		if (funcArray[gj -1][gi -1] &lt;= cont) {</span>
<span class="nc" id="L705">			doInterpolation();</span>
<span class="nc" id="L706">			return true;</span>
		}

<span class="nc" id="L709">		fij = funcArray[gj -1][gi -1];</span>

<span class="nc" id="L711">		return false;</span>
	}

	/**
	*  Do interpolation for X, Y coordinates.
	*
	*  This function represents the block of code in the original
	*  FORTRAN program that comes after line 60.
	**/
	private void doInterpolation() {

		//	Do interpolation for X,Y coordinates.
<span class="nc" id="L723">		double func = funcArray[gj -1][gi -1];</span>
<span class="nc" id="L724">		double xyf = (cont - func)/(fij - func);</span>
		
		/*  This tests for a contour point coinciding with a grid point.  In this case
		 *  the contour routine comes up with the same physical coordinate twice.  If
		 *  If we don't trap it, it can (in some cases significantly) increase the
		 *  number of points in a contour line.  Also, if this happens on the first
		 *  point in a line, the second point could be misinterpreted as the end of a
		 *   (circling) contour line.
		 */
<span class="nc bnc" id="L733" title="All 2 branches missed.">		if (xyf == 0)</span>
<span class="nc" id="L734">			++ignext;</span>

<span class="nc" id="L736">		double wxx=0, wyy=0;</span>
<span class="nc" id="L737">		double xVal=0, yVal=0;</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">		if (xArray != null) {</span>
			//	We have 2D arrays for the X &amp; Y grid points.
<span class="nc" id="L740">			xVal = xArray[gj -1][gi -1];</span>
<span class="nc" id="L741">			yVal = yArray[gj -1][gi -1];</span>
<span class="nc bnc" id="L742" title="All 5 branches missed.">			switch (idir) {</span>
				case 1:				//	East
<span class="nc" id="L744">					wxx = xVal + xyf*(xArray[gj -1][gi + 1 -1] - xVal);</span>
<span class="nc" id="L745">					wyy = yVal + xyf*(yArray[gj -1][gi + 1 -1] - yVal);</span>
<span class="nc" id="L746">					break;</span>

				case 2:				//	North
<span class="nc" id="L749">					wxx = xVal + xyf*(xArray[gj + 1 -1][gi -1] - xVal);</span>
<span class="nc" id="L750">					wyy = yVal + xyf*(yArray[gj + 1 -1][gi -1] - yVal);</span>
<span class="nc" id="L751">					break;</span>

				case 3:				//	West
<span class="nc" id="L754">					wxx = xVal + xyf*(xArray[gj -1][gi - 1 -1] - xVal);</span>
<span class="nc" id="L755">					wyy = yVal + xyf*(yArray[gj -1][gi - 1 -1] - yVal);</span>
<span class="nc" id="L756">					break;</span>

				case 4:				//	South
<span class="nc" id="L759">					wxx = xVal + xyf*(xArray[gj - 1 -1][gi -1] - xVal);</span>
<span class="nc" id="L760">					wyy = yVal + xyf*(yArray[gj - 1 -1][gi -1] - yVal);</span>
<span class="nc" id="L761">					break;</span>
			}
			
		} else {
			//	We have 1D arrays for the X &amp; Y grid points.
<span class="nc" id="L766">			xVal = xArr1D[gi -1];</span>
<span class="nc" id="L767">			yVal = yArr1D[gj -1];</span>
<span class="nc bnc" id="L768" title="All 5 branches missed.">			switch (idir) {</span>
				case 1:				//	East
<span class="nc" id="L770">					wxx = xVal + xyf*(xArr1D[gi + 1 -1] - xVal);</span>
<span class="nc" id="L771">					wyy = yVal;</span>
<span class="nc" id="L772">					break;</span>

				case 2:				//	North
<span class="nc" id="L775">					wxx = xVal;</span>
<span class="nc" id="L776">					wyy = yVal + xyf*(yArr1D[gj + 1 -1] - yVal);</span>
<span class="nc" id="L777">					break;</span>

				case 3:				//	West
<span class="nc" id="L780">					wxx = xVal + xyf*(xArr1D[gi - 1 -1] - xVal);</span>
<span class="nc" id="L781">					wyy = yVal;</span>
<span class="nc" id="L782">					break;</span>

				case 4:				//	South
<span class="nc" id="L785">					wxx = xVal;</span>
<span class="nc" id="L786">					wyy = yVal + xyf*(yArr1D[gj - 1 -1] - yVal);</span>
					break;
			}
		}	

		if (DEBUG) {
			System.out.println(&quot;i, j = &quot; + gi + &quot;,&quot; + gj);
			System.out.println(&quot;cont = &quot; + (float)cont + &quot;,  fij = &quot; + (float)fij +
									&quot;,  func = &quot; + (float)func + &quot;,  xyf = &quot; + (float)xyf);
			System.out.println(&quot;xVal = &quot; + (float)xVal + &quot;,  yVal = &quot; + (float)yVal);
			System.out.println(&quot;wxx = &quot; + (float)wxx + &quot;,  wyy = &quot; + (float)wyy);
		}
		
		//	Figure out what to do with this point.
<span class="nc bnc" id="L800" title="All 2 branches missed.">		if (lnstrt == 1) {</span>
			//	This is the 1st point in the contour line.

<span class="nc" id="L803">			np = 1;</span>
<span class="nc" id="L804">			pathbufxt[np -1] = wxx;</span>
<span class="nc" id="L805">			pathbufyt[np -1] = wyy;</span>

			//	Save starting point as wx, wy.
<span class="nc" id="L808">			wx = wxx;</span>
<span class="nc" id="L809">			wy = wyy;</span>

			//	Clear the first point flag, we've got one now.
<span class="nc" id="L812">			lnstrt = 0;</span>
			
		} else {

<span class="nc" id="L816">			boolean skipFlg = false;</span>
			
			//	Second point and after comes here.
			//	Add a point to this line.  Check for duplicate point first.
<span class="nc bnc" id="L820" title="All 2 branches missed.">			if (ignext == 2) {</span>
<span class="nc bnc" id="L821" title="All 4 branches missed.">				if (wxx == pathbufxt[np -1] &amp;&amp; wyy == pathbufyt[np -1]) {</span>
<span class="nc" id="L822">					ignext = 0;</span>
<span class="nc" id="L823">					skipFlg = true;</span>
					
				} else
<span class="nc" id="L826">					ignext = 1;</span>
			}

<span class="nc bnc" id="L829" title="All 2 branches missed.">			if (!skipFlg) {</span>
			
				//	Increment # of points in contour.
<span class="nc" id="L832">				++np;</span>
<span class="nc" id="L833">				pathbufxt[np -1] = wxx;</span>
<span class="nc" id="L834">				pathbufyt[np -1] = wyy;</span>

				//	See if the temporary array xt, yt are full.
<span class="nc bnc" id="L837" title="All 2 branches missed.">				if (np == kBufSize) {</span>
<span class="nc" id="L838">					accumContour(np, icont, pathbufxt, pathbufyt, cAttr[icont]);</span>

					//	Last point becomes 1st point to continue.
<span class="nc" id="L841">					pathbufxt[0] = pathbufxt[np -1];</span>
<span class="nc" id="L842">					pathbufyt[0] = pathbufyt[np -1];</span>
<span class="nc" id="L843">					np =1;</span>
				}
	
				//	Check to see if we're back to the intial point.
<span class="nc bnc" id="L847" title="All 4 branches missed.">				if (wxx == wx &amp;&amp; wyy == wy)</span>
<span class="nc" id="L848">					return;</span>
			}

		}

		//	Search for the next point on this line.
<span class="nc bnc" id="L854" title="All 5 branches missed.">/*L67*/		switch(idir) {</span>
			case 1:
<span class="nc" id="L856">				++gi;</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">				if (!Routine_L51())</span>
<span class="nc" id="L858">					Routine_L21();</span>
				break;

			case 2:
<span class="nc" id="L862">				++gj;</span>
<span class="nc" id="L863">				Routine_L21();</span>
<span class="nc" id="L864">				break;</span>

			case 3:
<span class="nc" id="L867">				--gi;</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">				if (!Routine_L31())</span>
<span class="nc" id="L869">					Routine_L21();</span>
				break;

			case 4:
<span class="nc" id="L873">				--gj;</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">				if (!Routine_L41())</span>
<span class="nc" id="L875">					Routine_L21();</span>
				break;
		}
		
<span class="nc" id="L879">		return;</span>
	}
	
	/**
	*  Accumulate contour paths, as they are generated, into
	*  an overall list of contours.
	*
	*  @param  np      The number of points in the contour path buffers.
	*  @param  icont   The index to the current contour level.
	*  @param  x,y     Buffers containing x &amp; y coordinates of contour points.
	*  @param  cAttr   The attributes for this particular contour level.
	**/
	private void accumContour(int np, int icont, double[] x, double[] y, ContourAttrib cAttr) {
		
		//	To few points for a contour line.
<span class="nc bnc" id="L894" title="All 2 branches missed.">		if (np &lt; kMinNumPoints)	return;</span>
		
		//	Copy over coordinate points from buffers to their own arrays.
<span class="nc" id="L897">		double[] xArr = new double[np];</span>
<span class="nc" id="L898">		double[] yArr = new double[np];</span>
<span class="nc" id="L899">		System.arraycopy(x, 0, xArr, 0, np);</span>
<span class="nc" id="L900">		System.arraycopy(y, 0, yArr, 0, np);</span>
		
		//	Create a new contour path and add it to the list.
<span class="nc" id="L903">		ContourPath path = new ContourPath(cAttr, icont, xArr, yArr);</span>
<span class="nc" id="L904">		pathList.add(path);</span>
		
<span class="nc" id="L906">	}</span>
	
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>