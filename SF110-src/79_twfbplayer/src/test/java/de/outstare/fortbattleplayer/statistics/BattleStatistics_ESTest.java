/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 13 12:31:01 GMT 2024
 */

package de.outstare.fortbattleplayer.statistics;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import de.outstare.fortbattleplayer.model.Area;
import de.outstare.fortbattleplayer.model.CharacterClass;
import de.outstare.fortbattleplayer.model.Combatant;
import de.outstare.fortbattleplayer.model.CombatantSide;
import de.outstare.fortbattleplayer.model.impl.SimpleArea;
import de.outstare.fortbattleplayer.model.impl.SimpleSector;
import de.outstare.fortbattleplayer.statistics.AreaStatistic;
import de.outstare.fortbattleplayer.statistics.BattleStatistics;
import de.outstare.fortbattleplayer.statistics.CriticalHit;
import de.outstare.fortbattleplayer.statistics.LabeledData;
import de.outstare.fortbattleplayer.statistics.PositionSwitch;
import de.outstare.fortbattleplayer.statistics.WeaponModCounter;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class BattleStatistics_ESTest extends BattleStatistics_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundReturningPositive() throws Throwable  {
      // Given: A BattleStatistics object with round() method and a value of -1 for both x and y coordinates
      BattleStatistics battleStatistics = new BattleStatistics((-1), (-1));
      
      // When: The round() method is called with a value of 84.2853148
      int round = battleStatistics.round(84.2853148);
      
      // Then: The result should be the nearest integer to 84.2853148, which is 84
      assertEquals(84, round);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundReturningNegative() throws Throwable  {
      // Given: a BattleStatistics object with the round number -2465 and the number of ships sunk 383
      BattleStatistics battleStatistics = new BattleStatistics(-2465, 383);
      
      // When: calculating the round number for the value -2985
      int round = battleStatistics.round(-2985);
      
      // Then: the calculated round number should be -2985
      assertEquals(-2985, round);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCountWeaponMods() throws Throwable  {
      // Given: a BattleStatistics object with a specific number of weapon mods for the attacker side
      BattleStatistics battleStatistics = new BattleStatistics(-1923, 2609);
      
      // When: calling countWeaponMods() with null filter
      int countWeaponMods = battleStatistics.countWeaponMods(CombatantSide.ATTACKER, (WeaponModCounter) null);
      
      // Then: the result should be 0, as no weapon mods are filtered by the null filter
      assertEquals(0, countWeaponMods);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCritListWithNonNull() throws Throwable  {
      // Given: A new BattleStatistics object with a certain number of rounds
      BattleStatistics battleStatistics = new BattleStatistics(478, 478);
      
      // When: The critList method is called with the CombatantSide.DEFENDER argument
      List<CriticalHit> critList = battleStatistics.critList(CombatantSide.DEFENDER);
      
      // Then: The returned list of CriticalHit objects should be empty
      assertTrue(critList.isEmpty());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNotShootersPerRound() throws Throwable  {
      // Given a battle statistics object with 478 rounds and a round number of 478
      BattleStatistics battleStatistics = new BattleStatistics(478, 478);
      
      // When we call the getNotShootersPerRound method on this statistics object
      Map<CombatantSide, ? extends LabeledData> notShootersPerRound = battleStatistics.getNotShootersPerRound();
      
      // Then the returned map should have 2 elements (one for each combatant side)
      assertEquals(2, notShootersPerRound.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCritListWithNull() throws Throwable  {
      BattleStatistics battleStatistics = new BattleStatistics(-2040, -2040);
      // Given a BattleStatistics object with negative values for the number of combatants on both sides
      
      List<CriticalHit> critList = battleStatistics.critList(null);
      // When calling the critList method with null as an argument (i.e., no specific side is specified)
      
      assertTrue(critList.isEmpty());
      // Then, the resulting list of CriticalHits should be empty, since there are no combatants on either side to generate critical hits for
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCriticalHitDamage() throws Throwable  {
      // Given a BattleStatistics object with a damage of -463 and a critical hit chance of 10%
      BattleStatistics battleStatistics = new BattleStatistics(-463, 10);
      
      // When the combatant side is ATTACKER
      CombatantSide attacker = CombatantSide.ATTACKER;
      
      // Then the critical hit damage should be 0L
      long expectedDamage = 0L;
      assertEquals(expectedDamage, battleStatistics.criticalHitDamage(attacker));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSwitchedPosList() throws Throwable  {
      // Given: A BattleStatistics object with a certain number of battles and a certain number of combatants
      int battleCount = 478;
      int combatantCount = 478;
      BattleStatistics statistics = new BattleStatistics(battleCount, combatantCount);
      
      // When: The switchedPosList method is called with null as the parameter
      Set<PositionSwitch> switchedPosList = statistics.switchedPosList((CombatantSide) null);
      
      // Then: The returned set should be empty, as there are no position switches with a null CombatantSide
      assertEquals(0, switchedPosList.size());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNumberOfMovesPerPlayerReturningZero() throws Throwable  {
      // Given: Two players with a total of 478 moves in a battle
      BattleStatistics battleStatistics = new BattleStatistics(478, 478);
      
      // When: The number of moves per player is calculated for the defender side
      CombatantSide arg0 = CombatantSide.DEFENDER;
      double numberOfMovesPerPlayer = battleStatistics.numberOfMovesPerPlayer(arg0);
      
      // Then: The number of moves per player should be 0, since both players have the same number of moves
      assertEquals(0.0, numberOfMovesPerPlayer, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNumberOfMovesPerPlayerWithNonNull() throws Throwable  {
      // No Comments were added
      BattleStatistics battleStatistics = new BattleStatistics(1, 1);
      CombatantSide arg0 = CombatantSide.ATTACKER;
      double numberOfMovesPerPlayer = battleStatistics.numberOfMovesPerPlayer(arg0);
      assertEquals(0.0, numberOfMovesPerPlayer, 0.01);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCombatantLifetime() throws Throwable  {
      // Given a BattleStatistics object with 52 battles and 52 victories
      BattleStatistics battleStatistics = new BattleStatistics(52, 52);
      
      // When the combatantLifetime method is called with null input
      int combatantLifetime = battleStatistics.combatantLifetime((Combatant) null);
      
      // Then the method should return 0
      assertEquals(0, combatantLifetime);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetRoundWithNegative() throws Throwable  {
      BattleStatistics battleStatistics = new BattleStatistics(-2911, -2911);
      // Given the battle statistics object with the round set to -2911
      
      battleStatistics.setRound(-2911);
      // When the round is set to -2911
      
      battleStatistics.setRound(-2911);
      // Then the round is set to -2911 again
      
      battleStatistics.setRound(-2911);
      // And the round is set to -2911 one more time
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetShotsPerRound() throws Throwable  {
      // Given a BattleStatistics object with 478 rounds and 478 shots per round
      BattleStatistics battleStatistics = new BattleStatistics(478, 478);
      
      // When we call the getShotsPerRound() method on this object
      Map<CombatantSide, ? extends LabeledData> shotsPerRound = battleStatistics.getShotsPerRound();
      
      // Then the map returned should not be empty
      assertFalse(shotsPerRound.isEmpty());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAmountOfDefenseBonus() throws Throwable  {
      // Given: A BattleStatistics object with a defender side having 29 defense bonus points
      BattleStatistics battleStatistics = new BattleStatistics(29, 29);
      CombatantSide arg0 = CombatantSide.DEFENDER;
      
      // When: We call the amountOfDefenseBonus method with the defender side as an argument
      int amountOfDefenseBonus = battleStatistics.amountOfDefenseBonus(arg0);
      
      // Then: The amount of defense bonus points for the defender side should be 0
      assertEquals(0, amountOfDefenseBonus);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRoundReturningZero() throws Throwable  {
      // Given a battle statistics instance with negative values for both the attacker and defender's damage done in previous rounds
      BattleStatistics battleStatistics = new BattleStatistics(-322, -322);
      
      // When we call the round method with an argument of 0 (the current round number)
      int round = battleStatistics.round(0);
      
      // Then the method should return 0 as the round number
      assertEquals(0, round);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCriticalHits() throws Throwable  {
      // Given the BattleStatistics object with a negative total damage and a negative total damage taken
      BattleStatistics battleStatistics = new BattleStatistics(-221, -221);
      
      // When we call the criticalHits method with CombatantSide.DEFENDER as an argument
      int criticalHits = battleStatistics.criticalHits(CombatantSide.DEFENDER);
      
      // Then the result should be 0, since there are no critical hits when both sides have negative damage
      assertEquals(0, criticalHits);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetHitsPerRound() throws Throwable  {
      BattleStatistics battleStatistics = new BattleStatistics(-322, -322);
      Map<CombatantSide, ? extends LabeledData> hitsPerRound = battleStatistics.getHitsPerRound();
      // Given a BattleStatistics object with initialized data
      // When the getHitsPerRound method is called on the BattleStatistics object
      // Then the map returned should not be empty
      assertFalse(hitsPerRound.isEmpty());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHasMovedThrowsNullPointerException() throws Throwable  {
      // Given: A BattleStatistics object with a null combatant and area
      BattleStatistics battleStatistics = new BattleStatistics((-1), (-1));
      
      // When: We call the hasMoved method with a null combatant and area
      try {
      battleStatistics.hasMoved(null, null);
      fail("Expecting exception: NullPointerException");
      
      } catch (NullPointerException e) {
      // Then: We expect to get an exception due to the null inputs
      verifyException("de.outstare.fortbattleplayer.statistics.AllCombatantSidesCounter", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsAlive() throws Throwable  {
      // rollbacked to evosuite
      BattleStatistics battleStatistics = new BattleStatistics(2638, 0);
      battleStatistics.isAlive((Combatant) null);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNumberOfHipFlasks() throws Throwable  {
      BattleStatistics battleStatistics = new BattleStatistics(-221, -221);
      CombatantSide defenderSide = CombatantSide.DEFENDER;
      int numHipFlasks = battleStatistics.numberOfHipFlasks(defenderSide);
      
      // Asserts that the number of hip flasks for the defender side is 0, as expected.
      assertEquals(0, numHipFlasks);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNumberOfSchmierOil() throws Throwable  {
      // Given: A BattleStatistics instance with a number of Schmier Oil (23) and a null Combatant Side
      BattleStatistics battleStatistics = new BattleStatistics(23, 23);
      
      // When: The method "numberOfSchmierOil" is called with a null Combatant Side as parameter
      int numberOfSchmierOil = battleStatistics.numberOfSchmierOil((CombatantSide) null);
      
      // Then: The result should be 0, as the method only considers Schmier Oil from one side
      assertEquals(0, numberOfSchmierOil);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNumberOfFettesOil() throws Throwable  {
      // Given: A new BattleStatistics instance with a certain number of fettes oil for the defender side
      BattleStatistics battleStatistics = new BattleStatistics(478, 478);
      
      // When: The number of fettes oil is requested for the defender side
      int numberOfFettesOil = battleStatistics.numberOfFettesOil(CombatantSide.DEFENDER);
      
      // Then: The result should be 0 (i.e., no fettes oil has been used)
      assertEquals(0, numberOfFettesOil);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetFieldStatistics() throws Throwable  {
      // Given: A new BattleStatistics instance with default values
      BattleStatistics battleStatistics = new BattleStatistics(0, 0);
      
      // When: We retrieve the field statistics
      Map<Area, AreaStatistic> fieldStatistics = battleStatistics.getFieldStatistics();
      
      // Then: The field statistics map should be empty
      assertTrue(fieldStatistics.isEmpty());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTotalSwaps() throws Throwable  {
      // Given a BattleStatistics object with a negative number of ships and 2 swaps
      BattleStatistics battleStatistics = new BattleStatistics(-442, 2);
      
      // When we call the totalSwaps method with CombatantSide.ATTACKER as the argument
      int totalSwaps = battleStatistics.totalSwaps(CombatantSide.ATTACKER);
      
      // Then the method should return 0, since there are no swaps for the attacker side
      assertEquals(0, totalSwaps);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNumberOfGraphitLubricants() throws Throwable  {
      // Given a BattleStatistics object with no Graphit Lubricants
      BattleStatistics battleStatistics = new BattleStatistics(-221, -221);
      
      // When the number of Graphit Lubricants is requested with a null CombatantSide
      int numberOfGraphitLubricants = battleStatistics.numberOfGraphitLubricants(null);
      
      // Then 0 should be returned
      assertEquals(0, numberOfGraphitLubricants);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAmountOfAttackBonus() throws Throwable  {
      // This test checks that the method amountOfAttackBonus returns 0 for a defender.
      CombatantSide arg0 = CombatantSide.DEFENDER;
      BattleStatistics battleStatistics = new BattleStatistics((-386), 691);
      int expectedAmountOfAttackBonus = 0;
      assertEquals(expectedAmountOfAttackBonus, battleStatistics.amountOfAttackBonus(arg0));
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsDead() throws Throwable  {
      // rollbacked to evosuite
      BattleStatistics battleStatistics = new BattleStatistics(3, 3);
      battleStatistics.isDead((Combatant) null);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNumberOfLoadingChamerOrEnhancedPatrons() throws Throwable  {
      // Given a BattleStatistics instance with 1 defense round and 1 attacker
      BattleStatistics battleStatistics = new BattleStatistics(1, 1);
      
      // When we get the number of loading chambers or enhanced patrons for the defender side
      int numberOfLoadingChamerOrEnhancedPatrons = battleStatistics.numberOfLoadingChamerOrEnhancedPatrons(CombatantSide.DEFENDER);
      
      // Then we expect 0 as there are no loading chambers or enhanced patrons for the defender side
      assertEquals(0, numberOfLoadingChamerOrEnhancedPatrons);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNewDestination() throws Throwable  {
      // Arrange
      BattleStatistics battleStatistics = new BattleStatistics(0, 0);
      CharacterClass characterClass = CharacterClass.ADVENTURER;
      SimpleSector simpleSector = new SimpleSector(16716049, false, true, 1509, 612, false, 0, characterClass);
      SimpleArea simpleArea = new SimpleArea(16716049, 474, simpleSector);
      
      // Act
      battleStatistics.newDestination((Combatant) null, simpleArea);
      
      // Assert
      assertFalse(simpleArea.isOccupied());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNumberOfBayonets() throws Throwable  {
      // Given: A BattleStatistics instance with 23 battles
      BattleStatistics battleStatistics = new BattleStatistics(23, 23);
      
      // When: Calculating the number of bayonets for the attacker side
      CombatantSide arg0 = CombatantSide.ATTACKER;
      int numberOfBayonets = battleStatistics.numberOfBayonets(arg0);
      
      // Then: The result should be 0, as there are no bayonets for the attacker side
      assertEquals(0, numberOfBayonets);
  }
}
