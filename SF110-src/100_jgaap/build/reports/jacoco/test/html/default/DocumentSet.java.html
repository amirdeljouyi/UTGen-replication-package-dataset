<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DocumentSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">100_jgaap</a> &gt; <a href="index.source.html" class="el_package">default</a> &gt; <span class="el_source">DocumentSet.java</span></div><h1>DocumentSet.java</h1><pre class="source lang-java linenums">/**  DocumentSet.java
 *   Caleb Astey - 2007
 */

import java.util.Vector;
import java.util.Hashtable;
import java.util.StringTokenizer;
import java.util.*;

/**A Document Set is a group of documents written by the same author.  
 * This can be used to facilitate event sets that are larger than just 
 * a single document, which may be more indicative of an author's 
 * entire body of work.
 */
public class DocumentSet {

    public Hashtable frequency;
    Vector&lt;Document&gt; documents;

<span class="nc" id="L20">    DocumentSet() {</span>
<span class="nc" id="L21">	documents = new Vector&lt;Document&gt;();</span>
<span class="nc" id="L22">    }</span>

<span class="nc" id="L24">    DocumentSet(Document d) {</span>
<span class="nc" id="L25">	documents = new Vector&lt;Document&gt;();</span>
<span class="nc" id="L26">	documents.add(d);</span>
<span class="nc" id="L27">    }</span>

    /**Registers a new document to the list of documents by a given author.  
     * The document is appended on to the end of the list.  
     **/
    public void register(Document d) {
<span class="nc" id="L33">	documents.add(d);</span>
<span class="nc" id="L34">    }</span>


    /**Number of documents currently registered in this set of documents**/
    public int documentCount() {
<span class="nc" id="L39">	return documents.size();</span>
    }

    /**Returns an individual indexed documement.  The index is given by the 
     * order in which the documents were registered with the DocumentSet
     **/
    public Document getDocument(int index) {
<span class="nc" id="L46">	return documents.elementAt(index);</span>
    }

    /**Calculates the frequency of individual characters within the entire 
     * set of documents.  Each character is a key in a hashtable with the value
     * being the frequency of occurrance. This is legacy code rewritten and was 
     * included for completeness.
     **/  
    public void characterFrequency() {
<span class="nc" id="L55">	frequency = new Hashtable();</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">	for (int i = 0; i &lt; documents.size(); i++) {</span>
<span class="nc" id="L57">	    Vector&lt;Character&gt; pt = documents.elementAt(i).getProcessedText();</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">	    for (int j = 0; j &lt; documents.elementAt(i).getSize(); j++) {</span>
<span class="nc" id="L59">		char letter = pt.elementAt(j);</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">		if (frequency.containsKey(letter)) {</span>
<span class="nc" id="L61">		    Integer t = (Integer)frequency.get(letter);</span>
<span class="nc" id="L62">		    int ti = t.intValue() + 1;</span>
<span class="nc" id="L63">		    frequency.put(letter, new Integer(ti));</span>
<span class="nc" id="L64">		}</span>
		else
<span class="nc" id="L66">		    frequency.put(letter, new Integer(1));</span>
	    }
	}
<span class="nc" id="L69">    }</span>


    /**Calculates the frequency of full  words within the entire 
     * set of documents.  Each word is a key in a hashtable with the value
     * being the frequency of occurrance. This is legacy code rewritten and was 
     * included for completeness.
     **/     
    public void wordFrequency() {
<span class="nc" id="L78">	frequency = new Hashtable();</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">	for (int i = 0; i &lt; documents.size(); i++) {</span>
<span class="nc" id="L80">	    String stDoc = documents.elementAt(i).stringify();</span>
<span class="nc" id="L81">	    StringTokenizer st = new StringTokenizer(stDoc, &quot; .,;:?!\&quot;&quot;);</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">	    while (st.hasMoreTokens()) {</span>
<span class="nc" id="L83">		String word = st.nextToken();</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">		if (frequency.containsKey(word)) {</span>
<span class="nc" id="L85">		    Integer t = (Integer)frequency.get(word);</span>
<span class="nc" id="L86">		    int ti = t.intValue() + 1;</span>
<span class="nc" id="L87">		    frequency.put(word, new Integer(ti));</span>
<span class="nc" id="L88">		}</span>
		else
<span class="nc" id="L90">		    frequency.put(word, new Integer(1));</span>
<span class="nc" id="L91">	    }</span>
	}
<span class="nc" id="L93">    }</span>

    /**Returns the top most common words in the document with the rest 
     * replaced with a placeholder.  This is also legacy code, rewritten, 
     * generalized, and replaced from the old code.  
     * Side Note:  This code should probably be moved to the EventSet class, 
     * along with the frequency analysis classes.  This will allow character
     * and word frequencies to be generalized to event frequencies, by returning
     * the N most common events, replacing the rest with a generic event.  
     **/
    public void mostCommon(int n) {
<span class="nc" id="L104">	Vector keys = new Vector();</span>
<span class="nc" id="L105">	Vector values = new Vector();</span>
<span class="nc" id="L106">	Vector&lt;kvp&gt; kvps = new Vector&lt;kvp&gt;();</span>
<span class="nc" id="L107">	Enumeration ekeys = frequency.keys();</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">	while (ekeys.hasMoreElements()) {</span>
<span class="nc" id="L109">	    Object temp = ekeys.nextElement();</span>
<span class="nc" id="L110">	    kvps.add(new kvp(temp,(Integer)frequency.get(temp)));</span>
<span class="nc" id="L111">	}</span>
 
<span class="nc" id="L113">	Collections.sort(kvps);</span>
<span class="nc" id="L114">	Collections.reverse(kvps);</span>

<span class="nc bnc" id="L116" title="All 2 branches missed.">	for (int i = 0; i &lt; n; i++) </span>
<span class="nc" id="L117">	    System.out.println(kvps.elementAt(i));</span>
	
<span class="nc" id="L119">    }</span>

}

/**kvp -&gt; key value pair.  This is a specific 
 * hashtable implementation for the frequency 
 * analysis portions of DocumentSet.mostCommon()
 **/
class kvp implements Comparable {
    Object key;
    int value;

<span class="nc" id="L131">    public kvp(Object key, Integer value) {</span>
<span class="nc" id="L132">	this.key = key;</span>
<span class="nc" id="L133">	this.value = value.intValue();</span>
<span class="nc" id="L134">    }</span>

    public int compareTo(Object ol) {
<span class="nc bnc" id="L137" title="All 2 branches missed.">	if (this.value == ((kvp)ol).value)</span>
<span class="nc" id="L138">	    return 0;</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">	else if (this.value &lt; ((kvp)ol).value)</span>
<span class="nc" id="L140">	    return -1;</span>
<span class="nc" id="L141">	else return 1;</span>
    }

    public String toString() {
<span class="nc" id="L145">	String t = new String();</span>
<span class="nc" id="L146">        t = value + &quot;:\t&quot; + key;</span>
<span class="nc" id="L147">	return  t;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>