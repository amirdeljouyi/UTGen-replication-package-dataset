<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConnectionBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">63_objectexplorer</a> &gt; <a href="index.source.html" class="el_package">de.paragon.explorer.util</a> &gt; <span class="el_source">ConnectionBuilder.java</span></div><h1>ConnectionBuilder.java</h1><pre class="source lang-java linenums">/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 * 
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 **/
package de.paragon.explorer.util;

import org.apache.log4j.Logger;

import de.paragon.explorer.figure.ExplorerFigure;
import de.paragon.explorer.figure.ExplorerFigureBuilder;
import de.paragon.explorer.figure.ListBoxFigure;
import de.paragon.explorer.figure.StandardConnectionFigure;
import de.paragon.explorer.figure.TextBoxFigure;
import de.paragon.explorer.gui.Warning;
import de.paragon.explorer.model.AttributeModel;
import de.paragon.explorer.model.ConnectionModel;
import de.paragon.explorer.model.ExplorerModel;
import de.paragon.explorer.model.ObjectHeaderModel;
import de.paragon.explorer.model.ObjectModel;

/**
 * Kommentar: Aufgrund der zum Zeitpunkt zu Beginn der Implementierung der
 * ConnectionFigures absehbaren, eingeschraenkten Funktionalitaet der
 * zugehoerigen Builder und Models wurde fuer ConnectionFigure und fuer
 * ConnectionModel zusammen nur ein Builder installiert.
 */
public final class ConnectionBuilder {
<span class="nc" id="L43">	private static final Logger			logger					= LoggerFactory.make();</span>
	private static final String			ERROR_WHILE_REMOVING	= &quot;connectionbuilder.error_while_removing&quot;;
	private static ConnectionBuilder	singleton;

	public static ConnectionBuilder getInstance() {
<span class="nc" id="L48">		return ConnectionBuilder.getSingleton();</span>
	}

	private static ConnectionBuilder getSingleton() {
<span class="nc bnc" id="L52" title="All 2 branches missed.">		if (ConnectionBuilder.singleton == null) {</span>
<span class="nc" id="L53">			ConnectionBuilder.setSingleton(new ConnectionBuilder());</span>
		}
<span class="nc" id="L55">		return ConnectionBuilder.singleton;</span>
	}

	private static void setSingleton(ConnectionBuilder builder) {
<span class="nc" id="L59">		ConnectionBuilder.singleton = builder;</span>
<span class="nc" id="L60">	}</span>

	private ConnectionBuilder() {
		super();
	}

	/**
	 * Kommentar: Das ObjectHeaderModel ist das Zielmodell. Das AttributeModel
	 * ist das StartModell. Die beiden Modelle haben also, falls das Attribute
	 * des Objects nicht auf sich selbst refernziert, kein gemeinsames
	 * ObjectModel. Diese Methode erzeugt ConnectionFigure und ConnectionModel,
	 * baut und zeichnet die ConnectionFigure. &quot;add&quot; heisst hier: erzeugen,
	 * bauen und zeichnen.
	 */
	public void addConnection(ObjectHeaderModel headerModel, AttributeModel attrModl) {
<span class="nc" id="L75">		ConnectionModel conModl = this.createNewConnection(headerModel, attrModl);</span>
<span class="nc" id="L76">		StandardConnectionFigure conFig = (StandardConnectionFigure) conModl.getFigure();</span>
<span class="nc" id="L77">		TextBoxFigure headerFig = (TextBoxFigure) headerModel.getFigure();</span>
<span class="nc" id="L78">		TextBoxFigure attrFig = (TextBoxFigure) attrModl.getFigure();</span>
<span class="nc" id="L79">		this.buildConnection(conFig, headerFig, attrFig);</span>
		// this.drawConnectionFigure(conFig);
<span class="nc" id="L81">	}</span>

	/**
	 * Kommentar: Die StandardConnectionFigure ist so konzipiert, dass sie
	 * anhand der beiden verbundenen Figuren alles weiss. Das bedeutet, beim
	 * Zeichnen ermittelt sie selbstaendig anhand der Figuren, wo und wie sie
	 * sich zu zeichnen hat. Daher bedeutet &quot;bauen&quot; lediglich das Zuweisen der
	 * Start- und Zielfigur. Weiter baut diese Methode gleichzeitig die
	 * entsprechenden Models: Das ConnectionModel erhaelt Referenzen auf das
	 * Attribute- und das ObjectHeaderModel, die jeweiligen ObjectModels dieser
	 * Models erhalten Referenzen auf die ConnectionFigure.
	 */
	private void buildConnection(StandardConnectionFigure conFig, TextBoxFigure headerFigure, TextBoxFigure attrFigure) {
<span class="nc" id="L94">		AttributeModel attrModl = (AttributeModel) attrFigure.getModel();</span>
<span class="nc" id="L95">		ObjectHeaderModel headModl = (ObjectHeaderModel) headerFigure.getModel();</span>
<span class="nc" id="L96">		conFig.setStartFigure(attrFigure);</span>
<span class="nc" id="L97">		conFig.setEndFigure(headerFigure);</span>
<span class="nc" id="L98">		(conFig.getModel()).setAttributeModel(attrModl);</span>
<span class="nc" id="L99">		(conFig.getModel()).setHeaderModel(headModl);</span>
<span class="nc" id="L100">		(attrModl.getObjectModel()).addConnectionModel(conFig.getModel());</span>
<span class="nc" id="L101">		(headModl.getObjectModel()).addConnectionModel(conFig.getModel());</span>
<span class="nc" id="L102">	}</span>

	/**
	 * Kommentar: Diese Methode erzeugt ein neues ConnectionModel und eine neue
	 * StandardConnectionFigure. Danach werden alle Verknuepfungen
	 * gemacht:ConnectionModel mit ExplorerModel, die Zuweisung von HeaderModel
	 * und AttributeModel zum ConnectionModel, die Verknuepfung ConnectionModel
	 * mit ConnectionFigure und ConnectionFigure mit ExplorerFigure. Zu Beachten
	 * gilt: addConnectionFigure erledigt hier lediglich nur die Verknuepfung
	 * zwischen den Figuren, im Gegensatz dazu steht ja das add in der Methode
	 * addConnectionFigure fuer erzeugen, bauen und verknuepfen.
	 * 
	 * @param headerModel
	 *            ObjectHeaderModel
	 * @param attrModl
	 *            AttributeModel
	 * 
	 * @return ConnectionModel
	 */
	private ConnectionModel createNewConnection(ObjectHeaderModel headerModel, AttributeModel attrModl) {
<span class="nc" id="L122">		ExplorerFigure explFig = this.getExplorerFigureFor(headerModel);</span>
<span class="nc" id="L123">		ConnectionModel conModl = new ConnectionModel();</span>
<span class="nc" id="L124">		StandardConnectionFigure conFig = new StandardConnectionFigure();</span>
<span class="nc" id="L125">		attrModl.setConnectionModel(conModl);</span>
<span class="nc" id="L126">		conModl.setFigure(conFig);</span>
<span class="nc" id="L127">		conFig.setModel(conModl);</span>
<span class="nc" id="L128">		conModl.setHeaderModel(headerModel);</span>
<span class="nc" id="L129">		conModl.setAttributeModel(attrModl);</span>
<span class="nc" id="L130">		conModl.setExplorerModel((ExplorerModel) explFig.getModel());</span>
<span class="nc" id="L131">		this.getExplorerFigureBuilder().addConnectionFigure(conFig, explFig);</span>
<span class="nc" id="L132">		return conModl;</span>
	}

	private void drawInForeground(StandardConnectionFigure conFig) {
<span class="nc" id="L136">		this.getExplorerFigureBuilder().setInForeground(conFig);</span>
		// this.drawConnectionFigure(conFig);
<span class="nc" id="L138">	}</span>

	/**
	 * Kommentar: Diese Methode geht davon aus, dass zwei zu verbindende Figuren
	 * mit ihren Models -sprich eine TextBoxFigure und eine ListBoxFigure-
	 * existieren und im Vordergrund gezeichnet sind. Sie soll herausfinden, ob
	 * eine derartige ConnectionFigure mit ihrem Model bereits existiert. Anhand
	 * der ListBoxFigure werden zunaechst alle ConnectionModels ausfindig
	 * gemacht, die zur List-BoxFigure zeigen oder von ihr weg zeigen. Alle
	 * diese werden durchsucht, ob das Attribute-Model des ConnectionModels mit
	 * dem Model der TextBoxFigure und das HeaderModel des Connection-Models mit
	 * dem HeaderModel der ListBoxFigure uebereinstimmt. Dieses wird dann der
	 * Rueckgabevariablen zugewiesen. Wird keines gefunden, wird also null
	 * zurueckgegeben.
	 * 
	 * @param teBoFi
	 *            TextBoxFigure
	 * @param liBoFi
	 *            ListBoxFigure
	 * 
	 * @return StandardConnectionFigure
	 */
	private StandardConnectionFigure getConnectionFigureToShow(TextBoxFigure teBoFi, ListBoxFigure liBoFi) {
		StandardEnumeration enumeration;
<span class="nc" id="L162">		ObjectModel objModl = (ObjectModel) liBoFi.getModel();</span>
<span class="nc" id="L163">		StandardConnectionFigure conFigToShow = null;</span>
		ConnectionModel tempConModl;
<span class="nc" id="L165">		enumeration = objModl.getConnectionModels();</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">		while (enumeration.hasMoreElements()) {</span>
<span class="nc" id="L167">			tempConModl = (ConnectionModel) enumeration.nextElement();</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">			if (tempConModl.getAttributeModel() == (AttributeModel) teBoFi.getModel()) {</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">				if (tempConModl.getHeaderModel() == ((ObjectModel) liBoFi.getModel()).getHeaderModel()) {</span>
<span class="nc" id="L170">					conFigToShow = (StandardConnectionFigure) tempConModl.getFigure();</span>
				}
			}
		}
<span class="nc" id="L174">		return conFigToShow;</span>
	}

	private ExplorerFigureBuilder getExplorerFigureBuilder() {
<span class="nc" id="L178">		return ExplorerFigureBuilder.getInstance();</span>
	}

	private ExplorerFigure getExplorerFigureFor(ObjectHeaderModel headModl) {
<span class="nc" id="L182">		return (ExplorerFigure) headModl.getObjectModel().getExplorerModel().getFigure();</span>
	}

	/**
	 * Kommentar: Diese Methode geht davon aus, dass das objectModel und die
	 * zugehoerige ListBoxFigure geloescht, das heisst, aus ihren jeweiligen
	 * Containern entfernt sind. Sie entfernt das ConnectionModel vom
	 * AttributeModel, von dem es aus eine Referenz zeigte, und aus den Listen
	 * der beiden Objektmodelle, von dem bzw.zu dem das ConnectionModel zeigte.
	 */
	public void removeConnections(ObjectModel objModl) {
<span class="nc" id="L193">		StandardEnumeration conModls = objModl.getConnectionModels();</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">		while (conModls.hasMoreElements()) {</span>
<span class="nc" id="L195">			ConnectionModel tempConModl = (ConnectionModel) conModls.nextElement();</span>
<span class="nc" id="L196">			this.removeFromObjectModels(tempConModl);</span>
<span class="nc" id="L197">			this.removeFromAttributeModel(tempConModl);</span>
<span class="nc" id="L198">		}</span>
<span class="nc" id="L199">	}</span>

	/**
	 * Kommentar: Fuer den Fall, dass eine komplette ListBoxFigure geloescht
	 * werden soll, geht diese Methode davon aus, dass das objectModel und die
	 * zugehoerige ListBoxFigure geloescht, das heisst, aus ihren jeweiligen
	 * Containern entfernt sind. Eine Referenz von den beiden ObjectModels, auf
	 * die gezeigt wird und von denen gezeigt wird, exi- stiert ebenfalls nicht
	 * mehr. Fuer den Fall, dass eine Connection geloescht werden soll, geht
	 * diese Methode davon aus, dass eine Referenz von den beiden ObjectModels,
	 * auf die gezeigt wird und von denen gezeigt wird, nicht mehr existiert.
	 * Sie setzt die Referenz des Attributmodells zum Connectionmodell auf null
	 * und entfernt die zugehoerige ConnectionFigure aus dem figureStore der
	 * ExplorerFigure.
	 */
	private void removeFromAttributeModel(ConnectionModel conModl) {
<span class="nc" id="L215">		conModl.getAttributeModel().setConnectionModel(null);</span>
		try {
<span class="nc bnc" id="L217" title="All 2 branches missed.">			if (conModl.getFigure().getParent() != null) {</span>
<span class="nc" id="L218">				conModl.getFigure().getParent().remove(conModl.getFigure());</span>
			}
		}
<span class="nc" id="L221">		catch (Exception ex) {</span>
<span class="nc" id="L222">			ConnectionBuilder.logger.error(ResourceBundlePurchaser.getMessage(ConnectionBuilder.ERROR_WHILE_REMOVING), ex);</span>
<span class="nc" id="L223">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ConnectionBuilder.ERROR_WHILE_REMOVING));</span>
<span class="nc" id="L224">		}</span>
<span class="nc" id="L225">	}</span>

	/**
	 * Kommentar: Im Falle, dass diese Methode zum Loeschen einer ListBoxFigure
	 * aufgerufen wird, geht diese Methode davon aus, dass das objectModel und
	 * die zugehoerige ListBoxFigure geloescht, das heisst, aus ihren jeweiligen
	 * Containern entfernt sind. Weiter besteht keine Referenz mehr vom
	 * ExplorerModel und von der ExplorerFigure auf die Connection. Im Falle,
	 * dass diese Methode zum Loeschen einer einzelnen Connection aufgerufen
	 * wird, geht diese Methode davon aus, dass noch alle Beziehungen
	 * existieren. Diese Methode entfernt die Referenzen von den ObjectModels,
	 * von denen die Connection ausgeht oder auf die die Connection zeigt, auf
	 * die Connection.
	 */
	private void removeFromObjectModels(ConnectionModel conModl) {
<span class="nc" id="L240">		StandardConnectionFigure conFig = (StandardConnectionFigure) conModl.getFigure();</span>
		ListBoxFigure liBoFi;
<span class="nc" id="L242">		liBoFi = (ListBoxFigure) conFig.getStartFigure().getParent();</span>
<span class="nc" id="L243">		((ObjectModel) liBoFi.getModel()).removeConnectionModel(conModl);</span>
<span class="nc" id="L244">		liBoFi = (ListBoxFigure) conFig.getEndFigure().getParent();</span>
<span class="nc" id="L245">		((ObjectModel) liBoFi.getModel()).removeConnectionModel(conModl);</span>
<span class="nc" id="L246">	}</span>

	/**
	 * Kommentar: Diese Methode geht davon aus, dass noch nichts geloescht
	 * worden ist. Sie geht so vor, dass sie zunaechst die Referenzen aus den
	 * ObjectModels loescht, und dann aus dem AttributeModel, von dem die
	 * Connection aus die Referenz zeigte.
	 */
	public void removeSingleConnection(AttributeModel attrModl) {
<span class="nc bnc" id="L255" title="All 2 branches missed.">		if (attrModl.getConnectionModel() != null) {</span>
<span class="nc" id="L256">			this.removeFromObjectModels(attrModl.getConnectionModel());</span>
<span class="nc" id="L257">			this.removeFromAttributeModel(attrModl.getConnectionModel());</span>
		}
<span class="nc" id="L259">	}</span>

	/**
	 * Kommentar: Diese Methode geht davon aus, dass die TextBox- Figure mit
	 * einem AttributModel verknuepft ist. Weiter geht sie davon aus, dass eine
	 * zu referenzierende ListBoxFigure existiert, und im Vordergrund gezeichnet
	 * worden ist. Die ConnectionFigure muss noch gezeigt werden. Diese Methode
	 * ueberprueft zunaechst, ob eine entsprechende ConnectionFigure ueberhaupt
	 * existiert. Existiert sie, braucht sie lediglich in den Vordergrund
	 * gezeichnet werden. Existiert sie nicht, muss sie neu hinzugefuegt (&quot;add&quot;)
	 * werden.
	 */
	public void showConnection(TextBoxFigure teBoFi, ListBoxFigure liBoFi) {
<span class="nc" id="L272">		StandardConnectionFigure conFig = this.getConnectionFigureToShow(teBoFi, liBoFi);</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">		if (conFig == null) {</span>
<span class="nc" id="L274">			ObjectHeaderModel objHead = ((ObjectModel) liBoFi.getModel()).getHeaderModel();</span>
<span class="nc" id="L275">			this.addConnection(objHead, (AttributeModel) teBoFi.getModel());</span>
<span class="nc" id="L276">		}</span>
		else {
<span class="nc" id="L278">			this.drawInForeground(conFig);</span>
		}
<span class="nc" id="L280">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>