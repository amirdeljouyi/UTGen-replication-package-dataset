<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ListBoxFigureBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">63_objectexplorer</a> &gt; <a href="index.source.html" class="el_package">de.paragon.explorer.figure</a> &gt; <span class="el_source">ListBoxFigureBuilder.java</span></div><h1>ListBoxFigureBuilder.java</h1><pre class="source lang-java linenums">/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 * 
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 **/
package de.paragon.explorer.figure;

import java.lang.reflect.Modifier;
import java.util.Enumeration;

import org.apache.log4j.Logger;

import de.paragon.explorer.gui.Warning;
import de.paragon.explorer.model.AttributeModel;
import de.paragon.explorer.model.NullObject;
import de.paragon.explorer.model.ObjectHeaderModel;
import de.paragon.explorer.model.ObjectModel;
import de.paragon.explorer.model.ObjectModelPart;
import de.paragon.explorer.util.LoggerFactory;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;

public final class ListBoxFigureBuilder {
	private static final String			ERROR_WHILE_UPDATING_FIGURES					= &quot;listboxfigurebuilder.error_while_updating_figures&quot;;
	private static final String			ERROR_WHILE_GETTING_FIGURES						= &quot;listboxfigurebuilder.error_while_getting_figures&quot;;
	private static final String			ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE		= &quot;listboxfigurebuilder.error_while_setting_all_attributes_visible&quot;;
	private static final String			ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE	= &quot;listboxfigurebuilder.error_while_setting_all_attributes_unvisible&quot;;
	private static final String			ERROR_WHILE_INIT_MODELL							= &quot;listboxfigurebuilder.error_while_init_modell&quot;;
	private static final String			ERROR_WHILE_BUILDING_MODELL						= &quot;listboxfigurebuilder.error_while_building_modell&quot;;
	private static final String			ERROR_WHILE_BUILDING_LISTBOXFIGURE				= &quot;listboxfigurebuilder.error_while_building_listboxfigure&quot;;
<span class="nc" id="L45">	private static final Logger			logger											= LoggerFactory.make();</span>
	private static ListBoxFigureBuilder	singleton;

	public static ListBoxFigureBuilder getInstance() {
<span class="nc" id="L49">		return ListBoxFigureBuilder.getSingleton();</span>
	}

	private static ListBoxFigureBuilder getSingleton() {
<span class="nc bnc" id="L53" title="All 2 branches missed.">		if (ListBoxFigureBuilder.singleton == null) {</span>
<span class="nc" id="L54">			ListBoxFigureBuilder.setSingleton(new ListBoxFigureBuilder());</span>
		}
<span class="nc" id="L56">		return ListBoxFigureBuilder.singleton;</span>
	}

	private static void setSingleton(ListBoxFigureBuilder builder) {
<span class="nc" id="L60">		ListBoxFigureBuilder.singleton = builder;</span>
<span class="nc" id="L61">	}</span>

	private ListBoxFigureBuilder() {
		super();
	}

	protected void addTextBoxFigure(TextBoxFigure teBoFi) {
		try {
<span class="nc" id="L69">			((ObjectModelPart) teBoFi.getModel()).getObjectModel().getFigure().add(teBoFi);</span>
		}
<span class="nc" id="L71">		catch (Exception ex) {</span>
<span class="nc" id="L72">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_LISTBOXFIGURE), ex);</span>
<span class="nc" id="L73">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_LISTBOXFIGURE));</span>
<span class="nc" id="L74">		}</span>
<span class="nc" id="L75">	}</span>

	/**
	 * Kommentar: Diese Methode geht davon aus, dass die TextBoxFigure, die mit
	 * dem HeaderModel verknuepft ist, fertig ist. Anhand dessen bestimmt sie
	 * die Groesse der FilledRectangleFigure, die als Unterstrich fuer die
	 * Header-TextBoxFigure dient, und fuegt sie der ListBoxFigure hinzu.
	 */
	protected void buildHeaderUnderline(ObjectModel objModl) {
<span class="nc" id="L84">		TextBoxFigure teBoFig = (TextBoxFigure) objModl.getHeaderModel().getFigure();</span>
<span class="nc" id="L85">		int width = this.getFigureWidth(teBoFig);</span>
		// int height = this.getFigureHeight(teBoFig) / 5;
<span class="nc" id="L87">		int height = 1;</span>
<span class="nc" id="L88">		int y = 0, x = 0;</span>
		try {
<span class="nc" id="L90">			objModl.getFigure().add(new FilledRectangleFigure(x, y, width, height));</span>
		}
<span class="nc" id="L92">		catch (Exception ex) {</span>
<span class="nc" id="L93">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL), ex);</span>
<span class="nc" id="L94">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL));</span>
<span class="nc" id="L95">		}</span>
<span class="nc" id="L96">	}</span>

	/**
	 * Kommentar: Zunaechst wird fuer jedes TeilModel eine TextBoxFigure erzeugt
	 * und mit ihrem jeweiligen Model (Header- bzw. AttributeModel) verknuepft.
	 * Diese Methode geht davon aus, dass fuer das ObjectModel bereits
	 * HeaderModels und AttributeModels in dem Object angepasster Anzahl
	 * existieren. Dann wird jeder TextBoxFigure ein entsprechender String
	 * zugewiesen. Anschliessend wird zunaechst die soeben erzeugte
	 * TextBoxFigure fuer das HeaderModel gebaut, was die Bestimmung der Groesse
	 * bedeutet, und mit der ListBoxFigure, die auch die ExplorerFigure kennt,
	 * die die Graphics kennt, verknuepft. Danach wird eine neue
	 * FilledRectangleFigure erzeugt und mit der ListBoxFigure verknuepft.
	 * Danach wird jede der mit einem AttributModel verknuepften TextBoxFiguren
	 * gebaut und mit der ListBoxFigure verknuepft. Danach wird die
	 * ListBoxFigure fertiggebaut.
	 */
	public void buildListBoxFigure(ObjectModel objModl) {
<span class="nc" id="L114">		ListBoxFigure liBoFi = (ListBoxFigure) objModl.getFigure();</span>
<span class="nc" id="L115">		this.getTextBoxFigureBuilder().createTextBoxFigures(objModl);</span>
<span class="nc" id="L116">		this.initializeListBoxFigure(liBoFi);</span>
<span class="nc" id="L117">	}</span>

	/**
	 * Kommentar: Diese Methode geht davon aus, dass alle Verknuepfungen bereits
	 * existieren und die Teilfiguren -jede fuer sich- gebaut sind. Sie
	 * ermittelt die Weite der ListBoxFigure. Dabei geht sie so vor: Falls die
	 * Figur &quot;visible&quot; ist, geht sie in die Berechnung mit ein. Am Ende ist die
	 * Weite der ListBoxFigure das Maximum aller Weiten der sichtbaren
	 * TextBoxFiguren.
	 * 
	 * @return int
	 */
	private int computeListBoxFigureWidth(ListBoxFigure list) {
		/* damn the class Rectangle for having no get method for the width! */
<span class="nc" id="L131">		ObjectHeaderModel headModl = ((ObjectModel) list.getModel()).getHeaderModel();</span>
<span class="nc" id="L132">		StandardEnumeration attrModls = ((ObjectModel) list.getModel()).getAttributeModels();</span>
		AttributeModel tempModel;
<span class="nc" id="L134">		int x = this.getFigureWidth(headModl.getFigure());</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">		while (attrModls.hasMoreElements()) {</span>
<span class="nc" id="L136">			tempModel = (AttributeModel) attrModls.nextElement();</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">			if (((TextBoxFigure) tempModel.getFigure()).isVisible()) {</span>
<span class="nc" id="L138">				x = Math.max(this.getFigureWidth(tempModel.getFigure()), x);</span>
			}
		}
<span class="nc" id="L141">		return x;</span>
	}

	public void createNewListBoxFigure(ObjectModel objModl) {
<span class="nc" id="L145">		ExplorerFieldListBoxFigure exFiLiBoFi = new ExplorerFieldListBoxFigure();</span>
<span class="nc" id="L146">		objModl.setFigure(exFiLiBoFi);</span>
<span class="nc" id="L147">		exFiLiBoFi.setModel(objModl);</span>
<span class="nc" id="L148">		this.getExplorerFigureBuilder().addListBoxFigure(exFiLiBoFi);</span>
<span class="nc" id="L149">	}</span>

	/**
	 * Kommentar: Diese Methode geht davon aus, dass das ObjectModel bereits mit
	 * einem ExplorerModel verknuepft ist. Das ExplorerModel seinerseits ist
	 * bereits mit einer ExplorerFigure verknuepft. Diese Methode erzeugt eine
	 * neue ListBoxFigure und verknuepft sie mit dem ObjectModel. Anschliessend
	 * laesst sie die neue ListBoxFigure mit der ExplorerFigure verknuepfen, um
	 * den Kreis zu schliessen.
	 */
	public void createNewListBoxFigure(ObjectModel objModl, TextBoxFigure tbf) {
<span class="nc" id="L160">		ExplorerFieldListBoxFigure exFiLiBoFi = new ExplorerFieldListBoxFigure();</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">		if (tbf.getParent() instanceof ExplorerFieldListBoxFigure) {</span>
<span class="nc" id="L162">			((ExplorerFieldListBoxFigure) tbf.getParent()).addChild(exFiLiBoFi);</span>
		}
<span class="nc" id="L164">		objModl.setFigure(exFiLiBoFi);</span>
<span class="nc" id="L165">		exFiLiBoFi.setModel(objModl);</span>
<span class="nc" id="L166">		this.getExplorerFigureBuilder().addListBoxFigure(exFiLiBoFi);</span>
<span class="nc" id="L167">	}</span>

	private ExplorerFigureBuilder getExplorerFigureBuilder() {
<span class="nc" id="L170">		return ExplorerFigureBuilder.getInstance();</span>
	}

	private int getFigureHeight(Figure figure) {
<span class="nc" id="L174">		int tempHeight = 0;</span>
		try {
<span class="nc" id="L176">			tempHeight = figure.getDisplayBox().getRectangle().height;</span>
		}
<span class="nc" id="L178">		catch (Exception ex) {</span>
<span class="nc" id="L179">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL), ex);</span>
<span class="nc" id="L180">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL));</span>
<span class="nc" id="L181">		}</span>
<span class="nc" id="L182">		return tempHeight;</span>
	}

	private int getFigureWidth(Figure figure) {
<span class="nc" id="L186">		int tempWidth = 0;</span>
		try {
<span class="nc" id="L188">			tempWidth = figure.getDisplayBox().getRectangle().width;</span>
		}
<span class="nc" id="L190">		catch (Exception ex) {</span>
<span class="nc" id="L191">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL), ex);</span>
<span class="nc" id="L192">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL));</span>
<span class="nc" id="L193">		}</span>
<span class="nc" id="L194">		return tempWidth;</span>
	}

	private TextBoxFigureBuilder getTextBoxFigureBuilder() {
<span class="nc" id="L198">		return TextBoxFigureBuilder.getInstance();</span>
	}

	/**
	 * Kommentar: Diese Methode geht davon aus, dass saemtliche Verknuepfungen
	 * zwischen Models und Figures existieren, und dass die Text- BoxFigures
	 * jede fuer sich selbst gebaut sind. Diese Methode bestimmt die
	 * DisplayBoxen der Teilfiguren neu. Das heisst, sie ermittelt und setzt die
	 * Position der Teilfigur innerhalb der ListBoxFigure, und sie ermittelt die
	 * Weite der ListBoxFigure und setzt diese in allen Teilfiguren und der
	 * ListBoxFigure selbst. Bei der Emitt- lung der Weite wird die Angabe
	 * &quot;visible&quot; beruecksichtigt. Anschliessend positioniert sie die
	 * ListBoxFigure in der ExplorerFigure, wieder abhaengig von &quot;visible&quot;.
	 */
	public void initializeListBoxFigure(ListBoxFigure liBoFi) {
<span class="nc" id="L213">		this.setListBoxFigureWidths(liBoFi, this.computeListBoxFigureWidth(liBoFi));</span>
		StandardEnumeration figParts;
		try {
<span class="nc" id="L216">			figParts = liBoFi.getFigures();</span>
		}
<span class="nc" id="L218">		catch (Exception ex) {</span>
<span class="nc" id="L219">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_INIT_MODELL), ex);</span>
<span class="nc" id="L220">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_INIT_MODELL));</span>
<span class="nc" id="L221">			figParts = null;</span>
<span class="nc" id="L222">		}</span>
<span class="nc" id="L223">		this.setFigureHeight(liBoFi, 0);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">		if (figParts != null) {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">			while (figParts.hasMoreElements()) {</span>
<span class="nc" id="L226">				RectangleFigure tempFig = (RectangleFigure) figParts.nextElement();</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">				if (tempFig.isVisible()) {</span>
					try {
<span class="nc" id="L229">						tempFig.moveBy(0, this.getFigureHeight(liBoFi));</span>
					}
<span class="nc" id="L231">					catch (Exception ex) {</span>
<span class="nc" id="L232">						ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_INIT_MODELL), ex);</span>
<span class="nc" id="L233">						Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_INIT_MODELL));</span>
<span class="nc" id="L234">					}</span>
<span class="nc" id="L235">					this.setFigureHeight(liBoFi, this.getFigureHeight(liBoFi) + this.getFigureHeight(tempFig));</span>
				}
<span class="nc" id="L237">			}</span>
		}
<span class="nc" id="L239">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind, auf unvisible
	 * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0
	 * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure
	 * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann
	 * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der
	 * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt
	 * wird. Also wird die TextBoxFigure wieder um die Position der
	 * ListBoxFigure verschoben.
	 */
	public void setAllAttributesUnvisible(ListBoxFigure liBoFi) {
		ObjectModel objModl;
		StandardEnumeration parts;
		TextBoxFigure teBoFi;
		AttributeModel attrModl;
		RectangleFigure liBoFiPart;
<span class="nc" id="L258">		objModl = (ObjectModel) liBoFi.getModel();</span>
<span class="nc" id="L259">		objModl.getObjectViewManager().setAllAttributesVisible(false);</span>
		// objModl.getObjectViewManager().setNullAttributesVisible(false);
		// objModl.getObjectViewManager().setStaticAttributesVisible(false);
		// objModl.getObjectViewManager().setUnexploredAttributesVisible(false);
<span class="nc" id="L263">		parts = objModl.getAttributeModels();</span>
		try {
			// Hier werden alle Attribute unsichtbar gesetzt.
<span class="nc bnc" id="L266" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L267">				attrModl = (AttributeModel) parts.nextElement();</span>
<span class="nc" id="L268">				((TextBoxFigure) attrModl.getFigure()).setUnvisible();</span>
			}
			// Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die
			// Positionen gleich der Position der ListBoxFigure.
			// Hierzu bekommt parts eine neue Zuweisung.
<span class="nc" id="L273">			parts = liBoFi.getFigures();</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L275">				liBoFiPart = (RectangleFigure) parts.nextElement();</span>
<span class="nc" id="L276">				liBoFiPart.getBounds().width = 0;</span>
<span class="nc" id="L277">				liBoFiPart.getBounds().x = liBoFi.getBounds().x;</span>
<span class="nc" id="L278">				liBoFiPart.getBounds().y = liBoFi.getBounds().y;</span>
			}
			// Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.
			// Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0
			// gesetzt wird. Daher werden die Figuren anschliessend um die Posi-
			// tion der ListBoxFigure verschoben.
			// Da in der folgenden NeuBerechnung die FilledRectangularBox nicht
			// mitberuecksichtigt wird, war es oben noetig, die Position aller
			// TeilFiguren auf die der ListBoxFigure zu setzten.
			// Es wird mit der TextBoxFigure des HeaderModels begonnen.
<span class="nc" id="L288">			teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();</span>
<span class="nc" id="L289">			teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L290">			teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			// Jetzt kommen die TextBoxFigures der AttributeModels dran.
<span class="nc" id="L292">			parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L294">				teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();</span>
<span class="nc" id="L295">				teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L296">				teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			}
		}
<span class="nc" id="L299">		catch (Exception ex) {</span>
<span class="nc" id="L300">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE), ex);</span>
<span class="nc" id="L301">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE));</span>
<span class="nc" id="L302">		}</span>
<span class="nc" id="L303">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind, auf visible
	 * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0
	 * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure
	 * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann
	 * folgendes: Die DisplayBox wird erneut berechnet. Die Berechnung der
	 * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt
	 * wird. Also wird die TextBoxFigure wieder um die Position der
	 * ListBoxFigure verschoben.
	 */
	public void setAllAttributesVisible(ListBoxFigure liBoFi) {
		ObjectModel objModl;
		StandardEnumeration parts;
		TextBoxFigure teBoFi;
		AttributeModel attrModl;
		RectangleFigure liBoFiPart;
<span class="nc" id="L322">		objModl = (ObjectModel) liBoFi.getModel();</span>
<span class="nc" id="L323">		objModl.getObjectViewManager().setAllAttributesVisible(true);</span>
		// objModl.getObjectViewManager().setNullAttributesVisible(true);
		// objModl.getObjectViewManager().setStaticAttributesVisible(true);
		// objModl.getObjectViewManager().setUnexploredAttributesVisible(true);
<span class="nc" id="L327">		parts = objModl.getAttributeModels();</span>
		try {
			// Hier werden alle Attribute sichtbar gesetzt.
<span class="nc bnc" id="L330" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L331">				attrModl = (AttributeModel) parts.nextElement();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">				if (objModl.getObjectViewManager().shouldBeVisible(attrModl)) {</span>
<span class="nc" id="L333">					((TextBoxFigure) attrModl.getFigure()).setVisible();</span>
				}
			}
			// Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die
			// Positionen gleich der Position der ListBoxFigure.
			// Hierzu bekommt parts eine neue Zuweisung.
<span class="nc" id="L339">			parts = liBoFi.getFigures();</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L341">				liBoFiPart = (RectangleFigure) parts.nextElement();</span>
<span class="nc" id="L342">				liBoFiPart.getBounds().width = 0;</span>
<span class="nc" id="L343">				liBoFiPart.getBounds().x = liBoFi.getBounds().x;</span>
<span class="nc" id="L344">				liBoFiPart.getBounds().y = liBoFi.getBounds().y;</span>
			}
			// Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.
			// Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0
			// gesetzt wird. Daher werden die Figuren anschliessend um die Posi-
			// tion der ListBoxFigure verschoben.
			// Da in der folgenden NeuBerechnung die FilledRectangularBox nicht
			// mitberuecksichtigt wird, war es oben noetig, die Position aller
			// TeilFiguren auf die der ListBoxFigure zu setzten.
			// Es wird mit der TextBoxFigure des HeaderModels begonnen.
<span class="nc" id="L354">			teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();</span>
<span class="nc" id="L355">			teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L356">			teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			// Jetzt kommen die TextBoxFigures der AttributeModels dran.
<span class="nc" id="L358">			parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L360">				teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();</span>
<span class="nc" id="L361">				teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L362">				teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			}
		}
<span class="nc" id="L365">		catch (Exception ex) {</span>
<span class="nc" id="L366">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE), ex);</span>
<span class="nc" id="L367">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE));</span>
<span class="nc" id="L368">		}</span>
<span class="nc" id="L369">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind und die kein
	 * ConnectionModel haben, auf unvisible gesetzt. Dann wird die Weite von
	 * allen Teilen der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden
	 * gleich dem Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die
	 * TextBoxFigure sind, geschieht dann folgendes: Die DisplayBox wird erneut
	 * berechnet. Die Be- rechnung der DisplayBox hat zur Folge, dass der Ort
	 * der Figure wieder auf 0,0 gesetzt wird. Also wird die TextBoxFigure
	 * wieder um die Position der ListBoxFigure verschoben.
	 */
	public void setAllUnexploredAttributesUnvisible(ListBoxFigure liBoFi) {
		ObjectModel objModl;
		StandardEnumeration parts;
		TextBoxFigure teBoFi;
		AttributeModel attrModl;
		RectangleFigure liBoFiPart;
<span class="nc" id="L388">		objModl = (ObjectModel) liBoFi.getModel();</span>
<span class="nc" id="L389">		objModl.getObjectViewManager().setUnexploredAttributesVisible(false);</span>
<span class="nc" id="L390">		parts = objModl.getAttributeModels();</span>
		try {
			// Hier werden alle Attribute, die nicht explored sind, unsichtbar
			// gesetzt.
<span class="nc bnc" id="L394" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L395">				attrModl = (AttributeModel) parts.nextElement();</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">				if (attrModl.getConnectionModel() == null) {</span>
<span class="nc" id="L397">					((TextBoxFigure) attrModl.getFigure()).setUnvisible();</span>
				}
			}
			// Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die
			// Positionen gleich der Position der ListBoxFigure.
			// Hierzu bekommt parts eine neue Zuweisung.
<span class="nc" id="L403">			parts = liBoFi.getFigures();</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L405">				liBoFiPart = (RectangleFigure) parts.nextElement();</span>
<span class="nc" id="L406">				liBoFiPart.getBounds().width = 0;</span>
<span class="nc" id="L407">				liBoFiPart.getBounds().x = liBoFi.getBounds().x;</span>
<span class="nc" id="L408">				liBoFiPart.getBounds().y = liBoFi.getBounds().y;</span>
			}
			// Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.
			// Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0
			// gesetzt wird. Daher werden die Figuren anschliessend um die Posi-
			// tion der ListBoxFigure verschoben.
			// Da in der folgenden NeuBerechnung die FilledRectangularBox nicht
			// mitberuecksichtigt wird, war es oben noetig, die Position aller
			// TeilFiguren auf die der ListBoxFigure zu setzten.
			// Es wird mit der TextBoxFigure des HeaderModels begonnen.
<span class="nc" id="L418">			teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();</span>
<span class="nc" id="L419">			teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L420">			teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			// Jetzt kommen die TextBoxFigures der AttributeModels dran.
<span class="nc" id="L422">			parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L424">				teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();</span>
<span class="nc" id="L425">				teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L426">				teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			}
		}
<span class="nc" id="L429">		catch (Exception ex) {</span>
<span class="nc" id="L430">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE), ex);</span>
<span class="nc" id="L431">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE));</span>
<span class="nc" id="L432">		}</span>
<span class="nc" id="L433">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind und die kein
	 * ConnectionModel haben, auf unvisible gesetzt. Dann wird die Weite von
	 * allen Teilen der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden
	 * gleich dem Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die
	 * TextBoxFigure sind, geschieht dann folgendes: Die DisplayBox wird erneut
	 * berechnet. Die Be- rechnung der DisplayBox hat zur Folge, dass der Ort
	 * der Figure wieder auf 0,0 gesetzt wird. Also wird die TextBoxFigure
	 * wieder um die Position der ListBoxFigure verschoben.
	 */
	public void setAllUnexploredAttributesVisible(ListBoxFigure liBoFi) {
		ObjectModel objModl;
		de.paragon.explorer.util.StandardEnumeration parts;
		TextBoxFigure teBoFi;
		AttributeModel attrModl;
		RectangleFigure liBoFiPart;
<span class="nc" id="L452">		objModl = (ObjectModel) liBoFi.getModel();</span>
<span class="nc" id="L453">		objModl.getObjectViewManager().setUnexploredAttributesVisible(true);</span>
<span class="nc" id="L454">		parts = objModl.getAttributeModels();</span>
		try {
			// Hier werden alle Attribute, die nicht explored sind, unsichtbar
			// gesetzt.
<span class="nc bnc" id="L458" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L459">				attrModl = (AttributeModel) parts.nextElement();</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">				if (objModl.getObjectViewManager().shouldBeVisible(attrModl)) {</span>
<span class="nc" id="L461">					((TextBoxFigure) attrModl.getFigure()).setVisible();</span>
				}
			}
			// Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die
			// Positionen gleich der Position der ListBoxFigure.
			// Hierzu bekommt parts eine neue Zuweisung.
<span class="nc" id="L467">			parts = liBoFi.getFigures();</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L469">				liBoFiPart = (RectangleFigure) parts.nextElement();</span>
<span class="nc" id="L470">				liBoFiPart.getBounds().width = 0;</span>
<span class="nc" id="L471">				liBoFiPart.getBounds().x = liBoFi.getBounds().x;</span>
<span class="nc" id="L472">				liBoFiPart.getBounds().y = liBoFi.getBounds().y;</span>
			}
			// Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.
			// Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0
			// gesetzt wird. Daher werden die Figuren anschliessend um die Posi-
			// tion der ListBoxFigure verschoben.
			// Da in der folgenden NeuBerechnung die FilledRectangularBox nicht
			// mitberuecksichtigt wird, war es oben noetig, die Position aller
			// TeilFiguren auf die der ListBoxFigure zu setzten.
			// Es wird mit der TextBoxFigure des HeaderModels begonnen.
<span class="nc" id="L482">			teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();</span>
<span class="nc" id="L483">			teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L484">			teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			// Jetzt kommen die TextBoxFigures der AttributeModels dran.
<span class="nc" id="L486">			parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L488">				teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();</span>
<span class="nc" id="L489">				teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L490">				teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			}
		}
<span class="nc" id="L493">		catch (Exception ex) {</span>
<span class="nc" id="L494">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE), ex);</span>
<span class="nc" id="L495">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE));</span>
<span class="nc" id="L496">		}</span>
<span class="nc" id="L497">	}</span>

	private void setFigureHeight(Figure figure, int y) {
		try {
<span class="nc" id="L501">			figure.getDisplayBox().getRectangle().height = y;</span>
		}
<span class="nc" id="L503">		catch (Exception ex) {</span>
<span class="nc" id="L504">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL), ex);</span>
<span class="nc" id="L505">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL));</span>
<span class="nc" id="L506">		}</span>
<span class="nc" id="L507">	}</span>

	private void setFigureWidth(Figure figure, int x) {
		try {
<span class="nc" id="L511">			figure.getDisplayBox().getRectangle().width = x;</span>
		}
<span class="nc" id="L513">		catch (Exception ex) {</span>
<span class="nc" id="L514">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL), ex);</span>
<span class="nc" id="L515">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_BUILDING_MODELL));</span>
<span class="nc" id="L516">		}</span>
<span class="nc" id="L517">	}</span>

	/**
	 * Kommentar: Diese Methode geht davon aus, dass alle Verknuepfungen bereits
	 * existieren und die Teilfiguren -jede fuer sich- gebaut sind. Sie weist
	 * jeder Teilfigur und der ListBoxFigure die Breite zu. Zu Beachten gilt
	 * dabei, dass dies auch fuer die &quot;unvisible&quot; TextBoxFigures geschieht,
	 * damit die Connections richtig posi- tioniert sind.
	 */
	private void setListBoxFigureWidths(ListBoxFigure list, int width) {
		/* damn the class Rectangle for having no get method for the width! */
		StandardEnumeration figParts;
		try {
<span class="nc" id="L530">			figParts = list.getFigures();</span>
		}
<span class="nc" id="L532">		catch (Exception ex) {</span>
<span class="nc" id="L533">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_GETTING_FIGURES), ex);</span>
<span class="nc" id="L534">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_GETTING_FIGURES));</span>
<span class="nc" id="L535">			figParts = null;</span>
<span class="nc" id="L536">		}</span>
<span class="nc" id="L537">		this.setFigureWidth(list, width);</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">		if (figParts != null) {</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">			while (figParts.hasMoreElements()) {</span>
<span class="nc" id="L540">				this.setFigureWidth((Figure) figParts.nextElement(), width);</span>
			}
		}
<span class="nc" id="L543">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind, auf unvisible
	 * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0
	 * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure
	 * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann
	 * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der
	 * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt
	 * wird. Also wird die TextBoxFigure wieder um die Position der
	 * ListBoxFigure verschoben.
	 */
	public void setNullAttributesUnvisible(ListBoxFigure liBoFi) {
		ObjectModel objModl;
		StandardEnumeration parts;
		TextBoxFigure teBoFi;
		AttributeModel attrModl;
		RectangleFigure liBoFiPart;
<span class="nc" id="L562">		objModl = (ObjectModel) liBoFi.getModel();</span>
<span class="nc" id="L563">		objModl.getObjectViewManager().setNullAttributesVisible(false);</span>
<span class="nc" id="L564">		parts = objModl.getAttributeModels();</span>
		try {
			// Hier werden die Attribute unsichtbar gesetzt, deren Wert gleich
			// null ist.
<span class="nc bnc" id="L568" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L569">				attrModl = (AttributeModel) parts.nextElement();</span>
				// if (attrModl.getValue() == null) {
<span class="nc bnc" id="L571" title="All 2 branches missed.">				if (NullObject.isNullObject(attrModl.getValue())) {</span>
<span class="nc" id="L572">					((TextBoxFigure) attrModl.getFigure()).setUnvisible();</span>
					// this.getConnectionBuilder().removeSingleConnection(attrModl);
				}
			}
			// Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die
			// Positionen gleich der Position der ListBoxFigure.
			// Hierzu bekommt parts eine neue Zuweisung.
<span class="nc" id="L579">			parts = liBoFi.getFigures();</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L581">				liBoFiPart = (RectangleFigure) parts.nextElement();</span>
<span class="nc" id="L582">				liBoFiPart.getBounds().width = 0;</span>
<span class="nc" id="L583">				liBoFiPart.getBounds().x = liBoFi.getBounds().x;</span>
<span class="nc" id="L584">				liBoFiPart.getBounds().y = liBoFi.getBounds().y;</span>
			}
			// Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.
			// Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0
			// gesetzt wird. Daher werden die Figuren anschliessend um die Posi-
			// tion der ListBoxFigure verschoben.
			// Da in der folgenden NeuBerechnung die FilledRectangularBox nicht
			// mitberuecksichtigt wird, war es oben noetig, die Position aller
			// TeilFiguren auf die der ListBoxFigure zu setzten.
			// Es wird mit der TextBoxFigure des HeaderModels begonnen.
<span class="nc" id="L594">			teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();</span>
<span class="nc" id="L595">			teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L596">			teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			// Jetzt kommen die TextBoxFigures der AttributeModels dran.
<span class="nc" id="L598">			parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L600">				teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();</span>
<span class="nc" id="L601">				teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L602">				teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			}
		}
<span class="nc" id="L605">		catch (Exception ex) {</span>
<span class="nc" id="L606">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE), ex);</span>
<span class="nc" id="L607">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE));</span>
<span class="nc" id="L608">		}</span>
<span class="nc" id="L609">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind, auf unvisible
	 * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0
	 * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure
	 * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann
	 * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der
	 * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt
	 * wird. Also wird die TextBoxFigure wieder um die Position der
	 * ListBoxFigure verschoben.
	 */
	public void setNullAttributesVisible(ListBoxFigure liBoFi) {
		ObjectModel objModl;
		Enumeration&lt;?&gt; parts;
		TextBoxFigure teBoFi;
		AttributeModel attrModl;
		RectangleFigure liBoFiPart;
<span class="nc" id="L628">		objModl = (ObjectModel) liBoFi.getModel();</span>
<span class="nc" id="L629">		objModl.getObjectViewManager().setNullAttributesVisible(true);</span>
<span class="nc" id="L630">		parts = objModl.getAttributeModels().getVector().elements();</span>
		try {
			// Hier werden die Attribute unsichtbar gesetzt, deren Wert gleich
			// null ist.
<span class="nc bnc" id="L634" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L635">				attrModl = (AttributeModel) parts.nextElement();</span>
				// if (attrModl.getValue() == null) {
<span class="nc bnc" id="L637" title="All 2 branches missed.">				if (objModl.getObjectViewManager().shouldBeVisible(attrModl)) {</span>
<span class="nc" id="L638">					((TextBoxFigure) attrModl.getFigure()).setVisible();</span>
				}
			}
			// Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die
			// Positionen gleich der Position der ListBoxFigure.
			// Hierzu bekommt parts eine neue Zuweisung.
<span class="nc" id="L644">			parts = liBoFi.getFigures();</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L646">				liBoFiPart = (RectangleFigure) parts.nextElement();</span>
<span class="nc" id="L647">				liBoFiPart.getBounds().width = 0;</span>
<span class="nc" id="L648">				liBoFiPart.getBounds().x = liBoFi.getBounds().x;</span>
<span class="nc" id="L649">				liBoFiPart.getBounds().y = liBoFi.getBounds().y;</span>
			}
			// Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.
			// Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0
			// gesetzt wird. Daher werden die Figuren anschliessend um die Posi-
			// tion der ListBoxFigure verschoben.
			// Da in der folgenden NeuBerechnung die FilledRectangularBox nicht
			// mitberuecksichtigt wird, war es oben noetig, die Position aller
			// TeilFiguren auf die der ListBoxFigure zu setzten.
			// Es wird mit der TextBoxFigure des HeaderModels begonnen.
<span class="nc" id="L659">			teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();</span>
<span class="nc" id="L660">			teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L661">			teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			// Jetzt kommen die TextBoxFigures der AttributeModels dran.
<span class="nc" id="L663">			parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L665">				teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();</span>
<span class="nc" id="L666">				teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L667">				teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			}
		}
<span class="nc" id="L670">		catch (Exception ex) {</span>
<span class="nc" id="L671">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE), ex);</span>
<span class="nc" id="L672">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE));</span>
<span class="nc" id="L673">		}</span>
<span class="nc" id="L674">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Zunaechst wird die TextBoxFigure,
	 * auf unvisible gesetzt. Dann wird die Weite von allen Teilen der
	 * ListBoxFigure auf 0 (null) gesetzt, und die Orte werden gleich dem Ort
	 * der ListBoxFigure gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind,
	 * geschieht dann folgendes: Die DisplayBox wird erneut berechnet. Die Be-
	 * rechnung der DisplayBox hat zur Folge, dass der Ort der Figure wieder auf
	 * 0,0 gesetzt wird. Also wird die TextBoxFigure wieder um die Position der
	 * ListBoxFigure verschoben.
	 */
	public void setSingleAttributeUnvisible(TextBoxFigure texBoFi) {
<span class="nc" id="L687">		ListBoxFigure liBoFi = (ListBoxFigure) texBoFi.getParent();</span>
		de.paragon.explorer.util.StandardEnumeration parts;
		TextBoxFigure teBoFi;
		// AttributeModel attrModl;
		RectangleFigure liBoFiPart;
		try {
			// Hier wird das Attribut unsichtbar gesetzt.
<span class="nc" id="L694">			texBoFi.setUnvisible();</span>
			// this.getConnectionBuilder().removeSingleConnection((AttributeModel)
			// texBoFi.getModel());
			// Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die
			// Positionen gleich der Position der ListBoxFigure.
			// Hierzu bekommt parts eine neue Zuweisung.
<span class="nc" id="L700">			parts = liBoFi.getFigures();</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L702">				liBoFiPart = (RectangleFigure) parts.nextElement();</span>
<span class="nc" id="L703">				liBoFiPart.getBounds().width = 0;</span>
<span class="nc" id="L704">				liBoFiPart.getBounds().x = liBoFi.getBounds().x;</span>
<span class="nc" id="L705">				liBoFiPart.getBounds().y = liBoFi.getBounds().y;</span>
			}
			// Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.
			// Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0
			// gesetzt wird. Daher werden die Figuren anschliessend um die Posi-
			// tion der ListBoxFigure verschoben.
			// Da in der folgenden NeuBerechnung die FilledRectangularBox nicht
			// mitberuecksichtigt wird, war es oben noetig, die Position aller
			// TeilFiguren auf die der ListBoxFigure zu setzten.
			// Es wird mit der TextBoxFigure des HeaderModels begonnen.
<span class="nc" id="L715">			teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();</span>
<span class="nc" id="L716">			teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L717">			teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			// Jetzt kommen die TextBoxFigures der AttributeModels dran.
<span class="nc" id="L719">			parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L721">				teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();</span>
<span class="nc" id="L722">				teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L723">				teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			}
		}
<span class="nc" id="L726">		catch (Exception ex) {</span>
<span class="nc" id="L727">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE), ex);</span>
<span class="nc" id="L728">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE));</span>
<span class="nc" id="L729">		}</span>
<span class="nc" id="L730">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind, auf visible
	 * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0
	 * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure
	 * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann
	 * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der
	 * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt
	 * wird. Also wird die TextBoxFigure wieder um die Position der
	 * ListBoxFigure verschoben.
	 */
	public void setSingleAttributeVisible(TextBoxFigure texBoFi) {
<span class="nc" id="L744">		ListBoxFigure liBoFi = (ListBoxFigure) texBoFi.getParent();</span>
		StandardEnumeration parts;
		TextBoxFigure teBoFi;
		// AttributeModel attrModl;
		RectangleFigure liBoFiPart;
		try {
<span class="nc" id="L750">			texBoFi.setVisible();</span>
			// Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die
			// Positionen gleich der Position der ListBoxFigure.
			// Hierzu bekommt parts eine neue Zuweisung.
<span class="nc" id="L754">			parts = liBoFi.getFigures();</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L756">				liBoFiPart = (RectangleFigure) parts.nextElement();</span>
<span class="nc" id="L757">				liBoFiPart.getBounds().width = 0;</span>
<span class="nc" id="L758">				liBoFiPart.getBounds().x = liBoFi.getBounds().x;</span>
<span class="nc" id="L759">				liBoFiPart.getBounds().y = liBoFi.getBounds().y;</span>
			}
			// Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.
			// Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0
			// gesetzt wird. Daher werden die Figuren anschliessend um die Posi-
			// tion der ListBoxFigure verschoben.
			// Da in der folgenden NeuBerechnung die FilledRectangularBox nicht
			// mitberuecksichtigt wird, war es oben noetig, die Position aller
			// TeilFiguren auf die der ListBoxFigure zu setzten.
			// Es wird mit der TextBoxFigure des HeaderModels begonnen.
<span class="nc" id="L769">			teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();</span>
<span class="nc" id="L770">			teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L771">			teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			// Jetzt kommen die TextBoxFigures der AttributeModels dran.
<span class="nc" id="L773">			parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L775">				teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();</span>
<span class="nc" id="L776">				teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L777">				teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			}
		}
<span class="nc" id="L780">		catch (Exception ex) {</span>
<span class="nc" id="L781">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE), ex);</span>
<span class="nc" id="L782">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE));</span>
<span class="nc" id="L783">		}</span>
<span class="nc" id="L784">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind, auf unvisible
	 * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0
	 * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure
	 * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann
	 * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der
	 * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt
	 * wird. Also wird die TextBoxFigure wieder um die Position der
	 * ListBoxFigure verschoben.
	 */
	public void setStaticAttributesUnvisible(ListBoxFigure liBoFi) {
		ObjectModel objModl;
		de.paragon.explorer.util.StandardEnumeration parts;
		TextBoxFigure teBoFi;
		AttributeModel attrModl;
		RectangleFigure liBoFiPart;
<span class="nc" id="L803">		objModl = (ObjectModel) liBoFi.getModel();</span>
<span class="nc" id="L804">		objModl.getObjectViewManager().setStaticAttributesVisible(false);</span>
<span class="nc" id="L805">		parts = objModl.getAttributeModels();</span>
		try {
			// Hier werden die Attribute unsichtbar gesetzt, deren Wert gleich
			// null ist.
<span class="nc bnc" id="L809" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L810">				attrModl = (AttributeModel) parts.nextElement();</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">				if (Modifier.isStatic(attrModl.getModifiers())) {</span>
<span class="nc" id="L812">					((TextBoxFigure) attrModl.getFigure()).setUnvisible();</span>
					// this.getConnectionBuilder().removeSingleConnection(attrModl);
				}
			}
			// Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die
			// Positionen gleich der Position der ListBoxFigure.
			// Hierzu bekommt parts eine neue Zuweisung.
<span class="nc" id="L819">			parts = liBoFi.getFigures();</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L821">				liBoFiPart = (RectangleFigure) parts.nextElement();</span>
<span class="nc" id="L822">				liBoFiPart.getBounds().width = 0;</span>
<span class="nc" id="L823">				liBoFiPart.getBounds().x = liBoFi.getBounds().x;</span>
<span class="nc" id="L824">				liBoFiPart.getBounds().y = liBoFi.getBounds().y;</span>
			}
			// Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.
			// Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0
			// gesetzt wird. Daher werden die Figuren anschliessend um die Posi-
			// tion der ListBoxFigure verschoben.
			// Da in der folgenden NeuBerechnung die FilledRectangularBox nicht
			// mitberuecksichtigt wird, war es oben noetig, die Position aller
			// TeilFiguren auf die der ListBoxFigure zu setzten.
			// Es wird mit der TextBoxFigure des HeaderModels begonnen.
<span class="nc" id="L834">			teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();</span>
<span class="nc" id="L835">			teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L836">			teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			// Jetzt kommen die TextBoxFigures der AttributeModels dran.
<span class="nc" id="L838">			parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L840">				teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();</span>
<span class="nc" id="L841">				teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L842">				teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			}
		}
<span class="nc" id="L845">		catch (Exception ex) {</span>
<span class="nc" id="L846">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE), ex);</span>
<span class="nc" id="L847">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_UNVISIBLE));</span>
<span class="nc" id="L848">		}</span>
<span class="nc" id="L849">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind, auf unvisible
	 * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0
	 * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure
	 * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann
	 * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der
	 * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt
	 * wird. Also wird die TextBoxFigure wieder um die Position der
	 * ListBoxFigure verschoben.
	 */
	public void setStaticAttributesVisible(ListBoxFigure liBoFi) {
		ObjectModel objModl;
		de.paragon.explorer.util.StandardEnumeration parts;
		TextBoxFigure teBoFi;
		AttributeModel attrModl;
		RectangleFigure liBoFiPart;
<span class="nc" id="L868">		objModl = (ObjectModel) liBoFi.getModel();</span>
<span class="nc" id="L869">		objModl.getObjectViewManager().setStaticAttributesVisible(true);</span>
<span class="nc" id="L870">		parts = objModl.getAttributeModels();</span>
		try {
			// Hier werden die Attribute unsichtbar gesetzt, deren Wert gleich
			// null ist.
<span class="nc bnc" id="L874" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L875">				attrModl = (AttributeModel) parts.nextElement();</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">				if (objModl.getObjectViewManager().shouldBeVisible(attrModl)) {</span>
<span class="nc" id="L877">					((TextBoxFigure) attrModl.getFigure()).setVisible();</span>
				}
			}
			// Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die
			// Positionen gleich der Position der ListBoxFigure.
			// Hierzu bekommt parts eine neue Zuweisung.
<span class="nc" id="L883">			parts = liBoFi.getFigures();</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L885">				liBoFiPart = (RectangleFigure) parts.nextElement();</span>
<span class="nc" id="L886">				liBoFiPart.getBounds().width = 0;</span>
<span class="nc" id="L887">				liBoFiPart.getBounds().x = liBoFi.getBounds().x;</span>
<span class="nc" id="L888">				liBoFiPart.getBounds().y = liBoFi.getBounds().y;</span>
			}
			// Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.
			// Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0
			// gesetzt wird. Daher werden die Figuren anschliessend um die Posi-
			// tion der ListBoxFigure verschoben.
			// Da in der folgenden NeuBerechnung die FilledRectangularBox nicht
			// mitberuecksichtigt wird, war es oben noetig, die Position aller
			// TeilFiguren auf die der ListBoxFigure zu setzten.
			// Es wird mit der TextBoxFigure des HeaderModels begonnen.
<span class="nc" id="L898">			teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();</span>
<span class="nc" id="L899">			teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L900">			teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			// Jetzt kommen die TextBoxFigures der AttributeModels dran.
<span class="nc" id="L902">			parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L904">				teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();</span>
<span class="nc" id="L905">				teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L906">				teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			}
		}
<span class="nc" id="L909">		catch (Exception ex) {</span>
<span class="nc" id="L910">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE), ex);</span>
<span class="nc" id="L911">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_SETTING_ALL_ATTRIBUTES_VISIBLE));</span>
<span class="nc" id="L912">		}</span>
<span class="nc" id="L913">	}</span>

	public void updateObject(ListBoxFigure liBoFi) {
		StandardEnumeration parts;
		TextBoxFigure teBoFi;
		RectangleFigure liBoFiPart;
		try {
			// Hier werden die Weiten aller Teilfiguren auf 0 gesetzt und die
			// Positionen gleich der Position der ListBoxFigure.
			// Hierzu bekommt parts eine neue Zuweisung.
<span class="nc" id="L923">			this.getTextBoxFigureBuilder().updateHeader((ObjectModel) liBoFi.getModel());</span>
<span class="nc" id="L924">			this.getTextBoxFigureBuilder().updateAttributes((ObjectModel) liBoFi.getModel());</span>
<span class="nc" id="L925">			parts = liBoFi.getFigures();</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L927">				liBoFiPart = (RectangleFigure) parts.nextElement();</span>
<span class="nc" id="L928">				liBoFiPart.getBounds().width = 0;</span>
<span class="nc" id="L929">				liBoFiPart.getBounds().x = liBoFi.getBounds().x;</span>
<span class="nc" id="L930">				liBoFiPart.getBounds().y = liBoFi.getBounds().y;</span>
			}
			// Hier werden die DisplayBoxen aller TextBoxFigures neu berechnet.
			// Beachte, dass die Berechnung bewirkt, dass die Position auf 0,0
			// gesetzt wird. Daher werden die Figuren anschliessend um die Posi-
			// tion der ListBoxFigure verschoben.
			// Da in der folgenden NeuBerechnung die FilledRectangularBox nicht
			// mitberuecksichtigt wird, war es oben noetig, die Position aller
			// TeilFiguren auf die der ListBoxFigure zu setzten.
			// Es wird mit der TextBoxFigure des HeaderModels begonnen.
<span class="nc" id="L940">			teBoFi = (TextBoxFigure) ((ObjectModel) liBoFi.getModel()).getHeaderModel().getFigure();</span>
<span class="nc" id="L941">			teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L942">			teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			// Jetzt kommen die TextBoxFigures der AttributeModels dran.
<span class="nc" id="L944">			parts = ((ObjectModel) liBoFi.getModel()).getAttributeModels();</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">			while (parts.hasMoreElements()) {</span>
<span class="nc" id="L946">				teBoFi = (TextBoxFigure) ((AttributeModel) parts.nextElement()).getFigure();</span>
<span class="nc" id="L947">				teBoFi.setBounds(this.getTextBoxFigureBuilder().computeDisplayBox(teBoFi));</span>
<span class="nc" id="L948">				teBoFi.moveBy(liBoFi.getBounds().x, liBoFi.getBounds().y);</span>
			}
		}
<span class="nc" id="L951">		catch (Exception ex) {</span>
<span class="nc" id="L952">			ListBoxFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_UPDATING_FIGURES), ex);</span>
<span class="nc" id="L953">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigureBuilder.ERROR_WHILE_UPDATING_FIGURES));</span>
<span class="nc" id="L954">		}</span>
<span class="nc" id="L955">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>