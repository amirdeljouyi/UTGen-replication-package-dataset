<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExplorerFigureBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">63_objectexplorer</a> &gt; <a href="index.source.html" class="el_package">de.paragon.explorer.figure</a> &gt; <span class="el_source">ExplorerFigureBuilder.java</span></div><h1>ExplorerFigureBuilder.java</h1><pre class="source lang-java linenums">/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 * 
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 **/
package de.paragon.explorer.figure;

import java.util.Vector;

import org.apache.log4j.Logger;

import de.paragon.explorer.gui.Warning;
import de.paragon.explorer.model.AttributeModel;
import de.paragon.explorer.model.ObjectModel;
import de.paragon.explorer.util.LoggerFactory;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;
import de.paragon.explorer.util.StandardEnumerator;

<span class="nc" id="L34">public class ExplorerFigureBuilder {</span>
	private static final int				NUMBER_15														= 15;
	private static final int				NUMBER_25														= 25;
	private static final int				NUMBER_24														= 24;
	private static final int				NUMBER_5														= 5;
	private static final int				NUMBER_50														= 50;
	private static final int				NUMBER_20														= 20;
	private static final String				EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL		= &quot;explorerfigurebuilder.error_while_building_explorermodel&quot;;
	private static final String				EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL				= &quot;explorerfigurebuilder.error_while_building_model&quot;;
	private static final String				EXPLORERFIGUREBUILDER_ERROR_WHILE_COPYING_FIGURES				= &quot;explorerfigurebuilder.error_while_copying_figures&quot;;
	private static final String				EXPLORERFIGUREBUILDER_ERROR_WHILE_DRAWING						= &quot;explorerfigurebuilder.error_while_drawing&quot;;
	private static final String				EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST			= &quot;explorerfigurebuilder.error_while_initializing_1st_list&quot;;
	private static final String				EXPLORERFIGUREBUILDER_ERROR_WHILE_REMOVING						= &quot;explorerfigurebuilder.error_while_removing&quot;;
	private static final String				EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_FIGURE_IN_FOREGROUND	= &quot;explorerfigurebuilder.error_while_setting_figure_in_foreground&quot;;
	private static final String				EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_LBF_BEHIND			= &quot;explorerfigurebuilder.error_while_setting_lbf_behind&quot;;
<span class="nc" id="L49">	private static final Logger				logger															= LoggerFactory.make();</span>
	private static ExplorerFigureBuilder	singleton;

	public static ExplorerFigureBuilder getInstance() {
<span class="nc" id="L53">		return ExplorerFigureBuilder.getSingleton();</span>
	}

	private static ExplorerFigureBuilder getSingleton() {
<span class="nc bnc" id="L57" title="All 2 branches missed.">		if (ExplorerFigureBuilder.singleton == null) {</span>
<span class="nc" id="L58">			ExplorerFigureBuilder.setSingleton(new ExplorerFigureBuilder());</span>
		}
<span class="nc" id="L60">		return ExplorerFigureBuilder.singleton;</span>
	}

	private static void setSingleton(ExplorerFigureBuilder builder) {
<span class="nc" id="L64">		ExplorerFigureBuilder.singleton = builder;</span>
<span class="nc" id="L65">	}</span>

	/**
	 * Kommentar: Diese Methode verknuepft die ListBoxFigure mit der
	 * ExplorerFigure. Im Gegensatz zur Methode addListBoxFigure benoetigt diese
	 * Methode hier die ExplorerFigure, da die StandardConnectionFigure nicht
	 * mit einem Model verknuepft ist, ueber das auf die ExplorerFigure
	 * zurueckgeschlossen werden koennte. Ansonsten macht diese Methode das
	 * gleiche. Das Verknuepfen von ListBox- bzw. StandardConnectionFigure mit
	 * der Explorer- Figure geschieht in zwei verschiedenen Methoden in Hinblick
	 * auf eventuelle, spaetere Unterscheidung zwischen beiden.
	 */
	public void addConnectionFigure(StandardConnectionFigure conFig, ExplorerFigure explFig) {
		try {
<span class="nc" id="L79">			explFig.add(conFig);</span>
		}
<span class="nc" id="L81">		catch (Exception ex) {</span>
<span class="nc" id="L82">			ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL), ex);</span>
<span class="nc" id="L83">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL));</span>
<span class="nc" id="L84">		}</span>
<span class="nc" id="L85">	}</span>

	/**
	 * Kommentar: Diese Methode geht davon aus, dass die Verknuepfungen zwischen
	 * ListBoxFigure, ObjectModel und ExplorerModel bereits existieren. Sie
	 * verknuepft die ListBoxFigure mit der ExplorerFigure.
	 */
	public void addListBoxFigure(ListBoxFigure liBoFi) {
<span class="nc" id="L93">		ObjectModel objModl = (ObjectModel) liBoFi.getModel();</span>
		try {
<span class="nc" id="L95">			objModl.getExplorerModel().getFigure().add(liBoFi);</span>
		}
<span class="nc" id="L97">		catch (Exception ex) {</span>
<span class="nc" id="L98">			ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL), ex);</span>
<span class="nc" id="L99">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_EXPLORERMODEL));</span>
<span class="nc" id="L100">		}</span>
<span class="nc" id="L101">	}</span>

	public ExplorerFigure createNewExplorerFigure() {
<span class="nc" id="L104">		return new ExplorerFigure();</span>
	}

	/**
	 * Kommentar: Diese Methode geht davon aus, dass die uebergebene
	 * ListBoxFigure nicht die erste ist. Soll heissen, dass anhand der
	 * ListBoxFigure die Graphics ermittelt werden koennen.
	 */
	public void draw(ListBoxFigure liBoFi) {
<span class="nc" id="L113">		((ExplorerFigure) liBoFi.getParent()).repaint();</span>
<span class="nc" id="L114">	}</span>

	/**
	 * Kommentar: Der Methodenname dieser Methode drueckt es schon aus:
	 * drawInForeground bedeutet, eine Figure zuerst in den Verdergrund zu
	 * setzen und dann zu zeichnen. Ein vorheriges Loeschen ist nicht noetig, da
	 * es nichts gibt, das vorher verdeckt war und nachher zu sehen sein wird.
	 */
	public void drawInForeground(ListBoxFigure liBoFi) {
<span class="nc" id="L123">		this.setInForeground(liBoFi);</span>
<span class="nc" id="L124">		this.draw(liBoFi);</span>
<span class="nc" id="L125">	}</span>

	private int getFigureHeight(Figure figure) {
<span class="nc" id="L128">		int tempHeight = 0;</span>
		try {
<span class="nc" id="L130">			tempHeight = figure.getDisplayBox().getRectangle().height;</span>
		}
<span class="nc" id="L132">		catch (Exception ex) {</span>
<span class="nc" id="L133">			ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL), ex);</span>
<span class="nc" id="L134">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL));</span>
<span class="nc" id="L135">		}</span>
<span class="nc" id="L136">		return tempHeight;</span>
	}

	/**
	 * Kommentar: Eine Kopie der Aufzaehlung muss aus folgenden Grund extra
	 * erstellt werden: Der Operator new StandardEnumerator(Vector v) erzeugt
	 * einen neuen StandardEnumerator, der auf den selben, uebergebenen Vector v
	 * zeigt. Ist dies der Vector aus dem FigureStore, so werden neue und alte
	 * StandardEnumeration nicht unabhaengig voneinander bearbeitet.
	 * 
	 * @return StandardEnumeration
	 */
	private StandardEnumeration getFiguresOf(ExplorerFigure explFig) {
<span class="nc" id="L149">		StandardEnumeration returnEnum = new StandardEnumerator();</span>
<span class="nc" id="L150">		StandardEnumeration tempEnum = null;</span>
		try {
<span class="nc" id="L152">			tempEnum = explFig.getFigures();</span>
		}
<span class="nc" id="L154">		catch (Exception ex) {</span>
<span class="nc" id="L155">			ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_COPYING_FIGURES), ex);</span>
<span class="nc" id="L156">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_COPYING_FIGURES));</span>
<span class="nc" id="L157">		}</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">		if (tempEnum != null) {</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">			while (tempEnum.hasMoreElements()) {</span>
<span class="nc" id="L160">				returnEnum.addElement(tempEnum.nextElement());</span>
			}
		}
<span class="nc" id="L163">		return returnEnum;</span>
	}

	private int getFigureWidth(Figure figure) {
<span class="nc" id="L167">		int tempWidth = 0;</span>
		try {
<span class="nc" id="L169">			tempWidth = figure.getDisplayBox().getRectangle().width;</span>
		}
<span class="nc" id="L171">		catch (Exception ex) {</span>
<span class="nc" id="L172">			ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL), ex);</span>
<span class="nc" id="L173">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL));</span>
<span class="nc" id="L174">		}</span>
<span class="nc" id="L175">		return tempWidth;</span>
	}

	/**
	 * Kommentar: Diese Methode geht davon aus, dass die ListBoxFigure schon in
	 * allen Variablen definiert ist und nur noch in Position und Groesse in die
	 * ExplorerFigure einge- baut werden muss.
	 */
	public void initialize1stList(ListBoxFigure liBoFi) {
<span class="nc" id="L184">		ExplorerFigure explFig = (ExplorerFigure) liBoFi.getParent();</span>
		try {
<span class="nc" id="L186">			liBoFi.moveBy(ExplorerFigureBuilder.NUMBER_20, ExplorerFigureBuilder.NUMBER_50);</span>
		}
<span class="nc" id="L188">		catch (Exception ex) {</span>
<span class="nc" id="L189">			ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST), ex);</span>
<span class="nc" id="L190">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST));</span>
<span class="nc" id="L191">		}</span>
<span class="nc" id="L192">		this.setFigureWidth(explFig, ExplorerFigureBuilder.NUMBER_20 + this.getFigureWidth(liBoFi));</span>
<span class="nc" id="L193">		this.setFigureHeight(explFig, ExplorerFigureBuilder.NUMBER_50 + this.getFigureHeight(liBoFi));</span>
<span class="nc" id="L194">	}</span>

	/**
	 * Kommentar: Diese Methode geht davon aus, dass die ListBoxFigure schon in
	 * allen Variablen definiert ist und nur noch in Position und Groesse in die
	 * ExplorerFigure einge- baut werden muss.
	 */
	public void initializeCopyList(ListBoxFigure liBoFi) {
		ExplorerFigure explFig;
		java.awt.Point p;
		int x;
		int y;
<span class="nc" id="L206">		explFig = (ExplorerFigure) liBoFi.getParent();</span>
<span class="nc" id="L207">		p = javax.swing.SwingUtilities.convertPoint(explFig.getFrame(), ExplorerFigureBuilder.NUMBER_5, ExplorerFigureBuilder.NUMBER_24, explFig.getPanel());</span>
<span class="nc" id="L208">		x = (int) p.getX() + ExplorerFigureBuilder.NUMBER_20;</span>
<span class="nc" id="L209">		y = (int) p.getY() + ExplorerFigureBuilder.NUMBER_20;</span>
		try {
<span class="nc" id="L211">			liBoFi.moveBy(x, y);</span>
		}
<span class="nc" id="L213">		catch (Exception ex) {</span>
<span class="nc" id="L214">			ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST), ex);</span>
<span class="nc" id="L215">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST));</span>
<span class="nc" id="L216">		}</span>
<span class="nc" id="L217">		this.setFigureWidth(explFig, x + this.getFigureWidth(liBoFi));</span>
<span class="nc" id="L218">		this.setFigureHeight(explFig, y + this.getFigureHeight(liBoFi));</span>
<span class="nc" id="L219">	}</span>

	public void initializeListFor(ObjectModel objModl, AttributeModel attrModl) {
<span class="nc" id="L222">		ListBoxFigure liBoFi = (ListBoxFigure) objModl.getFigure();</span>
<span class="nc" id="L223">		TextBoxFigure teBoFi = (TextBoxFigure) attrModl.getFigure();</span>
		try {
<span class="nc" id="L225">			int x = teBoFi.getBounds().x + teBoFi.getBounds().width + ExplorerFigureBuilder.NUMBER_15;</span>
<span class="nc" id="L226">			int y = teBoFi.getBounds().y;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">			if (!teBoFi.isVisible()) {</span>
<span class="nc" id="L228">				ObjectModel myObjModl = (ObjectModel) ((ListBoxFigure) teBoFi.getParent()).getModel();</span>
<span class="nc" id="L229">				Vector&lt;?&gt; attrModls = myObjModl.getAttributeModels().getVector();</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">				for (int i = 0; i &lt; attrModls.size(); i++) {</span>
<span class="nc" id="L231">					AttributeModel myAttrModl = (AttributeModel) attrModls.elementAt(i);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">					if (myAttrModl.getConnectionModel() != null) {</span>
<span class="nc" id="L233">						y = y + ExplorerFigureBuilder.NUMBER_25;</span>
					}
				}
			}
<span class="nc" id="L237">			liBoFi.moveBy(x, y);</span>
		}
<span class="nc" id="L239">		catch (Exception ex) {</span>
<span class="nc" id="L240">			ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST), ex);</span>
<span class="nc" id="L241">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_INITIALIZING_1ST_LIST));</span>
<span class="nc" id="L242">		}</span>
<span class="nc" id="L243">	}</span>

	/**
	 * Kommentar: Das Verschieben funktioniert so: Anhand der ListBoxFigure
	 * bestimmt diese Methode die zugehoerige ExplorerFigure. Diese wird
	 * geloescht. Dann werden die zugehoerigen Daten der ListBoxFigure
	 * verschoben. Danach wird die gesamte ExplorerFigure wieder gezeichnet.
	 */
	public void moveFigureBy(ListBoxFigure liBoFi, int x, int y) {
		// ExplorerFigure explFig = (ExplorerFigure) liBoFi.getParent();
		// explFig.clear();
		try {
<span class="nc" id="L255">			liBoFi.moveBy(x, y);</span>
			// explFig.draw();
		}
<span class="nc" id="L258">		catch (Exception ex) {</span>
<span class="nc" id="L259">			ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_DRAWING), ex);</span>
<span class="nc" id="L260">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_DRAWING));</span>
<span class="nc" id="L261">		}</span>
<span class="nc" id="L262">	}</span>

	/**
	 * Kommentar: Zunaechst wird die betreffende Figur aus der Liste aller
	 * Figuren entfernt. Dann wird eine Kopie der Liste der uebrigen Figuren
	 * erstellt. Die betreffende Figur wird der Liste aller Figuren wieder
	 * hinzugefuegt, danach die uebri- gen. Auf diese Weise wird die betreffende
	 * Figur zuerst gezeichnet und dann von allen anderen uebermalt. Eine Kopie
	 * der Aufzaehlung muss aus folgenden Grund extra erstellt werden: Der
	 * Operator new StandardEnumerator(Vector v) erzeugt einen neuen
	 * StandardEnumerator, der auf den selben, uebergebenen Vector v zeigt. Ist
	 * dies der Vector aus dem FigureStore, so werden neue und alte
	 * StandardEnumeration nicht unabhaengig voneinander bearbeitet.
	 */
	public void placeBehind(ListBoxFigure liBoFi) {
<span class="nc" id="L277">		ExplorerFigure explFig = (ExplorerFigure) liBoFi.getParent();</span>
		StandardEnumeration enumeration;
		try {
<span class="nc" id="L280">			explFig.remove(liBoFi);</span>
<span class="nc" id="L281">			enumeration = this.getFiguresOf(explFig);</span>
<span class="nc" id="L282">			explFig.removeAll();</span>
<span class="nc" id="L283">			explFig.add(liBoFi);</span>
<span class="nc" id="L284">			explFig.addAll(enumeration);</span>
		}
<span class="nc" id="L286">		catch (Exception ex) {</span>
<span class="nc" id="L287">			ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_LBF_BEHIND), ex);</span>
<span class="nc" id="L288">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_LBF_BEHIND));</span>
<span class="nc" id="L289">		}</span>
<span class="nc" id="L290">	}</span>

	/**
	 * Kommentar: Diese Methode geht davon aus, dass das zugehoerige ObjectModel
	 * bereits geloescht worden ist. Das Loeschen einer ListBoxFigure besteht
	 * darin, sie aus der Liste figureStore der ExplorerFigure zu entfernen.
	 */
	public void removeFromExplorer(ListBoxFigure liBoFi) {
		try {
<span class="nc bnc" id="L299" title="All 2 branches missed.">			if (liBoFi.getParent() != null) {</span>
<span class="nc" id="L300">				liBoFi.getParent().remove(liBoFi);</span>
			}
		}
<span class="nc" id="L303">		catch (Exception ex) {</span>
<span class="nc" id="L304">			ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_REMOVING), ex);</span>
<span class="nc" id="L305">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_REMOVING));</span>
<span class="nc" id="L306">		}</span>
<span class="nc" id="L307">	}</span>

	private void setFigureHeight(Figure figure, int y) {
		try {
<span class="nc" id="L311">			figure.getDisplayBox().getRectangle().height = y;</span>
		}
<span class="nc" id="L313">		catch (Exception ex) {</span>
<span class="nc" id="L314">			ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL), ex);</span>
<span class="nc" id="L315">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL));</span>
<span class="nc" id="L316">		}</span>
<span class="nc" id="L317">	}</span>

	private void setFigureWidth(Figure figure, int x) {
		try {
<span class="nc" id="L321">			figure.getDisplayBox().getRectangle().width = x;</span>
		}
<span class="nc" id="L323">		catch (Exception ex) {</span>
<span class="nc" id="L324">			ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL), ex);</span>
<span class="nc" id="L325">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_BUILDING_MODEL));</span>
<span class="nc" id="L326">		}</span>
<span class="nc" id="L327">	}</span>

	/**
	 * Kommentar: Diese Methode geht davon aus, dass die uebergebene Figure
	 * entweder eine ListBoxFigure oder eine ConnectionFigure ist. Diese Methode
	 * entfernt die entsprechende List- BoxFigure aus der Menge aller
	 * ListBoxFigures und setzt sie ans Ende dieser Liste. Es wird nicht
	 * gezeichnet!
	 */
	public void setInForeground(Figure figure) {
<span class="nc" id="L337">		ExplorerFigure explFig = (ExplorerFigure) figure.getParent();</span>
		try {
<span class="nc" id="L339">			explFig.getFigures().removeElement(figure);</span>
<span class="nc" id="L340">			explFig.add(figure);</span>
		}
<span class="nc" id="L342">		catch (Exception ex) {</span>
<span class="nc" id="L343">			ExplorerFigureBuilder.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_FIGURE_IN_FOREGROUND), ex);</span>
<span class="nc" id="L344">			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigureBuilder.EXPLORERFIGUREBUILDER_ERROR_WHILE_SETTING_FIGURE_IN_FOREGROUND));</span>
<span class="nc" id="L345">		}</span>
<span class="nc" id="L346">	}</span>

	public void update(ExplorerFigure explFig) {
<span class="nc" id="L349">		explFig.repaint();</span>
<span class="nc" id="L350">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>