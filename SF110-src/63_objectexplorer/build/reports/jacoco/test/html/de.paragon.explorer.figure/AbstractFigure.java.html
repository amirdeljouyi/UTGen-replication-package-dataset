<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractFigure.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">63_objectexplorer</a> &gt; <a href="index.source.html" class="el_package">de.paragon.explorer.figure</a> &gt; <span class="el_source">AbstractFigure.java</span></div><h1>AbstractFigure.java</h1><pre class="source lang-java linenums">/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 * 
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 **/
package de.paragon.explorer.figure;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Rectangle;

import de.paragon.explorer.excp.FigureEventException;
import de.paragon.explorer.excp.FigureException;
import de.paragon.explorer.gui.DisplayBox;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;

/**
 * Kommentar: Diese Klasse implementiert Figure und gibt Default-Implementation
 * fuer die grafischen Basisklassen vor Beschreibung der Kasse:
 * 
 * Die Instanzvariablen: parent: normale Hierarchieverknuepfung, die Figur, von
 * der diese Figur Teilfigur ist.
 */
public abstract class AbstractFigure implements Figure {
	private static final String	ERROR_WHILE_DISPATCHING_APPEARED								= &quot;abstractfigure.error_while_dispatching_appeared&quot;;
	private static final String	ERROR_WHILE_DISPATCHING_INVALIDATED								= &quot;abstractfigure.error_while_dispatching_invalidated&quot;;
	private static final String	LISTENER_DOESNT_KNOW2HANDLE_FIGURE_CHANGE_EVENT					= &quot;abstractfigure.listener_doesnt_know2handle_figure_change_event&quot;;
	private static final String	TRYING2ADD_A_FIGURE2A_BASICFIGURE								= &quot;abstractfigure.trying2add_a_figure2a_basicfigure&quot;;
	private static final String	TRYING2ADD_PARTS2A_NON_COMPOSITE_FIGURE							= &quot;abstractfigure.trying2add_parts2a_non_composite_figure&quot;;
	private static final String	TRYING2CHECK_WHETER_A_FIGURE_IS_PART_OF_A_NON_COMPOSITE_FIGURE	= &quot;abstractfigure.trying2check_wheter_a_figure_is_part_of_a_non_composite_figure&quot;;
	private static final String	TRYING2GET_PARTS_OF_A_BASIC_FIGURE								= &quot;abstractfigure.trying2get_parts_of_a_basic_figure&quot;;
	private static final String	TRYING2REMOVE_ALL_FROM_A_BASIC_FIGURE							= &quot;abstractfigure.trying2remove_all_from_a_basic_figure&quot;;
	private static final String	TRYING2REMOVE_FROM_A_BASIC_FIGURE								= &quot;abstractfigure.trying2remove_from_a_basic_figure&quot;;
	private static final String	TRYING2SET_PARTS_OF_A_NON_COMPOSITE_FIGURE						= &quot;abstractfigure.trying2set_parts_of_a_non_composite_figure&quot;;
	private FigureChangeManager	changeManager;
	private Figure				parent;

	// gemeinsames Eventhandling von E.Gamma implizit angesprochen
	// durch Implementationsbeispiel in Figure
	//
	// changeManager zur Kapselung der Listenerverwaltung ist
	// hier Idee von C.L., im Observer Pattern aber auch angesprochen
	//
	// fuer Defaultverhalten des Eventhandlings
<span class="fc" id="L60">	protected AbstractFigure() {</span>
<span class="fc" id="L61">		this.changeManager = new FigureChangeManager();</span>
<span class="fc" id="L62">	}</span>

	// Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag
	// von E.Gamma). Exception werfen ist Implementationsempfehlung des
	// DesignPatterns.
	public void add(Figure f) throws FigureException {
<span class="nc" id="L68">		throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2ADD_A_FIGURE2A_BASICFIGURE));</span>
	}

	// Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag
	// von E.Gamma). Exception werfen ist Implementationsempfehlung des
	// DesignPatterns.
	public void addAll(StandardEnumeration figures) throws FigureException {
<span class="nc" id="L75">		throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2ADD_PARTS2A_NON_COMPOSITE_FIGURE));</span>
	}

	// MethodenIdee: E.Gamma, Delegation: C.L.
	public void addChangeListener(FigureChangeListener l) {
<span class="nc" id="L80">		this.getChangeManager().addChangeListener(l);</span>
<span class="nc" id="L81">	}</span>

	// Vorschlag von E.Gamma
	protected abstract void basicMoveBy(int x, int y) throws FigureException;

	// Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag
	// von E.Gamma). Exception werfen ist Implementationsempfehlung des
	// DesignPatterns.
	public boolean containsFigure(Figure f) throws FigureException {
<span class="nc" id="L90">		throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2CHECK_WHETER_A_FIGURE_IS_PART_OF_A_NON_COMPOSITE_FIGURE));</span>
	}

	// identisch zum Beispielcode von E.Gamma
	// (bis auf displayBox-&gt;getDisplayBox() und Exceptions)
	//
	// Die Frage, ob eine Figur einen Punkt enthaelt oder nicht,
	// ist durch die dieser bekannten DisplayBox zu beantworten
	// und kann folglich an sie delegiert werden.
	public boolean containsPoint(int x, int y) {
<span class="nc" id="L100">		return this.getDisplayBox().isInside(x, y);</span>
	}

	// Wiederholung der Nennung: 80% C.L. (in Analogie zu getDisplayBox())
	public abstract void draw(Graphics g) throws FigureException;

	// Ausdifferenzierung nach erscheinenden und verschwindenden Figuren: C.L.
	public void figureAppeared(FigureChangeEvent e) throws FigureException {
<span class="nc" id="L108">		throw new FigureEventException(ResourceBundlePurchaser.getMessage(AbstractFigure.LISTENER_DOESNT_KNOW2HANDLE_FIGURE_CHANGE_EVENT));</span>
	}

	// Vorschlag von E.Gamma
	public void figureInvalidated(FigureChangeEvent e) throws FigureException {
<span class="nc" id="L113">		throw new FigureEventException(ResourceBundlePurchaser.getMessage(AbstractFigure.LISTENER_DOESNT_KNOW2HANDLE_FIGURE_CHANGE_EVENT));</span>
	}

	public Rectangle getBounds() throws FigureException {
<span class="nc" id="L117">		return this.getDisplayBox().getRectangle();</span>
	}

	// C.L:
	protected FigureChangeManager getChangeManager() {
<span class="nc" id="L122">		return this.changeManager;</span>
	}

	// von Figure, E.Gamma nennt in Figure (Folie 11) und AbstractFigure (Folie
	// 13) jeweils die abstrakte Methode displayBox();
	// Folie 11 deutet allerdings auf eine Defaultimplementation von
	// displayBox() hin, die basicDisplayBox() aufruft (vermutlich abstrakt).
	// Dies macht eigentlich nur fuer einen echten Zeichenprozess Sinn (im
	// Widerspruch zum Beispielcode von containsPoint()).
	// C.L. realisiert die Version von Folie 13.
	//
	// Implementation durch konkrete Subklassen
	public abstract DisplayBox getDisplayBox();

	// Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag
	// von E.Gamma). Exception werfen ist Implementationsempfehlung des
	// DesignPatterns.
	public StandardEnumeration getFigures() throws FigureException {
<span class="nc" id="L140">		throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2GET_PARTS_OF_A_BASIC_FIGURE));</span>
	}

	public Figure getParent() {
<span class="nc" id="L144">		return this.parent;</span>
	}

	public Dimension getSize() throws FigureException {
<span class="nc" id="L148">		Dimension d = new Dimension();</span>
<span class="nc" id="L149">		Rectangle r = this.getBounds();</span>
<span class="nc" id="L150">		d.width = r.width;</span>
<span class="nc" id="L151">		d.height = r.height;</span>
<span class="nc" id="L152">		return d;</span>
	}

	public void hasChanged() throws FigureEventException {
		try {
<span class="nc" id="L157">			this.getChangeManager().processEvent(new FigureChangeEvent(this, this.getDisplayBox(), PackageConstants.FIGURE_APPEARED));</span>
		}
<span class="nc" id="L159">		catch (Exception ex) {</span>
<span class="nc" id="L160">			throw new FigureEventException(ResourceBundlePurchaser.getMessage(AbstractFigure.ERROR_WHILE_DISPATCHING_APPEARED));</span>
<span class="nc" id="L161">		}</span>
<span class="nc" id="L162">	}</span>

	// identisch zum Beispielcode von E.Gamma
	// (bis auf changed()-&gt;hasChanged(), dx -&gt; x, dy -&gt; y und Exceptions)
	// 
	// erlaubt es einen gemeinsamen Notification-Mechanismus vorzuimplementieren
	// (durch willChange() und changed()), delegiert eigentliche Bewegung
	// an Unterklasse
	public void moveBy(int x, int y) throws FigureException {
<span class="nc" id="L171">		this.willChange();</span>
<span class="nc" id="L172">		this.basicMoveBy(x, y);</span>
<span class="nc" id="L173">		this.hasChanged();</span>
<span class="nc" id="L174">	}</span>

	// Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag
	// von E.Gamma). Exception werfen ist Implementationsempfehlung des
	// DesignPatterns.
	public void remove(Figure f) throws FigureException {
<span class="nc" id="L180">		throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2REMOVE_FROM_A_BASIC_FIGURE));</span>
	}

	// Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag
	// von E.Gamma). Exception werfen ist Implementationsempfehlung des
	// DesignPatterns.
	public void removeAll() throws FigureException {
<span class="nc" id="L187">		throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2REMOVE_ALL_FROM_A_BASIC_FIGURE));</span>
	}

	// MethodenIdee E.Gamma, Delegation: C.L.
	public void removeChangeListener(FigureChangeListener l) {
<span class="nc" id="L192">		this.getChangeManager().removeChangeListener(l);</span>
<span class="nc" id="L193">	}</span>

	public void setBounds(int x, int y, int width, int height) throws FigureException {
<span class="nc" id="L196">		Rectangle r = new Rectangle(x, y, width, height);</span>
<span class="nc" id="L197">		this.setBounds(r);</span>
<span class="nc" id="L198">	}</span>

	public void setBounds(Rectangle r) throws FigureException {
<span class="nc" id="L201">		this.willChange();</span>
<span class="nc" id="L202">		Rectangle db = this.getDisplayBox().getRectangle();</span>
<span class="nc" id="L203">		db.x = r.x;</span>
<span class="nc" id="L204">		db.y = r.y;</span>
<span class="nc" id="L205">		db.width = r.width;</span>
<span class="nc" id="L206">		db.height = r.height;</span>
<span class="nc" id="L207">		this.hasChanged();</span>
<span class="nc" id="L208">	}</span>

	// Methode folgt aus dem DesignPattern Composite (Verwendung ist Vorschlag
	// von E.Gamma). Exception werfen ist Implementationsempfehlung des
	// DesignPatterns.
	public void setFigures(StandardEnumeration figures) throws FigureException {
<span class="nc" id="L214">		throw new FigureException(ResourceBundlePurchaser.getMessage(AbstractFigure.TRYING2SET_PARTS_OF_A_NON_COMPOSITE_FIGURE));</span>
	}

	public void setParent(Figure newParent) {
<span class="nc" id="L218">		this.parent = newParent;</span>
<span class="nc" id="L219">	}</span>

	public void setSize(Dimension d) throws FigureException {
<span class="nc" id="L222">		this.willChange();</span>
<span class="nc" id="L223">		Rectangle db = this.getDisplayBox().getRectangle();</span>
<span class="nc" id="L224">		db.width = d.width;</span>
<span class="nc" id="L225">		db.height = d.height;</span>
<span class="nc" id="L226">		this.hasChanged();</span>
<span class="nc" id="L227">	}</span>

	// Vorschlag von E.Gamma
	//
	//
	public void setSize(int width, int height) throws FigureException {
<span class="nc" id="L233">		Dimension d = new Dimension(width, height);</span>
<span class="nc" id="L234">		this.setSize(d);</span>
<span class="nc" id="L235">	}</span>

	public void willChange() throws FigureEventException {
		try {
<span class="nc" id="L239">			this.getChangeManager().processEvent(new FigureChangeEvent(this, (DisplayBox) this.getDisplayBox().clone(), PackageConstants.FIGURE_INVALIDATED));</span>
		}
<span class="nc" id="L241">		catch (Exception ex) {</span>
<span class="nc" id="L242">			throw new FigureEventException(ResourceBundlePurchaser.getMessage(AbstractFigure.ERROR_WHILE_DISPATCHING_INVALIDATED));</span>
<span class="nc" id="L243">		}</span>
<span class="nc" id="L244">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>