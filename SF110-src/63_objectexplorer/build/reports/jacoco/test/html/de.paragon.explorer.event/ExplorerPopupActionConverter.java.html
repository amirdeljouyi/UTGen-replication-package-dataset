<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExplorerPopupActionConverter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">63_objectexplorer</a> &gt; <a href="index.source.html" class="el_package">de.paragon.explorer.event</a> &gt; <span class="el_source">ExplorerPopupActionConverter.java</span></div><h1>ExplorerPopupActionConverter.java</h1><pre class="source lang-java linenums">/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 * 
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 **/
package de.paragon.explorer.event;

import de.paragon.explorer.Explorer;
import de.paragon.explorer.figure.ExplorerFigure;
import de.paragon.explorer.figure.ExplorerFigureBuilder;
import de.paragon.explorer.figure.ListBoxFigure;
import de.paragon.explorer.figure.ListBoxFigureBuilder;
import de.paragon.explorer.figure.TextBoxFigure;
import de.paragon.explorer.model.AttributeModel;
import de.paragon.explorer.model.ExplorerModelBuilder;
import de.paragon.explorer.model.ObjectModel;
import de.paragon.explorer.util.ConnectionBuilder;
import de.paragon.explorer.util.StandardEnumeration;

/**
 * Kommentar: Diese Klasse ist speziell dafuer da, Popupmenu-Events zu empfangen
 * und an die entsprechenden Builder weiterzuleiten.
 */
public class ExplorerPopupActionConverter {
	private static ExplorerPopupActionConverter	singleton;

	public static ExplorerPopupActionConverter getInstance() {
<span class="nc" id="L42">		return ExplorerPopupActionConverter.getSingleton();</span>
	}

	private static ExplorerPopupActionConverter getSingleton() {
<span class="nc bnc" id="L46" title="All 2 branches missed.">		if (ExplorerPopupActionConverter.singleton == null) {</span>
<span class="nc" id="L47">			ExplorerPopupActionConverter.setSingleton(new ExplorerPopupActionConverter());</span>
		}
<span class="nc" id="L49">		return ExplorerPopupActionConverter.singleton;</span>
	}

	private static void setSingleton(ExplorerPopupActionConverter builder) {
<span class="nc" id="L53">		ExplorerPopupActionConverter.singleton = builder;</span>
<span class="nc" id="L54">	}</span>

	public ExplorerPopupActionConverter() {
<span class="nc" id="L57">		super();</span>
<span class="nc" id="L58">	}</span>

	/**
	 * Kommentar: Diese Methode oeffnet einfach einen neuen PARAGON-Explorer
	 * fuer das Objekt, das mit dem ObjectModel der ListBoxFigure verbunden ist.
	 */
	public void exploreObjectOf(ListBoxFigure liBoFi) {
<span class="nc" id="L65">		Explorer.explore(liBoFi);</span>
<span class="nc" id="L66">	}</span>

	private ConnectionBuilder getConnectionBuilder() {
<span class="nc" id="L69">		return ConnectionBuilder.getInstance();</span>
	}

	private ExplorerFigureBuilder getExplorerFigureBuilder() {
<span class="nc" id="L73">		return ExplorerFigureBuilder.getInstance();</span>
	}

	private ExplorerModelBuilder getExplorerModelBuilder() {
<span class="nc" id="L77">		return ExplorerModelBuilder.getInstance();</span>
	}

	private ListBoxFigureBuilder getListBoxFigureBuilder() {
<span class="nc" id="L81">		return ListBoxFigureBuilder.getInstance();</span>
	}

	/**
	 * Diese Methode loescht eine einzelne Connection. Zunaechst werden die
	 * Referenzen auf die Connection von dem AttributeModell und von der
	 * ExplorerFigure entfernt. Dann werden die Referenzen von den beiden
	 * Objectmodellen, auf die bzw. von denen eine Referenz dargestellt wird,
	 * geloescht.
	 */
	public void hideAllReferences(ListBoxFigure liBoFi) {
<span class="nc" id="L92">		AttributeModel attrModl = null;</span>
<span class="nc" id="L93">		StandardEnumeration attrModls = ((ObjectModel) liBoFi.getModel()).getAttributeModels();</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">		while (attrModls.hasMoreElements()) {</span>
<span class="nc" id="L95">			attrModl = ((AttributeModel) attrModls.nextElement());</span>
<span class="nc" id="L96">			this.removeConnection((TextBoxFigure) attrModl.getFigure());</span>
		}
<span class="nc" id="L98">	}</span>

	private void initializeListBoxFigureAndUpdateExplorerFigure(ListBoxFigure liBoFi) {
<span class="nc" id="L101">		this.getListBoxFigureBuilder().initializeListBoxFigure(liBoFi);</span>
<span class="nc" id="L102">		this.getExplorerFigureBuilder().update((ExplorerFigure) liBoFi.getParent());</span>
<span class="nc" id="L103">	}</span>

	/**
	 * Kommentar: Diese Methode setzt die uebergebene ListBoxFigure nach ganz
	 * hinten und zeichnet dann alles neu.
	 */
	public void placeBehind(ListBoxFigure liBoFi) {
<span class="nc" id="L110">		this.getExplorerFigureBuilder().placeBehind(liBoFi);</span>
<span class="nc" id="L111">		this.getExplorerFigureBuilder().update((ExplorerFigure) liBoFi.getParent());</span>
<span class="nc" id="L112">	}</span>

	public void removeChildListBoxFigure(ListBoxFigure liBoFi) {
<span class="nc" id="L115">		ObjectModel objModl = (ObjectModel) liBoFi.getModel();</span>
<span class="nc" id="L116">		objModl.getExplorerModel().removeObjectModel(objModl);</span>
<span class="nc" id="L117">		this.getExplorerFigureBuilder().removeFromExplorer((ListBoxFigure) liBoFi.getModel().getFigure());</span>
<span class="nc" id="L118">		this.getConnectionBuilder().removeConnections(objModl);</span>
<span class="nc" id="L119">	}</span>

	/**
	 * Diese Methode loescht eine einzelne Connection. Zunaechst werden die
	 * Referenzen auf die Connection von dem AttributeModell und von der
	 * ExplorerFigure entfernt. Dann werden die Referenzen von den beiden
	 * Objectmodellen, auf die bzw. von denen eine Referenz dargestellt wird,
	 * geloescht.
	 */
	public void removeConnection(TextBoxFigure teBoFi) {
<span class="nc" id="L129">		this.getConnectionBuilder().removeSingleConnection((AttributeModel) teBoFi.getModel());</span>
<span class="nc" id="L130">		ListBoxFigure liBoFi = (ListBoxFigure) teBoFi.getParent();</span>
<span class="nc" id="L131">		this.getExplorerFigureBuilder().update((ExplorerFigure) liBoFi.getParent());</span>
<span class="nc" id="L132">	}</span>

	/**
	 * Ein ObjectModel wird so geloescht: Zunaechst werden die Referenzen der
	 * entsprechenden Containerobjekten auf die ListBoxFigure bzw. das
	 * Object-Model geloescht. Dann werden die Referenzen von den obigen
	 * Containerobjekten auf die Connections geloescht, ebenso die des
	 * AttributeModels und die der Object- Models. Schliesslich wird die
	 * Zeichnung geloescht, und es wird neu gezeichnet.
	 */
	public void removeListBoxFigure(ListBoxFigure liBoFi) {
<span class="nc" id="L143">		ExplorerFigure tempExplFig = (ExplorerFigure) liBoFi.getParent();</span>
<span class="nc" id="L144">		this.getExplorerModelBuilder().removeFromExplorer((ObjectModel) liBoFi.getModel());</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">		if (tempExplFig != null) {</span>
<span class="nc" id="L146">			this.getExplorerFigureBuilder().update(tempExplFig);</span>
		}
<span class="nc" id="L148">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Die Methode
	 * setAllAttributesUnvisible macht folgendes: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind, auf unvisible
	 * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0
	 * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure
	 * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann
	 * folgendes: Die DisplayBox wird erneut berechnet. Die Berechnung der
	 * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt
	 * wird. Also wird die TextBoxFigure wieder um die Position der
	 * ListBoxFigure verschoben.
	 * 
	 * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen
	 * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt
	 * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller
	 * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer
	 * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-
	 * sitioniert.
	 * 
	 * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu
	 * gezeichnet.
	 */
	public void setAllAttributesUnvisibleOf(ListBoxFigure liBoFi) {
<span class="nc" id="L173">		this.getListBoxFigureBuilder().setAllAttributesUnvisible(liBoFi);</span>
<span class="nc" id="L174">		this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);</span>
<span class="nc" id="L175">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Die Methode setAllAttributesVisible
	 * macht folgendes: Zunaechst werden alle AttributeModels auf visible
	 * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0
	 * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure
	 * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann
	 * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der
	 * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt
	 * wird. Also wird die TextBoxFigure wieder um die Position der
	 * ListBoxFigure verschoben.
	 * 
	 * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen
	 * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt
	 * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller
	 * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer
	 * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-
	 * sitioniert.
	 * 
	 * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu
	 * gezeichnet.
	 */
	public void setAllAttributesVisibleOf(ListBoxFigure liBoFi) {
<span class="nc" id="L199">		this.getListBoxFigureBuilder().setAllAttributesVisible(liBoFi);</span>
<span class="nc" id="L200">		this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);</span>
<span class="nc" id="L201">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Die Methode
	 * setAllExploredAttributesVisible macht folgendes: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind und nicht
	 * explored sind,auf unvisible gesetzt. Dann wird die Weite von allen Teilen
	 * der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden gleich dem
	 * Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die TextBoxFigure
	 * sind, geschieht dann folgendes: Die DisplayBox wird erneut berechnet. Die
	 * Be- rechnung der DisplayBox hat zur Folge, dass der Ort der Figure wieder
	 * auf 0,0 gesetzt wird. Also wird die TextBoxFigure wieder um die Position
	 * der ListBoxFigure verschoben.
	 * 
	 * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen
	 * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt
	 * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller
	 * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer
	 * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-
	 * sitioniert.
	 * 
	 * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu
	 * gezeichnet.
	 */
	public void setAllUnexploredAttributesUnvisibleOf(ListBoxFigure liBoFi) {
<span class="nc" id="L226">		this.getListBoxFigureBuilder().setAllUnexploredAttributesUnvisible(liBoFi);</span>
<span class="nc" id="L227">		this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);</span>
<span class="nc" id="L228">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Die Methode
	 * setAllExploredAttributesVisible macht folgendes: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind und nicht
	 * explored sind,auf unvisible gesetzt. Dann wird die Weite von allen Teilen
	 * der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden gleich dem
	 * Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die TextBoxFigure
	 * sind, geschieht dann folgendes: Die DisplayBox wird erneut berechnet. Die
	 * Be- rechnung der DisplayBox hat zur Folge, dass der Ort der Figure wieder
	 * auf 0,0 gesetzt wird. Also wird die TextBoxFigure wieder um die Position
	 * der ListBoxFigure verschoben.
	 * 
	 * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen
	 * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt
	 * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller
	 * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer
	 * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-
	 * sitioniert.
	 * 
	 * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu
	 * gezeichnet.
	 */
	public void setAllUnexploredAttributesVisibleOf(ListBoxFigure liBoFi) {
<span class="nc" id="L253">		this.getListBoxFigureBuilder().setAllUnexploredAttributesVisible(liBoFi);</span>
<span class="nc" id="L254">		this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);</span>
<span class="nc" id="L255">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Die Methode
	 * setAllAttributesUnvisible macht folgendes: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind und keinen Wert
	 * null haben, auf unvisible gesetzt. Dann wird die Weite von allen Teilen
	 * der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden gleich dem
	 * Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die TextBoxFigure
	 * sind, geschieht dann folgendes: Die DisplayBox wird erneut berechnet. Die
	 * Be- rechnung der DisplayBox hat zur Folge, dass der Ort der Figure wieder
	 * auf 0,0 gesetzt wird. Also wird die TextBoxFigure wieder um die Position
	 * der ListBoxFigure verschoben.
	 * 
	 * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen
	 * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt
	 * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller
	 * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer
	 * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-
	 * sitioniert.
	 * 
	 * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu
	 * gezeichnet.
	 */
	public void setNullAttributesUnvisibleOf(ListBoxFigure liBoFi) {
<span class="nc" id="L280">		this.getListBoxFigureBuilder().setNullAttributesUnvisible(liBoFi);</span>
<span class="nc" id="L281">		this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);</span>
<span class="nc" id="L282">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Die Methode
	 * setAllAttributesUnvisible macht folgendes: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind und keinen Wert
	 * null haben, auf unvisible gesetzt. Dann wird die Weite von allen Teilen
	 * der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden gleich dem
	 * Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die TextBoxFigure
	 * sind, geschieht dann folgendes: Die DisplayBox wird erneut berechnet. Die
	 * Be- rechnung der DisplayBox hat zur Folge, dass der Ort der Figure wieder
	 * auf 0,0 gesetzt wird. Also wird die TextBoxFigure wieder um die Position
	 * der ListBoxFigure verschoben.
	 * 
	 * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen
	 * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt
	 * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller
	 * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer
	 * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-
	 * sitioniert.
	 * 
	 * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu
	 * gezeichnet.
	 */
	public void setNullAttributesVisibleOf(ListBoxFigure liBoFi) {
<span class="nc" id="L307">		this.getListBoxFigureBuilder().setNullAttributesVisible(liBoFi);</span>
<span class="nc" id="L308">		this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);</span>
<span class="nc" id="L309">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Die Methode
	 * setSingleAttributesUnvisible macht folgendes: Zunaechst wird das
	 * AttributeModel, das mit der TextBoxFigure verknuepft ist, auf unvisible
	 * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0
	 * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure
	 * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann
	 * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der
	 * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt
	 * wird. Also wird die TextBoxFigure wieder um die Position der
	 * ListBoxFigure verschoben.
	 * 
	 * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen
	 * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt
	 * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller
	 * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer
	 * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-
	 * sitioniert.
	 * 
	 * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu
	 * gezeichnet.
	 */
	public void setSingleAttributeUnvisibleOf(TextBoxFigure teBoFi) {
<span class="nc" id="L334">		ListBoxFigure liBoFi = (ListBoxFigure) teBoFi.getParent();</span>
<span class="nc" id="L335">		this.getListBoxFigureBuilder().setSingleAttributeUnvisible(teBoFi);</span>
<span class="nc" id="L336">		this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);</span>
<span class="nc" id="L337">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Die Methode
	 * setAllAttributesUnvisible macht folgendes: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind und keinen Wert
	 * null haben, auf unvisible gesetzt. Dann wird die Weite von allen Teilen
	 * der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden gleich dem
	 * Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die TextBoxFigure
	 * sind, geschieht dann folgendes: Die DisplayBox wird erneut berechnet. Die
	 * Be- rechnung der DisplayBox hat zur Folge, dass der Ort der Figure wieder
	 * auf 0,0 gesetzt wird. Also wird die TextBoxFigure wieder um die Position
	 * der ListBoxFigure verschoben.
	 * 
	 * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen
	 * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt
	 * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller
	 * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer
	 * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-
	 * sitioniert.
	 * 
	 * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu
	 * gezeichnet.
	 */
	public void setStaticAttributesUnvisibleOf(ListBoxFigure liBoFi) {
<span class="nc" id="L362">		this.getListBoxFigureBuilder().setStaticAttributesUnvisible(liBoFi);</span>
<span class="nc" id="L363">		this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);</span>
<span class="nc" id="L364">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Die Methode
	 * setAllAttributesUnvisible macht folgendes: Zunaechst werden alle
	 * AttributeModels, die in der ListBoxFigure enthalten sind und keinen Wert
	 * null haben, auf unvisible gesetzt. Dann wird die Weite von allen Teilen
	 * der ListBoxFigure auf 0 (null) gesetzt, und die Orte werden gleich dem
	 * Ort der ListBoxFigure gesetzt. Mit allen TeilFiguren, die TextBoxFigure
	 * sind, geschieht dann folgendes: Die DisplayBox wird erneut berechnet. Die
	 * Be- rechnung der DisplayBox hat zur Folge, dass der Ort der Figure wieder
	 * auf 0,0 gesetzt wird. Also wird die TextBoxFigure wieder um die Position
	 * der ListBoxFigure verschoben.
	 * 
	 * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen
	 * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt
	 * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller
	 * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer
	 * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-
	 * sitioniert.
	 * 
	 * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu
	 * gezeichnet.
	 */
	public void setStaticAttributesVisibleOf(ListBoxFigure liBoFi) {
<span class="nc" id="L389">		this.getListBoxFigureBuilder().setStaticAttributesVisible(liBoFi);</span>
<span class="nc" id="L390">		this.initializeListBoxFigureAndUpdateExplorerFigure(liBoFi);</span>
<span class="nc" id="L391">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>