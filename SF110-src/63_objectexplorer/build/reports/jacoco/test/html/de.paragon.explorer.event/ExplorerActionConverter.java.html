<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExplorerActionConverter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">63_objectexplorer</a> &gt; <a href="index.source.html" class="el_package">de.paragon.explorer.event</a> &gt; <span class="el_source">ExplorerActionConverter.java</span></div><h1>ExplorerActionConverter.java</h1><pre class="source lang-java linenums">/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 * 
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 **/
package de.paragon.explorer.event;

import de.paragon.explorer.figure.ExplorerFigure;
import de.paragon.explorer.figure.ExplorerFigureBuilder;
import de.paragon.explorer.figure.ListBoxFigure;
import de.paragon.explorer.figure.ListBoxFigureBuilder;
import de.paragon.explorer.figure.TextBoxFigure;
import de.paragon.explorer.model.AttributeModel;
import de.paragon.explorer.model.ExplorerModelBuilder;
import de.paragon.explorer.model.ObjectHeaderModel;
import de.paragon.explorer.model.ObjectModel;
import de.paragon.explorer.util.ConnectionBuilder;
import de.paragon.explorer.util.ObjectViewManager;
import de.paragon.explorer.util.PropertyManager;
import de.paragon.explorer.util.StandardEnumeration;

/**
 * Kommentar: Diese Klasse empfaengt Explorer-Spezifische Aktionen,die sie vom
 * EventConverter erhalten hat. Aufgabe ist es, diese Aktionen an die Builder
 * weiterzuleiten.
 */
public class ExplorerActionConverter {
	private static ExplorerActionConverter	singleton;

	public static ExplorerActionConverter getInstance() {
<span class="nc" id="L45">		return ExplorerActionConverter.getSingleton();</span>
	}

	private static ExplorerActionConverter getSingleton() {
<span class="nc bnc" id="L49" title="All 2 branches missed.">		if (ExplorerActionConverter.singleton == null) {</span>
<span class="nc" id="L50">			ExplorerActionConverter.setSingleton(new ExplorerActionConverter());</span>
		}
<span class="nc" id="L52">		return ExplorerActionConverter.singleton;</span>
	}

	private static void setSingleton(ExplorerActionConverter builder) {
<span class="nc" id="L56">		ExplorerActionConverter.singleton = builder;</span>
<span class="nc" id="L57">	}</span>

	public ExplorerActionConverter() {
<span class="nc" id="L60">		super();</span>
<span class="nc" id="L61">	}</span>

	/**
	 * draw bedeutet, dass nur die im Argument angebene Figur gezeichnet wird.
	 * draw wird immer dann aufgerufen, wenn sich die Stelle der zu zeich-
	 * nenden Figure nicht geaendert hat.
	 */
	public void draw(ListBoxFigure liBoFi) {
<span class="nc" id="L69">		this.getExplorerFigureBuilder().draw(liBoFi);</span>
<span class="nc" id="L70">	}</span>

	private ConnectionBuilder getConnectionBuilder() {
<span class="nc" id="L73">		return ConnectionBuilder.getInstance();</span>
	}

	private ExplorerFigureBuilder getExplorerFigureBuilder() {
<span class="nc" id="L77">		return ExplorerFigureBuilder.getInstance();</span>
	}

	private ExplorerModelBuilder getExplorerModelBuilder() {
<span class="nc" id="L81">		return ExplorerModelBuilder.getInstance();</span>
	}

	private ListBoxFigureBuilder getListBoxFigureBuilder() {
<span class="nc" id="L85">		return ListBoxFigureBuilder.getInstance();</span>
	}

	/**
	 * Kommentar: Diese Methode geht davon aus, dass die ueberge- bene
	 * TextBoxFigure mit einem AttributeModel verknuepft ist. Anhand der
	 * TextBoxFigure werden zunaechst alle existierenden ListBoxFigures
	 * ausfindig gemacht. Alle diese werden durchsucht nach dem Object. Dieses
	 * wird dann der Rueckgabevariablen zugewiesen. Wird keines gefunden, wird
	 * also null zurueck- gegeben.
	 */
	private ListBoxFigure getListBoxFigureToShow(TextBoxFigure teBoFi) {
		StandardEnumeration enumeration;
<span class="nc" id="L98">		AttributeModel attrModl = (AttributeModel) teBoFi.getModel();</span>
<span class="nc" id="L99">		ListBoxFigure liBoFiToShow = null;</span>
		ObjectModel tempObjModl;
<span class="nc" id="L101">		enumeration = attrModl.getObjectModel().getExplorerModel().getObjectModels();</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">		while (enumeration.hasMoreElements()) {</span>
<span class="nc" id="L103">			tempObjModl = (ObjectModel) enumeration.nextElement();</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">			if (tempObjModl.getObject() == attrModl.getValue()) {</span>
<span class="nc" id="L105">				liBoFiToShow = (ListBoxFigure) tempObjModl.getFigure();</span>
			}
		}
<span class="nc" id="L108">		return liBoFiToShow;</span>
	}

	/**
	 * Kommentar: Eine Figure wird bewegt, wenn -wie bei normalen Fenstern- die
	 * linke Maustaste gedrueckt gehalten wird und gleichzeitig verschoben wird.
	 * Ist dies geschehen, so gibt der DrawingFrameEventConverter an den
	 * ExplorerActionConverter dies weiter. Das weitere Bewegen erfolgt durch
	 * den Explorer- FigureBuilder.
	 */
	public void moveFigureBy(ListBoxFigure liBoFi, int x, int y) {
<span class="nc" id="L119">		this.getExplorerFigureBuilder().moveFigureBy(liBoFi, x, y);</span>
<span class="nc" id="L120">	}</span>

	/**
	 * Diese Methode loescht eine einzelne Connection. Zunaechst werden die
	 * Referenzen auf die Connection von dem AttributeModell und von der Ex-
	 * plorerFigure entfernt. Dann werden die Referenzen von den beiden Object-
	 * modellen, auf die bzw. von denen eine Referenz dargestellt wird,
	 * geloescht.
	 */
	private void removeConnection(TextBoxFigure teBoFi) {
<span class="nc" id="L130">		this.getConnectionBuilder().removeSingleConnection((AttributeModel) teBoFi.getModel());</span>
<span class="nc" id="L131">		ListBoxFigure liBoFi = (ListBoxFigure) teBoFi.getParent();</span>
<span class="nc" id="L132">		this.getExplorerFigureBuilder().update((ExplorerFigure) liBoFi.getParent());</span>
<span class="nc" id="L133">	}</span>

	public void setInForeground(ListBoxFigure liBoFi) {
<span class="nc" id="L136">		this.getExplorerFigureBuilder().setInForeground(liBoFi);</span>
<span class="nc" id="L137">	}</span>

	/**
	 * Kommentar: Diese Methode geht so vor: Die Methode setAllAttributesVisible
	 * macht folgendes: Zunaechst werden alle AttributeModels auf visible
	 * gesetzt. Dann wird die Weite von allen Teilen der ListBoxFigure auf 0
	 * (null) gesetzt, und die Orte werden gleich dem Ort der ListBoxFigure
	 * gesetzt. Mit allen TeilFiguren, die TextBoxFigure sind, geschieht dann
	 * folgendes: Die DisplayBox wird erneut berechnet. Die Be- rechnung der
	 * DisplayBox hat zur Folge, dass der Ort der Figure wieder auf 0,0 gesetzt
	 * wird. Also wird die TextBoxFigure wieder um die Position der
	 * ListBoxFigure verschoben.
	 * 
	 * Nach der Methode setAllAttributesUnvisible sind alle Voraussetzungen
	 * geschaffen, um initializeListBoxFigure anzuwenden. Diese Methode setzt
	 * alle Weiten auf ein einheit- liches Mass, naemlich das Maximum aller
	 * sicht- baren Figuren. Anschliessend werden alle Figuren je nach ihrer
	 * Erscheinung (Stelle in der Liste und (Sichtbarkeit) richtig po-
	 * sitioniert.
	 * 
	 * Schliesslich wird noch upgedated (oh Gott!), d.h. geloescht und neu
	 * gezeichnet.
	 */
	// private void setSingleAttributeVisibleOf(TextBoxFigure teBoFi) {
	// ListBoxFigure liBoFi = (ListBoxFigure) teBoFi.getParent();
	// this.getListBoxFigureBuilder().setSingleAttributeVisible(teBoFi);
	// this.getListBoxFigureBuilder().initializeListBoxFigure(liBoFi);
	// this.getExplorerFigureBuilder().update((ExplorerFigure)
	// liBoFi.getParent());
	// }
	// private void showAllReferences(ListBoxFigure liBoFi) {
	// AttributeModel attrModl = null;
	// this.draw(liBoFi);
	// StandardEnumeration attrModls = ((ObjectModel)
	// liBoFi.getModel()).getAttributeModels();
	// while (attrModls.hasMoreElements()) {
	// attrModl = ((de.paragon.explorer.model.AttributeModel)
	// attrModls.nextElement());
	// if (!(attrModl.isAttributePrimitive())) {
	// this.showReferenceFor((TextBoxFigure) attrModl.getFigure());
	// this.setSingleAttributeVisibleOf((TextBoxFigure) attrModl.getFigure());
	// }
	// }
	// }
	// private void showAllReferencesRec(ListBoxFigure liBoFi) {
	// AttributeModel attrModl = null;
	// this.draw(liBoFi);
	// de.paragon.explorer.util.StandardEnumeration attrModls = ((ObjectModel)
	// liBoFi.getModel()).getAttributeModels();
	// while (attrModls.hasMoreElements()) {
	// attrModl = ((de.paragon.explorer.model.AttributeModel)
	// attrModls.nextElement());
	// if (attrModl.getConnectionModel() == null) {
	// this.showReferenceFor((TextBoxFigure) attrModl.getFigure());
	// }
	// }
	// attrModls = ((ObjectModel) liBoFi.getModel()).getAttributeModels();
	// while (attrModls.hasMoreElements()) {
	// attrModl = ((de.paragon.explorer.model.AttributeModel)
	// attrModls.nextElement());
	// if (!attrModl.isAttributePrimitive()) {
	// this.showAllReferencesRec((ListBoxFigure)
	// attrModl.getConnectionModel().getHeaderModel().getObjectModel().getFigure());
	// }
	// }
	// }
	/**
	 * Kommentar: Zunaechst wird die zur TextBoxFigure gehoerige ListBoxFigure
	 * neu gezeichnet, sodass sie (zunaechst) im Vordergrund erscheint. Darueber
	 * kommen nur noch die beiden unten beschriebenen Figuren. Anschliessend
	 * wird die zu zeigende ListBoxFigure gesucht, nach vorn gesetzt und
	 * gezeichnet. Analog dazu wird der verbindende Pfeil gesucht, nach vorn
	 * gesetzt und gezeichnet.
	 */
	public void showInForeground(TextBoxFigure teBoFi) {
<span class="nc" id="L212">		this.draw((ListBoxFigure) teBoFi.getParent());</span>
<span class="nc" id="L213">		this.showReferenceFor(teBoFi);</span>
<span class="nc" id="L214">	}</span>

	/**
	 * Kommentar: Diese Methode geht davon aus, dass die uebergebene
	 * TextBoxFigure eine mit AttributeModel ist. Beim Zeigen einer Referenz ist
	 * die Aktion abhaengig von den bereits existierenden Figuren: 1. Die
	 * ListBoxFigure fuer das entsprechende Objekt existiert schon; 2. Die
	 * entsprechende ListBoxFigure existiert noch nicht. Im ersten Fall wird die
	 * Figur nach vorn gesetzt. Danach muessen zwei weitere Moeglichkeiten
	 * unterschieden werden: 1.a. Der Referenzpfeil existiert auch schon; 1.b.
	 * Der Pfeil existiert nicht. Im Fall a. wird der Pfeil nach vorn gesetzt
	 * und gezeichnet. Im Fall b. wird der Pfeil hinzugefuegt und anschliessend
	 * nur die Figur und der Pfeil gezeichnet. Im zweiten Fall, falls die Figur
	 * nicht da ist, wird die Figur, anschliessend der Pfeil gesetzt. Dann
	 * werden nur die Figur und der Pfeil gezeichnet. &quot;show&quot; soll bedeuten, dass
	 * immer zuerst geguckt wird, ob die entsprechende Figure bereits existiert.
	 * Davon ist abhaengig, ob sie gezeichnet wird.
	 */
	private void showReferenceFor(TextBoxFigure teBoFi) {
<span class="nc" id="L233">		ListBoxFigure liBoFiToShow = this.getListBoxFigureToShow(teBoFi);</span>
		// Liefert mir die darzustellende ListBoxFigure zurueck
<span class="nc bnc" id="L235" title="All 2 branches missed.">		if (liBoFiToShow == null) {</span>
			// this.getExplorerModelBuilder().handleAttributeModel((de.paragon.explorer.model.AttributeModel)teBoFi.getModel());
<span class="nc" id="L237">			this.getExplorerModelBuilder().handleAttributeModel(teBoFi);</span>
		}
		else {
<span class="nc" id="L240">			this.getExplorerFigureBuilder().drawInForeground(liBoFiToShow);</span>
<span class="nc" id="L241">			this.getConnectionBuilder().showConnection(teBoFi, liBoFiToShow);</span>
		}
<span class="nc" id="L243">	}</span>

	public void updateAllAttributesOf(ListBoxFigure liBoFi) {
		// de.paragon.explorer.model.AttributeModel attrModl = null;
<span class="nc" id="L247">		StandardEnumeration attrModls = ((ObjectModel) liBoFi.getModel()).getAttributeModels();</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">		while (attrModls.hasMoreElements()) {</span>
<span class="nc" id="L249">			this.updateAttribute((AttributeModel) attrModls.nextElement());</span>
		}
<span class="nc" id="L251">		this.updateObject(liBoFi);</span>
<span class="nc" id="L252">	}</span>

	public void updateAttribute(AttributeModel attrModl) {
<span class="nc bnc" id="L255" title="All 2 branches missed.">		if (!attrModl.isAttributePrimitive()) {</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">			if (attrModl.getConnectionModel() != null) {</span>
<span class="nc" id="L257">				this.removeConnection((TextBoxFigure) attrModl.getFigure());</span>
<span class="nc" id="L258">				this.showReferenceFor((TextBoxFigure) attrModl.getFigure());</span>
			}
		}
<span class="nc" id="L261">	}</span>

	public void updateObject(ListBoxFigure liBoFi) {
<span class="nc" id="L264">		this.getListBoxFigureBuilder().updateObject(liBoFi);</span>
<span class="nc" id="L265">		this.getListBoxFigureBuilder().initializeListBoxFigure(liBoFi);</span>
<span class="nc" id="L266">		this.getExplorerFigureBuilder().update((ExplorerFigure) liBoFi.getParent());</span>
<span class="nc" id="L267">	}</span>

	public void saveAttribute(ObjectHeaderModel newModel) {
		//
<span class="nc bnc" id="L271" title="All 2 branches missed.">		if (newModel != null) {</span>
<span class="nc" id="L272">			ObjectModel objectModel = newModel.getObjectModel();</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">			if (objectModel != null) {</span>
<span class="nc" id="L274">				ObjectViewManager objectViewManager = objectModel.getObjectViewManager();</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">				if (objectViewManager != null) {</span>
<span class="nc" id="L276">					boolean newValueHideNull = objectViewManager.isNullAttributesVisible();</span>
<span class="nc" id="L277">					boolean newValueHideStatic = objectViewManager.isStaticAttributesVisible();</span>
<span class="nc" id="L278">					boolean newValueHideUnexplored = objectViewManager.isUnexploredAttributesVisible();</span>
<span class="nc" id="L279">					PropertyManager.getInstance().setHideAttributes(newValueHideNull, newValueHideStatic, newValueHideUnexplored);</span>
				}
			}
		}
<span class="nc" id="L283">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>