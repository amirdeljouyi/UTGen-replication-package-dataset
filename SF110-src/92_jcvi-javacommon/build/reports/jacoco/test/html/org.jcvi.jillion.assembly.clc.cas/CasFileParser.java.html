<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CasFileParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.clc.cas</a> &gt; <span class="el_source">CasFileParser.java</span></div><h1>CasFileParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Oct 27, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.assembly.clc.cas;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import org.jcvi.jillion.assembly.clc.cas.CasFileVisitor.CasVisitorCallback;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.internal.core.io.RandomAccessFileInputStream;

public final class CasFileParser {
	
	
<span class="nc" id="L47">	private static final byte[] CAS_MAGIC_NUMBER = new byte[]{</span>
        (byte)0x43,
        (byte)0x4c,
        (byte)0x43,
        (byte)0x80,
        (byte)0x00,
        (byte)0x00,
        (byte)0x00,
        (byte)0x01,
    };
	
    private  int numberOfBytesForContigPosition,numberOfBytesForContigNumber;
    private  long numberOfReads;
    private CasScoringScheme scoringScheme;
    private final File casFile;
    
<span class="nc" id="L63">    public CasFileParser(File file) throws IOException{</span>
       /* parseMetaData(file,visitor);
        if(parseMatches){
            parseMatches(file,visitor);
        }
        visitor.visitEndOfFile();
        */
<span class="nc bnc" id="L70" title="All 2 branches missed.">    	if(file ==null){</span>
<span class="nc" id="L71">    		throw new NullPointerException(&quot;cas file can not be null&quot;);</span>
    	}
<span class="nc" id="L73">    	this.casFile = file;</span>
<span class="nc" id="L74">    }</span>
    
    public void accept(CasFileVisitor visitor) throws IOException{
<span class="nc" id="L77">    	parseMetaData(visitor);</span>
<span class="nc" id="L78">    	CasVisitorCallbackImpl callback = new CasVisitorCallbackImpl();</span>
<span class="nc" id="L79">    	CasMatchVisitor matchVisitor = visitor.visitMatches(callback);</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">    	if(matchVisitor!=null){</span>
    		//need to visit matches
<span class="nc" id="L82">        	visitMatches(callback, matchVisitor);</span>

    	}
    	//done the file
<span class="nc bnc" id="L86" title="All 2 branches missed.">		if(callback.keepParsing()){</span>
<span class="nc" id="L87">			visitor.visitEnd();</span>
		}else{
<span class="nc" id="L89">			visitor.halted();</span>
		}
<span class="nc" id="L91">	}</span>
    	
    private void visitMatches(CasVisitorCallbackImpl callback,
    		CasMatchVisitor visitor) throws IOException {
<span class="nc" id="L95">        DataInputStream dataIn = new DataInputStream(new BufferedInputStream(new FileInputStream(casFile)));</span>
        try{
<span class="nc" id="L97">        IOUtil.blockingSkip(dataIn, 16);</span>
<span class="nc bnc" id="L98" title="All 4 branches missed.">        for(int i=0; callback.keepParsing() &amp;&amp; i&lt;numberOfReads; i++){</span>
<span class="nc" id="L99">            byte info = dataIn.readByte();</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">            boolean hasMatch= (info &amp; 0x01)!=0;</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">            boolean hasMultipleMatches= (info &amp; 0x02)!=0;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">            boolean hasMultipleAlignments= (info &amp; 0x04)!=0;</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            boolean isPartOfPair= (info &amp; 0x08)!=0;</span>
<span class="nc bnc" id="L104" title="All 4 branches missed.">            long totalNumberOfMatches=hasMatch?1:0, numberOfReportedAlignments=hasMatch?1:0;</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">            if(hasMultipleMatches){                </span>
<span class="nc" id="L106">                totalNumberOfMatches = CasUtil.parseByteCountFrom(dataIn) +2;</span>
            }
<span class="nc bnc" id="L108" title="All 2 branches missed.">            if(hasMultipleAlignments){</span>
<span class="nc" id="L109">                numberOfReportedAlignments = CasUtil.parseByteCountFrom(dataIn) +2;</span>
            }
            
<span class="nc" id="L112">            int score=0;</span>
<span class="nc" id="L113">            CasAlignment chosenAlignment=null;</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">            if(hasMatch){</span>
           
<span class="nc" id="L116">                long numberOfBytesInForThisMatch =CasUtil.parseByteCountFrom(dataIn);</span>
<span class="nc" id="L117">                long contigSequenceId = CasUtil.readCasUnsignedInt(dataIn, this.numberOfBytesForContigNumber);</span>
<span class="nc" id="L118">                long startPosition = CasUtil.readCasUnsignedInt(dataIn, this.numberOfBytesForContigPosition);</span>
<span class="nc" id="L119">                boolean isreverse = dataIn.readBoolean();</span>
<span class="nc" id="L120">                DefaultCasAlignment.Builder builder = new DefaultCasAlignment.Builder(</span>
                                                    contigSequenceId, startPosition, 
                                                    isreverse);
<span class="nc" id="L123">                long count=0;</span>
                
<span class="nc bnc" id="L125" title="All 2 branches missed.">                while(count &lt;numberOfBytesInForThisMatch){</span>
<span class="nc" id="L126">                    short matchValue = CasUtil.readCasUnsignedByte(dataIn);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">                    if(matchValue == 255){</span>
<span class="nc" id="L128">                        builder.addPhaseChange(dataIn.readByte());                        </span>
<span class="nc" id="L129">                        count++;</span>
                    }
<span class="nc bnc" id="L131" title="All 2 branches missed.">                    else if(matchValue&lt;128){</span>
<span class="nc" id="L132">                        builder.addRegion(CasAlignmentRegionType.MATCH_MISMATCH, matchValue +1);                        </span>
                    }
<span class="nc bnc" id="L134" title="All 2 branches missed.">                    else if(matchValue&lt;192){</span>
<span class="nc" id="L135">                        builder.addRegion(CasAlignmentRegionType.INSERT, matchValue -127);</span>
                    }
                    else{
<span class="nc" id="L138">                        builder.addRegion(CasAlignmentRegionType.DELETION, matchValue -191);</span>
                    }
<span class="nc" id="L140">                    count++;</span>
<span class="nc" id="L141">                }</span>
<span class="nc" id="L142">                chosenAlignment =builder.build();</span>
            }
<span class="nc" id="L144">            visitor.visitMatch(new DefaultCasMatch(hasMatch, totalNumberOfMatches, numberOfReportedAlignments,</span>
                    isPartOfPair, chosenAlignment,score));
        }
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if(callback.keepParsing()){</span>
<span class="nc" id="L148">        	visitor.visitEnd();</span>
        }else{
<span class="nc" id="L150">        	visitor.halted();</span>
        }
        }finally{
<span class="nc" id="L153">            IOUtil.closeAndIgnoreErrors(dataIn);</span>
        }
        
<span class="nc" id="L156">    }</span>
    private void parseMetaData(CasFileVisitor visitor) throws IOException {
<span class="nc" id="L158">    	RandomAccessFile randomAccessFile = new RandomAccessFile(casFile,&quot;r&quot;);</span>
<span class="nc" id="L159">    	RandomAccessFileInputStream in=null;</span>
    	try{
<span class="nc" id="L161">    		in = new RandomAccessFileInputStream(randomAccessFile);</span>
<span class="nc" id="L162">    		byte[] magicNumber = IOUtil.toByteArray(in, 8);</span>
	    	
<span class="nc bnc" id="L164" title="All 2 branches missed.">    	 if(!Arrays.equals(CAS_MAGIC_NUMBER, magicNumber)){</span>
<span class="nc" id="L165">             throw new IllegalArgumentException(&quot;input stream not a valid cas file wrong magic number&quot;);</span>
         }
    	 //the cas file puts the header at the end of the file
    	 //perhaps to make it easier to modify later?
    	 //so we have to skip over all the matches (possibly gigabytes of data)
<span class="nc" id="L170">    	 BigInteger headerOffset = CasUtil.readCasUnsignedLong(in);</span>
<span class="nc" id="L171">    	 randomAccessFile.seek(headerOffset.longValue());</span>
    	 
<span class="nc" id="L173">    	 long numberOfContigSequences = CasUtil.readCasUnsignedInt(in);</span>
         
<span class="nc" id="L175">         numberOfReads = CasUtil.readCasUnsignedInt(in);</span>
        
<span class="nc" id="L177">          visitor.visitMetaData(numberOfContigSequences, numberOfReads);</span>
<span class="nc" id="L178">          String nameOfAssemblyProgram = CasUtil.parseCasStringFrom(in);</span>
<span class="nc" id="L179">          String version = CasUtil.parseCasStringFrom(in);</span>
<span class="nc" id="L180">          String parameters = CasUtil.parseCasStringFrom(in);</span>
<span class="nc" id="L181">          visitor.visitAssemblyProgramInfo(nameOfAssemblyProgram, version, parameters);</span>
          
<span class="nc" id="L183">          long numberOfContigFiles =CasUtil.parseByteCountFrom(in);</span>
<span class="nc" id="L184">         visitor.visitNumberOfReferenceFiles(numberOfContigFiles);            </span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">          for(long i=0; i&lt; numberOfContigFiles; i++){</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">            boolean twoFiles =(in.read() &amp; 0x01)==1;</span>
<span class="nc" id="L187">            long numberOfSequencesInFile = CasUtil.readCasUnsignedInt(in);</span>
<span class="nc" id="L188">            BigInteger residuesInFile = CasUtil.readCasUnsignedLong(in);</span>
<span class="nc" id="L189">            List&lt;String&gt; names = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L190">            names.add(CasUtil.parseCasStringFrom(in));</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">            if(twoFiles){</span>
<span class="nc" id="L192">                names.add(CasUtil.parseCasStringFrom(in));</span>
            }
<span class="nc" id="L194">            visitor.visitReferenceFileInfo(new DefaultCasFileInfo(names, numberOfSequencesInFile, residuesInFile));</span>
          }
          
<span class="nc" id="L197">          long numberOfReadFiles =CasUtil.parseByteCountFrom(in);</span>
<span class="nc" id="L198">          visitor.visitNumberOfReadFiles(numberOfReadFiles);            </span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">           for(long i=0; i&lt; numberOfReadFiles; i++){</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">             boolean twoFiles =(in.read() &amp; 0x01)==1;</span>
<span class="nc" id="L201">             long numberOfSequencesInFile = CasUtil.readCasUnsignedInt(in);</span>
<span class="nc" id="L202">             BigInteger residuesInFile = CasUtil.readCasUnsignedLong(in);</span>
<span class="nc" id="L203">             List&lt;String&gt; names = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L204">             names.add(CasUtil.parseCasStringFrom(in));</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">             if(twoFiles){</span>
<span class="nc" id="L206">                 names.add(CasUtil.parseCasStringFrom(in));</span>
             }
<span class="nc" id="L208">             visitor.visitReadFileInfo(new DefaultCasFileInfo(names, numberOfSequencesInFile, residuesInFile));</span>
           }
       
<span class="nc" id="L211">          CasScoreType scoreType = CasScoreType.valueOf((byte)in.read());</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">          if(scoreType != CasScoreType.NO_SCORE){</span>
<span class="nc" id="L213">              CasAlignmentScoreBuilder alignmentScoreBuilder = new CasAlignmentScoreBuilder()</span>
<span class="nc" id="L214">                                  .firstInsertion(CasUtil.readCasUnsignedShort(in))</span>
<span class="nc" id="L215">                                  .insertionExtension(CasUtil.readCasUnsignedShort(in))</span>
<span class="nc" id="L216">                                  .firstDeletion(CasUtil.readCasUnsignedShort(in))</span>
<span class="nc" id="L217">                                  .deletionExtension(CasUtil.readCasUnsignedShort(in))</span>
<span class="nc" id="L218">                                  .match(CasUtil.readCasUnsignedShort(in))</span>
<span class="nc" id="L219">                                  .transition(CasUtil.readCasUnsignedShort(in))</span>
<span class="nc" id="L220">                                  .transversion(CasUtil.readCasUnsignedShort(in))</span>
<span class="nc" id="L221">                                  .unknown(CasUtil.readCasUnsignedShort(in));</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">              if(scoreType == CasScoreType.COLOR_SPACE_SCORE){</span>
<span class="nc" id="L223">                  alignmentScoreBuilder.colorSpaceError(IOUtil.readUnsignedShort(in));</span>
              }
<span class="nc" id="L225">              CasAlignmentScore score = alignmentScoreBuilder.build();</span>
<span class="nc" id="L226">              CasAlignmentType alignmentType = CasAlignmentType.valueOf((byte)in.read());</span>
<span class="nc" id="L227">              scoringScheme = new DefaultCasScoringScheme(scoreType, score, alignmentType);</span>
<span class="nc" id="L228">              visitor.visitScoringScheme(scoringScheme);</span>
<span class="nc" id="L229">              long maxContigLength=0;</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">              for(long i=0; i&lt;numberOfContigSequences; i++){</span>
<span class="nc" id="L231">                  long contigLength = CasUtil.readCasUnsignedInt(in);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">                  boolean isCircular = (IOUtil.readUnsignedShort(in) &amp; 0x01)==1;</span>
<span class="nc" id="L233">                  visitor.visitReferenceDescription(new DefaultCasReferenceDescription(contigLength, isCircular));</span>
<span class="nc" id="L234">                  maxContigLength = Math.max(maxContigLength, contigLength);</span>
              }
<span class="nc" id="L236">              numberOfBytesForContigNumber = CasUtil.numberOfBytesRequiredFor(numberOfContigSequences);</span>
                          
<span class="nc" id="L238">              numberOfBytesForContigPosition =CasUtil.numberOfBytesRequiredFor(maxContigLength);</span>
              //contig pairs not currently used so ignore them
              
          }
    	 
    	}finally{
<span class="nc" id="L244">    		IOUtil.closeAndIgnoreErrors(in, randomAccessFile);</span>
    	}
        
        
<span class="nc" id="L248">    }</span>
    
   
    
    
<span class="nc" id="L253">    private static final class CasVisitorCallbackImpl implements CasVisitorCallback{</span>
<span class="nc" id="L254">    	private final AtomicBoolean keepParsing = new AtomicBoolean(true);</span>
		@Override
		public boolean canCreateMemento() {
<span class="nc" id="L257">			return false;</span>
		}

		@Override
		public CasVisitorMemento createMemento() {
<span class="nc" id="L262">			throw new UnsupportedOperationException(&quot;mementos not supported&quot;);</span>
		}

		@Override
		public void haltParsing() {
<span class="nc" id="L267">			keepParsing.set(false);			</span>
<span class="nc" id="L268">		}</span>
		
		public boolean keepParsing(){
<span class="nc" id="L271">			return keepParsing.get();</span>
		}
    	
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>