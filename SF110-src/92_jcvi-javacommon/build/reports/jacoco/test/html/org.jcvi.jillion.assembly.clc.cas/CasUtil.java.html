<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CasUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.clc.cas</a> &gt; <span class="el_source">CasUtil.java</span></div><h1>CasUtil.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Oct 27, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.assembly.clc.cas;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;

import org.jcvi.jillion.assembly.clc.cas.read.CasPlacedRead;
import org.jcvi.jillion.assembly.clc.cas.read.DefaultCasPlacedReadFromCasAlignmentBuilder;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.io.IOUtil.Endian;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
/**
 * {@code CasUtil} is a utility class for dealing with the binary
 * encodings inside a .cas file.
 * @author dkatzel
 *
 *
 */
public final class CasUtil {

<span class="nc" id="L52">    private static final Charset UTF_8 = Charset.forName(&quot;UTF-8&quot;);</span>
    
    private CasUtil(){}
    /**
     * Get the number of bytes required to store the given number.
     * To save space, .cas files use a varible length field to 
     * store counters.  The length of the field depends on the max number
     * to be stored.
     * @param i the number to store.
     * @return the number of bytes needed to store the given 
     * input number as an int (which may be {@code 0}).
     * @throws IllegalArgumentException if {@code i&lt;1}.
     */
    public static int numberOfBytesRequiredFor(long i){
<span class="nc bnc" id="L66" title="All 2 branches missed.">        if(i &lt; 1){</span>
<span class="nc" id="L67">            throw new IllegalArgumentException(&quot;input number must be &gt; 0 : &quot; + i);</span>
        }
       
<span class="nc" id="L70">        return (int)Math.ceil(Math.log(i)/Math.log(256));</span>
    }
    /**
     * Parse a byte count from the given {@link InputStream}.
     * To save space, CAS files have a variable length field for byte counts
     * which range from 1 to 5 bytes long.
     * @param in the inputstream to read.
     * @return a byte count as a long; should always be &gt;=0.
     * @throws IOException if there is a problem reading from the inputstream
     * @throws NullPointerException if {@code in == null}.
     */
    public static long parseByteCountFrom(InputStream in) throws IOException{
        
<span class="nc" id="L83">        int firstByte =in.read();</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">        if(firstByte&lt;254){</span>
<span class="nc" id="L85">            return firstByte;</span>
        }
        
<span class="nc bnc" id="L88" title="All 2 branches missed.">        if(firstByte ==254){</span>
            //read next 2 bytes
<span class="nc" id="L90">           return readCasUnsignedShort(in);</span>
        }
<span class="nc" id="L92">        return readCasUnsignedInt(in);</span>
    }
    /**
     * parse a CAS encoded String from the given {@link InputStream}.
     * CAS files store strings in Pascal like format with 
     * the number of bytes in the string first, followed by the
     * characters in the string, there is no terminating character.
     * @param in the inputstream to parse.
     * @return the next String in the InputStream.
     * @throws IOException if there is a problem reading the String.
     * @throws NullPointerException if {@code in == null}.
     */
    public static String parseCasStringFrom(InputStream in) throws IOException{
<span class="nc" id="L105">        int length = (int)parseByteCountFrom(in);</span>
       
<span class="nc" id="L107">        byte bytes[] = IOUtil.toByteArray(in, length);</span>
        
<span class="nc" id="L109">        return new String(bytes, UTF_8);</span>
        
    }
    /**
     * Read the next unsigned byte in the given inputStream.
     * CAS files are encoded in little endian.
     * @param in the inputstream to parse.
     * @return an unsigned byte as a short.
     * @throws IOException if there is a problem reading the inputStream.
     */
    public static short readCasUnsignedByte(InputStream in) throws IOException{
<span class="nc" id="L120">        return new BigInteger(1,</span>
<span class="nc" id="L121">                 IOUtil.toByteArray(in, 1, Endian.LITTLE)).shortValue();</span>
     }
    /**
     * Read the next unsigned short in the given inputStream.
     * CAS files are encoded in little endian.
     * @param in the inputstream to parse.
     * @return an unsigned short as an int.
     * @throws IOException if there is a problem reading the inputStream.
     */
    public static int readCasUnsignedShort(InputStream in) throws IOException{
<span class="nc" id="L131">        return new BigInteger(1,</span>
<span class="nc" id="L132">                 IOUtil.toByteArray(in, 2, Endian.LITTLE)).intValue();</span>
     }
    /**
     * Read the next unsigned int in the given inputStream.
     * this is the same as {@link #readCasUnsignedInt(InputStream, int)
     * readCasUnsignedInt(in,4)}
     * CAS files are encoded in little endian.
     * @param in the inputstream to parse.
     * @return an unsigned int as an long.
     * @throws IOException if there is a problem reading the inputStream.
     * @see #readCasUnsignedInt(InputStream, int)
     */
    public static long readCasUnsignedInt(InputStream in) throws IOException{
<span class="nc" id="L145">       return readCasUnsignedInt(in, 4);</span>
    }
    /**
     * Read the next X bytes as an unsigned int in the given inputStream.
     * CAS files are encoded in little endian.
     * @param in the inputstream to parse.
     * @param numberOfBytesInNumber number of bytes to read from the inputStream.
     * @return an unsigned int as an long.
     * @throws IOException if there is a problem reading the inputStream.
     * @see #readCasUnsignedInt(InputStream, int)
     */
    public static long readCasUnsignedInt(InputStream in, int numberOfBytesInNumber) throws IOException{
<span class="nc" id="L157">        return new BigInteger(1,</span>
<span class="nc" id="L158">                 IOUtil.toByteArray(in, numberOfBytesInNumber, Endian.LITTLE)).longValue();</span>
     }
    /**
     * Read the next unsigned long in the given inputStream.
     * CAS files are encoded in little endian.
     * @param in the inputstream to parse.
     * @return an unsigned long as an {@link BigInteger}; never null.
     * @throws IOException if there is a problem reading the inputStream.
     */
    public static BigInteger readCasUnsignedLong(InputStream in) throws IOException{
<span class="nc" id="L168">        return new BigInteger(1,</span>
<span class="nc" id="L169">                 IOUtil.toByteArray(in, 8, Endian.LITTLE));</span>
     }
    
    
    public static CasPlacedRead createCasPlacedRead(CasMatch match,String readId,
            NucleotideSequence fullLengthReadBasecalls, Range traceTrimRange,
            NucleotideSequence gappedReference){
<span class="nc" id="L176">		CasAlignment alignment = match.getChosenAlignment();</span>
        
        DefaultCasPlacedReadFromCasAlignmentBuilder builder;
<span class="nc" id="L179">        long ungappedStartOffset = alignment.getStartOfMatch();</span>
<span class="nc" id="L180">        long gappedStartOffset = gappedReference.getGappedOffsetFor((int)ungappedStartOffset);</span>
<span class="nc" id="L181">        builder = new DefaultCasPlacedReadFromCasAlignmentBuilder(readId,</span>
        		gappedReference,
        		fullLengthReadBasecalls,
<span class="nc" id="L184">                alignment.readIsReversed(),</span>
                gappedStartOffset,
                traceTrimRange
               );
<span class="nc" id="L188">        List&lt;CasAlignmentRegion&gt; regionsToConsider = new ArrayList&lt;CasAlignmentRegion&gt;(alignment.getAlignmentRegions());</span>
<span class="nc" id="L189">        int lastIndex = regionsToConsider.size()-1;</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if(regionsToConsider.get(lastIndex).getType()==CasAlignmentRegionType.INSERT){</span>
<span class="nc" id="L191">            regionsToConsider.remove(lastIndex);</span>
        }
        try{
<span class="nc" id="L194">            builder.addAlignmentRegions(regionsToConsider,gappedReference);</span>
<span class="nc" id="L195">        }catch(Throwable t){</span>
<span class="nc" id="L196">            System.err.println(&quot;error computing alignment regions for &quot;+ readId);</span>
<span class="nc" id="L197">            throw new RuntimeException(t);</span>
<span class="nc" id="L198">        }</span>
        
<span class="nc" id="L200">        return builder.build();</span>
	}

    /**
     * Get the java File object for a filepath in a cas file.
     * @param workingDir the working directory this cas file was
     * created in (usually the same location as the cas file itself);
     * If workingDir is {@code null}, then the working dir is the 
     * current directory.
     * @param filePath the path to the file which may or may not
     * be relative.
     * @return a new File object that represents the file.
     * @throws FileNotFoundException if the file does not exist.
     * @throws NullPointerException if filePath is null.
     */
    public static File getFileFor(File workingDir,String filePath) throws FileNotFoundException {
<span class="nc bnc" id="L216" title="All 2 branches missed.">    	if(filePath ==null){</span>
<span class="nc" id="L217">    		throw new NullPointerException(&quot;filePath can not be null&quot;);</span>
    	}
<span class="nc bnc" id="L219" title="All 2 branches missed.">        boolean isAbsolutePath = filePath.charAt(0) == File.separatorChar;</span>
        final File dataStoreFile;
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if(isAbsolutePath){</span>
<span class="nc" id="L222">            dataStoreFile = new File(filePath);</span>
        }else{
<span class="nc" id="L224">            dataStoreFile = new File(workingDir, filePath);</span>
        }            
         
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if(!dataStoreFile.exists()){</span>
<span class="nc" id="L228">            throw new FileNotFoundException(dataStoreFile.getAbsolutePath());</span>
        }
<span class="nc" id="L230">        return dataStoreFile;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>