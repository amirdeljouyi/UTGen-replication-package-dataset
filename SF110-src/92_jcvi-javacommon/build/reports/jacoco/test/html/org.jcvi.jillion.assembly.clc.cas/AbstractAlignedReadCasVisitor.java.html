<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractAlignedReadCasVisitor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.clc.cas</a> &gt; <span class="el_source">AbstractAlignedReadCasVisitor.java</span></div><h1>AbstractAlignedReadCasVisitor.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.clc.cas;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.jcvi.jillion.assembly.clc.cas.read.CasPlacedRead;
import org.jcvi.jillion.assembly.clc.cas.read.DefaultCasPlacedReadFromCasAlignmentBuilder;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.datastore.DataStoreException;
import org.jcvi.jillion.core.datastore.DataStoreProviderHint;
import org.jcvi.jillion.core.datastore.DataStoreUtil;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.qual.QualitySequenceBuilder;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.util.iter.IteratorUtil;
import org.jcvi.jillion.core.util.iter.StreamingIterator;
import org.jcvi.jillion.fasta.nt.NucleotideFastaDataStore;
import org.jcvi.jillion.fasta.nt.NucleotideFastaFileDataStoreBuilder;
import org.jcvi.jillion.fasta.nt.NucleotideFastaRecord;
import org.jcvi.jillion.trace.Trace;
import org.jcvi.jillion.trace.TraceDataStore;
import org.jcvi.jillion.trace.fastq.FastqDataStore;
import org.jcvi.jillion.trace.fastq.FastqFileDataStoreBuilder;
import org.jcvi.jillion.trace.sff.SffFileIterator;
import org.jcvi.jillion.trace.sff.SffFlowgram;
import org.jcvi.jillion.trace.sff.SffUtil;

public abstract class AbstractAlignedReadCasVisitor extends AbstractCasFileVisitor{

	private final CasGappedReferenceDataStore gappedReferenceDataStore;

	private final File workingDir;
	
<span class="nc" id="L59">	private List&lt;StreamingIterator&lt;? extends Trace&gt;&gt; iterators = new ArrayList&lt;StreamingIterator&lt;? extends Trace&gt;&gt;();</span>
	
	
	
	public AbstractAlignedReadCasVisitor(File casFile,
<span class="nc" id="L64">			CasGappedReferenceDataStore gappedReferenceDataStore) {</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">		if(gappedReferenceDataStore ==null){</span>
<span class="nc" id="L66">			throw new NullPointerException(&quot;gapped Reference DataStore can not be null&quot;);</span>
		}
<span class="nc bnc" id="L68" title="All 2 branches missed.">		if(casFile ==null){</span>
<span class="nc" id="L69">			throw new NullPointerException(&quot;cas file can not be null&quot;);</span>
		}
<span class="nc" id="L71">		this.workingDir = casFile.getParentFile();</span>
<span class="nc" id="L72">		this.gappedReferenceDataStore = gappedReferenceDataStore;</span>
<span class="nc" id="L73">	}</span>

	public final CasGappedReferenceDataStore getGappedReferenceDataStore() {
<span class="nc" id="L76">		return gappedReferenceDataStore;</span>
	}

	@Override
	public void visitReadFileInfo(CasFileInfo readFileInfo) {
<span class="nc bnc" id="L81" title="All 2 branches missed.">		for(String filePath :readFileInfo.getFileNames()){</span>
			try {
<span class="nc" id="L83">				File file = CasUtil.getFileFor(workingDir, filePath);</span>
				
<span class="nc" id="L85">				iterators.add(createIteratorFor(file));</span>
<span class="nc" id="L86">			} catch (Exception e) {</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">				for(StreamingIterator&lt;? extends Trace&gt; iter : iterators){</span>
<span class="nc" id="L88">					IOUtil.closeAndIgnoreErrors(iter);</span>
<span class="nc" id="L89">				}</span>
<span class="nc" id="L90">				throw new IllegalStateException(&quot;error getting input read data&quot;, e);</span>
<span class="nc" id="L91">			}           </span>
<span class="nc" id="L92">        }</span>
<span class="nc" id="L93">	}</span>
	
	private StreamingIterator&lt;? extends Trace&gt; createIteratorFor(File file) throws DataStoreException{
<span class="nc" id="L96">        ReadFileType readType = ReadFileType.getTypeFromFile(file.getName());</span>
<span class="nc bnc" id="L97" title="All 4 branches missed.">           switch(readType){</span>
	            case FASTQ: 
<span class="nc" id="L99">	            	return createFastqIterator(file);</span>
	            case SFF:
<span class="nc" id="L101">	            	return createSffIterator(file);</span>
	            case FASTA:
<span class="nc" id="L103">                       return createFastaIterator(file);</span>
	            default: 
<span class="nc" id="L105">	            	throw new IllegalArgumentException(&quot;unsupported type &quot;+ file.getName());</span>
	            }
        
   }


    protected StreamingIterator&lt;? extends Trace&gt; createFastqIterator(File illuminaFile) throws DataStoreException {
		try {
<span class="nc" id="L113">			FastqDataStore datastore = new FastqFileDataStoreBuilder(illuminaFile)</span>
<span class="nc" id="L114">											.hint(DataStoreProviderHint.ITERATION_ONLY)</span>
<span class="nc" id="L115">											.build();</span>
<span class="nc" id="L116">			return datastore.iterator();</span>
<span class="nc" id="L117">		} catch (IOException e) {</span>
<span class="nc" id="L118">			throw new IllegalStateException(&quot;fastq file no longer exists! : &quot;+ illuminaFile.getAbsolutePath());</span>
		}
		
    }

    protected StreamingIterator&lt;? extends Trace&gt; createSffIterator(File sffFile) throws DataStoreException{
<span class="nc" id="L124">        return SffFileIterator.createNewIteratorFor(sffFile);</span>
    }

    protected StreamingIterator&lt;? extends Trace&gt; createFastaIterator(File fastaFile) throws DataStoreException{        
        try {
<span class="nc" id="L129">			NucleotideFastaDataStore datastore = new NucleotideFastaFileDataStoreBuilder(fastaFile)</span>
<span class="nc" id="L130">															.hint(DataStoreProviderHint.ITERATION_ONLY)</span>
<span class="nc" id="L131">															.build();</span>
			
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L134">			TraceDataStore&lt;Trace&gt; fakeQualities = DataStoreUtil.adapt(TraceDataStore.class, datastore, </span>
<span class="nc" id="L135">					new DataStoreUtil.AdapterCallback&lt;NucleotideFastaRecord, Trace&gt;() {</span>

						@Override
						public Trace get(final NucleotideFastaRecord from) {
<span class="nc" id="L139">						        int numberOfQualities =(int) from.getSequence().getLength();</span>
<span class="nc" id="L140">								byte[] qualities = new byte[numberOfQualities];</span>
<span class="nc" id="L141">								Arrays.fill(qualities, PhredQuality.valueOf(30).getQualityScore());</span>
<span class="nc" id="L142">						        final QualitySequence qualSequence = new QualitySequenceBuilder(qualities).build();</span>
<span class="nc" id="L143">							return new Trace() {</span>
								
								@Override
								public QualitySequence getQualitySequence() {
<span class="nc" id="L147">									return qualSequence;</span>
								}
								
								@Override
								public NucleotideSequence getNucleotideSequence() {

<span class="nc" id="L153">									return from.getSequence();</span>
								}
								
								@Override
								public String getId() {
<span class="nc" id="L158">									return from.getId();</span>
								}
							};
						}
				
			});
<span class="nc" id="L164">			return fakeQualities.iterator();</span>
<span class="nc" id="L165">        } catch (IOException e) {</span>
<span class="nc" id="L166">			throw new DataStoreException(&quot;error reading fasta file &quot;+ fastaFile.getAbsolutePath(),e);</span>
		}
    }
	    
    protected abstract void visitUnMatched(Trace currentTrace);

    protected abstract void  visitMatch(String referenceId, CasPlacedRead read, Trace traceOfRead);
    
	@Override
	public CasMatchVisitor visitMatches(CasVisitorCallback callback) {
		
		
<span class="nc" id="L178">		return new TraceCasMatchVisitor(IteratorUtil.createChainedStreamingIterator(iterators));</span>
		
	}
	
	private class TraceCasMatchVisitor implements CasMatchVisitor{
		private final StreamingIterator&lt;Trace&gt; chainedTraceIterator;
		
		public TraceCasMatchVisitor(
<span class="nc" id="L186">				StreamingIterator&lt;Trace&gt; chainedTraceIterator) {</span>
<span class="nc" id="L187">			this.chainedTraceIterator = chainedTraceIterator;</span>
<span class="nc" id="L188">		}</span>

		@Override
		public void visitMatch(CasMatch match) {
<span class="nc bnc" id="L192" title="All 2 branches missed.">			if(!chainedTraceIterator.hasNext()){</span>
<span class="nc" id="L193">				closeIterator();</span>
<span class="nc" id="L194">				throw new IllegalStateException(&quot;possible cas file corruption : no more reads in input files but cas file says there are more reads&quot;);</span>
			}
<span class="nc" id="L196">			Trace currentTrace = chainedTraceIterator.next();</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">			if(match.matchReported()){</span>
<span class="nc" id="L198">				CasAlignment alignment = match.getChosenAlignment();</span>
<span class="nc" id="L199">				long refIndex = alignment.getReferenceIndex();</span>
<span class="nc" id="L200">				String refId = gappedReferenceDataStore.getIdByIndex(refIndex);</span>
<span class="nc" id="L201">				CasPlacedRead read =null;</span>
<span class="nc" id="L202">				String readId = currentTrace.getId();</span>
				try {
<span class="nc bnc" id="L204" title="All 2 branches missed.">					if(refId ==null){</span>
<span class="nc" id="L205">						closeIterator();</span>
<span class="nc" id="L206">						throw new IllegalStateException(&quot;could not get get gapped reference for index &quot;+ refIndex);</span>
					
					}
<span class="nc" id="L209">					NucleotideSequence gappedReference = gappedReferenceDataStore.get(refId);</span>
<span class="nc" id="L210">					long ungappedStartOffset = alignment.getStartOfMatch();</span>
<span class="nc" id="L211">			        long gappedStartOffset = gappedReference.getGappedOffsetFor((int)ungappedStartOffset);</span>
			        
<span class="nc" id="L213">			        List&lt;CasAlignmentRegion&gt; regionsToConsider = new ArrayList&lt;CasAlignmentRegion&gt;(alignment.getAlignmentRegions());</span>
<span class="nc" id="L214">			        int lastIndex = regionsToConsider.size()-1;</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">			        if(regionsToConsider.get(lastIndex).getType()==CasAlignmentRegionType.INSERT){</span>
<span class="nc" id="L216">			            regionsToConsider.remove(lastIndex);</span>
			        }
			        
<span class="nc" id="L219">			        NucleotideSequence sequence = currentTrace.getNucleotideSequence();</span>
			        
<span class="nc" id="L221">			        Range trimRange = match.getTrimRange();</span>
<span class="nc bnc" id="L222" title="All 4 branches missed.">			        if(trimRange ==null &amp;&amp; currentTrace instanceof SffFlowgram){</span>
			        	//CLC uses the trimmed flowgrams when aligning
			        	//if the trimRange for this match isn't explicitly set
			        	//and the read is a flowgram, then use it's trim range 
<span class="nc" id="L226">			        	trimRange = SffUtil.computeTrimRangeFor((SffFlowgram)currentTrace);</span>
			        }
<span class="nc" id="L228">			        DefaultCasPlacedReadFromCasAlignmentBuilder readBuilder= new DefaultCasPlacedReadFromCasAlignmentBuilder(readId,</span>
			       		 gappedReference,
			       		sequence, 
<span class="nc" id="L231">			       		alignment.readIsReversed(), gappedStartOffset,</span>
			       		trimRange);
			        
<span class="nc" id="L234">			        readBuilder.addAlignmentRegions(regionsToConsider, gappedReference);</span>
<span class="nc" id="L235">			        read = readBuilder.build();</span>
			        
<span class="nc" id="L237">			        AbstractAlignedReadCasVisitor.this.visitMatch(refId, read, currentTrace);</span>
<span class="nc" id="L238">				} catch (Throwable e) {</span>
<span class="nc" id="L239">					closeIterator();</span>
<span class="nc" id="L240">					throw new IllegalStateException(&quot;processing read &quot; + readId + &quot; for reference &quot;+ refId, e);</span>
				
<span class="nc" id="L242">				}</span>
<span class="nc" id="L243">			}else{</span>
<span class="nc" id="L244">				AbstractAlignedReadCasVisitor.this.visitUnMatched(currentTrace);</span>
			}
			
<span class="nc" id="L247">		}</span>
		

		

		@Override
		public void visitEnd() {
<span class="nc" id="L254">			closeIterator();</span>
<span class="nc" id="L255">		}</span>

		@Override
		public void halted() {
<span class="nc" id="L259">			closeIterator();</span>
<span class="nc" id="L260">		}</span>
		
		private void closeIterator(){
<span class="nc" id="L263">			IOUtil.closeAndIgnoreErrors(chainedTraceIterator);</span>
<span class="nc" id="L264">		}</span>
	}
	
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>