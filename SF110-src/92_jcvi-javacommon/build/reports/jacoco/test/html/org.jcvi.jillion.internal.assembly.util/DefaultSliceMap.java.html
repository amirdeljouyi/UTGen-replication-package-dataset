<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultSliceMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.internal.assembly.util</a> &gt; <span class="el_source">DefaultSliceMap.java</span></div><h1>DefaultSliceMap.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Jun 16, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.internal.assembly.util;

import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

import org.jcvi.jillion.assembly.AssembledRead;
import org.jcvi.jillion.assembly.Contig;
import org.jcvi.jillion.assembly.util.CoverageMap;
import org.jcvi.jillion.assembly.util.CoverageRegion;
import org.jcvi.jillion.assembly.util.GapQualityValueStrategy;
import org.jcvi.jillion.assembly.util.Slice;
import org.jcvi.jillion.assembly.util.SliceElement;
import org.jcvi.jillion.assembly.util.SliceMap;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.datastore.DataStoreException;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.qual.QualitySequenceDataStore;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.util.iter.StreamingIterator;

public class DefaultSliceMap extends AbstractSliceMap{
	
	private final Slice[] slices;
    protected PhredQuality defaultQuality;
	    
    public static &lt;R extends AssembledRead, C extends Contig&lt;R&gt;&gt; SliceMap create(C contig, QualitySequenceDataStore qualityDataStore,
                        GapQualityValueStrategy qualityValueStrategy) throws DataStoreException{
<span class="nc" id="L57">        return new DefaultSliceMap(contig, qualityDataStore, qualityValueStrategy);</span>
    }
    
    public static &lt;PR extends AssembledRead&gt; DefaultSliceMap create(CoverageMap&lt;PR&gt; coverageMap,QualitySequenceDataStore qualityDataStore,GapQualityValueStrategy qualityValueStrategy){
<span class="nc" id="L61">        return new DefaultSliceMap(coverageMap, qualityDataStore, qualityValueStrategy);</span>
    }

   
    
    
    private DefaultSliceMap(CoverageMap&lt;? extends AssembledRead&gt; coverageMap, 
                        QualitySequenceDataStore qualityDataStore,
                        GapQualityValueStrategy qualityValueStrategy){
<span class="nc" id="L70">        this(coverageMap,qualityDataStore, qualityValueStrategy,null);</span>
<span class="nc" id="L71">    }</span>
    
    private &lt;PR extends AssembledRead,C extends Contig&lt;PR&gt;&gt;  DefaultSliceMap(
<span class="nc" id="L74">            C contig, QualitySequenceDataStore qualityDataStore,GapQualityValueStrategy qualityValueStrategy) throws DataStoreException {</span>
<span class="nc" id="L75">    	DefaultSlice.Builder builders[] = new DefaultSlice.Builder[(int)contig.getConsensusSequence().getLength()];</span>
<span class="nc" id="L76">    	StreamingIterator&lt;PR&gt; readIter = null;</span>
    	try{
<span class="nc" id="L78">    		readIter = contig.getReadIterator();</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">    		while(readIter.hasNext()){</span>
<span class="nc" id="L80">    			PR read = readIter.next();</span>
<span class="nc" id="L81">    			int start = (int)read.getGappedStartOffset();</span>
<span class="nc" id="L82">    			int i=0;</span>
<span class="nc" id="L83">    			String id =read.getId();</span>
<span class="nc" id="L84">    			Direction dir = read.getDirection();</span>
    			
<span class="nc" id="L86">    			QualitySequence fullQualities = qualityDataStore.get(id);</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">    			for(Nucleotide base : read.getNucleotideSequence()){</span>
<span class="nc" id="L88">    				PhredQuality quality = qualityValueStrategy.getQualityFor(read, fullQualities, i);</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">    				if(builders[start+i] ==null){</span>
<span class="nc" id="L90">    					builders[start+i] = new DefaultSlice.Builder();</span>
    				}
<span class="nc" id="L92">    				builders[start+i].add(id, base, quality, dir);</span>
<span class="nc" id="L93">    				i++;</span>
<span class="nc" id="L94">    			}</span>
<span class="nc" id="L95">    		}</span>
    		//done building
<span class="nc" id="L97">    		this.slices = new Slice[builders.length];</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">    		for(int i=0; i&lt;slices.length; i++){</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">    			if(builders[i] ==null){</span>
<span class="nc" id="L100">    				slices[i] = DefaultSlice.EMPTY;</span>
    			}else{
<span class="nc" id="L102">    				slices[i]= builders[i].build();</span>
    			}
    		}
    	}finally{
<span class="nc" id="L106">    		IOUtil.closeAndIgnoreErrors(readIter);</span>
    	}
<span class="nc" id="L108">    }</span>
    protected DefaultSliceMap(CoverageMap&lt;? extends AssembledRead&gt; coverageMap, 
            QualitySequenceDataStore qualityDataStore,
<span class="nc" id="L111">            GapQualityValueStrategy qualityValueStrategy, PhredQuality defaultQuality){</span>
<span class="nc" id="L112">    	int lengthOfMap = (int)getLastCoveredOffsetIn(coverageMap)+1;</span>
<span class="nc" id="L113">    	this.slices = new Slice[lengthOfMap];</span>
<span class="nc" id="L114">        this.defaultQuality = defaultQuality;</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">        for(CoverageRegion&lt;?  extends AssembledRead&gt; region : coverageMap){</span>
<span class="nc" id="L116">        	Range range = region.asRange();</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">            for(long i=range.getBegin(); i&lt;=range.getEnd(); i++ ){</span>
<span class="nc" id="L118">                List&lt;SliceElement&gt; sliceElements = createSliceElementsFor(region, i, qualityDataStore, qualityValueStrategy);</span>
<span class="nc" id="L119">                slices[(int)i] =new DefaultSlice.Builder()</span>
<span class="nc" id="L120">                                            .addAll(sliceElements)</span>
<span class="nc" id="L121">                                            .build();</span>
            
            }
<span class="nc" id="L124">        }</span>
<span class="nc" id="L125">    }</span>

    private static long getLastCoveredOffsetIn(CoverageMap&lt;?&gt; coverageMap){
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if(coverageMap.isEmpty()){</span>
<span class="nc" id="L129">            return -1L;</span>
        }
<span class="nc" id="L131">        return coverageMap.getRegion(coverageMap.getNumberOfRegions()-1).asRange().getEnd();</span>
}
    
    /**
     * @return the defaultQuality
     */
    protected PhredQuality getDefaultQuality() {
<span class="nc" id="L138">        return defaultQuality;</span>
    }

<span class="nc" id="L141">    public DefaultSliceMap(List&lt;Slice&gt; slices){</span>
<span class="nc" id="L142">    	this.slices = new Slice[slices.size()];</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">        for(int i=0; i&lt; this.slices.length; i++){</span>
<span class="nc" id="L144">        	this.slices[i] = slices.get(i);</span>
        }
<span class="nc" id="L146">    }</span>
    @Override
    public Slice getSlice(long offset) {
<span class="nc" id="L149">        return slices[(int)offset];</span>
    }
    @Override
    public long getSize() {
<span class="nc" id="L153">        return slices.length;</span>
    }
    @Override
    public Iterator&lt;Slice&gt; iterator() {
<span class="nc" id="L157">        return Arrays.&lt;Slice&gt;asList(slices).iterator();</span>
    }

	@Override
	public int hashCode() {
<span class="nc" id="L162">		final int prime = 31;</span>
<span class="nc" id="L163">		int result = 1;</span>
<span class="nc" id="L164">		result = prime * result + Arrays.hashCode(slices);</span>
<span class="nc" id="L165">		return result;</span>
	}

	@Override
	public boolean equals(Object obj) {
<span class="nc bnc" id="L170" title="All 2 branches missed.">		if (this == obj) {</span>
<span class="nc" id="L171">			return true;</span>
		}
<span class="nc bnc" id="L173" title="All 2 branches missed.">		if (obj == null) {</span>
<span class="nc" id="L174">			return false;</span>
		}
<span class="nc bnc" id="L176" title="All 2 branches missed.">		if (!(obj instanceof SliceMap)) {</span>
<span class="nc" id="L177">			return false;</span>
		}
<span class="nc" id="L179">		SliceMap other = (SliceMap) obj;</span>
<span class="nc" id="L180">		Iterator&lt;Slice&gt; iter = iterator();</span>
<span class="nc" id="L181">		Iterator&lt;Slice&gt; otherIter = other.iterator();</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">		while(iter.hasNext()){</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">			if(!otherIter.hasNext()){</span>
<span class="nc" id="L184">				return false;</span>
			}
<span class="nc bnc" id="L186" title="All 2 branches missed.">			if(!iter.next().equals(otherIter.next())){</span>
<span class="nc" id="L187">				return false;</span>
			}
		}
<span class="nc bnc" id="L190" title="All 2 branches missed.">		if(otherIter.hasNext()){</span>
<span class="nc" id="L191">			return false;</span>
		}
		
<span class="nc" id="L194">		return true;</span>
	}

    
   
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>