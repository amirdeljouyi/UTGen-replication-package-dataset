<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompactedSliceMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.internal.assembly.util</a> &gt; <span class="el_source">CompactedSliceMap.java</span></div><h1>CompactedSliceMap.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.internal.assembly.util;

import java.util.Arrays;
import java.util.Iterator;

import org.jcvi.jillion.assembly.AssembledRead;
import org.jcvi.jillion.assembly.Contig;
import org.jcvi.jillion.assembly.util.GapQualityValueStrategy;
import org.jcvi.jillion.assembly.util.Slice;
import org.jcvi.jillion.assembly.util.SliceMap;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.datastore.DataStoreException;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.qual.QualitySequenceDataStore;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.util.iter.StreamingIterator;

/**
 * @author dkatzel
 * 
 * 
 */
public final class CompactedSliceMap implements SliceMap {
<span class="nc" id="L46">    private static final PhredQuality DEFAULT_QUALITY = PhredQuality.valueOf(30);</span>
	private final CompactedSlice[] slices;
	

    public static &lt;PR extends AssembledRead&gt; CompactedSliceMap create(Contig&lt;PR&gt; contig,QualitySequenceDataStore qualityDataStore,GapQualityValueStrategy qualityValueStrategy) throws DataStoreException{
<span class="nc" id="L51">        return new CompactedSliceMap(contig, qualityDataStore, qualityValueStrategy, DEFAULT_QUALITY);</span>
    }
    public static &lt;PR extends AssembledRead&gt; CompactedSliceMap create(Contig&lt;PR&gt; contig,PhredQuality defaultQuality,GapQualityValueStrategy qualityValueStrategy) throws DataStoreException{
<span class="nc" id="L54">        return new CompactedSliceMap(contig, null, qualityValueStrategy, defaultQuality);</span>
    }
    
    public static &lt;PR extends AssembledRead&gt; CompactedSliceMap create(
    		StreamingIterator&lt;PR&gt; iter, int consensusSequenceLength,
    		QualitySequenceDataStore qualityDataStore,GapQualityValueStrategy qualityValueStrategy) throws DataStoreException{
<span class="nc" id="L60">        return new CompactedSliceMap(iter, consensusSequenceLength, qualityDataStore, qualityValueStrategy, DEFAULT_QUALITY);</span>
    }
    public static &lt;PR extends AssembledRead&gt; CompactedSliceMap create(
    		StreamingIterator&lt;PR&gt; iter, int consensusSequenceLength,
    		PhredQuality defaultQuality,GapQualityValueStrategy qualityValueStrategy) throws DataStoreException{
<span class="nc" id="L65">        return new CompactedSliceMap(iter, consensusSequenceLength, null, qualityValueStrategy, defaultQuality);</span>
    }
   
    private &lt;PR extends AssembledRead, C extends Contig&lt;PR&gt;&gt;  CompactedSliceMap(
            C contig, QualitySequenceDataStore qualityDataStore,GapQualityValueStrategy qualityValueStrategy, PhredQuality defaultQuality) throws DataStoreException {
<span class="nc" id="L70">		this(contig.getReadIterator(), (int)contig.getConsensusSequence().getLength(), qualityDataStore,</span>
				qualityValueStrategy,defaultQuality);
<span class="nc" id="L72">    }</span>
    private &lt;PR extends AssembledRead, C extends Contig&lt;PR&gt;&gt;  CompactedSliceMap(StreamingIterator&lt;PR&gt; readIter,
			int consensusLength, QualitySequenceDataStore qualityDataStore,
			GapQualityValueStrategy qualityValueStrategy, PhredQuality defaultQuality)
<span class="nc" id="L76">			throws DataStoreException {</span>
<span class="nc" id="L77">		CompactedSlice.Builder builders[] = new CompactedSlice.Builder[consensusLength];</span>
    
    	try{
<span class="nc bnc" id="L80" title="All 2 branches missed.">    		while(readIter.hasNext()){</span>
<span class="nc" id="L81">    			PR read = readIter.next();</span>
<span class="nc" id="L82">    			int start = (int)read.getGappedStartOffset();</span>
<span class="nc" id="L83">    			int i=0;</span>
<span class="nc" id="L84">    			String id =read.getId();</span>
<span class="nc" id="L85">    			Direction dir = read.getDirection();</span>
<span class="nc" id="L86">    			Iterator&lt;PhredQuality&gt; validRangeGappedQualitiesIterator =null;</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">    			if(qualityDataStore==null){</span>
<span class="nc" id="L88">    				validRangeGappedQualitiesIterator = createNewDefaultQualityIterator(defaultQuality);</span>

    			}else{
<span class="nc" id="L91">    				QualitySequence fullQualities = qualityDataStore.get(id);</span>
        			
<span class="nc bnc" id="L93" title="All 2 branches missed.">        			if(fullQualities ==null){</span>
<span class="nc" id="L94">        				throw new NullPointerException(&quot;could not get qualities for &quot;+id);</span>
        			}
<span class="nc" id="L96">        			validRangeGappedQualitiesIterator = qualityValueStrategy.getGappedValidRangeQualitySequenceFor(read, fullQualities)</span>
<span class="nc" id="L97">        													.iterator();</span>
        			
    			}
<span class="nc" id="L100">    			Iterator&lt;Nucleotide&gt; baseIterator = read.getNucleotideSequence().iterator();</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">    			while(baseIterator.hasNext()){</span>
<span class="nc" id="L102">    				Nucleotide base = baseIterator.next();</span>
<span class="nc" id="L103">    				PhredQuality quality = validRangeGappedQualitiesIterator.next();    			</span>
    			
<span class="nc bnc" id="L105" title="All 2 branches missed.">    				if(builders[start+i] ==null){</span>
<span class="nc" id="L106">    					builders[start+i] = new CompactedSlice.Builder();</span>
    				}
<span class="nc" id="L108">    				builders[start+i].addSliceElement(id, base, quality, dir);</span>
<span class="nc" id="L109">    				i++;</span>
<span class="nc" id="L110">    			}</span>
<span class="nc" id="L111">    		}</span>
    		//done building
<span class="nc" id="L113">    		this.slices = new CompactedSlice[builders.length];</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">    		for(int i=0; i&lt;slices.length; i++){</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">    			if(builders[i]==null){</span>
<span class="nc" id="L116">    				slices[i] = CompactedSlice.EMPTY;</span>
    			}else{
<span class="nc" id="L118">    				slices[i]= builders[i].build();</span>
    			}
    		}
    	}finally{
<span class="nc" id="L122">    		IOUtil.closeAndIgnoreErrors(readIter);</span>
    	}
<span class="nc" id="L124">	}</span>


    private Iterator&lt;PhredQuality&gt; createNewDefaultQualityIterator(
			final PhredQuality defaultQuality) {
<span class="nc" id="L129">		return new Iterator&lt;PhredQuality&gt;(){</span>

			@Override
			public boolean hasNext() {
				//always return true
<span class="nc" id="L134">				return true;</span>
			}

			@Override
			public PhredQuality next() {
<span class="nc" id="L139">				return defaultQuality;</span>
			}

			@Override
			public void remove() {
				//no-op				
<span class="nc" id="L145">			}</span>
			
		};
	}
	/**
     * {@inheritDoc}
     */
    @Override
    public Iterator&lt;Slice&gt; iterator() {
<span class="nc" id="L154">        return Arrays.&lt;Slice&gt;asList(slices).iterator();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Slice getSlice(long offset) {
<span class="nc" id="L162">        return slices[(int) offset];</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long getSize() {
<span class="nc" id="L170">        return slices.length;</span>
    }
	@Override
	public int hashCode() {
<span class="nc" id="L174">		final int prime = 31;</span>
<span class="nc" id="L175">		int result = 1;</span>
<span class="nc" id="L176">		result = prime * result + Arrays.hashCode(slices);</span>
<span class="nc" id="L177">		return result;</span>
	}
	@Override
	public boolean equals(Object obj) {
<span class="nc bnc" id="L181" title="All 2 branches missed.">		if (this == obj) {</span>
<span class="nc" id="L182">			return true;</span>
		}
<span class="nc bnc" id="L184" title="All 2 branches missed.">		if (obj == null) {</span>
<span class="nc" id="L185">			return false;</span>
		}
<span class="nc bnc" id="L187" title="All 2 branches missed.">		if (!(obj instanceof SliceMap)) {</span>
<span class="nc" id="L188">			return false;</span>
		}
<span class="nc" id="L190">		SliceMap other = (SliceMap) obj;</span>
<span class="nc" id="L191">		Iterator&lt;Slice&gt; iter = iterator();</span>
<span class="nc" id="L192">		Iterator&lt;Slice&gt; otherIter = other.iterator();</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">		while(iter.hasNext()){</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">			if(!otherIter.hasNext()){</span>
<span class="nc" id="L195">				return false;</span>
			}
<span class="nc bnc" id="L197" title="All 2 branches missed.">			if(!iter.next().equals(otherIter.next())){</span>
<span class="nc" id="L198">				return false;</span>
			}
		}
<span class="nc bnc" id="L201" title="All 2 branches missed.">		if(otherIter.hasNext()){</span>
<span class="nc" id="L202">			return false;</span>
		}
		
<span class="nc" id="L205">		return true;</span>
	}

    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>