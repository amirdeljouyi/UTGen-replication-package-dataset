<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TigrContigFileParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.tigr.contig</a> &gt; <span class="el_source">TigrContigFileParser.java</span></div><h1>TigrContigFileParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.tigr.contig;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jcvi.jillion.assembly.tigr.contig.TigrContigFileVisitor.TigrContigVisitorCallback;
import org.jcvi.jillion.assembly.tigr.contig.TigrContigFileVisitor.TigrContigVisitorCallback.TigrContigVisitorMemento;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.Range.CoordinateSystem;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;
import org.jcvi.jillion.internal.core.io.OpenAwareInputStream;
import org.jcvi.jillion.internal.core.io.RandomAccessFileInputStream;
import org.jcvi.jillion.internal.core.io.TextLineParser;

public abstract class TigrContigFileParser {

<span class="nc" id="L44">	  private static final Pattern NEW_CONTIG_PATTERN = Pattern.compile(&quot;##(\\S+).+&quot;);</span>
<span class="nc" id="L45">	    private static final Pattern NEW_READ_PATTERN = Pattern.compile(&quot;#(\\S+)\\((-?\\d+)\\)\\s+\\[(.*)\\].+\\{(-?\\d+) (-?\\d+)\\}.+&quot;);</span>
	  
	    
	public static TigrContigFileParser create(File contigFile){
<span class="nc" id="L49">		return new FileBasedTigrContigParser(contigFile);</span>
	}
	
	public static TigrContigFileParser create(InputStream contigFileStream){
<span class="nc" id="L53">		return new InputStreamBasedTigrContigParser(contigFileStream);</span>
	}
	private TigrContigFileParser(){
		//can not instantiate outside of this file
	}
	
	public void accept(TigrContigFileVisitor visitor) throws IOException{
<span class="nc" id="L60">		TextLineParser inputStream =new TextLineParser(getInputStream());</span>
		try{
<span class="nc" id="L62">			parse(visitor, inputStream, 0L);</span>
		}finally{
<span class="nc" id="L64">			IOUtil.closeAndIgnoreErrors(inputStream);</span>
		}
<span class="nc" id="L66">	}</span>
	
	public abstract void accept(TigrContigFileVisitor visitor,TigrContigVisitorMemento memento) throws IOException;

	protected final void parse(TigrContigFileVisitor visitor,
			TextLineParser parser, long initialOffset) throws IOException {
<span class="nc" id="L72">		boolean inConsensus =true;</span>
<span class="nc" id="L73">		TigrContigVisitor contigVisitor=null;</span>
<span class="nc" id="L74">		TigrContigReadVisitor readVisitor=null;</span>
<span class="nc" id="L75">		NucleotideSequenceBuilder currentBasesBuilder =new NucleotideSequenceBuilder();</span>
		
<span class="nc" id="L77">		boolean keepParsing=true;</span>
<span class="nc" id="L78">		AbstractTigrContigVisitorCallback callback=null;</span>
<span class="nc" id="L79">		long currentOffset = initialOffset;</span>
<span class="nc bnc" id="L80" title="All 4 branches missed.">		while(keepParsing &amp;&amp; parser.hasNextLine()){</span>
<span class="nc" id="L81">			String line = parser.nextLine();</span>
<span class="nc" id="L82">			Matcher newContigMatcher = NEW_CONTIG_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">			if (newContigMatcher.find()) {</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">				if (readVisitor != null) {</span>
<span class="nc" id="L85">					readVisitor.visitBasecalls(currentBasesBuilder.build());</span>
<span class="nc" id="L86">					readVisitor.visitEnd();</span>
				}
<span class="nc bnc" id="L88" title="All 2 branches missed.">				if(callback !=null){</span>
<span class="nc" id="L89">					keepParsing = callback.keepParsing();</span>
				}
<span class="nc bnc" id="L91" title="All 4 branches missed.">				if(keepParsing &amp;&amp; contigVisitor !=null){</span>
<span class="nc" id="L92">					contigVisitor.visitEnd();</span>
				}
<span class="nc bnc" id="L94" title="All 2 branches missed.">				if(callback !=null){</span>
<span class="nc" id="L95">					keepParsing = callback.keepParsing();</span>
				}
<span class="nc" id="L97">				readVisitor=null;	</span>
<span class="nc" id="L98">				contigVisitor =null;</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">				if(keepParsing){</span>
<span class="nc" id="L100">					inConsensus = true;</span>
<span class="nc" id="L101">					String contigId = newContigMatcher.group(1);</span>
<span class="nc" id="L102">					callback = createCallback(currentOffset);</span>
<span class="nc" id="L103">					contigVisitor = visitor.visitContig(callback, contigId);</span>
<span class="nc" id="L104">					currentBasesBuilder = new NucleotideSequenceBuilder();</span>
<span class="nc" id="L105">				}</span>
							
			} else {
<span class="nc" id="L108">				Matcher newSequenceMatcher = NEW_READ_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">				if (newSequenceMatcher.find()) {</span>
<span class="nc bnc" id="L110" title="All 4 branches missed.">					if (inConsensus &amp;&amp; contigVisitor != null) {</span>
<span class="nc" id="L111">						contigVisitor.visitConsensus(currentBasesBuilder.build());</span>
					}
<span class="nc bnc" id="L113" title="All 2 branches missed.">					if(readVisitor !=null){</span>
<span class="nc" id="L114">						readVisitor.visitBasecalls(currentBasesBuilder.build());</span>
<span class="nc" id="L115">						readVisitor.visitEnd();</span>
					}
<span class="nc" id="L117">					currentBasesBuilder = new NucleotideSequenceBuilder();</span>
<span class="nc" id="L118">					inConsensus = false;</span>
<span class="nc" id="L119">					readVisitor = fireVisitNewRead(newSequenceMatcher,</span>
							contigVisitor);
					
				} else {
<span class="nc" id="L123">					currentBasesBuilder.append(line);</span>
				}
			}
<span class="nc bnc" id="L126" title="All 2 branches missed.">			if(callback !=null){</span>
<span class="nc" id="L127">				keepParsing = callback.keepParsing();</span>
			}
<span class="nc" id="L129">			currentOffset +=line.length();</span>
<span class="nc" id="L130">		}</span>
		
<span class="nc bnc" id="L132" title="All 4 branches missed.">		if (readVisitor != null &amp;&amp; keepParsing){</span>
<span class="nc" id="L133">			readVisitor.visitBasecalls(currentBasesBuilder.build());</span>
<span class="nc" id="L134">			readVisitor.visitEnd();</span>
		}
<span class="nc bnc" id="L136" title="All 2 branches missed.">		if(contigVisitor !=null){</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">			if(keepParsing){</span>
<span class="nc" id="L138">				contigVisitor.visitEnd();</span>
			}else{
<span class="nc" id="L140">				contigVisitor.halted();</span>
			}
		}
<span class="nc bnc" id="L143" title="All 2 branches missed.">		if(keepParsing){</span>
<span class="nc" id="L144">			visitor.visitEnd();</span>
		}else{
<span class="nc" id="L146">			visitor.halted();</span>
		}
<span class="nc" id="L148">	}</span>
	
	protected abstract AbstractTigrContigVisitorCallback createCallback(long currentOffset);

	private static TigrContigReadVisitor fireVisitNewRead(Matcher newSequenceMatcher,  TigrContigVisitor contigVisitor) {
<span class="nc bnc" id="L153" title="All 2 branches missed.">		if(contigVisitor==null){</span>
<span class="nc" id="L154">			return null;</span>
		}
<span class="nc" id="L156">        String seqId = newSequenceMatcher.group(1);</span>
<span class="nc" id="L157">        int offset = Integer.parseInt(newSequenceMatcher.group(2));</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">        Direction dir= parseComplimentedFlag(newSequenceMatcher)?Direction.REVERSE: Direction.FORWARD;</span>
<span class="nc" id="L159">        Range validRange = parseValidRange(newSequenceMatcher, dir);</span>
   	 	
<span class="nc" id="L161">        return contigVisitor.visitRead(seqId, offset, dir, validRange);</span>
 }
	
	 private static Range parseValidRange(Matcher newSequenceMatcher,
	            Direction dir) {
<span class="nc" id="L166">	            int left = Integer.parseInt(newSequenceMatcher.group(4));</span>
<span class="nc" id="L167">	           int right = Integer.parseInt(newSequenceMatcher.group(5));</span>
	           Range validRange;
<span class="nc bnc" id="L169" title="All 2 branches missed.">	           if(dir == Direction.REVERSE){</span>
<span class="nc" id="L170">	               validRange = Range.of(CoordinateSystem.RESIDUE_BASED,right, left);</span>
	           }
	           else{
<span class="nc" id="L173">	               validRange = Range.of(CoordinateSystem.RESIDUE_BASED,left, right);</span>
	           }
<span class="nc" id="L175">	        return validRange;</span>
	    }
	 
	 private static boolean parseComplimentedFlag(Matcher newSequenceMatcher) {
<span class="nc bnc" id="L179" title="All 2 branches missed.">	        return !newSequenceMatcher.group(3).isEmpty();</span>
	    }
	
	protected abstract InputStream getInputStream() throws IOException;
	
	private static class InputStreamBasedTigrContigParser extends TigrContigFileParser{
		private final OpenAwareInputStream in;
		
<span class="nc" id="L187">		public InputStreamBasedTigrContigParser(InputStream in){</span>
<span class="nc" id="L188">			this.in = new OpenAwareInputStream(in);</span>
<span class="nc" id="L189">		}</span>

		@Override
		public void accept(TigrContigFileVisitor visitor,
				TigrContigVisitorMemento memento) throws IOException {
<span class="nc" id="L194">			throw new UnsupportedOperationException(&quot;inputstream parser does not support mementos&quot;);</span>
			
		}

		@Override
		protected AbstractTigrContigVisitorCallback createCallback(
				long currentOffset) {
<span class="nc" id="L201">			return NoMementoCallback.INSTANCE;</span>
		}

		@Override
		protected InputStream getInputStream() throws IOException {
<span class="nc bnc" id="L206" title="All 2 branches missed.">			if(!in.isOpen()){</span>
<span class="nc" id="L207">				throw new IOException(&quot;inputstream is closed&quot;);</span>
			}
<span class="nc" id="L209">			return in;</span>
		}
		
	}
	
	private static class FileBasedTigrContigParser extends TigrContigFileParser{
		private final File contigFile;

<span class="nc" id="L217">		public FileBasedTigrContigParser(File contigFile) {</span>
<span class="nc" id="L218">			this.contigFile = contigFile;</span>
<span class="nc" id="L219">		}</span>

		@Override
		protected InputStream getInputStream() throws IOException {
<span class="nc" id="L223">			return new BufferedInputStream(new FileInputStream(contigFile));</span>
		}

		@Override
		protected AbstractTigrContigVisitorCallback createCallback(long currentOffset) {
<span class="nc" id="L228">			return new MementoCallback(currentOffset);</span>
		}

		@Override
		public void accept(TigrContigFileVisitor visitor,
				TigrContigVisitorMemento memento) throws IOException {
<span class="nc bnc" id="L234" title="All 2 branches missed.">			if(!(memento instanceof OffsetMemento)){</span>
<span class="nc" id="L235">				throw new IllegalArgumentException(&quot;unknown memento type, must use instance created by this parser&quot;);</span>
			}
<span class="nc" id="L237">			long startOffset = ((OffsetMemento)memento).getOffset();</span>
<span class="nc" id="L238">			TextLineParser in=null;</span>
			try{
<span class="nc" id="L240">				in = new TextLineParser(new RandomAccessFileInputStream(contigFile, startOffset));</span>
<span class="nc" id="L241">				parse(visitor, in, startOffset);</span>
			}finally{
<span class="nc" id="L243">				IOUtil.closeAndIgnoreErrors(in);</span>
			}
			
<span class="nc" id="L246">		}</span>
		
	}
	
<span class="nc" id="L250">	private static abstract class AbstractTigrContigVisitorCallback implements TigrContigVisitorCallback{</span>
<span class="nc" id="L251">		private volatile boolean keepParsing=true;</span>
		
		@Override
		public void haltParsing() {
<span class="nc" id="L255">			keepParsing=false;</span>
			
<span class="nc" id="L257">		}</span>

		public final boolean keepParsing() {
<span class="nc" id="L260">			return keepParsing;</span>
		}
	}
	
<span class="nc" id="L264">	private static class NoMementoCallback extends AbstractTigrContigVisitorCallback{</span>

<span class="nc" id="L266">		static NoMementoCallback INSTANCE = new NoMementoCallback();</span>
		
		
		@Override
		public boolean canCreateMemento() {
<span class="nc" id="L271">			return false;</span>
		}

		@Override
		public TigrContigVisitorMemento createMemento() {
<span class="nc" id="L276">			throw new UnsupportedOperationException(&quot;can not create memento&quot;);</span>
		}
		
	}
	
	private static class MementoCallback extends AbstractTigrContigVisitorCallback{

		private final long offset;
		
<span class="nc" id="L285">		public MementoCallback(long offset){</span>
<span class="nc" id="L286">			this.offset = offset;</span>
<span class="nc" id="L287">		}</span>

		@Override
		public boolean canCreateMemento() {
<span class="nc" id="L291">			return true;</span>
		}

		@Override
		public TigrContigVisitorMemento createMemento() {
<span class="nc" id="L296">			return new OffsetMemento(offset);</span>
		}
		
	}
	
	private static class OffsetMemento implements TigrContigVisitorMemento{
		private final long offset;

<span class="nc" id="L304">		public OffsetMemento(long offset) {</span>
<span class="nc" id="L305">			this.offset = offset;</span>
<span class="nc" id="L306">		}</span>

		public final long getOffset() {
<span class="nc" id="L309">			return offset;</span>
		}
		
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>