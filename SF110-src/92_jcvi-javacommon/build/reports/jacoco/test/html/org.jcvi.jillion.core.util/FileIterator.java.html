<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileIterator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core.util</a> &gt; <span class="el_source">FileIterator.java</span></div><h1>FileIterator.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Aug 6, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.core.util;

import java.io.File;
import java.io.FileFilter;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Queue;

import org.jcvi.jillion.core.util.iter.IteratorUtil;

/**
 * {@code FileIterator} is an {@link Iterator} for File objects.
 * @author dkatzel
 *
 *
 */
public abstract class FileIterator implements Iterator&lt;File&gt;, Iterable&lt;File&gt;{
	
<span class="nc" id="L49">	private static final FileFilter  NON_DIRECTORY_FILTER = new NonDirectoryFileFilter();</span>
<span class="nc" id="L50">    private static final FileFilter  NON_HIDDEN_FILTER = new NonHiddenFileFilter();</span>
<span class="nc" id="L51">    private static final FileFilter  NULL_FILTER = new NullFileFilter();</span>
<span class="nc" id="L52">    private static final FileNameComparator FILE_NAME_SORTER = new FileNameComparator();</span>
    
   
    private Iterator&lt;File&gt; fileIterator;
    private final FileFilter fileFilter;
    private File nextFile;
    private final File rootDir;
    
    /**
     * Create a new {@link FileIteratorBuilder} instance that will create
     * a file iterator that will recursively iterate files in a depth
     * first manner. 
     * @param rootDir the root directory to start iterating from.
     * @return a new FileIteratorBuilder instance (will never be null)
     */
    public static FileIteratorBuilder createDepthFirstFileIteratorBuilder(File rootDir){
<span class="nc" id="L68">        return new DepthFirstFileIteratorBuilder(rootDir);</span>
    }
    /**
     * Create a new {@link FileIteratorBuilder} instance that will create
     * a file iterator that will recursively iterate files in a breadth
     * first manner. 
     * @param rootDir the root directory to start iterating from.
     * @return a new FileIteratorBuilder instance (will never be null)
     */
    public static FileIteratorBuilder createBreadthFirstFileIteratorBuilder(File rootDir){
<span class="nc" id="L78">        return new BreadthFirstFileIteratorBuilder(rootDir);</span>
    }
    /**
     * Create a new {@link FileIteratorBuilder} instance that will create
     * a file iterator that will only iterate files in the given directory
     * @param dir the directory iterate.
     * @return a new FileIteratorBuilder instance (will never be null)
     */
    public static FileIteratorBuilder createNonRecursiveFileIteratorBuilder(File dir){
<span class="nc" id="L87">        return new NonRecursiveFileIteratorBuilder(dir);</span>
    }
    private static final class FileNameComparator implements Comparator&lt;File&gt;, Serializable {
		/**
         * 
         */
        private static final long serialVersionUID = 4585888483429023724L;

        @Override
		public int compare(File o1, File o2) {
<span class="nc" id="L97">		    return o1.getName().compareTo(o2.getName());</span>
		}
	}
	/**
     * A FileFilter that only accepts files that are not 
     * directories.
     * @author dkatzel
     */
    private static final class NonDirectoryFileFilter implements FileFilter {
        @Override
        public boolean accept(File file) {
<span class="nc bnc" id="L108" title="All 2 branches missed.">            return !file.isDirectory();</span>
        }
    }
    private static final class NonHiddenFileFilter implements FileFilter {
        @Override
        public boolean accept(File file) {
<span class="nc bnc" id="L114" title="All 2 branches missed.">            return !file.isHidden();</span>
        }
    }
    private static final class NullFileFilter implements FileFilter {
        @Override
        public boolean accept(File file) {
<span class="nc" id="L120">            return true;</span>
        }
    }
    

<span class="nc" id="L125">    private FileIterator(File rootDir,FileFilter fileFilter){</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if(rootDir ==null){</span>
<span class="nc" id="L127">            throw new NullPointerException(&quot;rootDir can not be null&quot;);</span>
        }
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if(!rootDir.isDirectory()){</span>
<span class="nc" id="L130">            throw new IllegalArgumentException(&quot;rootDir must be a directory&quot;);</span>
        }
<span class="nc bnc" id="L132" title="All 2 branches missed.">        if(fileFilter ==null){</span>
<span class="nc" id="L133">            throw new NullPointerException(&quot;fileFilter can not be null&quot;);</span>
        }
<span class="nc" id="L135">        this.fileFilter = fileFilter;</span>
<span class="nc" id="L136">        this.rootDir = rootDir;</span>
<span class="nc" id="L137">        setUpInitialState(rootDir);</span>
        
<span class="nc" id="L139">    }</span>
    protected void setUpInitialState(File rootDir){
<span class="nc" id="L141">        updateFileIterator(rootDir);</span>
<span class="nc" id="L142">        nextFile = getNextFile();</span>
<span class="nc" id="L143">    }</span>
    protected void updateFileIterator(File rootDir) {
<span class="nc" id="L145">        fileIterator = getFilesFor(rootDir);</span>
<span class="nc" id="L146">    }</span>
    
    private Iterator&lt;File&gt; getFilesFor(File dir){
<span class="nc" id="L149">        final File[] listFiles = dir.listFiles(fileFilter);</span>
       
       
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if(listFiles ==null){</span>
            //either no files or no files we have permission to see
<span class="nc" id="L154">            return IteratorUtil.createEmptyIterator();</span>
        }
        //sort files by name this makes
        //iterating deterministic
<span class="nc" id="L158">        Arrays.sort(listFiles, FILE_NAME_SORTER);</span>
<span class="nc" id="L159">        return Arrays.asList(listFiles).iterator();</span>
    }
    /**
     * Returns a new iterator with the same
     * parameters as this.
     */
    @Override
    public Iterator&lt;File&gt; iterator() {
<span class="nc" id="L167">        return createNewInstance(this.rootDir, fileFilter);</span>
    }
    
    protected abstract Iterator&lt;File&gt; createNewInstance(File root, FileFilter fileFilter);
    protected File getNextFile(){
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if(fileIterator.hasNext()){</span>
<span class="nc" id="L173">            return fileIterator.next();</span>
        }        
<span class="nc" id="L175">        return null;        </span>
    }

   
    @Override
    public boolean hasNext() {
<span class="nc bnc" id="L181" title="All 2 branches missed.">        return nextFile !=null;</span>
    }

    @Override
    public File next() {
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if(!hasNext()){</span>
<span class="nc" id="L187">            throw new NoSuchElementException(&quot;no more files&quot;);</span>
        }
<span class="nc" id="L189">        File fileToReturn = nextFile;</span>
<span class="nc" id="L190">        nextFile = getNextFile();</span>
<span class="nc" id="L191">        return fileToReturn;</span>
    }

    @Override
    public void remove() {
<span class="nc" id="L196">        throw new UnsupportedOperationException(&quot;can not remove&quot;);</span>
    }
    private static class NonRecursiveFileIterator extends FileIterator{

        protected NonRecursiveFileIterator(File rootDir,
                FileFilter fileFilter) {
<span class="nc" id="L202">            super(rootDir, fileFilter);</span>
<span class="nc" id="L203">        }</span>

        @Override
        protected Iterator&lt;File&gt; createNewInstance(File root,
                FileFilter fileFilter) {
<span class="nc" id="L208">            return new NonRecursiveFileIterator(root, fileFilter);</span>
        }
        
    }
    /**
     * RecursiveFileIterator adds recursive abilities to FileIterator.
     * @author dkatzel
     *
     *
     */
    private abstract static class RecursiveFileIterator extends FileIterator{
    	
<span class="nc" id="L220">    	 private static final DirectoryFileFilter  DIRECTORY_FILTER = new DirectoryFileFilter();</span>
         
         private Queue&lt;File&gt; dirIterator;
         
        /**
         * A FileFilter that only accepts files that ARE 
         * directories.
         * @author dkatzel
         */
        private static final class DirectoryFileFilter implements FileFilter {
            @Override
            public boolean accept(File file) {
<span class="nc" id="L232">                return file.isDirectory();</span>
            }
        }
        
       
        protected RecursiveFileIterator(File rootDir,FileFilter fileFilter) {
<span class="nc" id="L238">            super(rootDir,fileFilter);</span>
<span class="nc" id="L239">        }</span>
        
        /**
         * Create an empty Queue of Files
         * that will be used to track the directories
         * to recursively iterate over.  The implementation
         * of the Queue returned will determine the order
         * the directories will be iterated.
         * @return a new empty Queue.
         */
        protected abstract Queue&lt;File&gt; createDirectoryIterator();
        
        private List&lt;File&gt; getSubdirectoriesFor(File dir){            
<span class="nc" id="L252">            final File[] listFiles = dir.listFiles(DIRECTORY_FILTER);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if(listFiles ==null){</span>
                //either no files or no files we have permission to see
<span class="nc" id="L255">                return Collections.emptyList();</span>
            }
<span class="nc" id="L257">            Arrays.sort(listFiles,FILE_NAME_SORTER);</span>
<span class="nc" id="L258">            return Arrays.asList(listFiles);</span>
            
        }
        @Override
        protected void setUpInitialState(File rootDir) {
<span class="nc" id="L263">            dirIterator = createDirectoryIterator();</span>
<span class="nc" id="L264">            dirIterator.addAll(getSubdirectoriesFor(rootDir));</span>
<span class="nc" id="L265">            super.setUpInitialState(rootDir);</span>
<span class="nc" id="L266">        }</span>
        @Override
        protected File getNextFile() {
<span class="nc" id="L269">            File nextFile = super.getNextFile();</span>
<span class="nc bnc" id="L270" title="All 4 branches missed.">            if(nextFile ==null &amp;&amp; hasMoreSubDirs()){            </span>
<span class="nc" id="L271">                return getNextFromSubDir();</span>
            }
            
<span class="nc" id="L274">            return nextFile;</span>
        }
        private boolean hasMoreSubDirs() {
<span class="nc bnc" id="L277" title="All 2 branches missed.">            return !dirIterator.isEmpty();</span>
        }

        private File getNextFromSubDir() {
<span class="nc" id="L281">            File newDir = dirIterator.poll();</span>
<span class="nc" id="L282">            updateFileIterator(newDir);</span>
<span class="nc" id="L283">            dirIterator.addAll(getSubdirectoriesFor(newDir));</span>
<span class="nc" id="L284">            return getNextFile();</span>
        }
        
    }
    private static class DepthFirstFileIterator extends RecursiveFileIterator{

        public DepthFirstFileIterator(File rootDir,FileFilter fileFilter) {
<span class="nc" id="L291">            super(rootDir,fileFilter);           </span>
<span class="nc" id="L292">        }</span>

        
        @Override
        protected Queue&lt;File&gt; createDirectoryIterator() {
<span class="nc" id="L297">            return new LIFOQueue&lt;File&gt;();</span>
        }


        @Override
        protected Iterator&lt;File&gt; createNewInstance(File root,
                FileFilter fileFilter) {
<span class="nc" id="L304">            return new DepthFirstFileIterator(root, fileFilter);</span>
        } 
    }
    private static class BreadthFirstFileIterator extends RecursiveFileIterator{

        public BreadthFirstFileIterator(File rootDir,FileFilter fileFilter) {
<span class="nc" id="L310">            super(rootDir,fileFilter);           </span>
<span class="nc" id="L311">        }</span>

        

        @Override
        protected Queue&lt;File&gt; createDirectoryIterator() {
<span class="nc" id="L317">            return new FIFOQueue&lt;File&gt;();</span>
        }  
        @Override
        protected Iterator&lt;File&gt; createNewInstance(File root,
                FileFilter fileFilter) {
<span class="nc" id="L322">            return new BreadthFirstFileIterator(root, fileFilter);</span>
        } 
    }
    
    /**
     * {@code FileIteratorBuilder} is used to build a new instance of a 
     * {@link FileIterator}.
     * @author dkatzel
     *
     *
     */
    public abstract static class FileIteratorBuilder implements Builder&lt;FileIterator&gt;{
        
<span class="nc" id="L335">        private boolean includeDirectories=false;</span>
<span class="nc" id="L336">        private boolean includeHiddenFiles=false;</span>
<span class="nc" id="L337">        private FileFilter userDefinedFileFilter=null;</span>
        private final File rootDir;
        
<span class="nc" id="L340">        public FileIteratorBuilder(File rootdir){</span>
<span class="nc" id="L341">            this.rootDir = rootdir;</span>
<span class="nc" id="L342">        }</span>
        /**
         * Should the iterator include the actual subdirectory directory files
         * during iteration.  Defaults to {@code false} if this method is not set.
         * &lt;p/&gt;For Example:&lt;p/&gt;
         * If the File Directory structure looks like this:
         * &lt;pre&gt;
         * +root
         *  | file1
         *  | file2
         *  +subdir
         *    | file3
         * &lt;/pre&gt;
         * If this iterator is NOT recursive and if includeDirectories is
         * set to {@code true}, {@code file1}, {@code file2} and the file object
         * that represents {@code subdir} will be iterated over. If the iterator
         * is NOT recursive and if includeDirectories is set to {@code false}
         * then only {@code file1} and {@code file2} will be iterated over.
         * &lt;p&gt;
         * If this iterator IS recursive and if includeDirectories is
         * set to {@code true}, then {@code file1}, {@code file2} and the file object
         * that represents {@code subdir} and {@code file3} will be iterated over. 
         * 
         * If the iterator
         * IS recursive and if includeDirectories is set to {@code false}
         * then only {@code file1}, {@code file2} and {@code file3} will be iterated over.
         * 
         * @param includeDirectories should the iterator include 
         * the actual subdirectory directory files.
         * during iteration.
         * @return this.
         */
        public FileIteratorBuilder includeDirectories(boolean includeDirectories){
<span class="nc" id="L375">            this.includeDirectories = includeDirectories;</span>
<span class="nc" id="L376">            return this;</span>
        }
        /**
         * Should hidden files be included in the file iteration. 
         * Defaults to {@code false} if this method is not set.
         * @param includeHiddenFiles {@code true} if hidden files should be included;
         * {@code false} otherwise.
         * @return this.
         */
        public FileIteratorBuilder includeHiddenFiles(boolean includeHiddenFiles){
<span class="nc" id="L386">            this.includeHiddenFiles = includeHiddenFiles;</span>
<span class="nc" id="L387">            return this;</span>
        }
        /**
         * Add additional constraints to the fileIterator by specifying 
         * a {@link FileFilter} that will be used to further restrict what
         * files to iterate.  The given Filter (if any) is applied after
         * the constraints set by {@link #includeDirectories(boolean)}
         * and {@link #includeHiddenFiles(boolean)}.
         * @param fileFilter a {@link FileFilter} instance to further
         * filter the files to iterate; passing in {@code null}
         * means do not do any additional filtering.
         * @return this.
         */
        public FileIteratorBuilder fileFilter(FileFilter fileFilter){
<span class="nc" id="L401">            this.userDefinedFileFilter = fileFilter;</span>
<span class="nc" id="L402">            return this;</span>
        }
        protected abstract FileIterator createFileIterator(File rootDir, FileFilter fileFilter);
        /**
         * Constructs a new FileIterator using the options set so far.
         * @return a new FileIterator (never null).
         */
        public FileIterator build(){
            FileFilter fileFilter;
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if(includeHiddenFiles){</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                if(includeDirectories){</span>
<span class="nc" id="L413">                    fileFilter = NULL_FILTER;</span>
                }else{
<span class="nc" id="L415">                    fileFilter = NON_DIRECTORY_FILTER;</span>
                }
            }else{
<span class="nc bnc" id="L418" title="All 2 branches missed.">                if(includeDirectories){</span>
<span class="nc" id="L419">                    fileFilter =NON_HIDDEN_FILTER;</span>
                }else{
<span class="nc" id="L421">                    fileFilter =new MultipleFileFilter(</span>
<span class="nc" id="L422">                            NON_DIRECTORY_FILTER,NON_HIDDEN_FILTER);</span>
                    
                }
            }
<span class="nc bnc" id="L426" title="All 2 branches missed.">            if(userDefinedFileFilter !=null){</span>
<span class="nc" id="L427">                fileFilter = new MultipleFileFilter(fileFilter, userDefinedFileFilter);</span>
            }
<span class="nc" id="L429">            return createFileIterator(rootDir, fileFilter);</span>
        }
    }
    
    private static final class BreadthFirstFileIteratorBuilder extends FileIteratorBuilder{
        /**
         * @param rootdir
         */
        public BreadthFirstFileIteratorBuilder(File rootdir) {
<span class="nc" id="L438">            super(rootdir);</span>
<span class="nc" id="L439">        }</span>

        /**
        * {@inheritDoc}
        */
        @Override
        protected FileIterator createFileIterator(File rootDir,
                FileFilter fileFilter) {
<span class="nc" id="L447">            return new BreadthFirstFileIterator(rootDir, fileFilter);</span>
        }
        
    }
    private static final class DepthFirstFileIteratorBuilder extends FileIteratorBuilder{
        /**
         * @param rootdir
         */
        public DepthFirstFileIteratorBuilder(File rootdir) {
<span class="nc" id="L456">            super(rootdir);</span>
<span class="nc" id="L457">        }</span>

        /**
        * {@inheritDoc}
        */
        @Override
        protected FileIterator createFileIterator(File rootDir,
                FileFilter fileFilter) {
<span class="nc" id="L465">            return new DepthFirstFileIterator(rootDir, fileFilter);</span>
        }
        
    }
    
    private static final class NonRecursiveFileIteratorBuilder extends FileIteratorBuilder{
        /**
         * @param rootdir
         */
        public NonRecursiveFileIteratorBuilder(File rootdir) {
<span class="nc" id="L475">            super(rootdir);</span>
<span class="nc" id="L476">        }</span>

        /**
        * {@inheritDoc}
        */
        @Override
        protected FileIterator createFileIterator(File rootDir,
                FileFilter fileFilter) {
<span class="nc" id="L484">            return new NonRecursiveFileIterator(rootDir, fileFilter);</span>
        }
        
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>