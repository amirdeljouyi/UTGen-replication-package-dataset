<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultZTRChromatogramWriterBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.internal.trace.chromat.ztr</a> &gt; <span class="el_source">DefaultZTRChromatogramWriterBuilder.java</span></div><h1>DefaultZTRChromatogramWriterBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.internal.trace.chromat.ztr;

import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

import org.jcvi.jillion.core.util.Builder;
import org.jcvi.jillion.internal.core.seq.trace.sanger.chromat.ztr.data.Data;
import org.jcvi.jillion.internal.trace.chromat.ztr.chunk.Chunk;
import org.jcvi.jillion.internal.trace.chromat.ztr.chunk.ChunkType;
import org.jcvi.jillion.internal.trace.chromat.ztr.data.DeltaEncodedData;
import org.jcvi.jillion.internal.trace.chromat.ztr.data.DeltaEncodedData.Level;
import org.jcvi.jillion.internal.trace.chromat.ztr.data.FollowData;
import org.jcvi.jillion.internal.trace.chromat.ztr.data.RunLengthEncodedData;
import org.jcvi.jillion.internal.trace.chromat.ztr.data.ShrinkToEightBitData;
import org.jcvi.jillion.internal.trace.chromat.ztr.data.ZLibData;
import org.jcvi.jillion.trace.TraceEncoderException;
import org.jcvi.jillion.trace.chromat.Chromatogram;


/**
 * {@code DefaultZTRChromatogramWriterBuilder} is a Builder for
 * {@link ZtrChromatogramWriter}s that allows total control
 * over what encoders are used in which order for every different
 * field in a {@link ZtrChromatogram}.
 * 
 * &lt;p/&gt;
 * For example: here is how to build a ZTRChromatogramWriter
 * that encodes the same as the staden IO_Lib module:
 * &lt;pre/&gt; 
 	DefaultZTRChromatogramWriterBuilder builder = new DefaultZTRChromatogramWriterBuilder();
	builder.forBasecallChunkEncoder()
    			.addEncoder(ZLibData.INSTANCE);
	builder.forPositionsChunkEncoder()
		.addDeltaEncoder(DeltaEncodedData.SHORT, Level.DELTA_LEVEL_3)
		.addEncoder(ShrinkToEightBitData.SHORT_TO_BYTE)
		.addEncoder(FollowData.INSTANCE)
		.addRunLengthEncoder()
		.addEncoder(ZLibData.INSTANCE);
	builder.forConfidenceChunkEncoder()
		.addDeltaEncoder(DeltaEncodedData.BYTE, Level.DELTA_LEVEL_1)
		.addRunLengthEncoder((byte)77)
		.addEncoder(ZLibData.INSTANCE);
	builder.forPeaksChunkEncoder()
		.addDeltaEncoder(DeltaEncodedData.INTEGER, Level.DELTA_LEVEL_1)
		.addEncoder(ShrinkToEightBitData.INTEGER_TO_BYTE)
		.addEncoder(ZLibData.INSTANCE);
	builder.forCommentsChunkEncoder()
		.addEncoder(ZLibData.INSTANCE);
		
	ZTRChromatogramWriter writer = builder.build();
	&lt;pre/&gt;
 * &lt;p/&gt;
 * @author dkatzel
 *
 */
<span class="nc" id="L80">public final class DefaultZTRChromatogramWriterBuilder implements Builder&lt;ZtrChromatogramWriter&gt;{</span>

<span class="nc" id="L82">	private final ChunkEncoderBuilder basecallEncoder = new ChunkEncoderBuilder(Chunk.BASE, ChunkType.BASECALLS);</span>
<span class="nc" id="L83">	private final ChunkEncoderBuilder positionsEncoder= new ChunkEncoderBuilder(Chunk.SMP4, ChunkType.SAMPLES);</span>
<span class="nc" id="L84">	private final ChunkEncoderBuilder confidenceEncoder= new ChunkEncoderBuilder(Chunk.CONFIDENCES, ChunkType.CONFIDENCE);</span>
<span class="nc" id="L85">	private final ChunkEncoderBuilder commentsEncoder= new ChunkEncoderBuilder(Chunk.COMMENTS, ChunkType.COMMENTS);</span>
<span class="nc" id="L86">	private final ChunkEncoderBuilder clipEncoder= new ChunkEncoderBuilder(Chunk.CLIP, ChunkType.CLIP);</span>
<span class="nc" id="L87">	private final ChunkEncoderBuilder peaksEncoder= new ChunkEncoderBuilder(Chunk.POSITIONS, ChunkType.POSITIONS);</span>
	/**
	 * Get the {@link ChunkEncoderBuilder} for the basecalls
	 * chunk.  
	 * @return a {@link ChunkEncoderBuilder} for the basecalls
	 * chunk of the ZTR.
	 */
	public ChunkEncoderBuilder forBasecallChunkEncoder(){
<span class="nc" id="L95">		return basecallEncoder;</span>
	}
	/**
	 * Get the {@link ChunkEncoderBuilder} for the positions
	 * chunk.  
	 * @return a {@link ChunkEncoderBuilder} for the positions
	 * chunk of the ZTR.
	 */
	public ChunkEncoderBuilder forPositionsChunkEncoder(){
<span class="nc" id="L104">		return positionsEncoder;</span>
	}
	/**
	 * Get the {@link ChunkEncoderBuilder} for the confidence
	 * (quality)
	 * chunk.  
	 * @return a {@link ChunkEncoderBuilder} for the confidence
	 * chunk of the ZTR.
	 */
	public ChunkEncoderBuilder forConfidenceChunkEncoder(){
<span class="nc" id="L114">		return confidenceEncoder;</span>
	}
	/**
	 * Get the {@link ChunkEncoderBuilder} for the comments
	 * chunk.  
	 * @return a {@link ChunkEncoderBuilder} for the comments
	 * chunk of the ZTR.
	 */
	public ChunkEncoderBuilder forCommentsChunkEncoder(){
<span class="nc" id="L123">		return commentsEncoder;</span>
	}
	/**
	 * Get the {@link ChunkEncoderBuilder} for the clip points
	 * chunk.  
	 * @return a {@link ChunkEncoderBuilder} for the clip points
	 * chunk of the ZTR.
	 */
	public ChunkEncoderBuilder forClipPointsChunkEncoder(){
<span class="nc" id="L132">		return clipEncoder;</span>
	}
	/**
	 * Get the {@link ChunkEncoderBuilder} for the peaks
	 * chunk.  
	 * @return a {@link ChunkEncoderBuilder} for the peaks
	 * chunk of the ZTR.
	 */
	public ChunkEncoderBuilder forPeaksChunkEncoder(){
<span class="nc" id="L141">		return peaksEncoder;</span>
	}
	/**
	 * Creates a new ZTRChromatogramWriter
	 * using the encoding settings that have been given.
	 */
	@Override
	public ZtrChromatogramWriter build() {
<span class="nc" id="L149">		return new DefaultZTRChromatogramWriter(</span>
<span class="nc" id="L150">				basecallEncoder.build(), </span>
<span class="nc" id="L151">				positionsEncoder.build(), </span>
<span class="nc" id="L152">				confidenceEncoder.build(), </span>
<span class="nc" id="L153">				commentsEncoder.build(), </span>
<span class="nc" id="L154">				clipEncoder.build(),</span>
<span class="nc" id="L155">				peaksEncoder.build());</span>
	}

	private static final class DataEncoder{
		private final Data data;
		private final byte optionalParameter;
		
		private DataEncoder(Data data) {
<span class="nc" id="L163">			this(data,(byte)0);</span>
<span class="nc" id="L164">		}</span>
<span class="nc" id="L165">		private DataEncoder(Data data, byte optionalParameter) {</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">			if(data==null){</span>
<span class="nc" id="L167">				throw new NullPointerException(&quot;data can not be null&quot;);</span>
			}
<span class="nc" id="L169">			this.data = data;</span>
<span class="nc" id="L170">			this.optionalParameter = optionalParameter;</span>
<span class="nc" id="L171">		}</span>


		private byte[] encode(byte[] data) throws TraceEncoderException{
<span class="nc" id="L175">			return this.data.encodeData(data, optionalParameter);</span>
		}
	}
	
	private static final class ChunkEncoder{
		private final ChunkType type;
		private final Chunk chunk;
		private final List&lt;DataEncoder&gt; dataEncoders;
		
		private ChunkEncoder(ChunkType type, Chunk chunk,
				List&lt;DataEncoder&gt; dataEncoders) {
<span class="nc" id="L186">			super();</span>
<span class="nc" id="L187">			this.type = type;</span>
<span class="nc" id="L188">			this.chunk = chunk;</span>
<span class="nc" id="L189">			this.dataEncoders = dataEncoders;</span>
<span class="nc" id="L190">		}</span>
		
		public byte[] encode(Chromatogram chromatogram) throws TraceEncoderException{
			
<span class="nc" id="L194">			byte[] currentData = chunk.encodeChunk(chromatogram);</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">			for(DataEncoder encoder : dataEncoders){</span>
<span class="nc" id="L196">				currentData =encoder.encode(currentData);</span>
<span class="nc" id="L197">			}</span>
<span class="nc" id="L198">			ByteBuffer encodedData = ByteBuffer.allocate(12+currentData.length);</span>
			try {
<span class="nc" id="L200">				encodedData.put(type.getTypeName().getBytes(&quot;UTF-8&quot;));</span>
<span class="nc" id="L201">			} catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L202">				throw new TraceEncoderException(&quot;could not encode chunk type &quot;+type,e);</span>
<span class="nc" id="L203">			}</span>
			//never put metadata, so metadata length is always zero
<span class="nc" id="L205">			encodedData.putInt(0);</span>
<span class="nc" id="L206">			encodedData.putInt(currentData.length);</span>
<span class="nc" id="L207">			encodedData.put(currentData);</span>
<span class="nc" id="L208">			return encodedData.array();</span>
		}
	}
	/**
	 * {@code ChunkEncoderBuilder} is a Builder which describes
	 * the order of the different encoding schemes used
	 * to encode each ZTR Chunk.  Encodings can be chained
	 * together to improve compression.  For example,
	 * it might be a good idea to encode a chunk with a Delta encoding
	 * and then with a {@link ShrinkToEightBitData} encoding
	 * since most of the delta values should fit into a single byte each. 
	 * 
	 * @author dkatzel
	 *
	 */
	public static class ChunkEncoderBuilder implements Builder&lt;ChunkEncoder&gt;{

		private final Chunk chunk;
		private final ChunkType chunkType;
<span class="nc" id="L227">		private final List&lt;DataEncoder&gt; encoders = new ArrayList&lt;DataEncoder&gt;();</span>
		/**
		 * Create a new ChunkEncoderBuilder for the given {@link Chunk} and {@link ChunkType}.
		 * @param chunk the chunk that this will encode; may not be null.
		 * @param chunkType the chunk type that this will encode; may not be null.
		 * @throws NullPointerException if chunk or chunkType are null.
		 */
<span class="nc" id="L234">		public ChunkEncoderBuilder(Chunk chunk, ChunkType chunkType) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">			if(chunk==null){</span>
<span class="nc" id="L236">				throw new NullPointerException(&quot;chunk can not be null&quot;);</span>
			}
<span class="nc bnc" id="L238" title="All 2 branches missed.">			if(chunkType==null){</span>
<span class="nc" id="L239">				throw new NullPointerException(&quot;chunkType can not be null&quot;);</span>
			}
<span class="nc" id="L241">			this.chunk = chunk;</span>
<span class="nc" id="L242">			this.chunkType = chunkType;</span>
<span class="nc" id="L243">		}		</span>
		/**
		 * Adds a runLength Encoder using the default
		 * guard value.  This is the same as
		 * {@link #addRunLengthEncoder(byte) addRunLengthEncoder(RunLengthEncodedData.DEFAULT_GUARD)}
		 * @return this
		 * @see RunLengthEncodedData#DEFAULT_GUARD
		 * @see #addRunLengthEncoder()
		 */
		public ChunkEncoderBuilder addRunLengthEncoder(){
<span class="nc" id="L253">			return addRunLengthEncoder(RunLengthEncodedData.DEFAULT_GUARD);</span>
		}
		/**
		 * Adds a ZLIB Encoder (for
		 * compressing data via ZIP).
		 * @return this.
		 */
		public ChunkEncoderBuilder addZLibEncoder(){
<span class="nc" id="L261">			encoders.add(new DataEncoder(ZLibData.INSTANCE));</span>
<span class="nc" id="L262">			return this;</span>
		}
		/**
		 * Adds a FollowData Encoder.
		 * @see FollowData
		 * @return this.
		 */
		public ChunkEncoderBuilder addFollowEncoder(){
<span class="nc" id="L270">			encoders.add(new DataEncoder(FollowData.INSTANCE));</span>
<span class="nc" id="L271">			return this;</span>
		}
		/**
		 * Adds a {@link ShrinkToEightBitData} encoder.
		 * @param shrinker the {@link ShrinkToEightBitData} encoder
		 * to use.
		 * @return this.
		 */
		public ChunkEncoderBuilder addShrinkEncoder(ShrinkToEightBitData shrinker){
<span class="nc" id="L280">			encoders.add(new DataEncoder(shrinker));</span>
<span class="nc" id="L281">			return this;</span>
		}
		/**
		 * Adds a runLength Encoder using the given
		 * guard value.  The guard value is used to run length blocks 
		 * and must be handled specially if it occurs in the un-encoded data;
		 * therefore it is preferable to use a guard value
		 * that won't occur often or at all in the un-encoded input data. 
		 * @param guard the value of the guard.
		 * @return this.
		 */
		public ChunkEncoderBuilder addRunLengthEncoder(byte guard){
<span class="nc" id="L293">			encoders.add(new DataEncoder(RunLengthEncodedData.INSTANCE,guard));</span>
<span class="nc" id="L294">			return this;</span>
		}
		/**
		 * Add a Delta Encoder of the given type with the given level.
		 * It has been found experimentally that {@link Level#DELTA_LEVEL_3}
		 * works better for int size values and {@link Level#DELTA_LEVEL_1}
		 * works better for byte and short sized values.
		 * @param deltaEncoder the deltaEncoder instance to use.
		 * @param deltaLevel the the delta level to use.  
		 * @return this
		 * @throws NullPointerException if deltaEncoder or deltaLevel are null.
		 */
		public ChunkEncoderBuilder addDeltaEncoder(DeltaEncodedData deltaEncoder,Level deltaLevel){
<span class="nc" id="L307">			encoders.add(new DataEncoder(deltaEncoder,deltaLevel.getLevel()));</span>
<span class="nc" id="L308">			return this;</span>
		}
		/**
		 * Constructs a new ChunkEncoder with the specified
		 * encoder chain for the given chunk and chunkType.
		 * @return a new ChunkEncoder.
		 */
		@Override
		public ChunkEncoder build() {			
<span class="nc" id="L317">			return new ChunkEncoder(chunkType, chunk, encoders);</span>
		}
	}
	
	
	/**
	 * {@code DefaultZTRChromatogramWriter} is an implementation
	 * of ZTRChromatogramWriter.  Use {@link DefaultZTRChromatogramWriterBuilder}
	 * to customize the encoding options.
	 * @author dkatzel
	 * @see &lt;a href=&quot;http://staden.sourceforge.net/ztr.html&quot;&gt;ZTR 1.2 Spec&lt;/a&gt;
	 */
	private static final class DefaultZTRChromatogramWriter implements ZtrChromatogramWriter{
		
		/**
		 * Specifies that this is chromatogram
		 * is encoded using ZTR 1.2 spec.
		 */
<span class="nc" id="L335">		private static final byte[] ZTR_VERSION =new byte[]{1,2};</span>
		private final ChunkEncoder basecallEncoder;
		private final ChunkEncoder peaksEncoder;
		private final ChunkEncoder positionsEncoder;
		private final ChunkEncoder confidenceEncoder;
		private final ChunkEncoder commentsEncoder;
		private final ChunkEncoder clipEncoder;
		
		
		private DefaultZTRChromatogramWriter(ChunkEncoder basecallEncoder,
				ChunkEncoder positionsEncoder, ChunkEncoder confidenceEncoder,
<span class="nc" id="L346">				ChunkEncoder commentsEncoder, ChunkEncoder clipEncoder, ChunkEncoder peaksEncoder) {</span>
<span class="nc" id="L347">			this.basecallEncoder = basecallEncoder;</span>
<span class="nc" id="L348">			this.positionsEncoder = positionsEncoder;</span>
<span class="nc" id="L349">			this.confidenceEncoder = confidenceEncoder;</span>
<span class="nc" id="L350">			this.commentsEncoder = commentsEncoder;</span>
<span class="nc" id="L351">			this.clipEncoder = clipEncoder;</span>
<span class="nc" id="L352">			this.peaksEncoder = peaksEncoder;</span>
<span class="nc" id="L353">		}</span>
		/**
		 * Encode the given chromatogram and write it
		 * to the given outputStream.  The stream
		 * WILL NOT be closed when this method completes.
		 * @param chromatogram the ZTR chromatogram to 
		 * encode and write; may not be null.
		 * @param out the OutputStream to write the encoded
		 * ZTR to.
		 * @throws TraceEncoderException if there is a problem
		 * encoding the ZTR chromatogram.
		 * @throws NullPointerException if chromatogram or out
		 * are null.
		 */
		public void write(Chromatogram chromatogram, OutputStream out)
				throws TraceEncoderException {
<span class="nc bnc" id="L369" title="All 2 branches missed.">			if(chromatogram ==null){</span>
<span class="nc" id="L370">				throw new NullPointerException(&quot;chromatogram can not be null&quot;);</span>
			}
			
			try {
<span class="nc" id="L374">				out.write(ZTRUtil.getMagicNumber());</span>
<span class="nc" id="L375">				out.write(ZTR_VERSION);</span>
				//this is the order that staden IO_Lib uses
				//some chunks are required before
				//other chunks can be parsed
				//(ex basecalls) so the order
				//should not be changed.
<span class="nc" id="L381">				out.write(positionsEncoder.encode(chromatogram));</span>
<span class="nc" id="L382">				out.write(basecallEncoder.encode(chromatogram));</span>
<span class="nc" id="L383">				out.write(peaksEncoder.encode(chromatogram));</span>
<span class="nc" id="L384">				out.write(confidenceEncoder.encode(chromatogram));			</span>
<span class="nc" id="L385">				out.write(commentsEncoder.encode(chromatogram));</span>
<span class="nc" id="L386">				out.write(clipEncoder.encode(chromatogram));</span>
				
<span class="nc" id="L388">			} catch (IOException e) {</span>
<span class="nc" id="L389">				throw new TraceEncoderException(&quot;error writing ZTR&quot;, e);</span>
<span class="nc" id="L390">			}</span>
			
<span class="nc" id="L392">		}</span>
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>