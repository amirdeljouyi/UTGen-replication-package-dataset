<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractFastaRecordWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.internal.fasta</a> &gt; <span class="el_source">AbstractFastaRecordWriter.java</span></div><h1>AbstractFastaRecordWriter.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.internal.fasta;

import java.io.BufferedOutputStream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.charset.Charset;
import java.util.Iterator;

import org.jcvi.jillion.core.Sequence;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.fasta.FastaRecord;
import org.jcvi.jillion.fasta.FastaRecordWriter;
import org.jcvi.jillion.fasta.FastaUtil;


public  abstract class AbstractFastaRecordWriter&lt;S, T extends Sequence&lt;S&gt;, F extends FastaRecord&lt;S,T&gt;&gt; implements FastaRecordWriter&lt;S, T, F&gt;{

	private final Writer writer;
	private final int numberOfResiduesPerLine;
	private final boolean hasSymbolSeparator;
	
	protected AbstractFastaRecordWriter(OutputStream out,
<span class="nc" id="L49">			int numberOfResiduesPerLine, Charset charSet) {</span>
		//wrap in OutputStream Writer to do char encodings
		//for us.  If we did String#getBytes(Charset) instead
		//for each write call that could put unwanted
		//char encoding headers in each record
		//which would be incorrect.  This way
		//the char encoding headers (if any) will
		//only appear at the beginning of the inputstream
<span class="nc" id="L57">		this.writer =  new BufferedWriter(new OutputStreamWriter(out,charSet));</span>
<span class="nc" id="L58">		this.numberOfResiduesPerLine = numberOfResiduesPerLine;</span>
<span class="nc" id="L59">		this.hasSymbolSeparator = hasSymbolSeparator();</span>
<span class="nc" id="L60">	}</span>

	@Override
	public final void close() throws IOException {
		//just incase the implementation of
		//OutputStream is buffering we need to explicitly
		//call flush
<span class="nc" id="L67">		writer.flush();</span>
<span class="nc" id="L68">		writer.close();		</span>
<span class="nc" id="L69">	}</span>

	@Override
	public final void write(F record) throws IOException {
<span class="nc" id="L73">		write(record.getId(),record.getSequence(),record.getComment());</span>
		
<span class="nc" id="L75">	}</span>

	@Override
	public final void write(String id, T sequence)
			throws IOException {
<span class="nc" id="L80">		write(id,sequence,null);		</span>
<span class="nc" id="L81">	}</span>

	@Override
	public final void write(String id, T sequence,
			String optionalComment) throws IOException {
<span class="nc" id="L86">		String formattedString = toFormattedString(id, sequence, optionalComment);</span>
<span class="nc" id="L87">		writer.write(formattedString);</span>
		
<span class="nc" id="L89">	}</span>

	private String toFormattedString(String id, T sequence, String comment)
    {
<span class="nc" id="L93">    	int bufferSize = computeFormattedBufferSize(id,sequence,comment);</span>
<span class="nc" id="L94">        final StringBuilder record = new StringBuilder(bufferSize);</span>
<span class="nc" id="L95">        appendDefline(id, comment, record);</span>
<span class="nc" id="L96">        appendRecordBody(sequence, record);</span>
        
<span class="nc" id="L98">        return record.toString();</span>
    }

	private void appendRecordBody(T sequence,
			final StringBuilder record) {
<span class="nc" id="L103">		Iterator&lt;S&gt; iter = sequence.iterator();</span>
        
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if(iter.hasNext()){</span>
<span class="nc" id="L106">        	record.append(getStringRepresentationFor(iter.next()));</span>
        }
<span class="nc" id="L108">        int count=1;</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        while(iter.hasNext()){</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        	if(count%numberOfResiduesPerLine==0){</span>
<span class="nc" id="L111">        		record.append(FastaUtil.LINE_SEPARATOR);</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">        	}else if(hasSymbolSeparator){</span>
<span class="nc" id="L113">        		record.append(getSymbolSeparator());</span>
        	}
<span class="nc" id="L115">        	record.append(getStringRepresentationFor(iter.next()));</span>
<span class="nc" id="L116">        	count++;</span>
        }
<span class="nc" id="L118">        record.append(FastaUtil.LINE_SEPARATOR);</span>
<span class="nc" id="L119">	}</span>

	protected abstract boolean hasSymbolSeparator();

	protected abstract String getSymbolSeparator();

	protected abstract String getStringRepresentationFor(S symbol);
	
	private void appendDefline(String id, String comment,
			final StringBuilder record) {
<span class="nc" id="L129">		record.append(FastaUtil.HEADER_PREFIX).append(id);</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (comment != null) {</span>
<span class="nc" id="L131">        	record.append(' ').append(comment);</span>
        }
<span class="nc" id="L133">        record.append(FastaUtil.LINE_SEPARATOR);</span>
<span class="nc" id="L134">	}</span>
    
    private int computeFormattedBufferSize(String id, T sequence, String comment) {
    	//2 extra bytes for '&gt;' and '\n'
<span class="nc" id="L138">		int defLineSize = 2 + id.length();</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">		if(comment!=null){</span>
			//extra byte for the space
<span class="nc" id="L141">			defLineSize +=1 + comment.length();</span>
		}
<span class="nc" id="L143">		int seqLength=(int)sequence.getLength();</span>
<span class="nc" id="L144">		int numberOfLines = seqLength/numberOfResiduesPerLine +1;</span>
<span class="nc" id="L145">		return defLineSize + numberOfCharsFor(seqLength)+numberOfLines;</span>
	}
   
    protected abstract int numberOfCharsFor(int numberOfSymbols);
    
    public abstract static class AbstractBuilder&lt;S, T extends Sequence&lt;S&gt;,F extends FastaRecord&lt;S,T&gt;, W extends FastaRecordWriter&lt;S, T, F&gt;&gt; implements org.jcvi.jillion.core.util.Builder&lt;W&gt;{
		
<span class="nc" id="L152">		private static final Charset DEFAULT_CHARSET = IOUtil.UTF_8;</span>
		private final OutputStream out;
		private int numberOfSymbolsPerLine;
		
<span class="nc" id="L156">		private Charset charSet = DEFAULT_CHARSET;</span>
		/**
		 * Create a new Builder that will use
		 * the given {@link OutputStream} to write
		 * out the fasta records.
		 * @param out the {@link OutputStream} to use;
		 * can not be null.
		 * @throws NullPointerException if out is null.
		 */
<span class="nc" id="L165">		public AbstractBuilder(OutputStream out){</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">			if(out==null){</span>
<span class="nc" id="L167">				throw new NullPointerException(&quot;outputstream can not be null&quot;);</span>
			}
<span class="nc" id="L169">			this.out = out;</span>
<span class="nc" id="L170">			numberPerLine(getDefaultNumberOfSymbolsPerLine());</span>
<span class="nc" id="L171">		}</span>
		/**
		 * Get the number of symbols
		 * that should be printed on each line
		 * of the fasta record body.
		 * @return a number &gt;=1.
		 */
		protected abstract int getDefaultNumberOfSymbolsPerLine();
		/**
		 * Create a new Builder that will use
		 * the given File to write
		 * out the fasta records.  Any contents
		 * that previously existed in this file
		 * will be overwritten.
		 * @param outputFile the File to use;
		 * can not be null.
		 * @throws NullPointerException if outputFile is null.
		 * @throws FileNotFoundException if the file exists but 
		 * is a directory rather than a regular file, 
		 * does not exist but cannot be created, 
		 * or cannot be opened for any other reason.
		 */
		public AbstractBuilder(File outputFile) throws FileNotFoundException{
<span class="nc" id="L194">			this(new BufferedOutputStream(new FileOutputStream(outputFile)));</span>
<span class="nc" id="L195">		}</span>
		/**
		 * Change the {@link Charset} used
		 * to write out the fasta record.
		 * If this method is not called,
		 * then the CharSet will default to
		 * UTF-8.
		 * @param charset the {@link Charset} to use;
		 * can not be null.
		 * @return this.
		 * @throws NullPointerException if charset is null.
		 */
		public final AbstractBuilder&lt;S,T,F,W&gt; charset(Charset charset){
<span class="nc bnc" id="L208" title="All 2 branches missed.">			if(charset ==null){</span>
<span class="nc" id="L209">				throw new NullPointerException(&quot;charset can not be null&quot;);</span>
			}
<span class="nc" id="L211">			this.charSet=charset;</span>
<span class="nc" id="L212">			return this;</span>
		}
		/**
		 * Change the number of bases per line
		 * to write for each fasta record.
		 * If this method is not called,
		 * then the a default value will be used.
		 * @param numberPerLine the basesPerLine to use
		 * must be &gt;=1.
		 * @return this.
		 * @throws IllegalArgumentException if basesPerLine &lt;1.
		 */
		public final AbstractBuilder&lt;S,T,F,W&gt; numberPerLine(int numberPerLine){
<span class="nc bnc" id="L225" title="All 2 branches missed.">			if(numberPerLine&lt;1){</span>
<span class="nc" id="L226">				throw new IllegalArgumentException(&quot;number per line must be &gt;=1&quot;);</span>
			}
<span class="nc" id="L228">			numberOfSymbolsPerLine = numberPerLine;</span>
<span class="nc" id="L229">			return this;</span>
		}
		
		/**
		 * Create a new {@link FastaRecordWriter} instance
		 * which uses the parameters supplied to this builder.
		 * @return a new instance of {@link FastaRecordWriter}. 
		 */
		@Override
		public final W build() {
<span class="nc" id="L239">			return create(out, numberOfSymbolsPerLine, charSet);</span>
		}
		/**
		 * Create a new instance of a {@link FastaRecordWriter}
		 * with the given non-null parameters.
		 * @param out the OutputStream that the new writer will use
		 * to output the fasta data; will never be null.
		 * @param numberOfResiduesPerLine the number of residues per line 
		 * that should be written to the file.  If a sequence length
		 * is more than this number, then the sequence should be split
		 * over several lines, each line never exceeding this value.
		 * @param charSet the {@link Charset} to encode the output to,
		 * usually UTF-8.
		 * @return a new {@link FastaRecordWriter}; can not be null.
		 */
		protected abstract W create(OutputStream out, int numberOfResiduesPerLine, Charset charSet);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>