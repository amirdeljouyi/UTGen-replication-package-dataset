<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Sff454NameUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.trace.sff</a> &gt; <span class="el_source">Sff454NameUtil.java</span></div><h1>Sff454NameUtil.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.trace.sff;

import java.math.BigInteger;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 454 Universal Accession Numbers are generated for each read based on the date
 * of the run, the machine name, the region the read came from and X-Y location
 * of the well.  The format is described in The FLX Data Analysis Software Manual
 * in section 13.3.7 454 Universal Accession Numbers.
 * @author dkatzel
 *
 *
 */
public final class Sff454NameUtil {
    /**
     * All 454 Universal Accession numbers follow the same 14 character format.  Some tools may add
     * suffixes to the accession number to include mate pair information.
     */
<span class="nc" id="L45">    private static final Pattern UNIVERSAL_ACCCESSION_NUM_PATTERN = Pattern.compile(&quot;^([A-Z0-9]{7}\\d\\d[A-Z0-9]{5})\\S*$&quot;);</span>
    
    
    private Sff454NameUtil(){
        //can not instantiate
    }
    /**
     * Is the given read id a 454 read.
     * @param readId the read id to check.
     * @return {@code true} if the readId is a single word
     * that starts with a valid
     * 454 universal accession number; {@code false} otherwise.
     */
    public static boolean is454Read(String readId){        
<span class="nc" id="L59">        Matcher matcher = UNIVERSAL_ACCCESSION_NUM_PATTERN.matcher(readId);</span>
<span class="nc" id="L60">        return matcher.matches();         </span>
    }
    /**
     * Parse the Universal Accession Number from a 454 read id
     * that may represent either an unmated 454 read or a mated
     * 454 read.  This method assumes that mate information
     * is appended to the universal accession number as a suffix.
     * @param readId the 454 read id to parse from.
     * @return the Universal Accession Number part of a valid 454 read id.
     * @throws IllegalArgumentException if the given read is not a valid 454 read.
     */
    public static String parseUniversalAccessionNumberFrom(String readId){        
<span class="nc" id="L72">        Matcher matcher = UNIVERSAL_ACCCESSION_NUM_PATTERN.matcher(readId);</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">        if(matcher.matches()){</span>
<span class="nc" id="L74">            return matcher.group(1);</span>
        }
<span class="nc" id="L76">        throw new IllegalArgumentException(&quot;not a valid 454 read id: &quot;+ readId);</span>
    }
    /**
     * Generate the correct 454 Universal Accession Number
     * for the given rigRunName, region number and well location.
     * @param rigRunName the name of the 454 rig run (usually starts 
     * 'R_{year}_{month}_{day}_{hour}_{minute}_{second}_'
     * @param regionNumber the region number of the 454 region to use.
     * @param wellLocation the Location object that refers to the 
     * X and Y coordinates of the well in the region to use.
     * @return the 454 Universal Accession Number that 
     * uniquely represents that read.
     * @throws NullPointerException if rigRunName  or wellLocation is null.
     * @throws IllegalArgumentException if rigRunName is not a valid rig run name.
     * @throws IllegalArgumentException if regionNumber is not a positive number between 0 and 99 inclusive.
     */
    public static String generateAccessionNumberFor(String rigRunName, int regionNumber, Location wellLocation){
<span class="nc bnc" id="L93" title="All 2 branches missed.">        if(rigRunName ==null){</span>
<span class="nc" id="L94">            throw new NullPointerException(&quot;rigRunName can not be null&quot;);</span>
        }
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if(wellLocation ==null){</span>
<span class="nc" id="L97">            throw new NullPointerException(&quot;wellLocation can not be null&quot;);</span>
        }
<span class="nc bnc" id="L99" title="All 4 branches missed.">        if(regionNumber&lt;0 || regionNumber &gt;99){</span>
<span class="nc" id="L100">            throw new IllegalArgumentException(&quot;region number must be &gt;=0 and &lt;=99 : &quot;+ regionNumber);</span>
        }
<span class="nc" id="L102">        RigRun rigRun = new RigRun(rigRunName);</span>
        
<span class="nc" id="L104">        final Date dateOfRigRun = rigRun.getDate();</span>
<span class="nc" id="L105">        final BigInteger encodedDate = _454DateEncoder.INSTANCE.encode(dateOfRigRun);</span>
<span class="nc" id="L106">        return new StringBuilder()</span>
<span class="nc" id="L107">                    .append(_454Base36Encoder.INSTANCE.encode(encodedDate))</span>
<span class="nc" id="L108">                    .append(rigRun.getRandomizingHashcode())</span>
<span class="nc" id="L109">                    .append(String.format(&quot;%02d&quot;, regionNumber))</span>
<span class="nc" id="L110">                    .append(wellLocation.encode())</span>
<span class="nc" id="L111">                    .toString();</span>
        
    }
    
    
    /**
     * Parse the Date of the Run when this
     * 454 read was generated.  
     * Universal 454 Accession Numbers encode the date of the run in their names,
     * this method parses that information out. 
     * @param readId the 454 read to parse.
     * @return a Date (not-null) of when this rig run started
     * that produced this readId.
     * @throws IllegalArgumentException is {@link #is454Read(String)}
     * returns false.
     */
    public static Date getDateOfRun(String readId){
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if(!is454Read(readId)){</span>
<span class="nc" id="L129">            throw new IllegalArgumentException(readId + &quot; is not a 454 read&quot;);</span>
        }
<span class="nc" id="L131">        final String substring = readId.substring(0,6);</span>
<span class="nc" id="L132">        BigInteger timeStamp = _454Base36Encoder.INSTANCE.decode(substring);        </span>
<span class="nc" id="L133">        return _454DateEncoder.INSTANCE.decode(timeStamp);</span>
    }
    
    /**
     * Parse the region number of where on the machine this
     * 454 read was generated.  
     * Universal 454 Accession Numbers encode the region number in their names,
     * this method parses that information out. 
     * @param readId the 454 read to parse.
     * @return a a positive 2 digit number of which region this read
     * is from. 
     * @throws IllegalArgumentException is {@link #is454Read(String)}
     * returns false.
     */
    public static int getRegionNumber(String readId){
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if(!is454Read(readId)){</span>
<span class="nc" id="L149">            throw new IllegalArgumentException(readId + &quot; is not a 454 read&quot;);</span>
        }
<span class="nc" id="L151">        final String substring = readId.substring(7,9);</span>
<span class="nc" id="L152">        return Integer.parseInt(substring);</span>
    }
    
    
    /**
     * {@code Location} represents the pixel coordinates of a well
     * on the PicoTiterPlate device which contains a DNA fragment being sequenced.
     * @author dkatzel
     *
     *
     */
    public static final class Location{
        private final int x,y;
<span class="nc" id="L165">        private static final BigInteger FOURTY_NINETY_SIX = BigInteger.valueOf(4096);</span>
        /**
         * @param x
         * @param y
         */
<span class="nc" id="L170">        public Location(int x, int y) {</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            if(x &lt;0){</span>
<span class="nc" id="L172">                throw new IllegalArgumentException(&quot;x coordinate can not be negative&quot;);</span>
            }
<span class="nc bnc" id="L174" title="All 2 branches missed.">            if(y &lt;0){</span>
<span class="nc" id="L175">                throw new IllegalArgumentException(&quot;y coordinate can not be negative&quot;);</span>
            }
<span class="nc" id="L177">            this.x = x;</span>
<span class="nc" id="L178">            this.y = y;</span>
<span class="nc" id="L179">        }</span>
        /**
         * Get the X pixel coordinate of this location.
         * @return a positive integer.
         */
        public int getX() {
<span class="nc" id="L185">            return x;</span>
        }
        /**
         * Get the Y pixel coordinate of this location.
         * @return a positive integer.
         */
        public int getY() {
<span class="nc" id="L192">            return y;</span>
        }
        
        private String encode(){
<span class="nc" id="L196">            return _454Base36Encoder.INSTANCE.encode(BigInteger.valueOf(x * 4096L + y));</span>
        }
        
        private static Location decode(String encodedLocation){
<span class="nc" id="L200">            BigInteger value =_454Base36Encoder.INSTANCE.decode(encodedLocation);</span>
<span class="nc" id="L201">            BigInteger x = value.divide(FOURTY_NINETY_SIX);</span>
<span class="nc" id="L202">            BigInteger y = value.mod(FOURTY_NINETY_SIX);</span>
<span class="nc" id="L203">            return new Location(x.intValue(), y.intValue());</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L208">            final int prime = 31;</span>
<span class="nc" id="L209">            int result = 1;</span>
<span class="nc" id="L210">            result = prime * result + x;</span>
<span class="nc" id="L211">            result = prime * result + y;</span>
<span class="nc" id="L212">            return result;</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L217" title="All 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L218">                return true;</span>
            }
<span class="nc bnc" id="L220" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L221">                return false;</span>
            }
<span class="nc bnc" id="L223" title="All 2 branches missed.">            if (!(obj instanceof Location)) {</span>
<span class="nc" id="L224">                return false;</span>
            }
<span class="nc" id="L226">            Location other = (Location) obj;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if (x != other.x) {</span>
<span class="nc" id="L228">                return false;</span>
            }
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (y != other.y) {</span>
<span class="nc" id="L231">                return false;</span>
            }
<span class="nc" id="L233">            return true;</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L238">            StringBuilder builder = new StringBuilder(30);</span>
<span class="nc" id="L239">            builder.append(&quot;Location [x=&quot;).append(x).append(&quot;, y=&quot;).append(y)</span>
<span class="nc" id="L240">                    .append(']');</span>
<span class="nc" id="L241">            return builder.toString();</span>
        }
        
    }
    /**
     * Parse the {@link Location} representing the X and Y coordinates 
     * of this 454 read id when it was run.
     * @param readId the 454 read id to parse from.
     * @return the Universal Accession Number part of a valid 454 read id.
     * @throws IllegalArgumentException is {@link #is454Read(String)}
     * returns false
     */
    public static Location parseLocationOf(String readId){
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if(!is454Read(readId)){</span>
<span class="nc" id="L255">            throw new IllegalArgumentException(readId + &quot; is not a 454 read&quot;);</span>
        }
<span class="nc" id="L257">        String subString = readId.substring(9,14);</span>
<span class="nc" id="L258">        return Location.decode(subString);</span>
    }
    /**
     * Singleton helper class to convert to and from
     * 454 base-36 encoding which is different
     * than normal base36 encoding in that
     * digits 0-9 represent numbers 26-35.
     * @author dkatzel
     *
     *
     */
<span class="nc" id="L269">    private static enum _454Base36Encoder{</span>
<span class="nc" id="L270">        INSTANCE;</span>
        
        BigInteger decode(String encodedString){
<span class="nc" id="L273">            StringBuilder decodedBuilder = new StringBuilder(); </span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">            for(char c : encodedString.toCharArray()){</span>
                final int value;
<span class="nc bnc" id="L276" title="All 2 branches missed.">                if(Character.isDigit(c)){</span>
<span class="nc" id="L277">                    value =Integer.parseInt(Character.toString(c))+26;</span>
                }else{
<span class="nc" id="L279">                    value =c-'A';</span>
                }
<span class="nc bnc" id="L281" title="All 2 branches missed.">                if(value &lt;10){</span>
<span class="nc" id="L282">                    decodedBuilder.append(value);</span>
                }else{
<span class="nc" id="L284">                    decodedBuilder.append((char)((value-10)+'A'));</span>
                }
                
            }
<span class="nc" id="L288">            return new BigInteger(decodedBuilder.toString(),36);</span>
        }
        
        String encode(long value){
<span class="nc" id="L292">            return encode(BigInteger.valueOf(value));</span>
        }
        
        
        String encode(BigInteger value){
<span class="nc" id="L297">            String base36EncodedString = value.toString(36).toUpperCase(Locale.ENGLISH);</span>
<span class="nc" id="L298">            StringBuilder x454EncodedBase36Builder = new StringBuilder();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">            for(Character c : base36EncodedString.toCharArray()){</span>
<span class="nc" id="L300">                int offset =Integer.parseInt(c.toString(), 36);</span>
               
<span class="nc bnc" id="L302" title="All 2 branches missed.">                if(offset&lt;26){</span>
<span class="nc" id="L303">                    x454EncodedBase36Builder.append((char)(offset+'A'));</span>
                }else{
<span class="nc" id="L305">                    x454EncodedBase36Builder.append((char)('0'+(offset-26)));</span>
                }
            }
            
<span class="nc" id="L309">            return x454EncodedBase36Builder.toString();</span>
        }
    }
    /**
     * Singleton to handle 454 Universal Accession Number
     * date calculations. 
     * &lt;p&gt; 
     * 454 Universal Accessions Numbers encode dates as a large number that 
     * is generated by multiplying the parts of the date by various
     * amounts and adding the results together.  Different Date parts can be
     * parsed out by division and modulus operations.
     * @author dkatzel
     *
     *
     */
<span class="nc" id="L324">    private static enum _454DateEncoder{</span>
<span class="nc" id="L325">        INSTANCE;</span>
        
<span class="nc" id="L327">        private static final BigInteger SIXTY = BigInteger.valueOf(60);</span>
<span class="nc" id="L328">        private static final BigInteger TWENTY_FOUR = BigInteger.valueOf(24);</span>
<span class="nc" id="L329">        private static final BigInteger THIRTEEN = BigInteger.valueOf(13);</span>
<span class="nc" id="L330">        private static final BigInteger THIRTY_TWO = BigInteger.valueOf(32);</span>
        
<span class="nc" id="L332">        private static final BigInteger MINUTE_MASK = SIXTY;</span>
<span class="nc" id="L333">        private static final BigInteger HOUR_MASK = MINUTE_MASK.multiply(SIXTY);</span>
<span class="nc" id="L334">        private static final BigInteger DAY_MASK = HOUR_MASK.multiply(TWENTY_FOUR);</span>
<span class="nc" id="L335">        private static final BigInteger MONTH_MASK = DAY_MASK.multiply(THIRTY_TWO);</span>
<span class="nc" id="L336">        private static final BigInteger YEAR_MASK = MONTH_MASK.multiply(THIRTEEN);</span>
        
        
        BigInteger encode(Date timestampOfRun){
<span class="nc" id="L340">            Calendar calendar = Calendar.getInstance();</span>
<span class="nc" id="L341">            calendar.setTime(timestampOfRun);</span>
<span class="nc" id="L342">            BigInteger year = BigInteger.valueOf(calendar.get(Calendar.YEAR) -2000);</span>
<span class="nc" id="L343">            BigInteger month = BigInteger.valueOf(calendar.get(Calendar.MONTH));</span>
<span class="nc" id="L344">            BigInteger day = BigInteger.valueOf(calendar.get(Calendar.DAY_OF_MONTH));</span>
<span class="nc" id="L345">            BigInteger hour = BigInteger.valueOf(calendar.get(Calendar.HOUR_OF_DAY));</span>
<span class="nc" id="L346">            BigInteger minute = BigInteger.valueOf(calendar.get(Calendar.MINUTE));</span>
<span class="nc" id="L347">            BigInteger second = BigInteger.valueOf(calendar.get(Calendar.SECOND));</span>
            
<span class="nc" id="L349">            return YEAR_MASK.multiply(year)</span>
<span class="nc" id="L350">                                .add(MONTH_MASK.multiply(month))</span>
<span class="nc" id="L351">                                .add(DAY_MASK.multiply(day))</span>
<span class="nc" id="L352">                                .add(HOUR_MASK.multiply(hour))</span>
<span class="nc" id="L353">                                .add(MINUTE_MASK.multiply(minute))</span>
<span class="nc" id="L354">                                .add(second);</span>
                                
        }
        
        Date decode(BigInteger timestamp){
<span class="nc" id="L359">            BigInteger current = timestamp;</span>
            
<span class="nc" id="L361">            BigInteger year = current.divide(YEAR_MASK);</span>
<span class="nc" id="L362">            current = current.mod(YEAR_MASK);</span>
            
<span class="nc" id="L364">            BigInteger month = current.divide(MONTH_MASK);</span>
<span class="nc" id="L365">            current = current.mod(MONTH_MASK);</span>
            
<span class="nc" id="L367">            BigInteger dayOfMonth = current.divide(DAY_MASK);</span>
<span class="nc" id="L368">            current = current.mod(DAY_MASK);</span>
            
<span class="nc" id="L370">            BigInteger hourOfDay = current.divide(HOUR_MASK);</span>
<span class="nc" id="L371">            current = current.mod(HOUR_MASK);</span>
            
<span class="nc" id="L373">            BigInteger minute = current.divide(MINUTE_MASK);</span>
<span class="nc" id="L374">            current = current.mod(MINUTE_MASK);</span>
            
<span class="nc" id="L376">            BigInteger second = current;</span>
<span class="nc" id="L377">            return new GregorianCalendar(</span>
<span class="nc" id="L378">                    year.intValue()+2000, month.intValue()-1, dayOfMonth.intValue(), </span>
<span class="nc" id="L379">                    hourOfDay.intValue(), minute.intValue(), second.intValue())</span>
<span class="nc" id="L380">            .getTime();</span>
            
        }        
    }
    /**
     * {@code RigRun} is an object
     * representation of a 454 Rig Run.
     * @author dkatzel
     *
     *
     */
    private static final class RigRun{
<span class="nc" id="L392">        private static final Pattern RIG_RUN_NAME_PATTERN = Pattern.compile(&quot;^R_(\\d+)_(\\d+)_(\\d+)_(\\d+)_(\\d+)_(\\d+)_.+&quot;);</span>
        
        private final Date dateOfRun;
        private final char hash;
        
<span class="nc" id="L397">        private RigRun(String rigRunName){</span>
<span class="nc" id="L398">            this.dateOfRun = parseDateFrom(rigRunName);</span>
<span class="nc" id="L399">            this.hash = generate454Hash(rigRunName);</span>
<span class="nc" id="L400">        }</span>
        /**
         * Get the date of the run.
         * @return
         */
        Date getDate(){
<span class="nc" id="L406">            return dateOfRun;</span>
        }
        /**
         * Get the 'randomizing' hash character used in universal accession
         * numbers to enhance uniqueness.  Since Universal Accessions use date of run
         * and region and well location to generate names, it is possible for name collisions
         * to occur if 2 454 machines
         * start running at the same time.  To avoid this problem, a hash
         * based on the run name is added to the name the reduce the chance of collisions.
         * @return the randomizing 'hash' character computed based on the algorithm
         * specified in the 454 documentation.
         */
        char getRandomizingHashcode(){
<span class="nc" id="L419">            return hash;</span>
        }
        
        private Date parseDateFrom(String rigRunName){
<span class="nc" id="L423">            Matcher matcher = RIG_RUN_NAME_PATTERN.matcher(rigRunName);</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">            if(!matcher.matches()){</span>
<span class="nc" id="L425">                throw new IllegalArgumentException(&quot;invalid rigRunName: &quot; + rigRunName);</span>
            }
<span class="nc" id="L427">            return new GregorianCalendar(</span>
<span class="nc" id="L428">                    Integer.parseInt(matcher.group(1)), </span>
<span class="nc" id="L429">                    Integer.parseInt(matcher.group(2)),</span>
<span class="nc" id="L430">                    Integer.parseInt(matcher.group(3)),</span>
<span class="nc" id="L431">                    Integer.parseInt(matcher.group(4)), </span>
<span class="nc" id="L432">                    Integer.parseInt(matcher.group(5)), </span>
<span class="nc" id="L433">                    Integer.parseInt(matcher.group(6))).getTime();</span>
        }
        private char generate454Hash(String rigRunName){
<span class="nc" id="L436">            int hash=0;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            for(char c : rigRunName.toCharArray()){</span>
<span class="nc" id="L438">                hash+= c;</span>
<span class="nc" id="L439">                hash%=31;</span>
            }
<span class="nc" id="L441">            return _454Base36Encoder.INSTANCE.encode(hash).charAt(0);</span>
            
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>