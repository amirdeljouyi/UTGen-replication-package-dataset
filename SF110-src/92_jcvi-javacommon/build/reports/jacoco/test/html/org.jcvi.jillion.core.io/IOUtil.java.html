<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IOUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core.io</a> &gt; <span class="el_source">IOUtil.java</span></div><h1>IOUtil.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Sep 11, 2008
 *
 * @author dkatzel
 */
package org.jcvi.jillion.core.io;

import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.EOFException;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.Reader;
import java.io.StringWriter;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.BitSet;
import java.util.Scanner;

import org.jcvi.jillion.internal.core.io.RandomAccessFileInputStream;

/**
 * {@code IOUtil} is a collection of static utility
 * methods that make working
 * with Input and Output easier.
 * @author dkatzel
 *
 */
public final class IOUtil {
    private static final int EOF = -1;
	/**
     * Some methods need to use Log base 2
     * a lot so it's easier to factor this out as a constant.
     */
<span class="fc" id="L64">    private static final double LOG_2 = Math.log(2);</span>
    /**
     * {@value}
     */
    public static final String UTF_8_NAME = &quot;UTF-8&quot;;
    /**
     * Singleton for the {@link Charset} implementation for 
     * UTF-8.
     */
<span class="fc" id="L73">    public static final Charset UTF_8 = Charset.forName(UTF_8_NAME);</span>
    
    /**
     * {@code Endian} is a way to specify how the ordering of bytes
     * is read from a byte array.
     * @author dkatzel
     *
     */
<span class="nc" id="L81">    public enum Endian{</span>
    	/**
    	 * Big Endian format has the most significant
    	 * byte as the first byte.
    	 */
<span class="nc" id="L86">        BIG,</span>
        /**
         * Little Endian format has the most significant
         * byte as the last byte.
         */
<span class="nc" id="L91">        LITTLE</span>
    }
    private IOUtil(){}
    /**
     * Recursively delete the given file.
     * @param file the root directory to delete.
     * @throws IOException if deleting the directory or
     * a file under the directory fails.
     * @throws NullPointerException if dir is null.    
     */
    public static void recursiveDelete(File file) throws IOException{
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if(file.exists()){</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            if (file.isDirectory()) {</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">                for(File subfile: file.listFiles()){</span>
<span class="nc" id="L105">                    recursiveDelete(subfile);</span>
                }
            }
        
            //we are here if dir is an empty dir or a file
<span class="nc" id="L110">            delete(file);</span>
        }

<span class="nc" id="L113">    }</span>
    /**
     * Deletes the given file and throws an Exception
     * if the delete fails.  This should be used in preference
     * over {@link File#delete()} since that method returns a boolean
     * result to indicate success or failure instead of 
     * throwing an exception.  If the file does not exist,
     * then this method will not do anything.
     * @param file the file to be deleted; if this parameter
     * is null, then method does nothing.
     * @throws IOException if there is a problem deleting the file.
     * @see #deleteIgnoreError(File)
     */
    public static void delete(File file) throws IOException{
<span class="nc bnc" id="L127" title="All 6 branches missed.">        if(file !=null &amp;&amp; file.exists() &amp;&amp; !file.delete()){</span>
<span class="nc" id="L128">            throw new IOException(&quot;unable to delete &quot;+ file);</span>
        }
<span class="nc" id="L130">    }</span>
    /**
     * Tries to delete the given File but doesn't
     * check to see if the delete was successful.
     * This is the same as calling {@link File#delete()}
     * without checking the return value.   If the file does not exist,
     * then this method will not do anything.
     * @param file the file to delete; if this parameter
     * is null, then method does nothing.
     */
    public static void deleteIgnoreError(File file){
    	//This method exists solely so we don't
    	//have file.delete()s without checking return
    	//values littered throughout the codebase. 
    	//programs like FindBugs will flag these
    	//statements as bad code since we don't check return value
    	//so I would rather have only 1 such warning instead of dozens.
<span class="nc bnc" id="L147" title="All 4 branches missed.">    	if(file!=null &amp;&amp; file.exists()){</span>
<span class="nc" id="L148">    		file.delete();</span>
    	}
<span class="nc" id="L150">    }</span>
    
    /**
     * Make the given directory and any non-existent 
     * parent directory as well.  This method should be used
     * in preference over {@link File#mkdirs()} since that method returns a boolean
     * result to indicate success or failure instead of 
     * throwing an exception.
     * @param dir the directory to be created; if dir is null or if it already
     * exists,
     * then this method does not do anything.
     * @throws IOException if there is a problem making the directories.
     */
    public static void mkdirs(File dir) throws IOException{
<span class="nc bnc" id="L164" title="All 2 branches missed.">    	if(dir==null){</span>
<span class="nc" id="L165">    		return;</span>
    	}
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if(dir.exists()){</span>
<span class="nc" id="L168">            return;</span>
        }
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if(!dir.mkdirs()){</span>
<span class="nc" id="L171">            throw new IOException(&quot;unable to mkdirs for &quot;+ dir);</span>
        }
<span class="nc" id="L173">    }</span>
    /**
     * Make the given directory.  This method should be used
     * in preference over {@link File#mkdir()} since that method returns a boolean
     * result to indicate success or failure instead of 
     * throwing an exception.
     * @param dir the directory to be created; if dir is null
     * then this method does not do anything. 
     * @throws IOException if there is a problem making the directory.
     */
    public static void mkdir(File dir) throws IOException{
<span class="nc bnc" id="L184" title="All 2 branches missed.">    	if(dir==null){</span>
<span class="nc" id="L185">    		return;</span>
    	}
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if(dir.exists()){</span>
<span class="nc" id="L188">            return;</span>
        }
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if(!dir.mkdir()){</span>
<span class="nc" id="L191">            throw new IOException(&quot;unable to mkdir for &quot;+ dir);</span>
        }
<span class="nc" id="L193">    }</span>
    /**
     * Close the given {@link Closeable} and ignore any exceptions
     * that are thrown.  Passing in a null will do nothing.
     * @param closeable the {@link Closeable} object to close.
     */
    public static void closeAndIgnoreErrors(Closeable closeable){
        try {
<span class="nc bnc" id="L201" title="All 2 branches missed.">            if(closeable !=null){</span>
<span class="nc" id="L202">                closeable.close();</span>
            }
<span class="nc" id="L204">        } catch (Exception ignore) {</span>
                //ignored on purpose
<span class="nc" id="L206">        }</span>
<span class="nc" id="L207">    }</span>
    /**
     * Convenience method for closing multiple
     * {@link Closeable}s at the same time, this
     * method is the same as calling {@link #closeAndIgnoreErrors(Closeable)}
     * on each parameter.
     * @param closeables the closeables to close.
     */
    public static void closeAndIgnoreErrors(Closeable...closeables){
<span class="nc bnc" id="L216" title="All 2 branches missed.">       for(Closeable closeable : closeables){</span>
<span class="nc" id="L217">           closeAndIgnoreErrors(closeable);</span>
       }
<span class="nc" id="L219">    }</span>
    /**
     * Close the given Statement and ignore any exceptions
     * that are thrown.  Passing in a null will do nothing.
     * @param statement the Statement object to close
     */
    public static void closeAndIgnoreErrors(Statement statement){
        try {
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if(statement !=null){</span>
<span class="nc" id="L228">                statement.close();</span>
            }
<span class="nc" id="L230">        } catch (SQLException ignore) {</span>
                //ignored on purpose
<span class="nc" id="L232">        }</span>
<span class="nc" id="L233">    }</span>
    /**
     * Close the given {@link ResultSet} and ignore any exceptions
     * that are thrown.  Passing in a null will do nothing.
     * @param resultSet the ResultSet object to close
     */
    public static void closeAndIgnoreErrors(ResultSet resultSet){
        try {
<span class="nc bnc" id="L241" title="All 2 branches missed.">            if(resultSet !=null){</span>
<span class="nc" id="L242">                resultSet.close();</span>
            }
<span class="nc" id="L244">        } catch (SQLException ignore) {</span>
                //ignored on purpose
<span class="nc" id="L246">        }</span>
<span class="nc" id="L247">    }</span>
    /**
     * Close the given {@link Connection} and ignore any exceptions
     * that are thrown.  Passing in a null will do nothing.
     * @param connection the Connection object to close
     */
    public static void closeAndIgnoreErrors(Connection connection){
        try {
<span class="nc bnc" id="L255" title="All 2 branches missed.">            if(connection !=null){</span>
<span class="nc" id="L256">                connection.close();</span>
            }
<span class="nc" id="L258">        } catch (SQLException ignore) {</span>
                //ignored on purpose
<span class="nc" id="L260">        }</span>
<span class="nc" id="L261">    }</span>
    /**
     * Close the given {@link Scanner} and ignore any exceptions
     * that are thrown.  Passing in a null will do nothing.
     * @param scanner the {@link Scanner}  object to close
     */
    public static void closeAndIgnoreErrors(Scanner scanner){
<span class="nc bnc" id="L268" title="All 2 branches missed.">        if(scanner !=null){</span>
<span class="nc" id="L269">            scanner.close();</span>
        }        
<span class="nc" id="L271">    }</span>
    /**
     * Skip &lt;code&gt;numberOfBytes&lt;/code&gt; in the {@link InputStream} 
     * and block until those bytes have been skipped. {@link InputStream#skip(long)}
     * will only skip as many bytes as it can without blocking.
     * @param in InputStream to skip.
     * @param numberOfBytes number of bytes to skip.
     * @throws IOException if there is a problem reading the inputstream
     * or if the end of file is reached before the number of bytes to skip
     * has been reached.
     */
    public static void blockingSkip(InputStream in, long numberOfBytes) throws IOException{

<span class="nc" id="L284">        long leftToSkip = numberOfBytes;</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">        while(leftToSkip &gt;0){</span>
        	//need to do a read() to see if we
        	//are at EOF yet. otherwise we loop forever
        	//since skip will return 0.
        	//this also is the reason for the -1 and +1 
        	//sprinkled around the leftToSkip computation.
<span class="nc" id="L291">        	int value =in.read();</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        	if(value == EOF){ </span>
<span class="nc" id="L293">        		throw new IOException(&quot;end of file reached before entire block was skipped&quot;);</span>
        	}
<span class="nc" id="L295">        	leftToSkip -= in.skip(leftToSkip-1) +1;</span>
<span class="nc" id="L296">        }</span>

<span class="nc" id="L298">    }</span>
    /**
     * Reads {@code buf.length} bytes of the given inputStream and
     * puts them into the given byte array starting at the given offset.
     * Will keep reading until length number of bytes have been read (possibly blocking). 
     * This is the same as {@link #blockingRead(InputStream, byte[], int, int) blockingRead(in,buf,0, buf.length)}
     * @param in the inputStream to read; can not be null.
     * @param buf the byte array to write the data from the stream to; can not be null.
     * @throws EOFException if EOF is unexpectedly reached.
     * @throws IOException if there is a problem reading the stream.
     * @throws NullPointerException if either inputStream  or buf are null.
     * @throws IllegalArgumentException if either offset  or length are negative.
     * @see #blockingRead(InputStream, byte[], int, int)
     */
    public static void blockingRead(InputStream in, byte[] buf) throws IOException{
<span class="nc" id="L313">    	blockingRead(in, buf, 0, buf.length);</span>
<span class="nc" id="L314">    }</span>
    
    /**
     * Reads {@code buf.length} bytes of the given {@link RandomAccessFile}
     * starting at the current file pointer and
     * puts them into the given byte array starting at the given offset.
     * Will keep reading until length number of bytes have been read (possibly blocking). 
     * This is the same as {@link #blockingRead(RandomAccessFile, byte[], int, int) blockingRead(in,buf,0, buf.length)}
     * @param file the {@link RandomAccessFile} to read; can not be null.
     * @param buf the byte array to write the data from the stream to; can not be null.
     * @throws EOFException if EOF is unexpectedly reached.
     * @throws IOException if there is a problem reading the stream.
     * @throws NullPointerException if either inputStream  or buf are null.
     * @throws IllegalArgumentException if either offset  or length are negative.
     * @see #blockingRead(RandomAccessFile, byte[], int, int)
     */
    public static void blockingRead(RandomAccessFile file, byte[] buf) throws IOException{
<span class="nc" id="L331">    	blockingRead(file, buf, 0, buf.length);</span>
<span class="nc" id="L332">    }</span>
    /**
     * Reads up to length number of bytes of the given inputStream and
     * puts them into the given byte array starting at the given offset.
     * Will keep reading until length number of bytes have been read (possibly blocking). 
     * @param in the inputStream to read; can not be null.
     * @param buf the byte array to write the data from the stream to; can not be null.
     * @param offset the offset into the byte array to begin writing 
     * bytes to must be {@code &gt;= 0}.
     * @param length the maximum number of bytes to read, must be {@code &gt;= 0}.
     * This number of bytes will be read unless the inputStream ends prematurely
     * (which will throw an IOException). 
     * @throws EOFException if EOF is unexpectedly reached.
     * @throws IOException if there is a problem reading the stream.
     * @throws NullPointerException if either inputStream  or buf are null.
     * @throws IllegalArgumentException if either offset  or length are negative.
     */
    public static void blockingRead(InputStream in, byte[] buf, int offset, int length) throws IOException{
<span class="nc" id="L350">        checkBlockingReadInputsAreOK(in, buf, offset, length);</span>
<span class="nc" id="L351">    	int currentBytesRead=0;</span>
<span class="nc" id="L352">        int totalBytesRead=0;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">        while((currentBytesRead =in.read(buf, offset+totalBytesRead, length-totalBytesRead))&gt;0){</span>
<span class="nc" id="L354">            totalBytesRead+=currentBytesRead;</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">            if(totalBytesRead == length){</span>
<span class="nc" id="L356">                break;</span>
            }
        }
<span class="nc bnc" id="L359" title="All 2 branches missed.">        if(currentBytesRead ==EOF){</span>
<span class="nc" id="L360">            throw new EOFException(String.format(&quot;end of file after only %d bytes read (expected %d)&quot;,totalBytesRead,length));</span>
        }
<span class="nc" id="L362">    }</span>
    
    
    /**
     * Reads up to length number of bytes of the given {@link RandomAccessFile} 
     * starting at the current file pointer and
     * puts them into the given byte array starting at the given offset.
     * Will keep reading until length number of bytes have been read (possibly blocking). 
     * @param file the {@link RandomAccessFile} to read; can not be null.
     * @param buf the byte array to write the data from the stream to; can not be null.
     * @param offset the offset into the byte array to begin writing 
     * bytes to must be {@code &gt;= 0}.
     * @param length the maximum number of bytes to read, must be {@code &gt;= 0}.
     * This number of bytes will be read unless the inputStream ends prematurely
     * (which will throw an IOException). 
     * @throws EOFException if EOF is unexpectedly reached.
     * @throws IOException if there is a problem reading the stream.
     * @throws NullPointerException if either inputStream  or buf are null.
     * @throws IllegalArgumentException if either offset  or length are negative.
     */
    public static void blockingRead(RandomAccessFile file, byte[] buf, int offset, int length) throws IOException{
<span class="nc" id="L383">        checkBlockingReadInputsAreOK(file, buf, offset, length);</span>
<span class="nc" id="L384">    	int currentBytesRead=0;</span>
<span class="nc" id="L385">        int totalBytesRead=0;</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        while((currentBytesRead =file.read(buf, offset+totalBytesRead, length-totalBytesRead))&gt;0){</span>
<span class="nc" id="L387">            totalBytesRead+=currentBytesRead;</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">            if(totalBytesRead == length){</span>
<span class="nc" id="L389">                break;</span>
            }
        }
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if(currentBytesRead ==EOF){</span>
<span class="nc" id="L393">            throw new EOFException(String.format(&quot;end of file after only %d bytes read (expected %d)&quot;,totalBytesRead,length));</span>
        }
<span class="nc" id="L395">    }</span>
	private static void checkBlockingReadInputsAreOK(InputStream in,
			byte[] buf, int offset, int length) {
<span class="nc bnc" id="L398" title="All 2 branches missed.">		if(buf ==null){</span>
<span class="nc" id="L399">        	throw new NullPointerException(&quot;byte array can not be null&quot;);</span>
        }
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if(in ==null){</span>
<span class="nc" id="L402">        	throw new NullPointerException(&quot;inputstream can not be null&quot;);</span>
        }
<span class="nc bnc" id="L404" title="All 2 branches missed.">        if(offset &lt;0){</span>
<span class="nc" id="L405">        	throw new IllegalArgumentException(&quot;offset must be &gt;= 0&quot;);</span>
        }
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if(length &lt;0){</span>
<span class="nc" id="L408">        	throw new IllegalArgumentException(&quot;length must be &gt;= 0&quot;);</span>
        }
<span class="nc" id="L410">	}</span>
	private static void checkBlockingReadInputsAreOK(RandomAccessFile in,
			byte[] buf, int offset, int length) {
<span class="nc bnc" id="L413" title="All 2 branches missed.">		if(buf ==null){</span>
<span class="nc" id="L414">        	throw new NullPointerException(&quot;byte array can not be null&quot;);</span>
        }
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if(in ==null){</span>
<span class="nc" id="L417">        	throw new NullPointerException(&quot;inputstream can not be null&quot;);</span>
        }
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if(offset &lt;0){</span>
<span class="nc" id="L420">        	throw new IllegalArgumentException(&quot;offset must be &gt;= 0&quot;);</span>
        }
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if(length &lt;0){</span>
<span class="nc" id="L423">        	throw new IllegalArgumentException(&quot;length must be &gt;= 0&quot;);</span>
        }
<span class="nc" id="L425">	}</span>
   
    public static short[] readUnsignedByteArray(InputStream in, int expectedLength) throws IOException {
<span class="nc" id="L428">        short[] array = new short[expectedLength];</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">        for(int i=0; i&lt;expectedLength; i++){</span>
<span class="nc" id="L430">            array[i]=(short)in.read();</span>
        }
<span class="nc" id="L432">        return array;</span>
    }
    public static short[] readShortArray(InputStream in, int numberOfShortsToRead) throws IOException {
<span class="nc" id="L435">        short[] array = new short[numberOfShortsToRead];</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">        for(int i=0; i&lt;numberOfShortsToRead; i++){</span>
        	//borrowed from DataInputStream#readShort()
<span class="nc" id="L438">        	int ch1 = in.read();</span>
<span class="nc" id="L439">            int ch2 = in.read();</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">            if ((ch1 | ch2) &lt; 0){</span>
<span class="nc" id="L441">                throw new EOFException();</span>
            }
<span class="nc" id="L443">            array[i]= (short)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));</span>
        }
<span class="nc" id="L445">        return array;</span>
    }

    public static void putShortArray(ByteBuffer buf, short[] array){
<span class="nc bnc" id="L449" title="All 2 branches missed.">        for(int i=0; i&lt; array.length; i++){</span>
<span class="nc" id="L450">            buf.putShort(array[i]);</span>
        }
<span class="nc" id="L452">    }</span>
    public static void putUnsignedByteArray(ByteBuffer buf, short[] array){
<span class="nc bnc" id="L454" title="All 2 branches missed.">        for(int i=0; i&lt; array.length; i++){</span>
<span class="nc" id="L455">            buf.put((byte)array[i]);</span>
        }
<span class="nc" id="L457">    }</span>
    /**
     * Converts signed java byte value into an unsigned value.
     * @param value the signed value to convert.
     * @return the unsigned value as an int.
     */
    public static int toUnsignedByte(byte value){
<span class="fc" id="L464">       return value &amp; 0xFF;</span>
    }
    /**
     * Converts an unsigned signed byte value into a signed value.
     * @param unsignedByte the unsigned value to convert.
     * @return the signed value as a byte.
     */
    public static byte toSignedByte(int unsignedByte){
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">    	if(unsignedByte&gt;127){</span>
<span class="nc" id="L473">    		return (byte)(unsignedByte-256);</span>
    	}
<span class="fc" id="L475">    	return (byte)unsignedByte;</span>
    }

    public static short toSignedShort(int unsignedShort){
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">        if(unsignedShort &gt; Short.MAX_VALUE){</span>
<span class="nc" id="L480">            return (short)(unsignedShort -(2*(Short.MAX_VALUE+1)));</span>
        }
<span class="fc" id="L482">        return (short)unsignedShort;</span>
    }
    public static int toSignedInt(long unsignedInt){
<span class="nc bnc" id="L485" title="All 2 branches missed.">        if(unsignedInt &gt; Integer.MAX_VALUE){</span>
<span class="nc" id="L486">            return (int)(unsignedInt -(2*(Integer.MAX_VALUE+1)));</span>
        }
<span class="nc" id="L488">        return (int)unsignedInt;</span>
    }
    /**
     * Converts signed java short value into an unsigned value.
     * @param value the signed value to convert.
     * @return the unsigned value as an int.
     */
    public static int toUnsignedShort(short value){
<span class="fc" id="L496">        return value &amp; 0xFFFF;</span>
    }
    
    
    /**
     * Converts signed java short value into an unsigned value.
     * @param value the signed value to convert.
     * @return the unsigned value as an long.
     */
    public static long toUnsignedInt(int value){
<span class="nc" id="L506">        return value &amp; 0xFFFFFFFFL;</span>
    }
    
    /**
     * This method changes the endian of the byte array.
     * @param byteArray
     * @return a new byte array which represents the same data as the
     * passed in array, but with the endian switched. (Big Endian -&gt; Little Endian
     * or vice versa)
     */
    public static byte[] switchEndian(byte[] byteArray){
<span class="nc" id="L517">        byte newByteArray[] = new byte[byteArray.length];</span>
        //only need to swap half the array
<span class="nc bnc" id="L519" title="All 2 branches missed.">        for(int i=0; i&lt; byteArray.length /2; i++){</span>

<span class="nc" id="L521">            newByteArray[i] = byteArray[byteArray.length-1 -i];</span>
<span class="nc" id="L522">            newByteArray[byteArray.length-1 -i]=byteArray[i];</span>
        }
        //handle case of odd length
<span class="nc bnc" id="L525" title="All 2 branches missed.">        if(byteArray.length %2 ==1){</span>
<span class="nc" id="L526">            int center =byteArray.length/2;</span>
<span class="nc" id="L527">            newByteArray[center]=byteArray[center];</span>
        }
<span class="nc" id="L529">        return newByteArray;</span>

    }
    
    public static BigInteger readUnsignedLong(InputStream in, Endian endian) throws IOException{
<span class="nc" id="L534">        return new BigInteger(1,</span>
<span class="nc" id="L535">                 IOUtil.toByteArray(in, 8, endian));</span>
     }
    public static long readUnsignedInt(InputStream in, Endian endian) throws IOException{
<span class="nc" id="L538">        return new BigInteger(1,</span>
<span class="nc" id="L539">                 IOUtil.toByteArray(in, 4, endian)).longValue();</span>
     }
    public static long readUnsignedInt(byte[] array){
<span class="nc" id="L542">        return new BigInteger(1,</span>
<span class="nc" id="L543">                 array).longValue();</span>
     }
    public static int readUnsignedShort(byte[] array){
<span class="nc" id="L546">        return new BigInteger(1,</span>
<span class="nc" id="L547">                 array).intValue();</span>
     }
    public static short readUnsignedByte(byte[] array){
<span class="nc" id="L550">        return new BigInteger(1,</span>
<span class="nc" id="L551">                 array).shortValue();</span>
     }
    public static int readUnsignedShort(InputStream in, Endian endian) throws IOException{
<span class="nc" id="L554">        return new BigInteger(1,</span>
<span class="nc" id="L555">                 IOUtil.toByteArray(in, 2, endian)).intValue();</span>
     }
    public static short readUnsignedByte(InputStream in, Endian endian) throws IOException{
<span class="nc" id="L558">        return new BigInteger(1,</span>
<span class="nc" id="L559">                 IOUtil.toByteArray(in, 1, endian)).shortValue();</span>
     }
    
    public static BigInteger getUnsignedLong(ByteBuffer buf) throws IOException{
<span class="nc" id="L563">        byte[] tmp = new byte[8];</span>
<span class="nc" id="L564">        buf.get(tmp);</span>
<span class="nc" id="L565">    	return new BigInteger(1,tmp);</span>
     }
    public static long getUnsignedInt(ByteBuffer buf) throws IOException{
<span class="nc" id="L568">        byte[] tmp = new byte[4];</span>
<span class="nc" id="L569">        buf.get(tmp);</span>
<span class="nc" id="L570">    	return new BigInteger(1,tmp).longValue();</span>
     }
    public static int getUnsignedShort(ByteBuffer buf) throws IOException{
<span class="nc" id="L573">        byte[] tmp = new byte[2];</span>
<span class="nc" id="L574">        buf.get(tmp);</span>
<span class="nc" id="L575">    	return new BigInteger(1,tmp).intValue();</span>
     }
    public static short getUnsignedByte(ByteBuffer buf) throws IOException{
<span class="nc" id="L578">        byte[] tmp = new byte[1];</span>
<span class="nc" id="L579">        buf.get(tmp);</span>
<span class="nc" id="L580">    	return new BigInteger(1,tmp).shortValue();</span>
     }
    
    
    
    
    public static BigInteger readUnsignedLong(InputStream in) throws IOException{
<span class="nc" id="L587">       return readUnsignedLong(in, Endian.BIG);</span>
     }
    public static long readUnsignedInt(InputStream in) throws IOException{
<span class="nc" id="L590">        return readUnsignedInt(in, Endian.BIG);</span>
      }
    public static int readUnsignedShort(InputStream in) throws IOException{
<span class="nc" id="L593">        return readUnsignedShort(in, Endian.BIG);</span>
      }
    public static short readUnsignedByte(InputStream in) throws IOException{
<span class="nc" id="L596">        return readUnsignedByte(in, Endian.BIG);</span>
      }
    
    public static byte[] convertUnsignedIntToByteArray(long unsignedInt){
<span class="nc" id="L600">        byte[] result = new byte[4];</span>
<span class="nc" id="L601">        long currentValue = unsignedInt;</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">        for(int i=result.length-1; i&gt;=0; i--){</span>
<span class="nc" id="L603">            result[i]=(byte)(currentValue &amp;0xff);</span>
<span class="nc" id="L604">            currentValue&gt;&gt;&gt;=8;</span>
        }
<span class="nc" id="L606">        return result;</span>
    }
    /**
     * Convert an unsigned short into a fully padded
     * byte array.
     * &lt;p/&gt;
     * For Example:&lt;br/&gt;
     * 3 =&gt; [0, 3]&lt;br/&gt;
     * 255 =&gt; [0, 255]&lt;br/&gt;
     * 256 =&gt; [1, 255]&lt;br/&gt;
     * @param unsignedShort
     * @return
     */
    public static byte[] convertUnsignedShortToByteArray(int unsignedShort){
<span class="nc" id="L620">        byte[] result = new byte[2];</span>
<span class="nc" id="L621">        int currentValue = unsignedShort;</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">        for(int i=result.length-1; i&gt;=0; i--){</span>
<span class="nc" id="L623">            result[i]=(byte)(currentValue &amp;0xff);</span>
<span class="nc" id="L624">            currentValue&gt;&gt;&gt;=8;</span>
        }
<span class="nc" id="L626">        return result;</span>
    }
    public static byte[] convertUnsignedByteToByteArray(short unsignedByte){
<span class="nc" id="L629">        byte[] result = new byte[1];       </span>
<span class="nc" id="L630">        result[0]=(byte)(unsignedByte &amp;0xff);</span>
          
<span class="nc" id="L632">        return result;</span>
    }
    
    public static byte[] convertUnsignedLongToByteArray(BigInteger unsignedLong){
        //BigInteger.toByteArray() only returns the minimum number of bytes
        //(signed) required to represent the number,
        //it's easier to convert to hex, padd with 0's then convert
        //each hex byte than to do the bit math to take an odd number of bits
        //and compute the padded value.
<span class="nc" id="L641">        String hexString =convertToPaddedHex(unsignedLong,16);</span>
<span class="nc" id="L642">        byte[] result = new byte[8];</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">        for(int i= 0; i&lt;16; i+=2){</span>
<span class="nc" id="L644">            String byteInHex = hexString.substring(i, i+2);</span>
<span class="nc" id="L645">            result[i/2] = (byte) Short.parseShort(byteInHex, 16);</span>
        }
        
<span class="nc" id="L648">       return result;</span>
    }
    
    private static String convertToPaddedHex(BigInteger value, int maxNumberOfHexChars) {
<span class="nc" id="L652">        String hexString =value.toString(16);</span>
<span class="nc" id="L653">        int padding = maxNumberOfHexChars-hexString.length();</span>
<span class="nc" id="L654">        StringBuilder paddingString = new StringBuilder();</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">        for(int i=0; i&lt; padding; i++){</span>
<span class="nc" id="L656">            paddingString.append('0');</span>
        }
<span class="nc" id="L658">        paddingString.append(hexString);</span>
<span class="nc" id="L659">        return paddingString.toString();</span>
    }
    
    public static InputStream createInputStreamFromFile(File file,long startOffset, int length)throws IOException {
<span class="nc" id="L663">       return new RandomAccessFileInputStream(file, startOffset, length);</span>
    }
    /**
     * Get the number of bits required
     * to represent this value in binary.
     * @param value the value as an positive long.
     * @return the number of bits that are required
     * to represent this value as an unsigned binary
     * integer.
     * @throw IllegalArgumentException if value &lt; 0.
     */
    public static int getUnsignedBitCount(long value) {
<span class="nc bnc" id="L675" title="All 2 branches missed.">        if(value &lt;0){</span>
<span class="nc" id="L676">            throw new IllegalArgumentException(&quot;value can not be &lt;0&quot;);</span>
        }
<span class="nc bnc" id="L678" title="All 2 branches missed.">        if(value ==Long.MAX_VALUE){</span>
            //special case
<span class="nc" id="L680">            return 64;</span>
        }
<span class="nc" id="L682">        return (int)Math.ceil(Math.log(value+1)/LOG_2);</span>
    }   
    
    /**
     * Get the number of bytes required
     * to represent this value in binary.
     * @param value the value as an positive long.
     * @return the number of bytes that are required
     * to represent this value as an unsigned binary
     * integer.
     * @throw IllegalArgumentException if value &lt; 0.
     */
    public static int getUnsignedByteCount(long value){
<span class="nc" id="L695">        int numBits = getUnsignedBitCount(value);</span>
<span class="nc" id="L696">        return (numBits+7)/8;</span>
    }
    
    /**
     * Convert the given {@link BitSet} into
     * the corresponding byte array.
     * For some reason {@link BitSet}
     * Java API thru java 6 does not include methods for converting
     * to and from a byte array.
     * @param bitset the bitset to convert.
     * @param bitLength the number of bits that need to be present
     * in the byte array.  This needs to be specified because
     * a {@link BitSet} may have trailing 0's
     * which would get truncated otherwise.
     * @return a new byte array containing the smallest 
     * number of bytes required to store the same data as
     * the given {@link BitSet}.
     * @throws NullPointerException if bitset is null.
     * @throws IllegalArgumentException if bitLength &lt;0.
     */
    public static byte[] toByteArray(BitSet bitset, int bitLength){
<span class="nc bnc" id="L717" title="All 2 branches missed.">    	if(bitset ==null){</span>
<span class="nc" id="L718">    		throw new NullPointerException(&quot;bitset can not be null&quot;);</span>
    	}
<span class="nc bnc" id="L720" title="All 2 branches missed.">    	if(bitLength&lt;0){</span>
<span class="nc" id="L721">    		throw new IllegalArgumentException(&quot;bitLength must be &gt;=0&quot;);</span>
    	}
    	
<span class="nc" id="L724">    	byte[] bytes = new byte[(bitLength + 7) / 8];</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">    	for(int i=0; i&lt;bitLength; i++){</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">    		if(bitset.get(i)){</span>
<span class="nc" id="L727">    			bytes[bytes.length-i/8-1] |= 1&lt;&lt; (i%8);</span>
    		}
    	}
<span class="nc" id="L730">    	return bytes;</span>
    }
    /**
     * Convert the given byte array into
     * the corresponding {@link BitSet}
     * using the &lt;strong&gt;least&lt;/strong&gt;
     * number of bits possible.
     * For some reason {@link BitSet}
     * Java API thru java 6 does not include methods for converting
     * to and from a byte array.
     * @param bytes the byte array to convert.
     * @return a new {@link BitSet} containing the same data as
     * the given byte array.
     * @throws NullPointerException if bytes is null.
     */
    public static BitSet toBitSet(byte[] bytes){
    	final BitSet bits;
<span class="nc" id="L747">    	bits = new BitSet();</span>
<span class="nc" id="L748">    	int maxNumberOfBits = bytes.length *8;</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">    	for(int i=0; i&lt;maxNumberOfBits; i++){</span>
<span class="nc" id="L750">			int value = bytes[bytes.length-i/8-1] &amp; (1&lt;&lt; (i%8));</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">			if(value !=0){</span>
<span class="nc" id="L752">    			bits.set(i);</span>
    		}
    	}
    	
<span class="nc" id="L756">    	return bits;</span>
    }
    /**
     * Convert the given byte array into
     * the corresponding {@link BitSet}
     * using the &lt;strong&gt;least&lt;/strong&gt;
     * number of bits possible.
     * For some reason {@link BitSet}
     * Java API thru java 6 does not include methods for converting
     * to and from a byte array.
     * @param buffer the {@link ByteBuffer} to convert.
     * @return a new {@link BitSet} containing the same data as
     * the given byte array.
     * @throws NullPointerException if bytes is null.
     */
    public static BitSet toBitSet(ByteBuffer buffer){
    	final BitSet bits;
<span class="nc" id="L773">    	bits = new BitSet(8*buffer.remaining());</span>
<span class="nc" id="L774">    	int j=0;</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">    	while(buffer.remaining() &gt;0){</span>
<span class="nc" id="L776">    		byte value = buffer.get();</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">    		for(int i=0; i&lt;8; i++){</span>
<span class="nc" id="L778">    			int bit = value &amp; (1&lt;&lt; i);</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">    			if(bit !=0){</span>
<span class="nc" id="L780">        			bits.set(j+i);</span>
        		}
    		}
<span class="nc" id="L783">    		j+=8;</span>
<span class="nc" id="L784">    	}</span>
    	
    	
<span class="nc" id="L787">    	return bits;</span>
    }
    /**
     * Convert the given single value into
     * the corresponding {@link BitSet}
     * using the &lt;strong&gt;least&lt;/strong&gt;
     * number of bits possible.
     * For some reason {@link BitSet}
     * Java API thru java 6 does not include methods for converting
     * to and from a byte array.
     * @param singleValue the value to convert.
     * @return a new {@link BitSet} containing the same data as
     * the given byte array.
     */
    public static BitSet toBitSet(long singleValue){
<span class="nc" id="L802">    	return toBitSet(BigInteger.valueOf(singleValue).toByteArray());    	</span>
    }
    /**
     * Copy the contents of the given inputStream to the given
     * outputStream.  This method buffers internally so there is no
     * need to use a {@link BufferedInputStream}.  This method 
     * &lt;strong&gt;does not&lt;/strong&gt; close either stream
     * after processing.
     * @param in the inputStream to read.
     * @param out the outputStream to write to.
     * @return the number of bytes that were copied.
     * @throws IOException if there is a problem reading or writing
     * the streams.
     * @throws NullPointerException if either stream is null.
     */
    public static long copy(InputStream in, OutputStream out) throws IOException{
<span class="nc" id="L818">    	byte[] buf = new byte[2048];</span>
<span class="nc" id="L819">    	long numBytesCopied=0;</span>
    	while(true){
<span class="nc" id="L821">    		int numBytesRead =in.read(buf);</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">    		if(numBytesRead ==EOF){</span>
<span class="nc" id="L823">    			break;</span>
    		}
<span class="nc" id="L825">    		numBytesCopied+=numBytesRead;</span>
<span class="nc" id="L826">    		out.write(buf, 0, numBytesRead);</span>
<span class="nc" id="L827">    		out.flush();</span>
<span class="nc" id="L828">    	}</span>
<span class="nc" id="L829">    	return numBytesCopied;</span>
    }
    /**
     * Read the contents of the given {@link InputStream}
     * using the default character encoding
     * and return the entire contents of the stream
     * as a String.  This method will not close the stream
     * when it is done.  There is no need to buffer the {@link InputStream}
     * since this method will buffer internally.
     * @param in the inputStream to read as a String; can not be null.
     * @return a String representing the contents of the given
     * String using the default character encoding.
     * @throws IOException if there is a problem reading the Stream.
     * @throws NullPointerException if inputStream is null.
     */
    public static String toString(InputStream in) throws IOException{
<span class="nc" id="L845">    	return toString(in,null);</span>
    }
    /**
     * Read the contents of the given {@link InputStream}
     * using the default character encoding
     * and return the entire contents of the stream
     * as a String.  This method will not close the stream
     * when it is done.  There is no need to buffer the {@link InputStream}
     * since this method will buffer internally.
     * @param in the inputStream to read as a String; can not be null.
     * @param encoding the name of the {@link Charset} encoding to use; if this value
     * is null, then use the default as defined by {@link Charset#defaultCharset()}.
     * @return a String representing the contents of the given
     * String using the default character encoding.
     * @throws IOException if there is a problem reading the Stream.
     * @throws NullPointerException if inputStream is null.
     * @throws UnsupportedEncodingException if the encoding name is not supported.
     */
    public static String toString(InputStream in, String encoding) throws IOException{
<span class="nc" id="L864">    	StringWriter writer = new StringWriter();</span>
    	final Reader reader;
<span class="nc bnc" id="L866" title="All 2 branches missed.">    	if(encoding ==null){</span>
<span class="nc" id="L867">    		reader= new InputStreamReader(in,Charset.defaultCharset());</span>
    	}else{
<span class="nc" id="L869">    		reader = new InputStreamReader(in,encoding);</span>
    	}
<span class="nc" id="L871">    	char[] buf = new char[1024];</span>
    	while(true){
<span class="nc" id="L873">    		int numBytesRead =reader.read(buf);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">    		if(numBytesRead ==EOF){</span>
<span class="nc" id="L875">    			break;</span>
    		}
<span class="nc" id="L877">    		writer.write(buf, 0, numBytesRead);</span>
<span class="nc" id="L878">    	}</span>
<span class="nc" id="L879">    	return writer.toString();</span>
    }
    /**
     * Copy the contents of the given {@link InputStream}
     * and return it as a byte[].
     * @param input the inputStream to convert into a byte[].  
     * This stream is not closed when the method finishes.
     * @return a new byte array instance containing all the bytes
     * from the given inputStream.
     * @throws IOException if there is a problem reading the Stream.
     */
	public static byte[] toByteArray(InputStream input) throws IOException {
<span class="nc" id="L891">		return toByteArray(input, Endian.BIG);</span>
	}
	/**
     * Copy the contents of the given {@link InputStream}
     * and return it as a byte[] using the given {@link Endian}
     * order.
     * @param input the inputStream to convert into a byte[].  
     * This stream is not closed when the method finishes.
     * @param endian the {@link Endian} to use; null is considered
     * {@link Endian#BIG} (the default).
     * @return a new byte array instance containing all the bytes
     * from the given inputStream.
     * @throws IOException if there is a problem reading the Stream.
     */
	public static byte[] toByteArray(InputStream input,Endian endian) throws IOException {
<span class="nc" id="L906">		ByteArrayOutputStream output = new ByteArrayOutputStream();</span>
<span class="nc" id="L907">        copy(input, output);</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">        if(endian ==Endian.LITTLE){</span>
<span class="nc" id="L909">        	return switchEndian(output.toByteArray());</span>
        }
<span class="nc" id="L911">        return output.toByteArray();</span>
	}
	 /**
     * Copy the numberOfBytesToRead of the given {@link InputStream}
     * and return it as a byte[].  This is the same
     * as {@link #toByteArray(InputStream, int, Endian)
     * toByteArray(in,numberOfBytesToRead,Endian.BIG)}
     */
	 public static byte[] toByteArray(InputStream in, int numberOfBytesToRead) throws IOException {
<span class="nc" id="L920">	       return toByteArray(in, numberOfBytesToRead, Endian.BIG);</span>
	 }
	 /**
     * Copy the numberOfBytesToRead of the given {@link InputStream}
     * and return it as a byte[] using the given {@link Endian}
     * order.
     * @param in the inputStream to convert into a byte[].  
     * This stream is not closed when the method finishes.
     * @param numberOfBytesToRead the number of bytes to read from the stream;
     * if there aren't enough bytes, then this method will block until
     * more bytes are available or until the stream reaches end of file
     * (which will cause an IOException to be thrown).
     * @param endian the {@link Endian} to use; null is considered
     * {@link Endian#BIG} (the default).
     * @return a new byte array instance containing all the bytes
     * from the given inputStream.
     * @throws EOFException if the end of the file is reached before
     * the given number of bytes.
     * @throws IOException if there is a problem reading the inputStream.
     */
    public static byte[] toByteArray(InputStream in, int numberOfBytesToRead, Endian endian) throws IOException {
<span class="nc" id="L941">        byte[] array = new byte[numberOfBytesToRead];</span>
<span class="nc" id="L942">        blockingRead(in,array,0,numberOfBytesToRead);        </span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">        if(endian == Endian.LITTLE){</span>
<span class="nc" id="L944">            return IOUtil.switchEndian(array);</span>
        }
<span class="nc" id="L946">        return array;</span>
    }
    
    
    /**
     * Compute the number of bits required to
     * store the given value. For example
     * the value 2 requires 2 bits and the value 6 requires 3 bits etc.
     * @param value the value to get the number of bits 
     * for.
     * @return the number of bits needed.
     */
	public static int computeNumberOfBitsIn(int value){
<span class="nc bnc" id="L959" title="All 2 branches missed.">		if(value ==0){</span>
			//special case
<span class="nc" id="L961">			return 1;</span>
		}
<span class="nc" id="L963">		return Integer.SIZE-Integer.numberOfLeadingZeros(value);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>