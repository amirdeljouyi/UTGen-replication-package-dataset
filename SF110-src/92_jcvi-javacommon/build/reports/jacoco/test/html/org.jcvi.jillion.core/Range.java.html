<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Range.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core</a> &gt; <span class="el_source">Range.java</span></div><h1>Range.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Jul 18, 2007
 *
 * @author dkatzel
 */
package org.jcvi.jillion.core;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.internal.core.util.Caches;
import org.jcvi.jillion.internal.core.util.JillionUtil;


/**
 * A &lt;code&gt;Range&lt;/code&gt; is a pair of coordinate values which describe a
 * contiguous subset of a sequence of values.  &lt;code&gt;Range&lt;/code&gt;s are
 * immutable.  Changes to a &lt;code&gt;Range&lt;/code&gt; are done using {@link Builder Range.Builder} 
 * to create new instances.
 * &lt;p&gt;
 * &lt;code&gt;Range&lt;/code&gt;s have a begin value and an end
 * value.  The start value will always be less than or equal to the end value.
 * The minimum start value of a Range is {@link Long#MIN_VALUE}  and the max end
 * value of a Range is {@link Long#MAX_VALUE}. Also due to limitations
 * to Java primitives, Ranges can not have a length &gt; {@link Long#MAX_VALUE}.
 *  Any attempt to build Ranges beyond
 * those values will throw Exceptions.
 * &lt;p&gt;
 * The Range coordinates are 0-based inclusive.  Thus, a &lt;code&gt;Range&lt;/code&gt;
 * of 20 to 30 has a size of 11, not 10, and a &lt;code&gt;Range&lt;/code&gt; of 42 to 42
 * will have a size of 1 not 0.  This is done to conform with the overwhelming
 * majority use of inclusive ranges in Bioinformatics. The implications of this are particularly important when thinking about the
 * desire to represent no range at all.  A &lt;code&gt;Range&lt;/code&gt; of 0 to 0 still
 * has a size of 1.  In order to represent a &lt;code&gt;Range&lt;/code&gt; with length 0,
 * you need to create a Range of length 0 by either using the static factory method
 * {@link Range#ofLength(long) Range.ofLength(0)} or create a new
 * {@link Builder Range.Builder} instance with either the empty constructor
 * or use the methods on the builder to shrink the range to an empty length.
 * &lt;p&gt;
 * Often, Bioinformatics formats use non-0-based coordinates. Other coordinate system start and end values can be queried
 * via the {@link #getBegin(CoordinateSystem)} and {@link #getEnd(CoordinateSystem)} methods.  
 * A different {@link CoordinateSystem} can be also be specified at construction time
 * via the {@link Range#of(CoordinateSystem, long, long)} method.  If this method is used,
 * the input values will automatically get converted into 0-based coordinates.
 * &lt;p/&gt;
 * Ranges can be constructed using either {@link Builder Range.Builder} 
 * of through several convenience static factory methods including
 *  {@link Range#of(long)}, {@link Range#of(long, long)} ,
 *  {@link Range#of(CoordinateSystem, long, long)} and {@link Range#ofLength(long)}.
 *  All of these methods use {@link Builder Range.Builder}  internally.
 *  &lt;p/&gt;
 *  The actual implementation of Range returned by these methods or the {@link Builder Range.Builder} 
 *  might vary based on input values in order to decrease memory usage.  (For example a Range that is very short
 *  could represent the length as a byte instead of a long.  Or if the range is in positive
 *  coordinates then memory could be saved by using unsigned values instead of signed. etc).
 *  In addition, since Ranges are immutable,
 * it is not guaranteed that the Range object returned by these creation methods
 * is a new instance since Ranges are often cached (Flyweight pattern).  Therefore;
 * &lt;strong&gt; Range objects should not be used
 * for synchronization locks.&lt;/strong&gt;  Range objects are cached and shared, synchronizing
 * on the same object as other, unrelated code can cause deadlock.
 * &lt;pre&gt; 
 * &amp;#047;&amp;#047;don't do this
 * private static Range range = Range.ofLength(10);
 * ...
 *   synchronized(range){ .. }
 * ...
 * &lt;/pre&gt;
 * @author dkatzel
 * @author jsitz@jcvi.org
 * 
 * @see CoordinateSystem
 * @see #Range.Builder
 * 
 */
public abstract class Range implements Rangeable,Iterable&lt;Long&gt;
{
	/**
	 * 2^8 -1.
	 */
	private static final int UNSIGNED_BYTE_MAX = 255;
	/**
	 * 2^16 -1.
	 */
	private static final int UNSIGNED_SHORT_MAX = 65535;
	/**
	 * 2^32 -1.
	 */
	private static final long UNSIGNED_INT_MAX = 4294967295L;
	/**
	 * Initial size of our cache of ranges {@link #CACHE}.
	 */
    private static final int INITIAL_CACHE_SIZE = 1024;

    /**
     * Regular expression in the form (left) .. (right).
     */
<span class="fc" id="L126">    private static Pattern DOT_PATTERN = Pattern.compile(&quot;(\\d+)\\s*\\.\\.\\s*(\\d+)&quot;);</span>
    /**
     * Regular expression in the form (left) - (right).
     */
<span class="fc" id="L130">    private static Pattern DASH_PATTERN = Pattern.compile(&quot;(\\d+)\\s*-\\s*(\\d+)&quot;);</span>
    /**
     * Regular expression in the form (left) , (right).
     */
<span class="fc" id="L134">    private static Pattern COMMA_PATTERN = Pattern.compile(&quot;(\\d+)\\s*,\\s*(\\d+)&quot;);</span>
    /**
     * Cache of previously built ranges.  
     * This cache uses  {@link SoftReference}s
     * so memory can be reclaimed if needed.
     */
    private static final Map&lt;String, Range&gt; CACHE;
    
    
    /**
     * {@code Comparators} is an enum of common Range
     * {@link Comparator} implementations.
     * @author dkatzel
     *
     *
     */
<span class="nc" id="L150">    public enum Comparators implements Comparator&lt;Range&gt;{</span>
        /**
         * Compares a pair of {@link Range}s
         * and assigns the lower comparative value to the Range which begins earlier.
         * In the case of two ranges having identical start coordinates, the one
         * with the lower end coordinate (the shorter range) will be ranked lower.
         * 
         */
<span class="nc" id="L158">        ARRIVAL{</span>
            @Override
            public int compare(Range first, Range second) 
            {
                /*
                 * We don't accept null values for comparison.
                 */
<span class="nc bnc" id="L165" title="All 2 branches missed.">                if (first == null){</span>
<span class="nc" id="L166">                    throw new NullPointerException(&quot;The first parameter in the comparison is null.&quot;);</span>
                }
<span class="nc bnc" id="L168" title="All 2 branches missed.">                if (second == null){</span>
<span class="nc" id="L169">                    throw new NullPointerException(&quot;The second parameter in the comparison is null.&quot;);</span>
                }

                /*
                 * Compare first by the start values, then by the end values, if the ranges start
                 * in the same place.
                 */
<span class="nc" id="L176">                final int startComparison = JillionUtil.compare(first.getBegin(),second.getBegin());</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                if (startComparison == 0)</span>
                {
<span class="nc" id="L179">                    return JillionUtil.compare(first.getEnd(), second.getEnd());</span>
                }
<span class="nc" id="L181">                return startComparison;</span>
            }
        },
        /**
         * Compares a pair of {@link Range}s
         * and assigns the lower comparative value to the Range which ends earlier.
         * In the case of two ranges having identical end coordinates, the one
         * with the lower start coordinate (the longer range) will be ranked lower.
         * 
         */
<span class="nc" id="L191">        DEPARTURE{</span>
            @Override
            public int compare(Range first, Range second) 
            {
                /*
                 * We don't accept null values for comparison.
                 */
<span class="nc bnc" id="L198" title="All 2 branches missed.">                if (first == null){</span>
<span class="nc" id="L199">                    throw new NullPointerException(&quot;The first parameter in the comparison is null.&quot;);</span>
                }
<span class="nc bnc" id="L201" title="All 2 branches missed.">                if (second == null){</span>
<span class="nc" id="L202">                    throw new NullPointerException(&quot;The second parameter in the comparison is null.&quot;);</span>
                }
                
                /*
                 * Compare first by the end values, then by the start values, if the ranges end
                 * in the same place.
                 */
<span class="nc" id="L209">                final int endComparison = JillionUtil.compare(first.getEnd(),second.getEnd());</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">                if (endComparison == 0)</span>
                {
<span class="nc" id="L212">                    return JillionUtil.compare(first.getBegin(),second.getBegin());</span>
                }
<span class="nc" id="L214">                return endComparison;</span>
            }
        },
        /**
         * Compares Ranges by length
         * and orders them longest to shortest. Ranges
         * of the same length are considered equal.
         */
<span class="nc" id="L222">        LONGEST_TO_SHORTEST{</span>

            @Override
            public int compare(Range o1, Range o2) {
<span class="nc" id="L226">                return -1 * JillionUtil.compare(o1.getLength(), o2.getLength());</span>
            }
            
        },
        /**
         * Compares Ranges by length
         * and orders them shortest to longest.
         * Ranges
         * of the same length are considered equal.
         */
<span class="nc" id="L236">        SHORTEST_TO_LONGEST{</span>

            @Override
            public int compare(Range o1, Range o2) {
<span class="nc" id="L240">                return JillionUtil.compare(o1.getLength(),o2.getLength());</span>
            }
            
        }
        ;
     
    }
    /**
     * Enumeration of available range coordinate systems.
     * &lt;p/&gt;
     * Different file formats or conventions use
     * different numbering systems in bioinformatics utilities.
     * All Range objects use the same internal system to be inter-operable
     * but users may want ranges to be input or output into different
     * coordinate systems to fit their needs.  CoordinateSystem implementations
     * can be used to translate to and from the various bioinformatics coordinate
     * systems to simplify working with multiple coordinate systems at the same time.
     * @see Range#getBegin(CoordinateSystem)
     * @see Range#getEnd(CoordinateSystem)
     */
<span class="fc" id="L260">    public enum CoordinateSystem {</span>
        /**
         * Zero-based coordinate systems are exactly like
         * array index offsets.  CoordinateSystem starts at 0
         * and the last element in the range has an offset
         * of {@code length() -1}.
         * &lt;pre&gt; 
         * coordinate system    0  1  2  3  4  5
         *                    --|--|--|--|--|--|
         * range elements       0  1  2  3  4  5
         * &lt;/pre&gt;
         */
<span class="fc" id="L272">    	ZERO_BASED(&quot;Zero Based&quot;, &quot;0B&quot;, 0, 0, 0, 0),</span>
    	/**
    	 * Residue based coordinate system is a &quot;1s based&quot;
    	 * position system where there first element has a 
    	 * position of 1 and the last element in the range
    	 * has a position of length.
    	 *  &lt;pre&gt; 
         * coordinate system    1  2  3  4  5  6
         *                    --|--|--|--|--|--|
         * range elements       0  1  2  3  4  5
         * &lt;/pre&gt;
    	 */
<span class="fc" id="L284">        RESIDUE_BASED(&quot;Residue Based&quot;, &quot;RB&quot;, 1, 1, -1, -1),</span>
        /**
         * Spaced based coordinate systems count the &quot;spaces&quot;
         * between elements.  The first element has a coordinate
         * of 0 while the last element in the range has a position 
         * of length.
         * &lt;pre&gt; 
         * coordinate system   0  1  2  3  4  5  6
         *                    --|--|--|--|--|--|--
         * range elements       0  1  2  3  4  5
         * &lt;/pre&gt;
         */
<span class="fc" id="L296">        SPACE_BASED(&quot;Space Based&quot;, &quot;SB&quot;, 0, 1, 0, -1);</span>

        /** The full name used to display this coordinate system. */
        private String displayName;
        
        /** An abbreviated name to use as a printable &lt;code&gt;Range&lt;/code&gt; annotation. */
        private String abbreviatedName;

        private long zeroBaseToCoordinateSystemStartAdjustmentValue;
        private long zeroBaseToCoordinateSystemEndAdjustmentValue;

        private long coordinateSystemToZeroBaseStartAdjustmentValue;
        private long coordinateSystemToZeroBaseEndAdjustmentValue;

        /**
         * Builds a &lt;code&gt;CoordinateSystem&lt;/code&gt;.
         *
         * @param displayName The full name used to display this coordinate system.
         * @param abbreviatedName An abbreviated name to use as a printable &lt;code&gt;Range&lt;/code&gt;
         * annotation.
         * @param zeroBaseToCoordinateSystemStartAdjustmentValue
         * @param zeroBaseToCoordinateSystemEndAdjustmentValue
         * @param coordinateSystemToZeroBaseStartAdjustmentValue
         * @param coordinateSystemToZeroBaseEndAdjustmentValue
         */
        private CoordinateSystem(String displayName,
                                 String abbreviatedName,
                                 long zeroBaseToCoordinateSystemStartAdjustmentValue,
                                 long zeroBaseToCoordinateSystemEndAdjustmentValue,
                                 long coordinateSystemToZeroBaseStartAdjustmentValue,
<span class="fc" id="L326">                                 long coordinateSystemToZeroBaseEndAdjustmentValue) {</span>
<span class="fc" id="L327">            this.displayName = displayName;</span>
<span class="fc" id="L328">            this.abbreviatedName = abbreviatedName;</span>
<span class="fc" id="L329">            this.zeroBaseToCoordinateSystemStartAdjustmentValue = zeroBaseToCoordinateSystemStartAdjustmentValue;</span>
<span class="fc" id="L330">            this.zeroBaseToCoordinateSystemEndAdjustmentValue = zeroBaseToCoordinateSystemEndAdjustmentValue;</span>
<span class="fc" id="L331">            this.coordinateSystemToZeroBaseStartAdjustmentValue = coordinateSystemToZeroBaseStartAdjustmentValue;</span>
<span class="fc" id="L332">            this.coordinateSystemToZeroBaseEndAdjustmentValue = coordinateSystemToZeroBaseEndAdjustmentValue;</span>
<span class="fc" id="L333">        }</span>

        /**
         * Get the shortened &quot;tag&quot; name for this &lt;code&gt;CoordinateSystem&lt;/code&gt;.
         * to be used in the toString value.
         * @return A two-letter abbreviation for this &lt;code&gt;CoordinateSystem&lt;/code&gt;.
         */
        public String getAbbreviatedName() 
        {
<span class="fc" id="L342">            return abbreviatedName;</span>
        }
        
        /**
         * 
         * {@inheritDoc}
         */
        @Override
        public String toString() 
        {
<span class="nc" id="L352">            return displayName;</span>
        }

        /**
         * Get the start coordinate in this system from the 
         * equivalent zero-based start coordinate.
         * @param zeroBasedStart start coordinate in 0-based
         * coordinate system.
         */
        private long getLocalStart(long zeroBasedStart) {
<span class="fc" id="L362">            return zeroBasedStart + zeroBaseToCoordinateSystemStartAdjustmentValue;</span>
        }
        /**
         * Get the end coordinate in this system from the 
         * equivalent zero-based end coordinate.
         * @param zeroBasedEnd the end coordinate in 0-based
         * coordiante system.
         */
        private long getLocalEnd(long zeroBasedEnd) {
<span class="fc" id="L371">            return zeroBasedEnd + zeroBaseToCoordinateSystemEndAdjustmentValue;</span>
        }

        /**
         * Get 0-base start coordinate
        * from this coordinate system start location.
         */
        private long getStart(long localStart) {
<span class="fc" id="L379">            return localStart + coordinateSystemToZeroBaseStartAdjustmentValue;</span>
        }
        /**
         * Get 0-base end location
        * from this coordinate system  end location.
         */
        private long getEnd(long localEnd) {
<span class="fc" id="L386">            return localEnd + coordinateSystemToZeroBaseEndAdjustmentValue;</span>
        }

    }
    
    /**
     * Initialize cache with a soft reference cache that will grow as needed.
     */
    static{
<span class="fc" id="L395">         CACHE = Caches.&lt;String, Range&gt;createSoftReferencedValueCache(INITIAL_CACHE_SIZE);</span>
<span class="fc" id="L396">    }</span>
    /**
     * Factory method to get a {@link Range} object in
     * the {@link CoordinateSystem#ZERO_BASED} coordinate system.
     * If end == start -1 then this method will return an empty range.
     * This method is not guaranteed to return new instances and may return
     * a cached instance instead (flyweight pattern).
     * @param start start coordinate inclusive.
     * @param end end coordinate inclusive.
     * @return a {@link Range}; never null but might 
     * not be a new instance.
     * @throws IllegalArgumentException if {@code end &lt; start -1} 
     * or if the resulting range length &gt; {@link Long#MAX_VALUE}.
     */
    public static Range of(long start, long end){
<span class="fc" id="L411">        return new Range.Builder(start,end).build();</span>
    }
    /**
     * Factory method to build a {@link Range} object.
     * of length 1 with the given coordinate in 
     * the {@link CoordinateSystem#ZERO_BASED} coordinate system.
     * @param singleCoordinate only coordinate in this range.
     * @return a {@link Range}; never null but might 
     * not be a new instance.
     */
    public static Range of(long singleCoordinate){
<span class="fc" id="L422">        return new Range.Builder(1)</span>
<span class="fc" id="L423">        			.shift(singleCoordinate)</span>
<span class="fc" id="L424">        			.build();</span>
    }

    /**
     * Factory method to build a {@link Range} object
     * with the given coordinates
     * specified in the given coordinate system. If after converting 
     * the coordinates into 0-based coordinate,
     * {@code end = start -1}, then
     * the returned range is equivalent to an empty range
     * at the start coordinate.
     * @param coordinateSystem the {@link CoordinateSystem} to use.
     * @param localStart the start coordinate in the given coordinateSystem.
     * @param localEnd the end coordinate in the given coordinateSystem.
     * @return a non-empty Range instance.  This is not guaranteed to be a 
     * new instance since Ranges use the flyweight pattern
     * to reuse the same objects.
     * @throws NullPointerException if coordinateSystem is null.
     * @throws IllegalArgumentException if length is negative
     *  @throws IndexOutOfBoundsException if the combination 
     * of start and length values would cause the Range to extend
     * beyond {@link Long#MAX_VALUE}.
     */
    public static Range of(CoordinateSystem coordinateSystem,long localStart, long localEnd){
<span class="fc" id="L448">        return new Range.Builder(coordinateSystem, localStart, localEnd)</span>
<span class="fc" id="L449">        			.build();    	</span>
    }
    /**
     * Builds a new Range instance whose implementation depends
     * on the input start and end coordinates.  The implementation
     * that can take up the fewest number of bytes is chosen.
     * @param zeroBasedStart
     * @param zeroBasedEnd
     * @return a new Range instance.
     */
    private static Range buildNewRange(long zeroBasedStart, long zeroBasedEnd){
    	
    	
<span class="fc bfc" id="L462" title="All 2 branches covered.">    	if(zeroBasedStart &gt;=0){</span>
    		//can use unsigned
<span class="fc" id="L464">    		long length = zeroBasedEnd - zeroBasedStart+1;</span>
<span class="fc" id="L465">    		return buildNewUnsignedRange(zeroBasedStart, zeroBasedEnd,length);</span>
    	}
    	
<span class="fc" id="L468">    	return buildNewSignedRange(zeroBasedStart, zeroBasedEnd);</span>
    }
    /**
     * Create a new Range instance that requires signed values
     * (probably because the range has negative coordinates).
     *  The implementation
     * that can take up the fewest number of bytes is chosen.
     * @param zeroBasedStart
     * @param zeroBasedEnd
     * @return a new Range instance.
     */
	private static Range buildNewSignedRange(long zeroBasedStart,
			long zeroBasedEnd) {

<span class="pc bpc" id="L482" title="1 of 2 branches missed.">    	if(canFitInSignedByte(zeroBasedStart, zeroBasedEnd)){</span>
<span class="nc" id="L483">    		return new ByteRange((byte)zeroBasedStart, (byte)zeroBasedEnd);</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">    	}else if(canFitInSignedShort(zeroBasedStart,zeroBasedEnd)){</span>
<span class="fc" id="L485">    		return new ShortRange((short)zeroBasedStart, (short)zeroBasedEnd);</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">    	}else if(canFitInSignedInt(zeroBasedStart,zeroBasedEnd)){</span>
<span class="nc" id="L487">    		return new IntRange((int)zeroBasedStart, (int)zeroBasedEnd);</span>
    	}    	
<span class="nc" id="L489">    	return new LongRange(zeroBasedStart, zeroBasedEnd);</span>
	}
	
	private static boolean canFitInSignedByte(long start, long end){
<span class="pc bpc" id="L493" title="6 of 8 branches missed.">		return start &lt;= Byte.MAX_VALUE &amp;&amp; start &gt;=Byte.MIN_VALUE</span>
    			&amp;&amp; end &lt;= Byte.MAX_VALUE &amp;&amp; end &gt;=Byte.MIN_VALUE;
	}
	private static boolean canFitInSignedShort(long start, long end){
<span class="pc bpc" id="L497" title="4 of 8 branches missed.">		return start &lt;= Short.MAX_VALUE &amp;&amp; start &gt;=Short.MIN_VALUE</span>
    			&amp;&amp; end &lt;= Short.MAX_VALUE &amp;&amp; end &gt;=Short.MIN_VALUE;
	}
	private static boolean canFitInSignedInt(long start, long end){
<span class="nc bnc" id="L501" title="All 8 branches missed.">		return start &lt;= Integer.MAX_VALUE &amp;&amp; start &gt;=Integer.MIN_VALUE</span>
    			&amp;&amp; end &lt;= Integer.MAX_VALUE &amp;&amp; end &gt;=Integer.MIN_VALUE;
	}
	/**
	 * Create a new Range instance which can use unsigned
	 * values to save memory.  The implementation
     * that can take up the fewest number of bytes is chosen.
	 * @param zeroBasedStart
	 * @param zeroBasedEnd
	 * @param length
	 * @return
	 */
	private static Range buildNewUnsignedRange(long zeroBasedStart,
			long zeroBasedEnd, long length) {
		
		//JVM spec of computing size of objects
		//in heap includes padding
		//to keep objects a multiple of 8 bytes.
		//This means that not all byte-short-int-long combinations
		//actually affect the object size.
<span class="fc bfc" id="L521" title="All 2 branches covered.">		if(zeroBasedStart &lt;= UNSIGNED_BYTE_MAX){			</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">			if(length &lt;= UNSIGNED_SHORT_MAX){</span>
<span class="fc" id="L523">				return new UnsignedByteStartShortLengthRange((short) zeroBasedStart, (int)length);</span>
			}
<span class="nc bnc" id="L525" title="All 2 branches missed.">			if(length &lt;= UNSIGNED_INT_MAX){</span>
<span class="nc" id="L526">				return new UnsignedByteStartIntLengthRange((short) zeroBasedStart, length);</span>
			}
<span class="nc" id="L528">			return new UnsignedByteStartLongLengthRange((short) zeroBasedStart, length);</span>
		}
		
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">		if(zeroBasedStart &lt;= UNSIGNED_SHORT_MAX){</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">			if(length &lt;= UNSIGNED_SHORT_MAX){</span>
<span class="fc" id="L533">				return new UnsignedShortStartShortLengthRange((int) zeroBasedStart, (int)length);</span>
			}
<span class="nc bnc" id="L535" title="All 2 branches missed.">			if(length &lt;= UNSIGNED_INT_MAX){</span>
<span class="nc" id="L536">				return new UnsignedShortStartIntLengthRange((int) zeroBasedStart, length);</span>
			}
<span class="nc" id="L538">			return new UnsignedShortStartLongLengthRange((int) zeroBasedStart, length);</span>
		}
<span class="nc bnc" id="L540" title="All 2 branches missed.">		if(zeroBasedStart &lt;= UNSIGNED_INT_MAX){</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">			if(length &lt;= UNSIGNED_INT_MAX){</span>
<span class="nc" id="L542">				return new UnsignedIntStartIntLengthRange(zeroBasedStart, length);</span>
			}
<span class="nc" id="L544">			return new UnsignedIntStartLongLengthRange(zeroBasedStart, length);</span>
		}
<span class="nc bnc" id="L546" title="All 2 branches missed.">		if(length &lt;= UNSIGNED_INT_MAX){</span>
<span class="nc" id="L547">			return new LongStartIntLengthRange(zeroBasedStart, length);</span>
		}
<span class="nc" id="L549">		return new LongRange(zeroBasedStart, zeroBasedEnd);</span>

	}
	private static Range buildNewEmptyRange(long zeroBasedStart) {
<span class="nc bnc" id="L553" title="All 2 branches missed.">		if(zeroBasedStart &gt;=0){</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">			if(zeroBasedStart &lt;=Byte.MAX_VALUE){</span>
<span class="nc" id="L555">				return new EmptyByteRange((byte)zeroBasedStart);</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">			}else if(zeroBasedStart &lt;=Short.MAX_VALUE){</span>
<span class="nc" id="L557">				return new EmptyShortRange((short)zeroBasedStart);</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">			}else if(zeroBasedStart &lt;=Integer.MAX_VALUE){</span>
<span class="nc" id="L559">				return new EmptyIntRange((int)zeroBasedStart);</span>
			}
		}
		//anything negative or &gt; unsigned int should be stored as a long
<span class="nc" id="L563">		return new EmptyLongRange(zeroBasedStart);</span>
	}
    private static synchronized Range getFromCache(Range range) {
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">       if(range==null){</span>
<span class="nc" id="L567">    	   throw new NullPointerException(&quot;can not add null range to cache&quot;);</span>
       }
<span class="fc" id="L569">        String hashcode = createCacheKeyFor(range);</span>
       
        //contains() followed by get() is not atomic;
        //we could gc in between - so only do a get
        //and check if null.
<span class="fc" id="L574">        Range cachedRange= CACHE.get(hashcode);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">        if(cachedRange !=null){</span>
<span class="fc" id="L576">        	return cachedRange;</span>
        }
        //not in cache so put it in
<span class="fc" id="L579">        CACHE.put(hashcode,range);</span>
<span class="fc" id="L580">        return range;</span>

    }
    private static String createCacheKeyFor(Range r){
        //Range's toString() should be fine
        //to ensure uniqueness in our cache.
<span class="fc" id="L586">        return r.toString();</span>
    }

    /**
     * Create a non-empty Range object in the Zero based coordinate
     * system starting at 0 and with the given length.
     * @param length the length of this range.
     * @return a non-empty Range instance  whose {@link Range#getBegin()}
     * will return {@code 0} and {@link Range#getLength()}
     * will return the pass in value.  This is not guaranteed to be a 
     * new instance since Ranges use the flyweight pattern
     * to reuse the same objects.
     * @throws IllegalArgumentException if length is negative
     */
    public static Range ofLength(long length){
<span class="fc" id="L601">        return new Range.Builder(length).build();</span>
    }
   
   
    
    /**
     * Parses a string in the format &amp;lt;left&amp;gt;[.. | - ]&amp;lt;right&amp;gt;. 
     * Any whitespace between the left and right parameters is ignored.
     * &lt;br&gt;
     * Examples:
     * &lt;ul&gt;
     * &lt;li&gt;24 .. 35&lt;/li&gt;
     * &lt;li&gt;24-35&lt;/li&gt;
     * &lt;li&gt;24,35&lt;/li&gt;
     * &lt;/ul&gt;
     * 
     * @param rangeAsString
     * @return a {@link Range}.
     * @throws IllegalArgumentException if the given String does not
     * match the correct format.
     */
    public static Range parseRange(String rangeAsString, CoordinateSystem coordinateSystem){
<span class="nc" id="L623">        Matcher dotMatcher =DOT_PATTERN.matcher(rangeAsString);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">        if(dotMatcher.find()){</span>
<span class="nc" id="L625">            return convertIntoRange(dotMatcher,coordinateSystem);</span>
        }
<span class="nc" id="L627">        Matcher dashMatcher = DASH_PATTERN.matcher(rangeAsString);</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">        if(dashMatcher.find()){</span>
<span class="nc" id="L629">            return convertIntoRange(dashMatcher,coordinateSystem);</span>
        }
<span class="nc" id="L631">        Matcher commaMatcher = COMMA_PATTERN.matcher(rangeAsString);</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if(commaMatcher.find()){</span>
<span class="nc" id="L633">            return convertIntoRange(commaMatcher,coordinateSystem);</span>
        }
<span class="nc" id="L635">        throw new IllegalArgumentException(&quot;can not parse &quot;+ rangeAsString +&quot; into a Range&quot;);</span>
    }
    /**
     * Parses a string in the format &amp;lt;left&amp;gt;[.. | - ]&amp;lt;right&amp;gt;. 
     * Any whitespace between the left and right parameters is ignored.
     * &lt;br&gt;
     * Examples:
     * &lt;ul&gt;
     * &lt;li&gt;24 .. 35&lt;/li&gt;
     * &lt;li&gt;24-35&lt;/li&gt;
     * &lt;li&gt;24,35&lt;/li&gt;
     * &lt;/ul&gt;
     * 
     * @param rangeAsString
     * @return a {@link Range}.
     * @throws IllegalArgumentException if the given String does not
     * match the correct format.
     */
    public static Range parseRange(String rangeAsString){
<span class="nc" id="L654">        return parseRange(rangeAsString, CoordinateSystem.ZERO_BASED);</span>
    }
    
    private static Range convertIntoRange(Matcher dashMatcher, CoordinateSystem coordinateSystem) {
<span class="nc" id="L658">        return Range.of(coordinateSystem,Long.parseLong(dashMatcher.group(1)), </span>
<span class="nc" id="L659">                Long.parseLong(dashMatcher.group(2))</span>
                );
    }


    private Range(){
    	//can not instantiate
    }

    
    @Override
	public abstract int hashCode();
    /**
     * Two {@link Range}s are equal
     * if they have the same begin and end
     * values.
     */
	@Override
	public abstract boolean equals(Object obj);
	
	/**
     * Fetch the first coordinate in this Range. This is the same as 
     * {@link #getBegin(CoordinateSystem)
     * getBegin(ZERO_BASED)}.
     *
     * @return The left-hand (starting) coordinate.
     * 
     */
    public abstract long getBegin();
    /**
     * Fetch the first coordinate using the given 
     * {@link CoordinateSystem}.  
     *
     * @return The first coordinate.
     * @throws NullPointerException if the given {@link CoordinateSystem} is null.
     */
    public long getBegin(CoordinateSystem coordinateSystem) {
<span class="nc bnc" id="L696" title="All 2 branches missed.">    	if(coordinateSystem==null){</span>
<span class="nc" id="L697">    		throw new NullPointerException(&quot;CoordinateSystem can not be null&quot;);</span>
    	}
<span class="nc" id="L699">        return coordinateSystem.getLocalStart(getBegin());</span>
    }
    /**
     * Fetch the 0-based last coordinate.
     * This is the same as {@link #getEnd(CoordinateSystem)
     * getEnd(ZERO_BASED)}.
     *
     * @return The right-hand (ending) coordinate.
     */
    public abstract long getEnd();
    
    
    /**
     * Fetch the right (end) coordinate using the given 
     * {@link CoordinateSystem}.
     *
     * @return The right-hand (ending) coordinate.
     * @throws NullPointerException if the given {@link CoordinateSystem} is null.
     */
    public long getEnd(CoordinateSystem coordinateSystem) {
<span class="nc bnc" id="L719" title="All 2 branches missed.">    	if(coordinateSystem==null){</span>
<span class="nc" id="L720">    		throw new NullPointerException(&quot;CoordinateSystem can not be null&quot;);</span>
    	}
<span class="nc" id="L722">        return coordinateSystem.getLocalEnd(getEnd());</span>
    }

    /**
     * Checks if this range is empty (has length of 0).
     * 
     * @return &lt;code&gt;true&lt;/code&gt; if the range is empty, &lt;code&gt;false&lt;/code&gt;
     * otherwise.
     */
    public boolean isEmpty(){
<span class="nc" id="L732">    	return false;</span>
    }
    /**
     * Checks to see if the this &lt;code&gt;Range&lt;/code&gt; is contained within
     * the given &lt;code&gt;Range&lt;/code&gt;.  This does not require this &lt;code&gt;Range&lt;/code&gt;
     * to be a strict subset of the target.  More precisely: a
     * &lt;code&gt;Range&lt;/code&gt; is always a sub-range of itself.
     *
     * @param range The &lt;code&gt;Range&lt;/code&gt; to compare to; can not be null.
     * @return &lt;code&gt;true&lt;/code&gt; if every value in this &lt;code&gt;Range&lt;/code&gt; is
     * found in the given comparison &lt;code&gt;Range&lt;/code&gt;.
     * @throws NullPointerException if range is null.
     */
    public boolean isSubRangeOf(Range range) {
<span class="nc bnc" id="L746" title="All 2 branches missed.">        if(range==null){</span>
<span class="nc" id="L747">            throw new NullPointerException(&quot;range can not be null&quot;);</span>
        }
<span class="nc bnc" id="L749" title="All 4 branches missed.">        return getBegin()&gt;=range.getBegin() &amp;&amp; getEnd()&lt;=range.getEnd();</span>
       
    }
    

    /**
     * Checks to see if the given {@link Range} intersects this one.
     * An empty range will never intersect any other range
     * (even itself)
     * @param target The {@link Range} to check.
     * @return &lt;code&gt;true&lt;/code&gt; if the coordinates of the two ranges overlap
     * each other in at least one point.
     */
    public boolean intersects(Range target)
    {
<span class="nc bnc" id="L764" title="All 2 branches missed.">        if (target == null)</span>
        {
<span class="nc" id="L766">            throw new IllegalArgumentException(&quot;Null Range used in intersection operation.&quot;);</span>
        }
<span class="nc bnc" id="L768" title="All 2 branches missed.">        if(isEmpty()){</span>
<span class="nc" id="L769">            return false;</span>
        }
<span class="nc bnc" id="L771" title="All 2 branches missed.">        if (target.isEmpty())</span>
        {
            /*
             * Instead of defining empty set semantics here, we do it in the
             * EmptyRange class
             * -jsitz
             */
<span class="nc" id="L778">            return target.intersects(this);</span>
        }

<span class="nc bnc" id="L781" title="All 4 branches missed.">        return !(this.getBegin() &gt; target.getEnd() || this.getEnd() &lt; target.getBegin());</span>
    }
    /**
     * Calculates the intersection of this {@link Range} and a second one.
     * 
     * &lt;p&gt;
     * The intersection of an empty Range with any other Range is always the
     * empty Range.
     *
     * @param other The second {@link Range} to compare
     * @return A {@link Range} object spanning only the range of values covered
     * by both this Range and the other {@link Range}.
     */
    public Range intersection(Range other)
    {
<span class="nc bnc" id="L796" title="All 2 branches missed.">        if (other == null){</span>
<span class="nc" id="L797">            throw new IllegalArgumentException(&quot;Null Range used in intersection operation.&quot;);</span>
        }
<span class="nc bnc" id="L799" title="All 2 branches missed.">        if(isEmpty()){</span>
<span class="nc" id="L800">        	return this;</span>
        }
<span class="nc bnc" id="L802" title="All 2 branches missed.">        if (other.isEmpty()){</span>
<span class="nc" id="L803">        	return other;</span>
        }
<span class="nc" id="L805">        long intersectionStart = Math.max(other.getBegin(), this.getBegin());</span>
<span class="nc" id="L806">		long intersectionEnd = Math.min(other.getEnd(), this.getEnd());</span>
		//this mess is so we don't deal with underflow
		//if start is Long.MIN_VALUE
<span class="nc" id="L809">		long length = intersectionEnd - intersectionStart+1;</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">		if(length&lt;=-1){</span>
<span class="nc" id="L811">			return new Range.Builder().build();</span>
		}
		//length &gt;=0 can be handled by builder
		//we include length of 0 since 
		//that might have a different start coordinate
<span class="nc" id="L816">			return new Range.Builder(length)</span>
<span class="nc" id="L817">						.shift(intersectionStart)</span>
<span class="nc" id="L818">						.build();</span>
		
    }
    /**
     * Get the List of Ranges that represents the 
     * {@code this - other}.  This is similar to the 
     * Set of all coordinates that don't intersect.
     * @param other the range to complement with.
     * @return
     */
    public List&lt;Range&gt; complement(Range other){
        //this - other
        //anything in this that doesn't intersect with other
<span class="nc" id="L831">        Range intersection = intersection(other);</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">        if(intersection.isEmpty()){</span>
<span class="nc" id="L833">            return Arrays.asList(this);</span>
        }
<span class="nc" id="L835">        List&lt;Range&gt; complementedRanges = new ArrayList&lt;Range&gt;();</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">        if(intersection.getBegin()!=Long.MIN_VALUE){</span>
<span class="nc" id="L837">	        Range beforeOther = Range.of(getBegin(), intersection.getBegin()-1);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">	        if(!beforeOther.isEmpty()){</span>
<span class="nc" id="L839">	            complementedRanges.add(beforeOther);</span>
	        }
        }
        
<span class="nc bnc" id="L843" title="All 2 branches missed.">        if(intersection.getEnd()!=Long.MAX_VALUE){        	</span>
<span class="nc" id="L844">        	Range afterOther= Range.of(intersection.getEnd()+1, getEnd());</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">        	if(!afterOther.isEmpty()){</span>
<span class="nc" id="L846">                complementedRanges.add(afterOther);</span>
            }
        }
        
       
        
<span class="nc" id="L852">        return Ranges.merge(complementedRanges);</span>
    }
    
    public List&lt;Range&gt; complementFrom(Collection&lt;Range&gt; ranges){
<span class="nc" id="L856">        List&lt;Range&gt; universe = Ranges.merge(new ArrayList&lt;Range&gt;(ranges));</span>
<span class="nc" id="L857">        List&lt;Range&gt; complements = new ArrayList&lt;Range&gt;(universe.size());</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">        for(Range range : universe){</span>
<span class="nc" id="L859">            complements.addAll(range.complement(this));</span>
<span class="nc" id="L860">        }</span>
<span class="nc" id="L861">        return Ranges.merge(complements);</span>
    }

    /**
     * Checks to see if this &lt;code&gt;Range&lt;/code&gt; starts before the given
     * comparison &lt;code&gt;Range&lt;/code&gt;.
     *
     * @param other The other &lt;code&gt;Range&lt;/code&gt; to compare to.
     * @return &lt;code&gt;true&lt;/code&gt; if the begin coordinate of this
     * &lt;code&gt;Range&lt;/code&gt; is less than the  begin coordinate of the
     * other &lt;code&gt;Range&lt;/code&gt;.
     * @throws NullPointerException if other is null.
     */
    public boolean startsBefore(Range other)
    {
<span class="nc bnc" id="L876" title="All 2 branches missed.">        if (other == null){</span>
<span class="nc" id="L877">            throw new NullPointerException(&quot;Null Range used in range comparison operation.&quot;);</span>
        }

<span class="nc bnc" id="L880" title="All 2 branches missed.">        return this.getBegin() &lt; other.getBegin();</span>
    }

    /**
     * Checks to see if this &lt;code&gt;Range&lt;/code&gt; ends before the given target.
     *
     * @param other The target &lt;code&gt;Range&lt;/code&gt; to check against.
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Range&lt;/code&gt; has an end value
     * which occurs before (and not at the same point as) the target
     * &lt;code&gt;Range&lt;/code&gt;.
     * @throws NullPointerException if other is null.
     */
    public boolean endsBefore(Range other)
    {
<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (other == null){</span>
<span class="nc" id="L895">            throw new NullPointerException(&quot;Null Range used in range comparison operation.&quot;);</span>
        }
        
<span class="nc bnc" id="L898" title="All 2 branches missed.">        return this.getEnd() &lt; other.getBegin();</span>
    } 
   
    /**
     * Convenience method that delegates to
     * {@link #toString(CoordinateSystem)} using {@link CoordinateSystem#ZERO_BASED}.
     * 
     * @see #toString(CoordinateSystem)
     * 
     */
    @Override
    public String toString()
    {
<span class="fc" id="L911">        return toString(CoordinateSystem.ZERO_BASED);</span>
    }
    /**
     * Returns a String representation of this Range in given coordinate system.
     * The actual format is {@code [localStart .. localEnd]/systemAbbreviatedName}
     * @throws NullPointerException if coordinateSystem is null.
     */
    public String toString(CoordinateSystem coordinateSystem)
    {
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">    	if(coordinateSystem ==null){</span>
<span class="nc" id="L921">    		throw new NullPointerException(&quot;coordinateSystem can not be null&quot;);</span>
    	}
<span class="fc" id="L923">        return String.format(&quot;[ %d .. %d ]/%s&quot;, </span>
<span class="fc" id="L924">        		coordinateSystem.getLocalStart(getBegin()) ,</span>
<span class="fc" id="L925">        		coordinateSystem.getLocalEnd(getEnd()),</span>
<span class="fc" id="L926">                coordinateSystem.getAbbreviatedName());</span>
    }
   

    @Override
    public Iterator&lt;Long&gt; iterator() {
<span class="nc" id="L932">        return new RangeIterator(this);</span>
    }
    
   
    /**
     * Splits a Range into a List of possibly several adjacent Range objects
     * where each of the returned ranges has a max length specified.
     * @param maxSplitLength the max length any of the returned split ranges can be.
     * @return a List of split Ranges; never null or empty but may
     * just be a single element if this Range is smaller than the max length
     * specified.
     * @throws IllegalArgumentException if maxSplitLength
     * &lt;1.
     */
    public List&lt;Range&gt; split(long maxSplitLength){
<span class="nc bnc" id="L947" title="All 2 branches missed.">    	if(maxSplitLength &lt;1){</span>
<span class="nc" id="L948">    		throw new IllegalArgumentException(&quot;max splitLength must be &gt;= 1&quot;);</span>
    	}
<span class="nc" id="L950">    	List&lt;Range&gt; list = new ArrayList&lt;Range&gt;();</span>
<span class="nc bnc" id="L951" title="All 2 branches missed.">        if(getLength()&lt;maxSplitLength){</span>
<span class="nc" id="L952">            list.add(this);</span>
        }else{
<span class="nc" id="L954">	        long currentStart=getBegin();	        </span>
<span class="nc" id="L955">	        long end = getEnd();</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">			while(currentStart&lt;=end){</span>
<span class="nc" id="L957">	            long endCoordinate = Math.min(end, currentStart+maxSplitLength-1);</span>
<span class="nc" id="L958">	            list.add(Range.of(currentStart, endCoordinate));</span>
<span class="nc" id="L959">	            currentStart = currentStart+maxSplitLength;</span>
<span class="nc" id="L960">	        }</span>
        }
<span class="nc" id="L962">        return list;</span>
    }
   
    /**
     * Get the length of this range.
     * @return the length;
     * will always be &gt;=0.
     */
    public long getLength() {
<span class="nc" id="L971">    	 return getEnd() - getBegin() + 1;</span>
    }
    /**
    * {@inheritDoc} 
    * &lt;p/&gt;
    * Returns this since it is already a Range.
    * @return this.
    */
    @Override
    public Range asRange() {
<span class="nc" id="L981">        return this;</span>
    }
    
    private static class RangeIterator implements Iterator&lt;Long&gt;{
        private final long from;
        private final long to;
        private long index;
        
<span class="nc" id="L989">        public RangeIterator(Range range){</span>
<span class="nc" id="L990">            from = range.getBegin();</span>
<span class="nc" id="L991">            to = range.getEnd();</span>
<span class="nc" id="L992">            index = from;</span>
<span class="nc" id="L993">        }</span>
        @Override
        public boolean hasNext() {
        	//have to handle special case where end
        	//coordinate is Long.MAX_VALUE since
        	//all longs are &lt;= MAX value
        	//see Java Puzzlers Puzzle #26 for more info
<span class="nc bnc" id="L1000" title="All 2 branches missed.">        	if(to == Long.MAX_VALUE){</span>
        		//if we wrap around to a number
        		//less than our starting point
        		//we know we overflowed
        		//so we have passed MAX_VALUE
        		//(or we are an empty range which
        		//wouldn't have a next anyway)
<span class="nc bnc" id="L1007" title="All 2 branches missed.">        		return index &gt;from;</span>
        	}else{
<span class="nc bnc" id="L1009" title="All 2 branches missed.">        		return index&lt;=to;</span>
        	}
        }

        @Override
        public Long next() {
<span class="nc" id="L1015">            return index++;</span>
        }

        @Override
        public void remove() {
<span class="nc" id="L1020">            throw new UnsupportedOperationException(&quot;can not remove from Range&quot;);</span>
            
        }
        
    }
    /**
     * Range implementation that stores the 
     * start and end coordinates as longs.
     * @author dkatzel
     *
     */
    private static final class LongRange extends Range{
        /**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final long start;

        /**
         * The end coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final  long end;
        
<span class="nc" id="L1044">    	private LongRange(long start, long end){</span>
<span class="nc" id="L1045">    		 this.start = start;</span>
<span class="nc" id="L1046">	        this.end = end;</span>
<span class="nc" id="L1047">    	}</span>
    	
    	/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="nc" id="L1059">            return start;</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="nc" id="L1070">            return end;</span>
        }
		@Override
		public int hashCode() {
<span class="nc" id="L1074">			final int prime = 31;</span>
<span class="nc" id="L1075">			int result = 1;</span>
<span class="nc" id="L1076">			result = prime * result + (int) (end ^ (end &gt;&gt;&gt; 32));</span>
<span class="nc" id="L1077">			result = prime * result + (int) (start ^ (start &gt;&gt;&gt; 32));</span>
<span class="nc" id="L1078">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L1083" title="All 2 branches missed.">			if (this == obj){</span>
<span class="nc" id="L1084">				return true;</span>
			}
<span class="nc bnc" id="L1086" title="All 2 branches missed.">			if (obj == null){</span>
<span class="nc" id="L1087">				return false;</span>
			}
<span class="nc bnc" id="L1089" title="All 2 branches missed.">			if (getClass() != obj.getClass()){</span>
<span class="nc" id="L1090">				return false;</span>
			}
<span class="nc" id="L1092">			LongRange other = (LongRange) obj;</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">			if (end != other.end){</span>
<span class="nc" id="L1094">				return false;</span>
			}
<span class="nc bnc" id="L1096" title="All 2 branches missed.">			if (start != other.start){</span>
<span class="nc" id="L1097">				return false;</span>
			}
<span class="nc" id="L1099">			return true;</span>
		}
    	
    	
    }
    /**
     * Range implementation that stores the 
     * start and end coordinates as ints.
     * @author dkatzel
     *
     */
    private static final class IntRange extends Range{
        /**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final int start;

        /**
         * The end coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final  int end;
        
<span class="nc" id="L1123">    	private IntRange(int start, int end){</span>
<span class="nc" id="L1124">    		 this.start = start;</span>
<span class="nc" id="L1125">	        this.end = end;</span>
<span class="nc" id="L1126">    	}</span>
    	
    	/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="nc" id="L1138">            return start;</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="nc" id="L1149">            return end;</span>
        }

		@Override
		public int hashCode() {
<span class="nc" id="L1154">			final int prime = 31;</span>
<span class="nc" id="L1155">			int result = 1;</span>
<span class="nc" id="L1156">			result = prime * result + end;</span>
<span class="nc" id="L1157">			result = prime * result + start;</span>
<span class="nc" id="L1158">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L1163" title="All 2 branches missed.">			if (this == obj){</span>
<span class="nc" id="L1164">				return true;</span>
			}
<span class="nc bnc" id="L1166" title="All 2 branches missed.">			if (obj == null){</span>
<span class="nc" id="L1167">				return false;</span>
			}
<span class="nc bnc" id="L1169" title="All 2 branches missed.">			if (getClass() != obj.getClass()){</span>
<span class="nc" id="L1170">				return false;</span>
			}
<span class="nc" id="L1172">			IntRange other = (IntRange) obj;</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">			if (end != other.end){</span>
<span class="nc" id="L1174">				return false;</span>
			}
<span class="nc bnc" id="L1176" title="All 2 branches missed.">			if (start != other.start){</span>
<span class="nc" id="L1177">				return false;</span>
			}
<span class="nc" id="L1179">			return true;</span>
		}
    }
    
   
    /**
     * Range implementation that stores the 
     * start and end coordinates as shorts.
     * @author dkatzel
     *
     */
    private static final class ShortRange extends Range{
        /**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final short start;

        /**
         * The end coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final  short end;
        
<span class="fc" id="L1203">    	private ShortRange(short start, short end){</span>
<span class="fc" id="L1204">    		 this.start = start;</span>
<span class="fc" id="L1205">	        this.end = end;</span>
<span class="fc" id="L1206">    	}</span>
    	
    	/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L1218">            return start;</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="fc" id="L1229">            return end;</span>
        }

		@Override
		public int hashCode() {
<span class="nc" id="L1234">			final int prime = 31;</span>
<span class="nc" id="L1235">			int result = 1;</span>
<span class="nc" id="L1236">			result = prime * result + end;</span>
<span class="nc" id="L1237">			result = prime * result + start;</span>
<span class="nc" id="L1238">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L1243" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L1244">				return true;</span>
			}
<span class="nc bnc" id="L1246" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L1247">				return false;</span>
			}
<span class="nc bnc" id="L1249" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L1250">				return false;</span>
			}
<span class="nc" id="L1252">			ShortRange other = (ShortRange) obj;</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">			if (end != other.end) {</span>
<span class="nc" id="L1254">				return false;</span>
			}
<span class="nc bnc" id="L1256" title="All 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L1257">				return false;</span>
			}
<span class="nc" id="L1259">			return true;</span>
		}
    }
    
   
    /**
     * Range implementation that stores the 
     * start and end coordinates as bytes.
     * @author dkatzel
     *
     */
    private static final class ByteRange extends Range{
        /**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final byte start;

        /**
         * The end coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final  byte end;
        
<span class="nc" id="L1283">    	private ByteRange(byte start, byte end){</span>
<span class="nc" id="L1284">    		 this.start = start;</span>
<span class="nc" id="L1285">	        this.end = end;</span>
<span class="nc" id="L1286">    	}</span>
    	
    	/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="nc" id="L1298">            return start;</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="nc" id="L1309">            return end;</span>
        }

		@Override
		public int hashCode() {
<span class="nc" id="L1314">			final int prime = 31;</span>
<span class="nc" id="L1315">			int result = 1;</span>
<span class="nc" id="L1316">			result = prime * result + end;</span>
<span class="nc" id="L1317">			result = prime * result + start;</span>
<span class="nc" id="L1318">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L1323" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L1324">				return true;</span>
			}
<span class="nc bnc" id="L1326" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L1327">				return false;</span>
			}
<span class="nc bnc" id="L1329" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L1330">				return false;</span>
			}
<span class="nc" id="L1332">			ByteRange other = (ByteRange) obj;</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">			if (end != other.end) {</span>
<span class="nc" id="L1334">				return false;</span>
			}
<span class="nc bnc" id="L1336" title="All 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L1337">				return false;</span>
			}
<span class="nc" id="L1339">			return true;</span>
		}
    	

    }
    
    
    
    /**
     * Range implementation that stores the 
     * start coordinates as an unsigned byte
     * and the length as an unsigned short.
     * This is commonly used for next-gen length
     * valid ranges or next-gen reads placed in the beginning
     * of contigs/scaffolds.
     * @author dkatzel
     *
     */
    private static final class UnsignedByteStartShortLengthRange extends Range{
        /**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final byte start;

        /**
         * The end coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final  short length;
        
<span class="fc" id="L1370">    	private UnsignedByteStartShortLengthRange(short start, int length){</span>
<span class="fc" id="L1371">    		this.start = IOUtil.toSignedByte(start);</span>
<span class="fc" id="L1372">	        this.length = IOUtil.toSignedShort(length);</span>
	       
<span class="fc" id="L1374">    	}</span>
    	
    	/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L1386">            return IOUtil.toUnsignedByte(start);</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getLength() {
<span class="fc" id="L1397">            return IOUtil.toUnsignedShort(length);</span>
        }

    	@Override
    	public long getEnd(){
<span class="fc" id="L1402">    		return getBegin() + getLength() -1;</span>
    	}
		@Override
		public int hashCode() {
<span class="fc" id="L1406">			final int prime = 31;</span>
<span class="fc" id="L1407">			int result = 1;</span>
<span class="fc" id="L1408">			result = prime * result + length;</span>
<span class="fc" id="L1409">			result = prime * result + start;</span>
<span class="fc" id="L1410">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L1415" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L1416">				return true;</span>
			}
<span class="nc bnc" id="L1418" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L1419">				return false;</span>
			}
<span class="nc bnc" id="L1421" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L1422">				return false;</span>
			}
<span class="nc" id="L1424">			UnsignedByteStartShortLengthRange other = (UnsignedByteStartShortLengthRange) obj;</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">			if (length != other.length) {</span>
<span class="nc" id="L1426">				return false;</span>
			}
<span class="nc bnc" id="L1428" title="All 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L1429">				return false;</span>
			}
<span class="nc" id="L1431">			return true;</span>
		}
    }
    
   
    
    /**
     * Range implementation that stores the 
     * start coordinates as an unsigned byte
     * and the length as an unsigned int.
     * This is commonly used for contigs
     * placed in the beginning
     * of scaffolds.
     * @author dkatzel
     *
     */
    private static final class UnsignedByteStartIntLengthRange extends Range{
        /**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final byte start;

        /**
         * The end coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final  int length;
        
<span class="nc" id="L1460">    	private UnsignedByteStartIntLengthRange(short start, long length){</span>
<span class="nc" id="L1461">    		this.start = IOUtil.toSignedByte(start);</span>
<span class="nc" id="L1462">	        this.length = IOUtil.toSignedInt(length);</span>
	       
<span class="nc" id="L1464">    	}</span>
    	
    	/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="nc" id="L1476">            return IOUtil.toUnsignedByte(start);</span>
        }

    	@Override
        public long getLength() {
<span class="nc" id="L1481">            return IOUtil.toUnsignedInt(length);</span>
        }

    	@Override
    	public long getEnd(){
<span class="nc" id="L1486">    		return getBegin() + getLength() -1;</span>
    	}
		@Override
		public int hashCode() {
<span class="nc" id="L1490">			final int prime = 31;</span>
<span class="nc" id="L1491">			int result = 1;</span>
<span class="nc" id="L1492">			result = prime * result + length;</span>
<span class="nc" id="L1493">			result = prime * result + start;</span>
<span class="nc" id="L1494">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L1499" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L1500">				return true;</span>
			}
<span class="nc bnc" id="L1502" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L1503">				return false;</span>
			}
<span class="nc bnc" id="L1505" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L1506">				return false;</span>
			}
<span class="nc" id="L1508">			UnsignedByteStartIntLengthRange other = (UnsignedByteStartIntLengthRange) obj;</span>
<span class="nc bnc" id="L1509" title="All 2 branches missed.">			if (length != other.length) {</span>
<span class="nc" id="L1510">				return false;</span>
			}
<span class="nc bnc" id="L1512" title="All 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L1513">				return false;</span>
			}
<span class="nc" id="L1515">			return true;</span>
		}
    }
    
    /**
     * Range implementation that stores the 
     * start coordinates as an unsigned byte
     * and the length as a long.
     * This is commonly used for large contig
     * or scaffold ranges.
     * @author dkatzel
     *
     */
    private static final class UnsignedByteStartLongLengthRange extends Range{
        /**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final byte start;

        /**
         * The end coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final  long length;
        
<span class="nc" id="L1541">    	private UnsignedByteStartLongLengthRange(short start, long length){</span>
<span class="nc" id="L1542">    		this.start = IOUtil.toSignedByte(start);</span>
<span class="nc" id="L1543">	        this.length = length;</span>
	       
<span class="nc" id="L1545">    	}</span>
    	
    	/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="nc" id="L1557">            return IOUtil.toUnsignedByte(start);</span>
        }

    	@Override
        public long getLength() {
<span class="nc" id="L1562">            return length;</span>
        }

    	@Override
    	public long getEnd(){
<span class="nc" id="L1567">    		return getBegin() + getLength() -1;</span>
    	}

		@Override
		public int hashCode() {
<span class="nc" id="L1572">			final int prime = 31;</span>
<span class="nc" id="L1573">			int result = 1;</span>
<span class="nc" id="L1574">			result = prime * result + (int) (length ^ (length &gt;&gt;&gt; 32));</span>
<span class="nc" id="L1575">			result = prime * result + start;</span>
<span class="nc" id="L1576">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L1581" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L1582">				return true;</span>
			}
<span class="nc bnc" id="L1584" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L1585">				return false;</span>
			}
<span class="nc bnc" id="L1587" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L1588">				return false;</span>
			}
<span class="nc" id="L1590">			UnsignedByteStartLongLengthRange other = (UnsignedByteStartLongLengthRange) obj;</span>
<span class="nc bnc" id="L1591" title="All 2 branches missed.">			if (length != other.length) {</span>
<span class="nc" id="L1592">				return false;</span>
			}
<span class="nc bnc" id="L1594" title="All 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L1595">				return false;</span>
			}
<span class="nc" id="L1597">			return true;</span>
		}
		
    }
    
    /**
     * Range implementation that stores the 
     * start as unsigned shorts
     * and the length as an unsigned byte.
     * This is probably the most common read valid
     * range for next-gen sequencing.
     * @author dkatzel
     *
     */
    private static final class UnsignedShortStartShortLengthRange extends Range{
        /**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final short start;

        /**
         * The length coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final  short length;
        
<span class="fc" id="L1624">    	private UnsignedShortStartShortLengthRange(int start, int length){</span>
<span class="fc" id="L1625">    		 this.start = IOUtil.toSignedShort(start);</span>
<span class="fc" id="L1626">	        this.length = IOUtil.toSignedShort(length);</span>
<span class="fc" id="L1627">    	}</span>
    	
    	@Override
		public long getLength() {
<span class="fc" id="L1631">			return IOUtil.toUnsignedShort(length);</span>
		}

		/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="fc" id="L1644">            return IOUtil.toUnsignedShort(start);</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="fc" id="L1655">            return getBegin()+getLength()-1;</span>
        }

		@Override
		public int hashCode() {
<span class="nc" id="L1660">			final int prime = 31;</span>
<span class="nc" id="L1661">			int result = 1;</span>
<span class="nc" id="L1662">			result = prime * result + length;</span>
<span class="nc" id="L1663">			result = prime * result + start;</span>
<span class="nc" id="L1664">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="fc bfc" id="L1669" title="All 2 branches covered.">			if (this == obj) {</span>
<span class="fc" id="L1670">				return true;</span>
			}
<span class="pc bpc" id="L1672" title="1 of 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L1673">				return false;</span>
			}
<span class="pc bpc" id="L1675" title="1 of 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L1676">				return false;</span>
			}
<span class="fc" id="L1678">			UnsignedShortStartShortLengthRange other = (UnsignedShortStartShortLengthRange) obj;</span>
<span class="pc bpc" id="L1679" title="1 of 2 branches missed.">			if (length != other.length) {</span>
<span class="nc" id="L1680">				return false;</span>
			}
<span class="pc bpc" id="L1682" title="1 of 2 branches missed.">			if (start != other.start) {</span>
<span class="fc" id="L1683">				return false;</span>
			}
<span class="nc" id="L1685">			return true;</span>
		}
    }
    
    /**
     * Range implementation that stores the 
     * start as unsigned shorts
     * and the length as an unsigned byte.
     * This is probably the most common read valid
     * range for next-gen sequencing.
     * @author dkatzel
     *
     */
    private static final class UnsignedShortStartIntLengthRange extends Range{
    

        /**
         * The length coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final  int length;
        
        /**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final short start;
        
<span class="nc" id="L1713">    	private UnsignedShortStartIntLengthRange(int start, long length){</span>
<span class="nc" id="L1714">    		 this.start = IOUtil.toSignedShort(start);</span>
<span class="nc" id="L1715">	        this.length = IOUtil.toSignedInt(length);</span>
<span class="nc" id="L1716">    	}</span>
    	
    	@Override
		public long getLength() {
<span class="nc" id="L1720">			return IOUtil.toUnsignedInt(length);</span>
		}

		/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="nc" id="L1733">            return IOUtil.toUnsignedShort(start);</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="nc" id="L1744">            return getBegin()+getLength()-1;</span>
        }

		@Override
		public int hashCode() {
<span class="nc" id="L1749">			final int prime = 31;</span>
<span class="nc" id="L1750">			int result = 1;</span>
<span class="nc" id="L1751">			result = prime * result + length;</span>
<span class="nc" id="L1752">			result = prime * result + start;</span>
<span class="nc" id="L1753">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L1758" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L1759">				return true;</span>
			}
<span class="nc bnc" id="L1761" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L1762">				return false;</span>
			}
<span class="nc bnc" id="L1764" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L1765">				return false;</span>
			}
<span class="nc" id="L1767">			UnsignedShortStartIntLengthRange other = (UnsignedShortStartIntLengthRange) obj;</span>
<span class="nc bnc" id="L1768" title="All 2 branches missed.">			if (length != other.length) {</span>
<span class="nc" id="L1769">				return false;</span>
			}
<span class="nc bnc" id="L1771" title="All 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L1772">				return false;</span>
			}
<span class="nc" id="L1774">			return true;</span>
		}
    }
    
    /**
     * Range implementation that stores the 
     * start as unsigned shorts
     * and the length as an long.
     * This is often used to placed
     * contigs in scaffolds.
     * @author dkatzel
     *
     */
    private static final class UnsignedShortStartLongLengthRange extends Range{
        /**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final short start;

        /**
         * The length coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final  long length;
        
<span class="nc" id="L1800">    	private UnsignedShortStartLongLengthRange(int start, long length){</span>
<span class="nc" id="L1801">    		 this.start = IOUtil.toSignedShort(start);</span>
<span class="nc" id="L1802">	        this.length = length;</span>
<span class="nc" id="L1803">    	}</span>
    	
    	@Override
		public long getLength() {
<span class="nc" id="L1807">			return length;</span>
		}

		/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="nc" id="L1820">            return IOUtil.toUnsignedShort(start);</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="nc" id="L1831">            return getBegin()+getLength()-1;</span>
        }

		@Override
		public int hashCode() {
<span class="nc" id="L1836">			final int prime = 31;</span>
<span class="nc" id="L1837">			int result = 1;</span>
<span class="nc" id="L1838">			result = prime * result + (int) (length ^ (length &gt;&gt;&gt; 32));</span>
<span class="nc" id="L1839">			result = prime * result + start;</span>
<span class="nc" id="L1840">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L1845" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L1846">				return true;</span>
			}
<span class="nc bnc" id="L1848" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L1849">				return false;</span>
			}
<span class="nc bnc" id="L1851" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L1852">				return false;</span>
			}
<span class="nc" id="L1854">			UnsignedShortStartLongLengthRange other = (UnsignedShortStartLongLengthRange) obj;</span>
<span class="nc bnc" id="L1855" title="All 2 branches missed.">			if (length != other.length) {</span>
<span class="nc" id="L1856">				return false;</span>
			}
<span class="nc bnc" id="L1858" title="All 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L1859">				return false;</span>
			}
<span class="nc" id="L1861">			return true;</span>
		}
    }
    
    /**
     * Range implementation that stores the 
     * start as unsigned int
     * and the length as an unsigned byte.
     * This is often used for placing contigs
     * at the middle/ends of scaffolds.
     * @author dkatzel
     *
     */
    private static final class UnsignedIntStartIntLengthRange extends Range{
        /**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final int start;

        /**
         * The length coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final  int length;
        
<span class="nc" id="L1887">    	private UnsignedIntStartIntLengthRange(long start, long length){</span>
<span class="nc" id="L1888">    		 this.start = IOUtil.toSignedInt(start);</span>
<span class="nc" id="L1889">	        this.length = IOUtil.toSignedInt(length);</span>
<span class="nc" id="L1890">    	}</span>
    	
    	@Override
		public long getLength() {
<span class="nc" id="L1894">			return IOUtil.toUnsignedInt(length);</span>
		}

		/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="nc" id="L1907">            return IOUtil.toUnsignedInt(start);</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="nc" id="L1918">            return getBegin()+getLength()-1;</span>
        }

		@Override
		public int hashCode() {
<span class="nc" id="L1923">			final int prime = 31;</span>
<span class="nc" id="L1924">			int result = 1;</span>
<span class="nc" id="L1925">			result = prime * result + length;</span>
<span class="nc" id="L1926">			result = prime * result + start;</span>
<span class="nc" id="L1927">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L1932" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L1933">				return true;</span>
			}
<span class="nc bnc" id="L1935" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L1936">				return false;</span>
			}
<span class="nc bnc" id="L1938" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L1939">				return false;</span>
			}
<span class="nc" id="L1941">			UnsignedIntStartIntLengthRange other = (UnsignedIntStartIntLengthRange) obj;</span>
<span class="nc bnc" id="L1942" title="All 2 branches missed.">			if (length != other.length) {</span>
<span class="nc" id="L1943">				return false;</span>
			}
<span class="nc bnc" id="L1945" title="All 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L1946">				return false;</span>
			}
<span class="nc" id="L1948">			return true;</span>
		}
    }
    
    /**
     * Range implementation that stores the 
     * start as an unsigned int
     * and the length as an long.
     * This is often used to placed
     * contigs in scaffolds.
     * @author dkatzel
     *
     */
    private static final class UnsignedIntStartLongLengthRange extends Range{
        /**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final int start;

        /**
         * The length coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final  long length;
        
<span class="nc" id="L1974">    	private UnsignedIntStartLongLengthRange(long start, long length){</span>
<span class="nc" id="L1975">    		 this.start = IOUtil.toSignedInt(start);</span>
<span class="nc" id="L1976">	        this.length = length;</span>
<span class="nc" id="L1977">    	}</span>
    	
    	@Override
		public long getLength() {
<span class="nc" id="L1981">			return length;</span>
		}

		/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="nc" id="L1994">            return IOUtil.toUnsignedInt(start);</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="nc" id="L2005">            return getBegin()+getLength()-1;</span>
        }

		@Override
		public int hashCode() {
<span class="nc" id="L2010">			final int prime = 31;</span>
<span class="nc" id="L2011">			int result = 1;</span>
<span class="nc" id="L2012">			result = prime * result + (int) (length ^ (length &gt;&gt;&gt; 32));</span>
<span class="nc" id="L2013">			result = prime * result + start;</span>
<span class="nc" id="L2014">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L2019" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L2020">				return true;</span>
			}
<span class="nc bnc" id="L2022" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L2023">				return false;</span>
			}
<span class="nc bnc" id="L2025" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L2026">				return false;</span>
			}
<span class="nc" id="L2028">			UnsignedIntStartLongLengthRange other = (UnsignedIntStartLongLengthRange) obj;</span>
<span class="nc bnc" id="L2029" title="All 2 branches missed.">			if (length != other.length) {</span>
<span class="nc" id="L2030">				return false;</span>
			}
<span class="nc bnc" id="L2032" title="All 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L2033">				return false;</span>
			}
<span class="nc" id="L2035">			return true;</span>
		}
    }
    /**
     * Range implementation that stores the 
     * start as signed long
     * and the length as an unsigned byte.
     * This is often used for placing contigs
     * at the middle/ends of scaffolds.
     * @author dkatzel
     *
     */
    private static final class LongStartIntLengthRange extends Range{
        /**
         * The start coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final long start;

        /**
         * The length coordinate.
         * This coordinate stored relative to the zero base coordinate system
         */
        private final  int length;
        
<span class="nc" id="L2060">    	private LongStartIntLengthRange(long start, long length){</span>
<span class="nc" id="L2061">    		 this.start = start;</span>
<span class="nc" id="L2062">	        this.length = IOUtil.toSignedInt(length);</span>
<span class="nc" id="L2063">    	}</span>
    	
    	@Override
		public long getLength() {
<span class="nc" id="L2067">			return IOUtil.toUnsignedInt(length);</span>
		}

		/**
         * Fetch the left (start) coordinate This is the same as 
         * {@link #getBegin(CoordinateSystem)
         * getStart(ZERO_BASED)}.
         *
         * @return The left-hand (starting) coordinate.
         * 
         */
    	@Override
        public long getBegin() {
<span class="nc" id="L2080">            return start;</span>
        }
    	 /**
         * Fetch the 0-based right (end) coordinate.
         * This is the same as {@link #getEnd(CoordinateSystem)
         * getEnd(ZERO_BASED)}.
         *
         * @return The right-hand (ending) coordinate.
         */
    	@Override
        public long getEnd() {
<span class="nc" id="L2091">            return getBegin()+getLength()-1;</span>
        }

		@Override
		public int hashCode() {
<span class="nc" id="L2096">			final int prime = 31;</span>
<span class="nc" id="L2097">			int result = 1;</span>
<span class="nc" id="L2098">			result = prime * result + length;</span>
<span class="nc" id="L2099">			result = prime * result + (int) (start ^ (start &gt;&gt;&gt; 32));</span>
<span class="nc" id="L2100">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L2105" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L2106">				return true;</span>
			}
<span class="nc bnc" id="L2108" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L2109">				return false;</span>
			}
<span class="nc bnc" id="L2111" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L2112">				return false;</span>
			}
<span class="nc" id="L2114">			LongStartIntLengthRange other = (LongStartIntLengthRange) obj;</span>
<span class="nc bnc" id="L2115" title="All 2 branches missed.">			if (length != other.length) {</span>
<span class="nc" id="L2116">				return false;</span>
			}
<span class="nc bnc" id="L2118" title="All 2 branches missed.">			if (start != other.start) {</span>
<span class="nc" id="L2119">				return false;</span>
			}
<span class="nc" id="L2121">			return true;</span>
		}

		
    }
  
    
    
    private static final class EmptyByteRange extends Range{
    	private final byte coordinate;
    	
<span class="nc" id="L2132">    	EmptyByteRange(byte coordinate){</span>
<span class="nc" id="L2133">    		this.coordinate = coordinate;</span>
<span class="nc" id="L2134">    	}</span>

		@Override
		public long getBegin() {
<span class="nc" id="L2138">			return coordinate;</span>
		}

		@Override
		public long getEnd() {
<span class="nc" id="L2143">			return coordinate-1;</span>
		}

		@Override
		public boolean isEmpty() {
<span class="nc" id="L2148">			return true;</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L2153">			final int prime = 31;</span>
<span class="nc" id="L2154">			int result = 1;</span>
<span class="nc" id="L2155">			result = prime * result + coordinate;</span>
<span class="nc" id="L2156">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L2161" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L2162">				return true;</span>
			}
<span class="nc bnc" id="L2164" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L2165">				return false;</span>
			}
<span class="nc bnc" id="L2167" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L2168">				return false;</span>
			}
<span class="nc" id="L2170">			EmptyByteRange other = (EmptyByteRange) obj;</span>
<span class="nc bnc" id="L2171" title="All 2 branches missed.">			if (coordinate != other.coordinate) {</span>
<span class="nc" id="L2172">				return false;</span>
			}
<span class="nc" id="L2174">			return true;</span>
		}
    	
    }
    
    private static final class EmptyShortRange extends Range{
    	private final short coordinate;
    	
<span class="nc" id="L2182">    	EmptyShortRange(short coordinate){</span>
<span class="nc" id="L2183">    		this.coordinate = coordinate;</span>
<span class="nc" id="L2184">    	}</span>

		@Override
		public long getBegin() {
<span class="nc" id="L2188">			return coordinate;</span>
		}

		@Override
		public long getEnd() {
<span class="nc" id="L2193">			return coordinate-1;</span>
		}

		@Override
		public boolean isEmpty() {
<span class="nc" id="L2198">			return true;</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L2203">			final int prime = 31;</span>
<span class="nc" id="L2204">			int result = 1;</span>
<span class="nc" id="L2205">			result = prime * result + coordinate;</span>
<span class="nc" id="L2206">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L2211" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L2212">				return true;</span>
			}
<span class="nc bnc" id="L2214" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L2215">				return false;</span>
			}
<span class="nc bnc" id="L2217" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L2218">				return false;</span>
			}
<span class="nc" id="L2220">			EmptyShortRange other = (EmptyShortRange) obj;</span>
<span class="nc bnc" id="L2221" title="All 2 branches missed.">			if (coordinate != other.coordinate) {</span>
<span class="nc" id="L2222">				return false;</span>
			}
<span class="nc" id="L2224">			return true;</span>
		}
    }
    
    private static final class EmptyIntRange extends Range{
    	private final int coordinate;
    	
<span class="nc" id="L2231">    	EmptyIntRange(int coordinate){</span>
<span class="nc" id="L2232">    		this.coordinate = coordinate;</span>
<span class="nc" id="L2233">    	}</span>

		@Override
		public long getBegin() {
<span class="nc" id="L2237">			return coordinate;</span>
		}

		@Override
		public long getEnd() {
<span class="nc" id="L2242">			return coordinate-1;</span>
		}

		@Override
		public boolean isEmpty() {
<span class="nc" id="L2247">			return true;</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L2252">			final int prime = 31;</span>
<span class="nc" id="L2253">			int result = 1;</span>
<span class="nc" id="L2254">			result = prime * result + coordinate;</span>
<span class="nc" id="L2255">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L2260" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L2261">				return true;</span>
			}
<span class="nc bnc" id="L2263" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L2264">				return false;</span>
			}
<span class="nc bnc" id="L2266" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L2267">				return false;</span>
			}
<span class="nc" id="L2269">			EmptyIntRange other = (EmptyIntRange) obj;</span>
<span class="nc bnc" id="L2270" title="All 2 branches missed.">			if (coordinate != other.coordinate) {</span>
<span class="nc" id="L2271">				return false;</span>
			}
<span class="nc" id="L2273">			return true;</span>
		}
    }
    
    private static final class EmptyLongRange extends Range{
    	private final long coordinate;
    	
<span class="nc" id="L2280">    	EmptyLongRange(long coordinate){</span>
<span class="nc" id="L2281">    		this.coordinate = coordinate;</span>
<span class="nc" id="L2282">    	}</span>

		@Override
		public long getBegin() {
<span class="nc" id="L2286">			return coordinate;</span>
		}

		@Override
		public long getEnd() {
<span class="nc" id="L2291">			return coordinate-1;</span>
		}

		@Override
		public boolean isEmpty() {
<span class="nc" id="L2296">			return true;</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L2301">			final int prime = 31;</span>
<span class="nc" id="L2302">			int result = 1;</span>
<span class="nc" id="L2303">			result = prime * result + (int) (coordinate ^ (coordinate &gt;&gt;&gt; 32));</span>
<span class="nc" id="L2304">			return result;</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L2309" title="All 2 branches missed.">			if (this == obj) {</span>
<span class="nc" id="L2310">				return true;</span>
			}
<span class="nc bnc" id="L2312" title="All 2 branches missed.">			if (obj == null) {</span>
<span class="nc" id="L2313">				return false;</span>
			}
<span class="nc bnc" id="L2315" title="All 2 branches missed.">			if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L2316">				return false;</span>
			}
<span class="nc" id="L2318">			EmptyLongRange other = (EmptyLongRange) obj;</span>
<span class="nc bnc" id="L2319" title="All 2 branches missed.">			if (coordinate != other.coordinate) {</span>
<span class="nc" id="L2320">				return false;</span>
			}
<span class="nc" id="L2322">			return true;</span>
		}
		
    }
    
    /**
     * {@code Builder} is a mutable object
     * that allows clients to create a 
     * {@link Range} object using the current
     * specification.  
     * &lt;p/&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; {@link Builder#build()} is not guaranteed to return new instances and may return
     * a cached instance instead (flyweight pattern).
     * &lt;p/&gt;
     * This class is not thread-safe.
     * @author dkatzel
     *
     */
    public static final class Builder {
    	
    	private long begin;
    	private long end;
    	private final CoordinateSystem inputCoordinateSystem;
    	/**
    	 * Create a new Builder instance
    	 * which is initialized to an 
    	 * empty range with a coordinate at the
    	 * origin (zero for {@link CoordinateSystem#ZERO_BASED}).
    	 */
    	public Builder(){
<span class="nc" id="L2352">    		this(0);</span>
<span class="nc" id="L2353">    	}</span>
    	public Builder(Builder copy){
<span class="nc" id="L2355">    		this(copy.inputCoordinateSystem, copy.begin, copy.end);</span>
<span class="nc" id="L2356">    	}</span>
    	/**
    	 * Create a new Builder instance
    	 * which is initialized to the given
    	 * begin and end coordinates in zero-based
    	 * coordinate space.
    	 * This is equivalent to 
    	 * {@link Builder#Builder(CoordinateSystem, long, long)
    	 * new Builder(CoordinateSystem.ZERO_BASED, begin,end)}.
    	 * @param begin the initial  inclusive begin coordinate of the range in zero based coordinates. 
    	 * @param end the initial inclusive end coordinate in zero based coordinates. 
    	 * @see Builder#Builder(CoordinateSystem, long, long)
    	 *  @throws IllegalArgumentException if the given
    	 * begin and end coordiantes cause the
    	 * length to be negative.
    	 */
    	public Builder(long begin, long end){
<span class="fc" id="L2373">    		this(CoordinateSystem.ZERO_BASED, begin,end);</span>
<span class="fc" id="L2374">    	}</span>
    	/**
    	 * Create a new Builder instance
    	 * which is initialized to the given
    	 * begin and end coordinates in the
    	 * given coordinate space.
    	 * @param cs the {@link CoordinateSystem} these coordinates are
    	 * given in; can not be null.
    	 * @param begin the initial  begin coordinate of the range in the given
    	 * {@link CoordinateSystem}. 
    	 * @param end the initial end coordinate of the range in the given
    	 * {@link CoordinateSystem}.  
    	 * @throws NullPointerException if cs is null.
    	 * @throws IllegalArgumentException if the given
    	 * begin and end coordiantes cause the
    	 * length to be negative.
    	 */
<span class="fc" id="L2391">    	public Builder(CoordinateSystem cs,long begin, long end){</span>
<span class="pc bpc" id="L2392" title="1 of 2 branches missed.">    		if(cs ==null){</span>
<span class="nc" id="L2393">    			throw new NullPointerException(&quot;CoordinateSystem can not be null&quot;);</span>
    		}
<span class="fc" id="L2395">    		assertValidCoordinates(begin,end);</span>
<span class="fc" id="L2396">    		this.begin = cs.getStart(begin);</span>
<span class="fc" id="L2397">    		this.end = cs.getEnd(end);</span>
<span class="fc" id="L2398">    		this.inputCoordinateSystem = cs;</span>
    		
<span class="fc" id="L2400">    	}</span>
    	private void assertValidCoordinates(long begin, long end){
<span class="fc" id="L2402">    		long length = end-begin+1;</span>
<span class="pc bpc" id="L2403" title="1 of 2 branches missed.">    		if(length&lt;0){</span>
<span class="nc" id="L2404">    			throw new IllegalArgumentException(&quot;length can not be negative&quot;);</span>
    		}
<span class="fc" id="L2406">    	}</span>
    	/**
    	 * Create a new Builder instance
    	 * which is initialized to an 
    	 * range with a coordinate at the
    	 * origin (zero for {@link CoordinateSystem#ZERO_BASED})
    	 * and a length of the given length.
    	 * @param length the initial length of the range;
    	 * can not be {@literal &lt;0}.
    	 * @throws IllegalArgumentException if length {@literal &lt;0}.
    	 */
<span class="fc" id="L2417">    	public Builder(long length){</span>
<span class="pc bpc" id="L2418" title="1 of 2 branches missed.">    		if(length &lt;0){</span>
<span class="nc" id="L2419">    			throw new IllegalArgumentException(&quot;must be &gt;=0&quot;);</span>
    		}
<span class="fc" id="L2421">    		begin=0;</span>
<span class="fc" id="L2422">    		end = length-1;</span>
<span class="fc" id="L2423">    		inputCoordinateSystem = CoordinateSystem.ZERO_BASED;</span>
<span class="fc" id="L2424">    	}</span>
    	/**
    	 * Create a new Builder instance
    	 * which is initialized to have the same
    	 * begin and end coordinates as the given {@link Range}.
    	 * @param range the range to copy;
    	 * can not be null.
    	 */
<span class="nc" id="L2432">    	public Builder(Range range){</span>
<span class="nc bnc" id="L2433" title="All 2 branches missed.">    		if(range ==null){</span>
<span class="nc" id="L2434">    			throw new NullPointerException(&quot;range can not be null&quot;);</span>
    		}
<span class="nc" id="L2436">    		begin=range.getBegin();</span>
<span class="nc" id="L2437">    		end = range.getEnd();</span>
<span class="nc" id="L2438">    		inputCoordinateSystem = CoordinateSystem.ZERO_BASED;</span>
<span class="nc" id="L2439">    	}</span>

    	/**
    	 * Shift the entire range by the given
    	 * amount of units. Both the begin and end coordinates
    	 * will be adjusted by the given value.  The length 
    	 * will remain the same. 
    	 * @param units the amount to shift. If this number
    	 * is positive, then the begin and end coordinates
    	 * will be increased; if this number is negative, 
    	 * then the begin and end coordinates will be decreased.
    	 * A value of 0 will cause no changes.
    	 * @return this.
    	 */
    	public Builder shift(long units){
<span class="fc" id="L2454">    		begin+=units;</span>
<span class="fc" id="L2455">    		end+=units;</span>
<span class="fc" id="L2456">    		return this;</span>
    	}
    	/**
    	 * Shrink the begin value by the given
    	 * amount of units.  This will add the given number
    	 * of  units to the begin coordinate which will also cause
    	 * the range's length to be shrunk by the given amount.
    	 * @param units the amount to shrink to the left. If this number
    	 * is negative, then that is the equivalent of growing
    	 * to the left by the given number of units
    	 * @return this.
    	 * @see #expandBegin(long)
    	 * @throws IllegalArgumentException if shrinking the begin
    	 * coordinate by the given amount causes the range's
    	 * length to be negative.
    	 */
    	public Builder contractBegin(long units){
<span class="nc" id="L2473">    		long newBegin = begin+units;</span>
<span class="nc" id="L2474">    		assertValidCoordinates(newBegin,end);</span>
<span class="nc" id="L2475">    		begin = newBegin;</span>
<span class="nc" id="L2476">    		return this;</span>
    	}
    	/**
    	 * Shrink the end value by the given
    	 * amount of units.  This will subtract the given number
    	 * of  units to the end coordinate which will also cause
    	 * the range's length to be shrunk by the given amount.
    	 * @param units the amount to shrink to the right. If this number
    	 * is negative, then that is the equivalent of growing
    	 * to the right by the given number of units
    	 * @return this.
    	 * @see #expandEnd(long)
    	 * @throws IllegalArgumentException if shrinking the end
    	 * coordinate by the given amount causes the range's
    	 * length to be negative.
    	 */
    	public Builder contractEnd(long units){
<span class="nc" id="L2493">    		long newEnd = end-units;</span>
<span class="nc" id="L2494">    		assertValidCoordinates(begin,newEnd);</span>
<span class="nc" id="L2495">    		end -=units;</span>
<span class="nc" id="L2496">    		return this;</span>
    	}
    	/**
    	 * Grows the begin value by the given
    	 * amount of units.  This will subtract the given number
    	 * of  units to the begin coordinate which will also cause
    	 * the range's length to be grown by the given amount.
    	 * @param units the amount to grow to the left. If this number
    	 * is negative, then that is the equivalent of shrinking
    	 * to the left by the given number of units
    	 * @return this.
    	 * @see #contractBegin(long)
    	 */
    	public Builder expandBegin(long units){
<span class="nc" id="L2510">    		begin-=units;</span>
<span class="nc" id="L2511">    		return this;</span>
    	}
    	/**
    	 * Grows the end value by the given
    	 * amount of units.  This will subtract the given number
    	 * of  units to the end coordinate which will also cause
    	 * the range's length to be grown by the given amount.
    	 * @param units the amount to grow to the right. If this number
    	 * is negative, then that is the equivalent of shrinking
    	 * to the right by the given number of units
    	 * @return this.
    	 * @see #contractEnd(long)
    	 */
    	public Builder expandEnd(long units){
<span class="nc" id="L2525">    		end +=units;</span>
<span class="nc" id="L2526">    		return this;</span>
    	}
    	/**
    	 * Create a copy of this Builder using the current values.
    	 * Any futher modifications to either the original Builder
    	 * or the copy will not affect the other.
    	 * @return a new instance.
    	 */
    	public Builder copy(){
<span class="nc" id="L2535">    		return new Builder(this);</span>
    	}
    	/**
    	 * Use the current begin, end and length
    	 * values of this Builder to return an instance
    	 * of a {@link Range} object with the same values.
    	 * This method is not guaranteed to return new instances and may return
	     * a cached instance instead (flyweight pattern).
	     * @return a {@link Range}; never null but might 
	     * not be a new instance.
	     * @throws IllegalArgumentException if {@code end &lt; begin -1} 
	     * or if the resulting range length &gt; {@link Long#MAX_VALUE}.
    	 */
    	public Range build(){
<span class="fc" id="L2549">    		long length = end-begin+1;</span>
<span class="pc bpc" id="L2550" title="1 of 2 branches missed.">    		if(length&lt;0){</span>
<span class="nc" id="L2551">    			throw new IllegalArgumentException(&quot;length can not be negative&quot;);</span>
    		}
<span class="fc bfc" id="L2553" title="All 2 branches covered.">    		if(begin &gt;0){</span>
<span class="fc" id="L2554">        		long maxLength = Long.MAX_VALUE - begin+1;</span>
<span class="pc bpc" id="L2555" title="1 of 2 branches missed.">        		if(maxLength &lt; length){</span>
<span class="nc" id="L2556">        			throw new IndexOutOfBoundsException(</span>
<span class="nc" id="L2557">        					String.format(&quot;given length %d would make range [%d - ? ] beyond max allowed end offset&quot;,</span>
<span class="nc" id="L2558">        							end, begin));</span>
        		}
        	}
    		
    		final Range range;
<span class="pc bpc" id="L2563" title="1 of 2 branches missed.">            if(end &gt;= begin) {</span>
<span class="fc" id="L2564">                range= buildNewRange(begin,end);            </span>
<span class="nc bnc" id="L2565" title="All 2 branches missed.">            } else if (end == begin-1) {</span>
<span class="nc" id="L2566">                range = buildNewEmptyRange(begin);</span>
            } else {
<span class="nc" id="L2568">                throw new IllegalArgumentException(String.format(&quot;Range coordinates %d, %d are not valid %s coordinates&quot;, </span>
<span class="nc" id="L2569">                		inputCoordinateSystem.getLocalStart(begin), inputCoordinateSystem.getLocalEnd(end), inputCoordinateSystem));</span>
            }
<span class="fc" id="L2571">            return getFromCache(range);</span>
    	}
    	
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>