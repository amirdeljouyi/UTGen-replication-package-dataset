<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RunLengthEncodedQualityCodec.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core.qual</a> &gt; <span class="el_source">RunLengthEncodedQualityCodec.java</span></div><h1>RunLengthEncodedQualityCodec.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Feb 20, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.core.qual;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.internal.core.io.ValueSizeStrategy;
import org.jcvi.jillion.internal.core.util.RunLength;
/**
 * {@code RunLengthEncodedQualityCodec} is a {@link QualitySymbolCodec}
 * that encodes {@link PhredQuality} values in a run-length encoding.
 * Since reads often have clusters of basecalls with the same quality value
 * encoding them in a run-length format could have significant memory savings.
 * @author dkatzel
 *
 */
final class RunLengthEncodedQualityCodec implements QualitySymbolCodec{
	/**
	 * Singleton instance.
	 */
<span class="nc" id="L51">    public static final RunLengthEncodedQualityCodec INSTANCE = new RunLengthEncodedQualityCodec(Byte.MIN_VALUE);</span>
    
    private final byte guard;

<span class="nc" id="L55">    RunLengthEncodedQualityCodec( byte guard){</span>
<span class="nc" id="L56">        this.guard = guard;</span>
<span class="nc" id="L57">    }</span>
    
    
    public Iterator&lt;PhredQuality&gt; iterator(byte[] encodedData){
<span class="nc" id="L61">    	  ByteBuffer buf = ByteBuffer.wrap(encodedData);</span>
<span class="nc" id="L62">          int size = buf.getInt();</span>
<span class="nc" id="L63">          byte guard = buf.get();</span>
<span class="nc" id="L64">          ValueSizeStrategy valueSizeStrategy = ValueSizeStrategy.values()[buf.get()];</span>
<span class="nc" id="L65">          return new RunLengthIterator(buf, guard,valueSizeStrategy, size);</span>
    }
    public Iterator&lt;PhredQuality&gt; iterator(byte[] encodedData, Range r){
<span class="nc" id="L68">  	  ByteBuffer buf = ByteBuffer.wrap(encodedData);</span>
<span class="nc" id="L69">        int size = buf.getInt();</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">        if(r.getEnd()&gt; size-1){</span>
<span class="nc" id="L71">        	throw new IndexOutOfBoundsException(</span>
<span class="nc" id="L72">        			String.format(&quot;can not iterate over %s when sequence is only %d long&quot;, r, size));</span>
        }
<span class="nc" id="L74">        byte guard = buf.get();</span>
<span class="nc" id="L75">        ValueSizeStrategy valueSizeStrategy = ValueSizeStrategy.values()[buf.get()];</span>
<span class="nc" id="L76">        return new RunLengthIterator(buf, guard,valueSizeStrategy, r.getEnd()+1, r.getBegin());</span>
  }
    
    private PhredQuality get(ByteBuffer buf, byte guard,  ValueSizeStrategy valueSizeStrategy, long index){
<span class="nc" id="L80">    	int currentOffset=0;</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">		while(buf.hasRemaining()){</span>
<span class="nc" id="L82">            byte runLengthCode = buf.get(); </span>
            byte currentValue;
<span class="nc bnc" id="L84" title="All 2 branches missed.">            if( runLengthCode == guard){                                  </span>
<span class="nc" id="L85">            	int count = valueSizeStrategy.getNext(buf);            	 </span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">            	if(count==0){</span>
<span class="nc" id="L87">            		currentOffset++;</span>
<span class="nc" id="L88">            		currentValue = guard;</span>
            	}else{
<span class="nc" id="L90">            		currentValue = buf.get();  </span>
<span class="nc" id="L91">            		currentOffset+=count;</span>
            	}
<span class="nc" id="L93">            }</span>
            else{
<span class="nc" id="L95">            	currentOffset++;</span>
<span class="nc" id="L96">            	currentValue = runLengthCode;</span>
            }
<span class="nc bnc" id="L98" title="All 2 branches missed.">            if(currentOffset&gt;index){</span>
<span class="nc" id="L99">            	return PhredQuality.valueOf(currentValue);</span>
            }
<span class="nc" id="L101">    	}</span>
		//should not happen, any method that calls this
		//should have done bounds checking but this
		//is required to get it to compile.
<span class="nc" id="L105">		throw new IndexOutOfBoundsException(&quot;could not find index &quot;+index);</span>
    }

   
    @Override
    public PhredQuality decode(byte[] encodedGlyphs, long index) {
<span class="nc bnc" id="L111" title="All 2 branches missed.">    	 if(index &lt;0){</span>
<span class="nc" id="L112">         	throw new IndexOutOfBoundsException(&quot;can not have negative length&quot;);</span>
         }
<span class="nc" id="L114">        ByteBuffer buf = ByteBuffer.wrap(encodedGlyphs);</span>
<span class="nc" id="L115">        int length=buf.getInt();       </span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if(index &gt;=length){</span>
<span class="nc" id="L117">        	throw new IndexOutOfBoundsException(&quot;can not have index beyond length&quot;);</span>
        }
<span class="nc" id="L119">        byte guard = buf.get();</span>
<span class="nc" id="L120">        ValueSizeStrategy valueSizeStrategy = ValueSizeStrategy.values()[buf.get()];</span>
<span class="nc" id="L121">        return get(buf,guard,valueSizeStrategy, index);</span>
    }

    @Override
    public int decodedLengthOf(byte[] encodedGlyphs) {
<span class="nc" id="L126">        ByteBuffer buf = ByteBuffer.wrap(encodedGlyphs);</span>
<span class="nc" id="L127">        return buf.getInt();</span>
    }
    
    @Override
    public byte[] encode(Collection&lt;PhredQuality&gt; glyphs) {
<span class="nc" id="L132">        List&lt;RunLength&lt;PhredQuality&gt;&gt; runLengthList = runLengthEncode(glyphs);</span>
<span class="nc" id="L133">        return createEncodedByteArray(glyphs.size(), runLengthList);</span>
    }
    
    public byte[] encode(byte[] qualities){
<span class="nc" id="L137">    	 List&lt;RunLength&lt;PhredQuality&gt;&gt; runLengthList = runLengthEncode(qualities);</span>
<span class="nc" id="L138">         return createEncodedByteArray(qualities.length, runLengthList);</span>
    }
    public byte[] encode(Iterable&lt;PhredQuality&gt; qualityIterable, int numberOfQualities) {
<span class="nc" id="L141">        List&lt;RunLength&lt;PhredQuality&gt;&gt; runLengthList = runLengthEncode(qualityIterable);</span>
<span class="nc" id="L142">        return createEncodedByteArray(numberOfQualities, runLengthList);</span>
    }
	private byte[] createEncodedByteArray(int numberOfQualities,
			List&lt;RunLength&lt;PhredQuality&gt;&gt; runLengthList) {
<span class="nc" id="L146">		Metrics metrics = new Metrics(runLengthList);</span>
<span class="nc" id="L147">		ValueSizeStrategy sizeStrategy = metrics.getSizeStrategy();</span>
<span class="nc" id="L148">        ByteBuffer buf = ByteBuffer.allocate(metrics.computeEncodingSize());</span>
<span class="nc" id="L149">        buf.putInt(numberOfQualities);</span>
<span class="nc" id="L150">        buf.put(guard);</span>
<span class="nc" id="L151">        buf.put((byte)sizeStrategy.ordinal());</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        for(RunLength&lt;PhredQuality&gt; runLength : runLengthList){</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if(runLength.getValue().getQualityScore() == guard){</span>
                
<span class="nc bnc" id="L155" title="All 2 branches missed.">                for(int repeatCount = 0; repeatCount&lt;runLength.getLength(); repeatCount++){</span>
<span class="nc" id="L156">                    buf.put(guard);</span>
<span class="nc" id="L157">                    sizeStrategy.put(buf, 0);</span>
                }
               
            }
            else{
<span class="nc bnc" id="L162" title="All 2 branches missed.">                if(runLength.getLength() ==1){</span>
<span class="nc" id="L163">                    buf.put(runLength.getValue().getQualityScore());</span>
                }
                else{
<span class="nc" id="L166">                    buf.put(guard);</span>
<span class="nc" id="L167">                    sizeStrategy.put(buf, runLength.getLength());</span>
<span class="nc" id="L168">                    buf.put(runLength.getValue().getQualityScore());</span>
                }
            }
<span class="nc" id="L171">        }</span>
<span class="nc" id="L172">        return buf.array();</span>
	}

    
    @Override
    public int hashCode() {
<span class="nc" id="L178">        final int prime = 31;</span>
<span class="nc" id="L179">        int result = 1;</span>
<span class="nc" id="L180">        result = prime * result + guard;</span>
<span class="nc" id="L181">        return result;</span>
    }
    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (this == obj){</span>
<span class="nc" id="L186">            return true;</span>
        }
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (!(obj instanceof RunLengthEncodedQualityCodec)){</span>
<span class="nc" id="L189">            return false;</span>
        }
<span class="nc" id="L191">        RunLengthEncodedQualityCodec other = (RunLengthEncodedQualityCodec) obj;</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (guard != other.guard){</span>
<span class="nc" id="L193">            return false;</span>
        }
<span class="nc" id="L195">        return true;</span>
    }
    private static List&lt;RunLength&lt;PhredQuality&gt;&gt; runLengthEncode(byte[] qualities){
<span class="nc" id="L198">    	int currentOffset=0;</span>

<span class="nc bnc" id="L200" title="All 2 branches missed.">    	if(qualities.length==0){</span>
<span class="nc" id="L201">    		return Collections.emptyList();</span>
    	}
<span class="nc" id="L203">    	List&lt;RunLength&lt;PhredQuality&gt;&gt; encoding = new ArrayList&lt;RunLength&lt;PhredQuality&gt;&gt;();</span>
<span class="nc" id="L204">    	byte currentElement=qualities[currentOffset];</span>
<span class="nc" id="L205">    	int runLength=1;</span>
<span class="nc" id="L206">    	currentOffset++;</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">    	while(currentOffset&lt; qualities.length){</span>
<span class="nc" id="L208">    		byte nextElement = qualities[currentOffset];</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">    		if(currentElement ==nextElement){</span>
<span class="nc" id="L210">    			runLength++;</span>
    		}else{
<span class="nc" id="L212">    			encoding.add(new RunLength&lt;PhredQuality&gt;(PhredQuality.valueOf(currentElement), runLength));</span>
<span class="nc" id="L213">    			runLength=1;</span>
<span class="nc" id="L214">    			currentElement=nextElement;</span>
    		}
<span class="nc" id="L216">    		currentOffset++;</span>
<span class="nc" id="L217">    	}</span>
<span class="nc" id="L218">    	encoding.add(new RunLength&lt;PhredQuality&gt;(PhredQuality.valueOf(currentElement), runLength));</span>
    	
<span class="nc" id="L220">    	return encoding;</span>
    }
    
    private static &lt;T&gt; List&lt;RunLength&lt;T&gt;&gt; runLengthEncode(Iterable&lt;T&gt; elements){
<span class="nc" id="L224">    	Iterator&lt;T&gt; iter = elements.iterator();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">    	if(!iter.hasNext()){</span>
<span class="nc" id="L226">    		return Collections.emptyList();</span>
    	}
<span class="nc" id="L228">    	List&lt;RunLength&lt;T&gt;&gt; encoding = new ArrayList&lt;RunLength&lt;T&gt;&gt;();</span>
<span class="nc" id="L229">    	T currentElement=iter.next();</span>
<span class="nc" id="L230">    	int runLength=1;</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">    	while(iter.hasNext()){</span>
<span class="nc" id="L232">    		T nextElement = iter.next();</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">    		if(currentElement.equals(nextElement)){</span>
<span class="nc" id="L234">    			runLength++;</span>
    		}else{
<span class="nc" id="L236">    			encoding.add(new RunLength&lt;T&gt;(currentElement, runLength));</span>
<span class="nc" id="L237">    			runLength=1;</span>
<span class="nc" id="L238">    			currentElement=nextElement;</span>
    		}
<span class="nc" id="L240">    	}</span>
<span class="nc" id="L241">    	encoding.add(new RunLength&lt;T&gt;(currentElement, runLength));</span>
    	
<span class="nc" id="L243">    	return encoding;</span>
    }
   
   
    private static final class RunLengthIterator implements Iterator&lt;PhredQuality&gt;{
		private long currentOffset;
		private final ByteBuffer buf;
		private final byte guard;
		private final long length;
		private PhredQuality currentQuality;
		private int currentRunEndOffset;
		private final ValueSizeStrategy valueSizeStrategy;
		
		RunLengthIterator(ByteBuffer buf, byte guard,ValueSizeStrategy valueSizeStrategy, long length){
<span class="nc" id="L257">			this(buf,guard,valueSizeStrategy, length,0L);</span>
<span class="nc" id="L258">		}</span>
<span class="nc" id="L259">		RunLengthIterator(ByteBuffer buf, byte guard, ValueSizeStrategy valueSizeStrategy,long length, long startOffset){</span>
<span class="nc" id="L260">			this.buf = buf;</span>
<span class="nc" id="L261">			this.guard =guard;</span>
<span class="nc" id="L262">			this.valueSizeStrategy = valueSizeStrategy;</span>
<span class="nc" id="L263">			currentOffset=startOffset;</span>
<span class="nc" id="L264">			this.length = length;</span>
<span class="nc" id="L265">			populateCurrentRun();</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">			while(currentOffset&gt;=currentRunEndOffset){</span>
<span class="nc" id="L267">				populateCurrentRun();</span>
			}
<span class="nc" id="L269">		}</span>
		@Override
		public boolean hasNext() {
<span class="nc bnc" id="L272" title="All 2 branches missed.">			return currentOffset&lt;length;</span>
		}


		@Override
		public void remove() {
<span class="nc" id="L278">			throw new UnsupportedOperationException();</span>
			
		}

		@Override
		public PhredQuality next() {
<span class="nc bnc" id="L284" title="All 2 branches missed.">			if(!hasNext()){</span>
<span class="nc" id="L285">				throw new NoSuchElementException(&quot;offset = &quot;+currentOffset);</span>
			}
<span class="nc bnc" id="L287" title="All 2 branches missed.">			if(currentOffset&gt;=currentRunEndOffset){</span>
<span class="nc" id="L288">				populateCurrentRun();</span>
			}
<span class="nc" id="L290">			currentOffset++;</span>
<span class="nc" id="L291">			return currentQuality;</span>
		}
		
		private void populateCurrentRun(){
<span class="nc" id="L295">			byte runLengthCode = buf.get(); </span>
            byte currentValue;
<span class="nc bnc" id="L297" title="All 2 branches missed.">            if( runLengthCode == guard){                                  </span>
<span class="nc" id="L298">            	int count = valueSizeStrategy.getNext(buf);          	 </span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">            	if(count==0){</span>
<span class="nc" id="L300">            		currentRunEndOffset++;</span>
<span class="nc" id="L301">            		currentValue = guard;</span>
            	}else{
<span class="nc" id="L303">            		currentValue = buf.get();  </span>
<span class="nc" id="L304">            		currentRunEndOffset+=count;</span>
            	}
<span class="nc" id="L306">            }</span>
            else{
<span class="nc" id="L308">            	currentRunEndOffset++;</span>
<span class="nc" id="L309">            	currentValue = runLengthCode;</span>
            }
<span class="nc" id="L311">            currentQuality = PhredQuality.valueOf(currentValue);</span>
<span class="nc" id="L312">		}</span>
	}
    
    private class Metrics{
<span class="nc" id="L316">    	private int numGuards=0;</span>
<span class="nc" id="L317">    	private int singletons=0;</span>
<span class="nc" id="L318">    	private int nonSingletons=0;</span>
        
<span class="nc" id="L320">    	private int maxRunLength=0;</span>
        
    	private final ValueSizeStrategy sizeStrategy;
<span class="nc" id="L323">    	public Metrics(List&lt;RunLength&lt;PhredQuality&gt;&gt; runLengthList){</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">    		for(RunLength&lt;PhredQuality&gt; runLength : runLengthList){</span>
<span class="nc" id="L325">    			int length = runLength.getLength();</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">    			if(length &gt; maxRunLength){</span>
<span class="nc" id="L327">    				maxRunLength = length;</span>
    			}
<span class="nc bnc" id="L329" title="All 2 branches missed.">                if(runLength.getValue().getQualityScore() == guard){</span>
<span class="nc" id="L330">                    numGuards+=length;</span>
                }
<span class="nc bnc" id="L332" title="All 2 branches missed.">                else if(length ==1){</span>
<span class="nc" id="L333">                    singletons++;</span>
                }
                else{
<span class="nc" id="L336">                    nonSingletons++;</span>
                }
                
<span class="nc" id="L339">            }</span>
    		
<span class="nc" id="L341">    		sizeStrategy = ValueSizeStrategy.getStrategyFor(maxRunLength);</span>
<span class="nc" id="L342">    	}</span>
    	
    	public int computeEncodingSize() {
    		//each qual value is 1 byte 
            
<span class="nc" id="L347">            int bytesPerLength = sizeStrategy.getNumberOfBytesPerValue();</span>
            //header is 4 bytes for length + 1 byte for guard + 1 byte for size strategy
<span class="nc" id="L349">			int header = 6;</span>
			//each guarded entry is sizeStrategy + qual value
<span class="nc" id="L351">			int sizeOfGuardedSections = numGuards *(bytesPerLength +1);</span>
			//each singleton is a qual value
<span class="nc" id="L353">			int sizeOfSingletons = singletons;</span>
			//each non-singleton is sizeStrategy + qual value + guard
<span class="nc" id="L355">			int sizeOfNonSingletons = nonSingletons * (bytesPerLength + 2);</span>
<span class="nc" id="L356">			return header+sizeOfGuardedSections+ sizeOfSingletons+sizeOfNonSingletons;</span>
        }

		public final ValueSizeStrategy getSizeStrategy() {
<span class="nc" id="L360">			return sizeStrategy;</span>
		}
    	
    	
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>