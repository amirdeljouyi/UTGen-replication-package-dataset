<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CoverageMapFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.util</a> &gt; <span class="el_source">CoverageMapFactory.java</span></div><h1>CoverageMapFactory.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Jan 16, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.assembly.util;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import org.jcvi.jillion.assembly.AssembledRead;
import org.jcvi.jillion.assembly.AssemblyUtil;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.Rangeable;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.util.iter.IteratorUtil;
import org.jcvi.jillion.core.util.iter.StreamingIterator;

/**
 * {@code CoverageMapFactory} is a factory class
 * that is able to build various kinds of
 * {@link CoverageMap}s.
 * 
 * @author dkatzel
 *
 */
final class CoverageMapFactory {

	/**
	 * Create a new {@link CoverageMap} using the given
	 * {@link Rangeable}s.
	 * @param elements the elements to create a coverage map of.
	 * @return a new {@link CoverageMap}; never null.
	 * @param &lt;R&gt; The type of {@link Rangeable} used in this map.
	 */
    public static &lt;R extends Rangeable&gt; CoverageMap&lt;R&gt; 
            create(Collection&lt;R&gt; elements){
<span class="nc" id="L65">        return new Builder&lt;R&gt;(elements).build();</span>
    }
    /**
	 * Create a new {@link CoverageMap} using the given
	 * {@link Rangeable}s but limiting the max coverage
	 * in the map to {@code maxAllowedCoverage}.  
	 * @param elements the elements to create a coverage map of.
	 * @param maxAllowedCoverage Any
	 * elements that would cause the max coverage to exceed this threshold
	 * will be ignored.
	 * @return a new {@link CoverageMap}; never null.
	 * @param &lt;R&gt; The type of {@link Rangeable} used in this map.
	 */
    public static &lt;R extends Rangeable&gt; CoverageMap&lt;R&gt; 
            create(Collection&lt;R&gt; elements, int maxAllowedCoverage){
<span class="nc" id="L80">        return new Builder&lt;R&gt;(elements,maxAllowedCoverage).build();</span>
    }

    public static &lt;R extends AssembledRead&gt; CoverageMap&lt;R&gt; createUngappedCoverageMap(
            NucleotideSequence consensus, CoverageMap&lt;R&gt; gappedCoverageMap) {
<span class="nc" id="L85">        List&lt;CoverageRegion&lt;R&gt;&gt; ungappedCoverageRegions = new ArrayList&lt;CoverageRegion&lt;R&gt;&gt;();</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        for(CoverageRegion&lt;R&gt; gappedCoverageRegion : gappedCoverageMap){</span>
<span class="nc" id="L87">            Range gappedRange = gappedCoverageRegion.asRange();</span>
<span class="nc" id="L88">            Range ungappedRange = AssemblyUtil.toUngappedRange(consensus,gappedRange);</span>
<span class="nc" id="L89">            List&lt;R&gt; reads = new ArrayList&lt;R&gt;(gappedCoverageRegion.getCoverageDepth());</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">            for(R read : gappedCoverageRegion){</span>
<span class="nc" id="L91">                reads.add(read);</span>
<span class="nc" id="L92">            }</span>
            
<span class="nc" id="L94">            ungappedCoverageRegions.add(</span>
<span class="nc" id="L95">                    new DefaultCoverageRegion.Builder&lt;R&gt;(ungappedRange.getBegin(),reads)</span>
<span class="nc" id="L96">                                .end(ungappedRange.getEnd())</span>
<span class="nc" id="L97">                                .build());</span>
<span class="nc" id="L98">        }</span>
        
<span class="nc" id="L100">        return new CoverageMapImpl&lt;R&gt;(ungappedCoverageRegions);</span>
    }

    private static class RangeableStartComparator &lt;T extends Rangeable&gt; implements Comparator&lt;T&gt;,Serializable {       
        /**
         * 
         */
        private static final long serialVersionUID = -8517894363563047881L;

        @Override
        public int compare(T o1, T o2) {           
<span class="nc" id="L111">        	 long o1End= o1.asRange().getBegin();</span>
<span class="nc" id="L112">             long o2End = o2.asRange().getBegin();</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">             if(o1End ==o2End){</span>
<span class="nc" id="L114">             	return 0;</span>
             }
<span class="nc bnc" id="L116" title="All 2 branches missed.">             if(o1End &lt; o2End){</span>
<span class="nc" id="L117">             	return -1;</span>
             }
<span class="nc" id="L119">             return 1;</span>
        }

    }
    
    private static class RangeableEndComparator&lt;T extends Rangeable&gt; implements Comparator&lt;T&gt;, Serializable {       
        /**
         * 
         */
        private static final long serialVersionUID = 5135449151100427846L;

        @Override
        public int compare(T o1, T o2) {    
        	
<span class="nc" id="L133">            long o1End= o1.asRange().getEnd();</span>
<span class="nc" id="L134">            long o2End = o2.asRange().getEnd();</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">            if(o1End ==o2End){</span>
<span class="nc" id="L136">            	return 0;</span>
            }
<span class="nc bnc" id="L138" title="All 2 branches missed.">            if(o1End &lt; o2End){</span>
<span class="nc" id="L139">            	return -1;</span>
            }
<span class="nc" id="L141">            return 1;</span>
        }
            
    }
    
    private CoverageMapFactory(){}
    
    private static final class CoverageMapImpl&lt;V extends Rangeable&gt; implements CoverageMap&lt;V&gt;{
	    private final CoverageRegion&lt;V&gt;[] regions;
	    /**
	     * The avg coverage of this coverage map
	     * we will lazy load this value
	     * since it could be expensive to compute.
	     */
<span class="nc" id="L155">	    private Double avgCoverage =null;</span>
	    /**
	     * The min coverage of this coverage map
	     * we will lazy load this value
	     * since it could be expensive to compute.
	     */
<span class="nc" id="L161">	    private Integer minCoverage =null;</span>
	    /**
	     * The max coverage of this coverage map
	     * we will lazy load this value
	     * since it could be expensive to compute.
	     */
<span class="nc" id="L167">	    private Integer maxCoverage =null;</span>
	    /**
	     *
	     * Creates a new &lt;code&gt;CoverageMapImpl&lt;/code&gt;.
	     * @param amplicons A {@link Collection} of {@link Coordinated}s.
	     */
	    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L174">		private CoverageMapImpl(List&lt;CoverageRegion&lt;V&gt;&gt; regions){</span>
<span class="nc" id="L175">	        this.regions = regions.toArray(new CoverageRegion[regions.size()]);</span>
<span class="nc" id="L176">	    }</span>
	    @Override
	    public int getNumberOfRegions() {
<span class="nc" id="L179">	        return regions.length;</span>
	    }
	    @Override
	    public CoverageRegion&lt;V&gt; getRegion(int i) {	    	
<span class="nc" id="L183">	        return regions[i];</span>
	    }
	    
	    @Override
	    public synchronized double getAverageCoverage(){
<span class="nc bnc" id="L188" title="All 2 branches missed.">	        if(avgCoverage ==null){</span>
<span class="nc" id="L189">		    	computeMinMaxAndAvgCoverage();</span>
	        }
<span class="nc" id="L191">	        return avgCoverage;</span>
	    }
		public synchronized void computeMinMaxAndAvgCoverage() {
			
<span class="nc bnc" id="L195" title="All 2 branches missed.">			if(isEmpty()){</span>
<span class="nc" id="L196">				avgCoverage = 0D;</span>
<span class="nc" id="L197">				minCoverage = 0;</span>
<span class="nc" id="L198">				maxCoverage = 0;</span>
<span class="nc" id="L199">				return;</span>
			}
<span class="nc" id="L201">			long totalLength = 0L;</span>
<span class="nc" id="L202">			long totalCoverage =0L;</span>
			
<span class="nc" id="L204">			int minCoverage = Integer.MAX_VALUE;</span>
<span class="nc" id="L205">			int maxCoverage = Integer.MIN_VALUE;</span>
			
<span class="nc bnc" id="L207" title="All 2 branches missed.">			for(CoverageRegion&lt;?&gt; region : this){</span>
<span class="nc" id="L208">				long regionLength = region.asRange().getLength();</span>
<span class="nc" id="L209">				totalLength +=regionLength;</span>
<span class="nc" id="L210">				int coverageDepth = region.getCoverageDepth();</span>
<span class="nc" id="L211">				totalCoverage += coverageDepth * regionLength;</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">				if(coverageDepth &lt; minCoverage){</span>
<span class="nc" id="L213">					minCoverage = coverageDepth;</span>
				}
<span class="nc bnc" id="L215" title="All 2 branches missed.">				if(coverageDepth &gt; maxCoverage){</span>
<span class="nc" id="L216">					maxCoverage = coverageDepth;</span>
				}
<span class="nc" id="L218">			}</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">			if(totalLength==0L){</span>
<span class="nc" id="L220">				avgCoverage=0D;</span>
<span class="nc" id="L221">				minCoverage = 0;</span>
<span class="nc" id="L222">				maxCoverage = 0;</span>
			}else{
<span class="nc" id="L224">				avgCoverage = totalCoverage/(double)totalLength;</span>
<span class="nc" id="L225">				this.minCoverage = minCoverage;</span>
<span class="nc" id="L226">				this.maxCoverage = maxCoverage;</span>
			}
<span class="nc" id="L228">		}</span>
	  
	    
	    
	    @Override
		public synchronized int getMinCoverage() {
<span class="nc bnc" id="L234" title="All 2 branches missed.">	    	if(minCoverage ==null){</span>
<span class="nc" id="L235">		    	computeMinMaxAndAvgCoverage();</span>
	        }
<span class="nc" id="L237">			return minCoverage;</span>
		}
		@Override
		public synchronized int getMaxCoverage() {
<span class="nc bnc" id="L241" title="All 2 branches missed.">	    	if(maxCoverage ==null){</span>
<span class="nc" id="L242">		    	computeMinMaxAndAvgCoverage();</span>
	        }
<span class="nc" id="L244">			return maxCoverage;</span>
		}
		@Override
	    public boolean equals(Object obj) {
<span class="nc bnc" id="L248" title="All 2 branches missed.">	        if(this == obj){</span>
<span class="nc" id="L249">	            return true;</span>
	        }
<span class="nc bnc" id="L251" title="All 2 branches missed.">	        if(obj instanceof CoverageMap){</span>
<span class="nc" id="L252">	        	CoverageMap&lt;?&gt; other = (CoverageMap&lt;?&gt;) obj;</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">	            if(getNumberOfRegions() !=other.getNumberOfRegions()){</span>
<span class="nc" id="L254">	                return false;</span>
	            }
<span class="nc bnc" id="L256" title="All 2 branches missed.">	            for( int i=0; i&lt;getNumberOfRegions(); i++){</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">	                if(!getRegion(i).equals(other.getRegion(i))){</span>
<span class="nc" id="L258">	                    return false;</span>
	                }
	            }
<span class="nc" id="L261">	            return true;</span>
	        }
<span class="nc" id="L263">	       return false;</span>
	    }
	
	      public int hashCode(){
<span class="nc" id="L267">	          final int prime = 37;</span>
<span class="nc" id="L268">	          int ret = 17;</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">	          for(CoverageRegion&lt;V&gt; region : regions){</span>
<span class="nc" id="L270">	              ret = ret*prime + region.hashCode();</span>
	          }
<span class="nc" id="L272">	          return ret;</span>
	      }
	    
	    /* (non-Javadoc)
	     * @see java.lang.Object#toString()
	     */
	    @Override
	    public String toString() {
<span class="nc" id="L280">	        StringBuffer buf = new StringBuffer();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">	        for(CoverageRegion&lt;V&gt; region : regions){</span>
<span class="nc" id="L282">	            buf.append(region);</span>
<span class="nc" id="L283">	            buf.append('\n');</span>
	        }
<span class="nc" id="L285">	        return buf.toString();</span>
	    }
	    @Override
	    public List&lt;CoverageRegion&lt;V&gt;&gt; getRegionsWhichIntersect(Range range) {
<span class="nc bnc" id="L289" title="All 2 branches missed.">	    	if(range ==null){</span>
<span class="nc" id="L290">	    		throw new NullPointerException(&quot;range can not be null&quot;);</span>
	    	}
<span class="nc bnc" id="L292" title="All 4 branches missed.">	    	if(this.isEmpty() || range.isEmpty()){</span>
	    		//empty coverage map or
	    		//empty ranges never intersect anything
<span class="nc" id="L295">	    		return Collections.emptyList();</span>
	    	}	    	
<span class="nc bnc" id="L297" title="All 2 branches missed.">	    	if(regions[0].asRange().getBegin() &gt; range.getEnd()){</span>
	    		//region is entirely before coverage map
<span class="nc" id="L299">	    		return Collections.emptyList();</span>
	    	}
<span class="nc bnc" id="L301" title="All 2 branches missed.">	    	if(regions[regions.length-1].asRange().getEnd() &lt; range.getBegin()){</span>
	    		//region is entirely after coverage map
<span class="nc" id="L303">	    		return Collections.emptyList();</span>
	    	}
<span class="nc" id="L305">	    	CoverageRegion&lt;V&gt; fakeRegion = new DefaultCoverageRegion.Builder&lt;V&gt;(range.getBegin(), Collections.&lt;V&gt;emptyList())</span>
<span class="nc" id="L306">	    											.end(range.getEnd())</span>
<span class="nc" id="L307">	    											.build();</span>
	    	
<span class="nc" id="L309">	    	int beginIndex =Arrays.binarySearch(regions, fakeRegion, CoverageRegionComparators.BY_BEGIN);</span>
<span class="nc" id="L310">	    	int endIndex =Arrays.binarySearch(regions, fakeRegion, CoverageRegionComparators.BY_END);</span>
	    	
	    	
	    	//Arrays.binarySearch will return a negative
	    	//(index+1) if the key isn't found but the 
	    	//absolute value -1 is where the key 
	    	//WOULD be if it was in the array
	    	//which is good enough for our intersection
	    	//so we need to adjust the offset by either 1 if it's
	    	//the end index or 2
	    	//if its the beginIndex
	    	//to get
	    	//the flanking region to be included
	    	
<span class="nc bnc" id="L324" title="All 2 branches missed.">	    	int correctedBeginIndex = Math.max(0, beginIndex&lt;0? Math.abs(beginIndex) -2 : beginIndex);</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">	    	int correctedEndIndex = Math.min(regions.length -1, endIndex &lt;0? Math.abs(endIndex)-1  : endIndex);</span>
	    	
	    	
<span class="nc" id="L328">	    	int numberOfRegionsIntersected = correctedEndIndex-correctedBeginIndex +1;</span>
	    	
<span class="nc" id="L330">	    	List&lt;CoverageRegion&lt;V&gt;&gt; intersectedRegions = new ArrayList&lt;CoverageRegion&lt;V&gt;&gt;(numberOfRegionsIntersected);</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">	    	for(int i=correctedBeginIndex; i&lt;=correctedEndIndex; i++){</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">	    		if(i&lt; regions.length){</span>
<span class="nc" id="L333">	    			intersectedRegions.add(regions[i]);</span>
	    		}
	    	}
<span class="nc" id="L336">	    	return intersectedRegions;	    	</span>
	    }
	    @Override
	    public CoverageRegion&lt;V&gt; getRegionWhichCovers(long consensusIndex) {
<span class="nc" id="L340">	        Range range = Range.of(consensusIndex, consensusIndex);</span>
<span class="nc" id="L341">	        final List&lt;CoverageRegion&lt;V&gt;&gt; intersectedRegion = getRegionsWhichIntersect(range);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">	        if(intersectedRegion.isEmpty()){</span>
<span class="nc" id="L343">	            return null;</span>
	        }
<span class="nc" id="L345">	        return intersectedRegion.get(0);</span>
	    }
	    
	    @Override
	    public Iterator&lt;CoverageRegion&lt;V&gt;&gt; iterator() {
<span class="nc" id="L350">	        return Arrays.asList(regions).iterator();</span>
	    }
	
	   
	    /**
	    * {@inheritDoc}
	    */
	    @Override
	    public boolean isEmpty() {
<span class="nc bnc" id="L359" title="All 2 branches missed.">	        return regions.length==0;</span>
	    }

    }
    
    
<span class="nc" id="L365">    private static enum CoverageRegionComparators implements Comparator&lt;CoverageRegion&lt;?&gt;&gt;{</span>
		//Comparators can't use the Range Comparators 
    	//because those comparators use not only being and end
    	//coordinates but range length as well to determine 
    	//if comparator returns 0
<span class="nc" id="L370">    	BY_BEGIN(new Comparator&lt;Range&gt;(){</span>

			@Override
			public int compare(Range o1, Range o2) {
<span class="nc" id="L374">				long l1 =o1.getBegin();</span>
<span class="nc" id="L375">				long l2 =o2.getBegin();</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">				if(l1 ==l2){</span>
<span class="nc" id="L377">					return 0;</span>
				}
<span class="nc bnc" id="L379" title="All 2 branches missed.">				if(l1&lt; l2){</span>
<span class="nc" id="L380">					return -1;</span>
				}
<span class="nc" id="L382">				return 1;</span>
			}			
		}
		),
<span class="nc" id="L386">		BY_END(new Comparator&lt;Range&gt;(){</span>

			@Override
			public int compare(Range o1, Range o2) {
<span class="nc" id="L390">				long l1 =o1.getEnd();</span>
<span class="nc" id="L391">				long l2 =o2.getEnd();</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">				if(l1 ==l2){</span>
<span class="nc" id="L393">					return 0;</span>
				}
<span class="nc bnc" id="L395" title="All 2 branches missed.">				if(l1&lt; l2){</span>
<span class="nc" id="L396">					return -1;</span>
				}
<span class="nc" id="L398">				return 1;</span>
			}			
		})
    	;
    	private final Comparator&lt;Range&gt; rangeComparator;
    	
<span class="nc" id="L404">    	private CoverageRegionComparators(Comparator&lt;Range&gt; comparator){</span>
<span class="nc" id="L405">    		this.rangeComparator = comparator;</span>
<span class="nc" id="L406">    	}</span>
    	
    	@Override
		public int compare(CoverageRegion&lt;?&gt; o1, CoverageRegion&lt;?&gt; o2) {
<span class="nc" id="L410">			return rangeComparator.compare(o1.asRange(), o2.asRange());</span>
		}
    	
    	
    }
    
    private static  class Builder&lt;P extends Rangeable&gt; extends AbstractCoverageMapBuilder&lt;P&gt;{
<span class="nc" id="L417">        private final List&lt;P&gt; startCoordinateSortedList = new ArrayList&lt;P&gt;();</span>
<span class="nc" id="L418">        private final List&lt;P&gt; endCoordinateSortedList = new ArrayList&lt;P&gt;();</span>
        
        public Builder(Collection&lt;P&gt; elements, int maxAllowedCoverage){
<span class="nc" id="L421">            super(maxAllowedCoverage);</span>
<span class="nc" id="L422">            initialize(elements);</span>
<span class="nc" id="L423">        }</span>
<span class="nc" id="L424">        public Builder(Collection&lt;P&gt; elements) {</span>
<span class="nc" id="L425">            initialize(elements);</span>
            
<span class="nc" id="L427">        }</span>
        
       
        private final void initialize(Collection&lt;P&gt; collection){
<span class="nc" id="L431">        	initialize(IteratorUtil.createStreamingIterator(collection.iterator()));</span>
<span class="nc" id="L432">        }</span>
        private final void initialize(StreamingIterator&lt;P&gt; elements){
        	try{
<span class="nc bnc" id="L435" title="All 2 branches missed.">        		while(elements.hasNext()){</span>
<span class="nc" id="L436">        			P element = elements.next();</span>
<span class="nc" id="L437">        			startCoordinateSortedList.add(element);</span>
<span class="nc" id="L438">        			endCoordinateSortedList.add(element);</span>
<span class="nc" id="L439">        		}</span>
        	}finally{
<span class="nc" id="L441">        		IOUtil.closeAndIgnoreErrors(elements);</span>
        	}
<span class="nc" id="L443">            filterAmpliconsWithoutCoordinates(startCoordinateSortedList);</span>
<span class="nc" id="L444">            filterAmpliconsWithoutCoordinates(endCoordinateSortedList);</span>
<span class="nc" id="L445">            Collections.sort(startCoordinateSortedList,</span>
                    new RangeableStartComparator&lt;P&gt;());
<span class="nc" id="L447">            Collections.sort(endCoordinateSortedList, new RangeableEndComparator&lt;P&gt;());</span>
<span class="nc" id="L448">        }</span>
        /**
         * If there are no coordinates (start or end are null) then we remove them
         * so they don't mess up our computations.
         * 
         * @param amp
         */
        private void filterAmpliconsWithoutCoordinates(Collection&lt;P&gt; amp) {
<span class="nc bnc" id="L456" title="All 2 branches missed.">            for (Iterator&lt;P&gt; it = amp.iterator(); it.hasNext();) {</span>
<span class="nc" id="L457">                P entry = it.next();</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                if (entry.asRange().getLength() == 0) {</span>
<span class="nc" id="L459">                    it.remove();</span>
                }
<span class="nc" id="L461">            }</span>
<span class="nc" id="L462">        }</span>
        @Override
        protected CoverageRegionBuilder&lt;P&gt; createNewCoverageRegionBuilder(
                Collection&lt;P&gt; elements, long start, Integer maxAllowedCoverage) {
<span class="nc" id="L466">            return new DefaultCoverageRegion.Builder&lt;P&gt;(start, elements,maxAllowedCoverage);</span>
        }

        private List&lt;CoverageRegion&lt;P&gt;&gt; buildAllCoverageRegions(List&lt;CoverageRegionBuilder&lt;P&gt;&gt; coverageRegionBuilders) {
            
<span class="nc" id="L471">            List&lt;CoverageRegion&lt;P&gt;&gt; regions = new ArrayList&lt;CoverageRegion&lt;P&gt;&gt;(</span>
<span class="nc" id="L472">                    coverageRegionBuilders.size());</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">            for (CoverageRegionBuilder&lt;P&gt; builder : coverageRegionBuilders) {</span>
<span class="nc" id="L474">                regions.add(builder.build());</span>
<span class="nc" id="L475">            }</span>
<span class="nc" id="L476">            return regions;</span>
        }

        @Override
        protected CoverageMap&lt;P&gt; build(
                List&lt;CoverageRegionBuilder&lt;P&gt;&gt; coverageRegionBuilders) {
<span class="nc" id="L482">            return new CoverageMapImpl&lt;P&gt;(</span>
<span class="nc" id="L483">                    buildAllCoverageRegions(coverageRegionBuilders));</span>
        }

        @Override
        protected Iterator&lt;P&gt; createEnteringIterator() {
<span class="nc" id="L488">            return startCoordinateSortedList.iterator();</span>
        }

        @Override
        protected Iterator&lt;P&gt; createLeavingIterator() {
<span class="nc" id="L493">            return endCoordinateSortedList.iterator();</span>
        }
        
    }

  

}



</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>