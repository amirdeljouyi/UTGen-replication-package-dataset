<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultAssembledRead.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.internal.assembly</a> &gt; <span class="el_source">DefaultAssembledRead.java</span></div><h1>DefaultAssembledRead.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Sep 4, 2008
 *
 * @author dkatzel
 */
package org.jcvi.jillion.internal.assembly;

import java.util.Map;

import org.jcvi.jillion.assembly.AssembledRead;
import org.jcvi.jillion.assembly.AssembledReadBuilder;
import org.jcvi.jillion.assembly.ReadInfo;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequenceBuilder;
import org.jcvi.jillion.core.residue.nt.ReferenceMappedNucleotideSequence;


public final class DefaultAssembledRead implements AssembledRead {

    private final long start;
    private final byte directionOrdinal;
    private final ReferenceMappedNucleotideSequence sequence;
    private final String id;
    private final ReadInfo readInfo;
    
    public static AssembledReadBuilder&lt;AssembledRead&gt; createBuilder(NucleotideSequence reference, 
            String readId,NucleotideSequence validBases,
            int offset, Direction dir, Range clearRange,
            int ungappedFullLength){
<span class="nc" id="L53">        return new Builder(reference, readId, validBases, offset, dir, </span>
                clearRange, ungappedFullLength);
    }
    
    public static AssembledReadBuilder&lt;AssembledRead&gt; createBuilder(NucleotideSequence reference, 
            String readId,String validBases,
            int offset, Direction dir, Range clearRange,
            int ungappedFullLength){
<span class="nc" id="L61">    	 return createBuilder(reference, readId, new NucleotideSequenceBuilder(validBases).build(), offset, dir, </span>
                 clearRange, ungappedFullLength);
    }
    
<span class="nc" id="L65">    public DefaultAssembledRead(String id, ReferenceMappedNucleotideSequence sequence, long start, Direction sequenceDirection, int ungappedFullLength, Range validRange){</span>
<span class="nc" id="L66">       this.id = id;</span>
<span class="nc" id="L67">       this.sequence = sequence;</span>
<span class="nc" id="L68">        this.start= start;</span>
<span class="nc" id="L69">        this.directionOrdinal = (byte)sequenceDirection.ordinal();</span>
<span class="nc" id="L70">        this.readInfo = new ReadInfo(validRange, ungappedFullLength);</span>
<span class="nc" id="L71">    }</span>
    
    
    @Override
	public ReadInfo getReadInfo() {
<span class="nc" id="L76">		return readInfo;</span>
	}

	@Override
    public long getGappedLength() {
<span class="nc" id="L81">        return sequence.getLength();</span>
    }

    @Override
    public long getGappedStartOffset() {
<span class="nc" id="L86">        return start;</span>
    }
    
    
    @Override
	public String toString() {
<span class="nc" id="L92">		return &quot;DefaultPlacedRead [start=&quot; + start + &quot;, directionOrdinal=&quot;</span>
				+ directionOrdinal + &quot;, id=&quot; + id + &quot;]&quot;;
	}

	@Override
    public int hashCode() {
<span class="nc" id="L98">        final int prime = 31;</span>
<span class="nc" id="L99">        int result = 1;</span>
<span class="nc" id="L100">        result = prime * result + id.hashCode();</span>
<span class="nc" id="L101">        result = prime * result + sequence.hashCode();</span>
<span class="nc" id="L102">        result = prime * result + directionOrdinal;</span>
<span class="nc" id="L103">        result = prime * result + (int) (start ^ (start &gt;&gt;&gt; 32));</span>
<span class="nc" id="L104">        return result;</span>
    }
    /**
     * Two PlacedReads are equal if they have the same start value
     * and they have their reads are equal.
     */
    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L112" title="All 2 branches missed.">        if (this == obj){</span>
<span class="nc" id="L113">            return true;</span>
        }
<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (obj instanceof AssembledRead){           </span>
<span class="nc" id="L116">        	AssembledRead other = (AssembledRead) obj;</span>
<span class="nc bnc" id="L117" title="All 4 branches missed.">        	if(getId()==null &amp;&amp; other.getId() !=null){</span>
<span class="nc" id="L118">        		return false;</span>
        	}
<span class="nc bnc" id="L120" title="All 2 branches missed.">        	if(!getId().equals(other.getId())){</span>
<span class="nc" id="L121">        		return false;</span>
        	}
<span class="nc bnc" id="L123" title="All 4 branches missed.">        	if(getNucleotideSequence()==null &amp;&amp; other.getNucleotideSequence() !=null){</span>
<span class="nc" id="L124">        		return false;</span>
        	}
<span class="nc bnc" id="L126" title="All 2 branches missed.">        	if(other.getNucleotideSequence() ==null){</span>
<span class="nc" id="L127">        		return false;</span>
        	}
<span class="nc bnc" id="L129" title="All 2 branches missed.">        	if(!getNucleotideSequence().equals(other.getNucleotideSequence())){</span>
<span class="nc" id="L130">        		return false;</span>
        	}
        	
<span class="nc bnc" id="L133" title="All 2 branches missed.">            return start== other.getGappedStartOffset() </span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">            &amp;&amp; getDirection() == other.getDirection();</span>
        }
<span class="nc" id="L136">        return false;</span>
        
    }
    
    @Override
    public Direction getDirection() {
<span class="nc" id="L142">        return Direction.values()[directionOrdinal];</span>
    }
  
    @Override
    public long getGappedEndOffset() {
<span class="nc" id="L147">        return getGappedStartOffset()+getGappedLength()-1;</span>
    }

    public Map&lt;Integer, Nucleotide&gt; getDifferenceMap(){
<span class="nc" id="L151">       return getNucleotideSequence().getDifferenceMap();</span>
        
    }
    @Override
    public ReferenceMappedNucleotideSequence getNucleotideSequence() {
<span class="nc" id="L156">        return sequence;</span>
    }
    @Override
    public String getId() {
<span class="nc" id="L160">        return id;</span>
    }
    @Override
    public long toGappedValidRangeOffset(long referenceIndex) {
        
<span class="nc" id="L165">        long validRangeIndex= referenceIndex - getGappedStartOffset();</span>
<span class="nc" id="L166">        checkValidRange(validRangeIndex);</span>
<span class="nc" id="L167">        return validRangeIndex;</span>
    }
    @Override
    public long toReferenceOffset(long validRangeIndex) {
<span class="nc" id="L171">        checkValidRange(validRangeIndex);</span>
<span class="nc" id="L172">        return getGappedStartOffset() +validRangeIndex;</span>
    }
    private void checkValidRange(long validRangeIndex) {
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if(validRangeIndex &lt;0){</span>
<span class="nc" id="L176">            throw new IllegalArgumentException(&quot;reference index refers to index before valid range &quot; + validRangeIndex);</span>
        }
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if(validRangeIndex &gt; getGappedLength()-1){</span>
<span class="nc" id="L179">            throw new IllegalArgumentException(&quot;reference index refers to index after valid range&quot;);</span>
        }
<span class="nc" id="L181">    }</span>

    /**
    * {@inheritDoc}
    */
    @Override
    public Range asRange() {
<span class="nc" id="L188">        return getGappedContigRange();</span>
    }
    
    @Override
	public Range getGappedContigRange() {
<span class="nc" id="L193">		return Range.of(getGappedStartOffset(), getGappedEndOffset());</span>
	}

	private static class Builder implements AssembledReadBuilder&lt;AssembledRead&gt;{
        private final String readId;
        /**
         * Our original encoded sequence.  If we 
         * edit the basecalls, this will get set to null
         * and we use {@link #basesBuilder} instead.
         */
        private NucleotideSequence originalSequence;
        /**
         * Our edited sequence, only used if needed
         * since it takes up more memory.
         */
<span class="nc" id="L208">        private NucleotideSequenceBuilder basesBuilder=null;</span>
        private int offset;
        private Range clearRange;
        private NucleotideSequence reference;
        private final Direction dir;
        private int ungappedFullLength;
        
        
<span class="nc" id="L216">        private Builder( Builder copy){</span>
<span class="nc" id="L217">        	this.readId = copy.readId;</span>
<span class="nc" id="L218">            this.dir =copy.dir;</span>
<span class="nc" id="L219">            this.clearRange = copy.clearRange;</span>
<span class="nc" id="L220">            this.offset = copy.offset;</span>
<span class="nc" id="L221">            this.originalSequence = copy.originalSequence;</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">            this.basesBuilder =copy.basesBuilder==null? null: copy.basesBuilder.copy();</span>
<span class="nc" id="L223">            this.reference = copy.reference;</span>
<span class="nc" id="L224">            this.ungappedFullLength = copy.ungappedFullLength;</span>
<span class="nc" id="L225">        }</span>
        
        public Builder(NucleotideSequence reference, String readId, NucleotideSequence validBases,
                            int offset, Direction dir, Range clearRange,
<span class="nc" id="L229">                            int ungappedFullLength){</span>
<span class="nc" id="L230">            this.readId = readId;</span>
<span class="nc" id="L231">            this.dir =dir;</span>
<span class="nc" id="L232">            this.clearRange = clearRange;</span>
<span class="nc" id="L233">            this.offset = offset;</span>
<span class="nc" id="L234">            this.originalSequence = validBases;</span>
<span class="nc" id="L235">            this.basesBuilder =null;</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">            if(offset + validBases.getLength() &gt; reference.getLength()){</span>
<span class="nc" id="L237">                throw new IllegalArgumentException(</span>
<span class="nc" id="L238">                		String.format(&quot;read %s , last offset %d goes beyond the reference (length %d)&quot;,</span>
<span class="nc" id="L239">                				readId, offset + validBases.getLength(), reference.getLength()));</span>
            }
<span class="nc bnc" id="L241" title="All 2 branches missed.">            if(offset &lt;0){</span>
<span class="nc" id="L242">                throw new IllegalArgumentException(&quot;read goes before the reference&quot;);</span>
            }
<span class="nc bnc" id="L244" title="All 2 branches missed.">            if(ungappedFullLength &lt; clearRange.getEnd()){</span>
<span class="nc" id="L245">            	throw new IllegalArgumentException(&quot;clear range extends beyond ungapped full length&quot;);</span>
            }
<span class="nc" id="L247">            this.reference = reference;</span>
<span class="nc" id="L248">            this.ungappedFullLength = ungappedFullLength;</span>
<span class="nc" id="L249">        }</span>
        
        @Override
		public AssembledReadBuilder&lt;AssembledRead&gt; copy() {
<span class="nc" id="L253">			return new Builder(this);</span>
		}
        /**
        * {@inheritDoc}
        */
        @Override
        public Builder reference(NucleotideSequence reference, int newOffset){
<span class="nc bnc" id="L260" title="All 2 branches missed.">            if(reference ==null){</span>
<span class="nc" id="L261">                throw new NullPointerException(&quot;reference can not be null&quot;);</span>
            }
<span class="nc" id="L263">            this.reference = reference;</span>
<span class="nc" id="L264">            this.offset = newOffset;</span>
<span class="nc" id="L265">            return this;</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public long getBegin(){
<span class="nc" id="L272">            return offset;</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public String getId(){
<span class="nc" id="L279">            return readId;</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public Builder setStartOffset(int newOffset){
<span class="nc" id="L286">            this.offset = newOffset;</span>
<span class="nc" id="L287">            return this;</span>
        }
        
        /**
        * {@inheritDoc}
        */
        @Override
        public Builder shift(int numberOfBases){
<span class="nc" id="L295">            return setStartOffset(offset+numberOfBases);</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public Range getClearRange() {
<span class="nc" id="L302">            return clearRange;</span>
        }


        /**
        * {@inheritDoc}
        */
        @Override
        public Direction getDirection() {
<span class="nc" id="L311">            return dir;</span>
        }

        

        /**
        * {@inheritDoc}
        */
        @Override
        public int getUngappedFullLength() {
<span class="nc" id="L321">            return ungappedFullLength;</span>
        }


        /**
        * {@inheritDoc}
        */
        @Override
        public synchronized AssembledRead build(){
        	final NucleotideSequenceBuilder finalBuilder;
        
<span class="nc bnc" id="L332" title="All 2 branches missed.">        	if(originalSequence !=null){</span>
<span class="nc" id="L333">        		finalBuilder = new NucleotideSequenceBuilder(originalSequence);</span>
        	}else{
<span class="nc" id="L335">        		finalBuilder = basesBuilder;</span>
        	}
<span class="nc" id="L337">            ReferenceMappedNucleotideSequence updatedEncodedBasecalls = finalBuilder</span>
<span class="nc" id="L338">            																.setReferenceHint(reference, offset)</span>
<span class="nc" id="L339">            																.buildReferenceEncodedNucleotideSequence();</span>
<span class="nc" id="L340">            return new DefaultAssembledRead(readId, </span>
            		updatedEncodedBasecalls, 
            		offset, dir, 
            		ungappedFullLength,
            		clearRange);
        }

        /**
        * {@inheritDoc}
        */
         @Override
        public Builder reAbacus(Range gappedValidRangeToChange, NucleotideSequence newBasecalls){
        	
<span class="nc" id="L353">        	 NucleotideSequence newUngappedBasecalls = new NucleotideSequenceBuilder(newBasecalls)</span>
<span class="nc" id="L354">				.ungap()</span>
<span class="nc" id="L355">				.build();</span>
        	 
<span class="nc" id="L357">            NucleotideSequence oldUngappedBasecalls = getNucleotideSequenceBuilder()</span>
<span class="nc" id="L358">            										.copy()</span>
<span class="nc" id="L359">            										.trim(gappedValidRangeToChange)</span>
<span class="nc" id="L360">            										.ungap()</span>
<span class="nc" id="L361">            										.build();</span>
           
<span class="nc bnc" id="L363" title="All 2 branches missed.">            if(!oldUngappedBasecalls.equals(newUngappedBasecalls)){</span>
<span class="nc" id="L364">                throw new IllegalReAbacus(oldUngappedBasecalls,newUngappedBasecalls);</span>
            }
<span class="nc" id="L366">            basesBuilder.delete(gappedValidRangeToChange);</span>
<span class="nc" id="L367">            basesBuilder.insert((int)gappedValidRangeToChange.getBegin(), newBasecalls);</span>
<span class="nc" id="L368">            return this;</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public synchronized long getLength(){
<span class="nc bnc" id="L375" title="All 2 branches missed.">            if(basesBuilder !=null){</span>
<span class="nc" id="L376">                return basesBuilder.getLength();</span>
            }
<span class="nc" id="L378">            return originalSequence.getLength();</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public long getEnd(){
<span class="nc" id="L385">            return offset + getLength()-1;</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public Range asRange(){
<span class="nc" id="L392">            return Range.of(offset,getEnd());</span>
        }
        /**
        * {@inheritDoc}
        */
        @Override
        public synchronized NucleotideSequenceBuilder getNucleotideSequenceBuilder() {
<span class="nc bnc" id="L399" title="All 2 branches missed.">            if(basesBuilder==null){</span>
<span class="nc" id="L400">                this.basesBuilder = new NucleotideSequenceBuilder(originalSequence);</span>
<span class="nc" id="L401">                originalSequence=null;</span>
            }
<span class="nc" id="L403">            return basesBuilder;</span>
        }
        
        /**
        * {@inheritDoc}
        */
        @Override
        public synchronized NucleotideSequence getCurrentNucleotideSequence(){
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if(originalSequence !=null){</span>
<span class="nc" id="L412">                return originalSequence;</span>
            }
<span class="nc" id="L414">            return basesBuilder.build();</span>
        }
       

        @Override
		public Builder append(Nucleotide base) {
<span class="nc" id="L420">        	getNucleotideSequenceBuilder().append(base);</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        	if(base !=Nucleotide.Gap){</span>
<span class="nc" id="L422">        		expandValidRangeEnd(1);</span>
<span class="nc" id="L423">        		ungappedFullLength++;</span>
        	}
<span class="nc" id="L425">			return this;</span>
		}


		@Override
		public Builder append(Iterable&lt;Nucleotide&gt; sequence) {
<span class="nc" id="L431">			NucleotideSequenceBuilder validRangeBuilder =getNucleotideSequenceBuilder();</span>
			//have to get old and new length 
			//because we don't know how long iterable is
			//(there's no size method on iterable)
<span class="nc" id="L435">			long oldLength = validRangeBuilder.getUngappedLength();</span>
<span class="nc" id="L436">			validRangeBuilder.append(sequence);</span>
<span class="nc" id="L437">			long newLength = validRangeBuilder.getUngappedLength();</span>
<span class="nc" id="L438">			long numberUngappedBasesAdded = newLength-oldLength;</span>
			//expand valid range end by length of insert
<span class="nc" id="L440">			expandValidRangeEnd(numberUngappedBasesAdded);</span>
			//update ungapped full length accordingly
<span class="nc" id="L442">			ungappedFullLength+=numberUngappedBasesAdded;</span>
<span class="nc" id="L443">			return this;</span>
		}


		@Override
		public Builder append(String sequence) {
<span class="nc" id="L449">			return append(new NucleotideSequenceBuilder(sequence));</span>
		}


		@Override
		public Builder insert(int offset, String sequence) {
<span class="nc" id="L455">			return insert(offset, new NucleotideSequenceBuilder(sequence));</span>
		}


		@Override
		public AssembledReadBuilder&lt;AssembledRead&gt; trim(Range trimRange) {
<span class="nc" id="L461">			NucleotideSequence untrimmed = getCurrentNucleotideSequence();</span>
<span class="nc" id="L462">			int numLeft =untrimmed.getUngappedOffsetFor((int)trimRange.getBegin());</span>
<span class="nc" id="L463">			int numRight =(int)(untrimmed.getUngappedLength()-1  -untrimmed.getUngappedOffsetFor((int)trimRange.getEnd()));</span>
			
			
			//for now we are actually trimming the sequence
			//but future versions will only update
			//valid range when we start tracking
			//the full sequence...
<span class="nc" id="L470">			getNucleotideSequenceBuilder()</span>
<span class="nc" id="L471">				.trim(trimRange);</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">			if(dir == Direction.FORWARD){</span>
<span class="nc" id="L473">				this.contractValidRangeBegin(numLeft);</span>
<span class="nc" id="L474">				this.contractValidRangeEnd(numRight);</span>
			}else{
<span class="nc" id="L476">				this.contractValidRangeBegin(numRight);</span>
<span class="nc" id="L477">				this.contractValidRangeEnd(numLeft);</span>
			}
			//shift this sequence the number of bases up
			//from its old start
<span class="nc" id="L481">			this.shift((int)trimRange.getBegin());</span>
<span class="nc" id="L482">			return this;</span>
		}

		@Override
		public Builder replace(int offset, Nucleotide replacement) {
			
<span class="nc" id="L488">			NucleotideSequenceBuilder sequenceBuilder = getNucleotideSequenceBuilder();</span>
<span class="nc" id="L489">			long oldLength = sequenceBuilder.getUngappedLength();</span>
<span class="nc" id="L490">			sequenceBuilder.replace(offset, replacement);</span>
<span class="nc" id="L491">			long newLength = sequenceBuilder.getUngappedLength();</span>
			//have to modify valid range
			//if number of gaps has changed
<span class="nc bnc" id="L494" title="All 2 branches missed.">			if(newLength &lt; oldLength){</span>
				//we replaced a nongap with a gap
<span class="nc" id="L496">				ungappedFullLength--;				</span>
<span class="nc" id="L497">				contractValidRangeEnd(1);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">			}else if(newLength &gt; oldLength){</span>
<span class="nc" id="L499">				ungappedFullLength++;</span>
<span class="nc" id="L500">				expandValidRangeEnd(1);</span>
			}
<span class="nc" id="L502">			return this;</span>
		}


		@Override
		public Builder delete(Range range) {
<span class="nc" id="L508">			NucleotideSequenceBuilder sequenceBuilder = getNucleotideSequenceBuilder();</span>
<span class="nc" id="L509">			long oldUngappedLength = sequenceBuilder.getUngappedLength();</span>
<span class="nc" id="L510">			sequenceBuilder.delete(range);</span>
<span class="nc" id="L511">			long newUngappedLength = sequenceBuilder.getUngappedLength();</span>
<span class="nc" id="L512">			long numberOfUngappedBasesDeleted = oldUngappedLength -newUngappedLength;</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">			if(numberOfUngappedBasesDeleted&gt;0){</span>
				//we only ever contract the end of the valid
				//range since the good part always starts
				//at the same place									
<span class="nc" id="L517">				contractValidRangeEnd(numberOfUngappedBasesDeleted);</span>
				//update ungapped full length accordingly
<span class="nc" id="L519">				ungappedFullLength-=numberOfUngappedBasesDeleted;</span>
			}
			
<span class="nc" id="L522">			return this;</span>
		}


		@Override
		public int getNumGaps() {
<span class="nc" id="L528">			return getNucleotideSequenceBuilder()</span>
<span class="nc" id="L529">					.getNumGaps();</span>
		}


		@Override
		public int getNumNs() {
<span class="nc" id="L535">			return getNucleotideSequenceBuilder()</span>
<span class="nc" id="L536">					.getNumNs();</span>
		}


		@Override
		public int getNumAmbiguities() {
<span class="nc" id="L542">			return getNucleotideSequenceBuilder()</span>
<span class="nc" id="L543">						.getNumAmbiguities();</span>
		}


		@Override
		public Builder prepend(String sequence) {
<span class="nc" id="L549">			return prepend(new NucleotideSequenceBuilder(sequence));</span>
		}


		@Override
		public Builder insert(int offset,
				Iterable&lt;Nucleotide&gt; sequence) {
<span class="nc" id="L556">			NucleotideSequenceBuilder validRangeBuilder =getNucleotideSequenceBuilder();</span>
			//have to get old and new length 
			//because we don't know how long iterable is
			//(there's no size method on iterable)
<span class="nc" id="L560">			long oldLength = validRangeBuilder.getUngappedLength();</span>
<span class="nc" id="L561">			validRangeBuilder.insert(offset, sequence);</span>
<span class="nc" id="L562">			long newLength = validRangeBuilder.getUngappedLength();</span>
<span class="nc" id="L563">			long numberOfNonGapsAdded = newLength-oldLength;</span>
			//expand valid range end by length of insert
<span class="nc" id="L565">			expandValidRangeEnd(numberOfNonGapsAdded);</span>
			
<span class="nc" id="L567">			ungappedFullLength+=numberOfNonGapsAdded;</span>
<span class="nc" id="L568">			return this;</span>
		}


		@Override
		public Builder insert(int offset, Nucleotide base) {
<span class="nc" id="L574">			NucleotideSequenceBuilder validRangeBuilder =getNucleotideSequenceBuilder();</span>
<span class="nc" id="L575">			validRangeBuilder.insert(offset, base);</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">			if(base !=Nucleotide.Gap){</span>
				//expand valid range end by 1 to include added base
<span class="nc" id="L578">				expandValidRangeEnd(1);</span>
<span class="nc" id="L579">				ungappedFullLength++;</span>
			}
<span class="nc" id="L581">			return this;</span>
		}


		@Override
		public Builder prepend(Iterable&lt;Nucleotide&gt; sequence) {
<span class="nc" id="L587">			return insert(0, sequence);</span>
		}

		

		private Builder expandValidRangeEnd(long units) {
<span class="nc" id="L593">			Range updatedClearRange = new Range.Builder(clearRange)</span>
<span class="nc" id="L594">											.expandEnd(units)</span>
<span class="nc" id="L595">											.build();</span>
<span class="nc" id="L596">			clearRange =updatedClearRange;</span>
<span class="nc" id="L597">			return this;</span>
		}

		private Builder contractValidRangeBegin(long units) {
<span class="nc" id="L601">			Range updatedClearRange = new Range.Builder(clearRange)</span>
<span class="nc" id="L602">											.contractBegin(units)</span>
<span class="nc" id="L603">											.build();</span>
<span class="nc" id="L604">			clearRange =updatedClearRange;</span>
<span class="nc" id="L605">			return this;</span>
		}

		private Builder contractValidRangeEnd(long units) {
<span class="nc" id="L609">			Range updatedClearRange = new Range.Builder(clearRange)</span>
<span class="nc" id="L610">											.contractEnd(units)</span>
<span class="nc" id="L611">											.build();</span>
<span class="nc" id="L612">			clearRange =updatedClearRange;</span>
<span class="nc" id="L613">			return this;</span>
		}


        
        /**
        * {@inheritDoc}
        */
        @Override
        public int hashCode() {
<span class="nc" id="L623">            final int prime = 31;</span>
<span class="nc" id="L624">            int result = 1;           </span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">            result = prime * result</span>
<span class="nc" id="L626">                    + ((readId == null) ? 0 : readId.hashCode());</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">            result = prime * result</span>
<span class="nc" id="L628">                    + ((reference == null) ? 0 : reference.hashCode());</span>
<span class="nc" id="L629">            return result;</span>
        }


        /**
        * {@inheritDoc}
        */
        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L639">                return true;</span>
            }
<span class="nc bnc" id="L641" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L642">                return false;</span>
            }
<span class="nc bnc" id="L644" title="All 2 branches missed.">            if (!(obj instanceof Builder)) {</span>
<span class="nc" id="L645">                return false;</span>
            }
<span class="nc" id="L647">            Builder other = (Builder) obj;</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">            if (readId == null) {</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">                if (other.readId != null) {</span>
<span class="nc" id="L650">                    return false;</span>
                }
<span class="nc bnc" id="L652" title="All 2 branches missed.">            } else if (!readId.equals(other.readId)) {</span>
<span class="nc" id="L653">                return false;</span>
            }
<span class="nc bnc" id="L655" title="All 2 branches missed.">            if (reference == null) {</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">                if (other.reference != null) {</span>
<span class="nc" id="L657">                    return false;</span>
                }
<span class="nc bnc" id="L659" title="All 2 branches missed.">            } else if (!reference.equals(other.reference)) {</span>
<span class="nc" id="L660">                return false;</span>
            }
<span class="nc" id="L662">            return true;</span>
        }


		
        
        
        
    }

    protected static final class IllegalReAbacus extends IllegalArgumentException{

        private static final long serialVersionUID = -8272559886165301526L;

        public IllegalReAbacus(NucleotideSequence  oldUngappedBasecalls, NucleotideSequence newUngappedBasecalls){
<span class="nc" id="L677">            super(String.format(&quot;reAbacusing must retain same ungapped basecalls! '%s' vs '%s'&quot;, </span>
                   oldUngappedBasecalls,
                    newUngappedBasecalls
                    ));
<span class="nc" id="L681">        }</span>
    
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>