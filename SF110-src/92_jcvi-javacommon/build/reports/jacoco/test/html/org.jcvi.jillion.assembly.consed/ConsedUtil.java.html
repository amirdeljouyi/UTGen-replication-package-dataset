<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConsedUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.consed</a> &gt; <span class="el_source">ConsedUtil.java</span></div><h1>ConsedUtil.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Jan 7, 2010
 *
 * @author dkatzel
 */
package org.jcvi.jillion.assembly.consed;

import java.io.File;
import java.io.FileFilter;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map.Entry;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jcvi.jillion.assembly.AssemblyUtil;
import org.jcvi.jillion.assembly.consed.ace.AceAssembledReadBuilder;
import org.jcvi.jillion.assembly.consed.ace.AceContig;
import org.jcvi.jillion.assembly.consed.ace.AceContigBuilder;
import org.jcvi.jillion.assembly.consed.ace.ConsensusAceTag;
import org.jcvi.jillion.assembly.consed.ace.PhdInfo;
import org.jcvi.jillion.assembly.util.CoverageMap;
import org.jcvi.jillion.assembly.util.CoverageMapBuilder;
import org.jcvi.jillion.assembly.util.CoverageRegion;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.Range.CoordinateSystem;
import org.jcvi.jillion.core.Ranges;
import org.jcvi.jillion.core.io.FileUtil;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;

/**
 * This class contains utility scripts for
 * converting {@link AceContig} data into
 * data that can work with Consed.
 * @author dkatzel
 *
 *
 */
public final class ConsedUtil {
	
	
    /**
     * 
     */
    private static final String CONTIG_RENAME_TAG_TYPE = &quot;contigName&quot;;

    /**
     * Consed rename comment header which tells us what the contig SHOULD 
     * be named instead of the given ID.
     */
<span class="nc" id="L74">    private static final Pattern CONTIG_RENAME_PATTERN = Pattern.compile(&quot;U(\\w+)&quot;);</span>
    
<span class="nc" id="L76">    private static final Pattern CONSED_ACE_PATTERN = Pattern.compile(&quot;((.+?)\\.)?ace(\\.(\\d+))?$&quot;);</span>
    
<span class="nc" id="L78">    private static final Pattern CONSED_ACE_VERSION_PATTERN = Pattern.compile(&quot;((.+?)\\.)?ace\\.(\\d+)$&quot;);</span>
    
<span class="nc" id="L80">    private static final Pattern ACE_CONTIG_ID_PATTERN = Pattern.compile(&quot;(\\S+)_(\\d+)_\\d+&quot;);</span>
    
    private ConsedUtil(){
		//private constructor
	}
    /**
     * Convert a string of basecalls with '*' to 
     * represent gaps (which is what consed uses) with '-' instead. 
     * @param basecallsWithAceGaps a string of basecalls with the '*' to 
     * represent gaps.
     * @return a new string with all the '*' converted into '-'.
     * @see #convertContigGapstoAceGaps(String)
     */
    public static String convertAceGapsToContigGaps(String basecallsWithAceGaps) {
<span class="nc" id="L94">        return basecallsWithAceGaps.replace('*', '-');</span>
    }
    /**
     * Convert a string of basecalls with the conventional '-' to 
     * represent gaps with '*' which is what consed uses instead. 
     * @param basecallsWithAceGaps a string of basecalls with the conventional '-' to 
     * represent gaps.
     * @return a new string with all the '-' converted into '*'.
     * @see #convertAceGapsToContigGaps(String)
     */
    public static String convertContigGapstoAceGaps(String basecallsWithAceGaps) {
<span class="nc" id="L105">        return basecallsWithAceGaps.replace('-', '*');</span>
    }
    public static PhdInfo generateDefaultPhdInfoFor(File traceFile, String readId,
			Date phdDate) {
		final String id;
<span class="nc bnc" id="L110" title="All 2 branches missed.">        if(traceFile ==null){</span>
<span class="nc" id="L111">        	id= readId;</span>
        }else{
<span class="nc" id="L113">            final String extension = FileUtil.getExtension(traceFile.getName());</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">            if(&quot;sff&quot;.equals(extension)){        </span>
<span class="nc" id="L115">                id=&quot;sff:&quot;+traceFile.getName()+&quot;:&quot;+readId;</span>
            }
<span class="nc bnc" id="L117" title="All 2 branches missed.">            else if(&quot;scf&quot;.equals(extension)){        </span>
<span class="nc" id="L118">                id=traceFile.getName();</span>
            }
            else{
<span class="nc" id="L121">                id= readId;</span>
            }
        }
<span class="nc" id="L124">        return new PhdInfo(id, readId+&quot;.phd.1&quot;, phdDate);</span>
	}
    /**
     * Split a contig which may contain zero coverage areas (0x)
     * into multiple contigs which all have at least some coverage at every
     * location.  If the given contig is split, the new contigs will be named
     * {@code &lt;original_id&gt;_&lt;ungapped reference 1-based start&gt;_&lt;ungapped reference 1-based end&gt;}
     * &lt;p/&gt;
     * Some Assemblers (mostly reference assemblers) create contigs with zero coverage
     * regions (0x) but that have the reference basecalls as the consensus in those 
     * areas. This method removes the parts of the contig which only have consensus. 
     * @param contigBuilder an {@link AceContig} that may have 0x regions.  Can not be null.
     * @param adjustIdCoordinates this contig id already has coordinates appended to the end
     * of the id, adjust these coordinates instead of appending new ones...
     * @return a {@link SortedMap} of (possibly new) AceContigs of the broken given contig.
     * The keys of the map are the Ranges into the original contig where these contigs
     * are placed and the values of the  map are the (possibly new) AceContigs.
     * If there are no 0x regions in the given contig, then a Map containing
     * one entry containing the Range covered and the reference of the given contig is returned.
     */
    public static SortedMap&lt;Range,AceContig&gt; split0xContig(AceContigBuilder contigBuilder, boolean adjustIdCoordinates){
<span class="nc" id="L145">        List&lt;Range&gt; coveredRegions = new ArrayList&lt;Range&gt;();</span>
<span class="nc" id="L146">        NucleotideSequence unSplitConsensus = contigBuilder.getConsensusBuilder().build();</span>
<span class="nc" id="L147">        CoverageMap&lt;AceAssembledReadBuilder&gt; coverageMap = new CoverageMapBuilder&lt;AceAssembledReadBuilder&gt;(contigBuilder.getAllAssembledReadBuilders())</span>
<span class="nc" id="L148">        															.build();</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        for(CoverageRegion&lt;AceAssembledReadBuilder&gt; region : coverageMap){</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">            if(region.getCoverageDepth()&gt;0){</span>
                
<span class="nc" id="L152">                final Range contigRange =region.asRange();</span>
<span class="nc" id="L153">                coveredRegions.add(contigRange);</span>
            }
<span class="nc" id="L155">        }</span>
        
<span class="nc" id="L157">        List&lt;Range&gt; contigRanges =Ranges.merge(coveredRegions);</span>
<span class="nc" id="L158">        SortedMap&lt;Range, AceContig&gt; map = new TreeMap&lt;Range, AceContig&gt;(Range.Comparators.ARRIVAL);</span>
        
<span class="nc" id="L160">        String originalContigId= contigBuilder.getContigId();</span>
<span class="nc" id="L161">        int oldStart=1;</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if(adjustIdCoordinates){</span>
<span class="nc" id="L163">            Matcher matcher = ACE_CONTIG_ID_PATTERN.matcher(originalContigId);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">            if(matcher.matches()){</span>
<span class="nc" id="L165">                originalContigId = matcher.group(1);</span>
<span class="nc" id="L166">                oldStart=Integer.parseInt(matcher.group(2));</span>
            }
        }
        
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if(contigRanges.size()==1){</span>
            //contig in 1 piece        	
<span class="nc" id="L172">        	Range gappedContigRange = contigRanges.get(0);</span>
<span class="nc" id="L173">			Range ungappedContigRange = AssemblyUtil.toUngappedRange(unSplitConsensus, gappedContigRange);</span>
        	//we might still have 0x regions at the edges so check
        	//to see if we're full (ungapped) size
<span class="nc bnc" id="L176" title="All 2 branches missed.">        	if(ungappedContigRange.getLength() &lt;unSplitConsensus.getUngappedLength()){</span>
<span class="nc" id="L177">        		String newContigId = computeSplitContigId(unSplitConsensus, originalContigId, oldStart, gappedContigRange);</span>
<span class="nc" id="L178">            	contigBuilder.setContigId(newContigId);</span>
        	}
<span class="nc" id="L180">        	map.put(gappedContigRange, contigBuilder.build());</span>
<span class="nc" id="L181">            return map;</span>
        }
<span class="nc bnc" id="L183" title="All 2 branches missed.">        for(Entry&lt;Range, AceContigBuilder&gt; splitContigEntry: contigBuilder.split(contigRanges).entrySet()){</span>
        	//id is now &lt;original_id&gt;_&lt;ungapped 1-based start&gt;_&lt;ungapped 1-based end&gt;
           
<span class="nc" id="L186">            AceContigBuilder splitContigBuilder = splitContigEntry.getValue();</span>
<span class="nc" id="L187">            Range contigRange = splitContigEntry.getKey();</span>
<span class="nc" id="L188">			String newContigId = computeSplitContigId(unSplitConsensus, originalContigId,</span>
    				oldStart, contigRange);
			
<span class="nc" id="L191">			splitContigBuilder.setContigId(newContigId);</span>
<span class="nc" id="L192">			map.put(contigRange, splitContigBuilder.build());</span>
<span class="nc" id="L193">        }</span>
        
<span class="nc" id="L195">        return map;</span>
    }
	private static String computeSplitContigId(NucleotideSequence consensus,
			String originalContigId, int oldStart, Range contigRange) {
<span class="nc" id="L199">		String contigId = String.format(&quot;%s_%d_%d&quot;,originalContigId, </span>
<span class="nc" id="L200">                oldStart + consensus.getUngappedOffsetFor((int) contigRange.getBegin()),</span>
<span class="nc" id="L201">                oldStart + consensus.getUngappedOffsetFor((int) contigRange.getEnd()));</span>
<span class="nc" id="L202">		return contigId;</span>
	}
    /**
     * Checks to see if the given {@link ConsensusAceTag} is denotes
     * that the contig has been renamed.
     * @param consensusTag the tag to check.
     * @return {@code true} if this tag denotes a contig rename; {@code false}
     * otherwise.
     * @throw {@link NullPointerException} if consensusTag is null.
     */
    public static boolean isContigRename(ConsensusAceTag consensusTag){
<span class="nc" id="L213">        return CONTIG_RENAME_TAG_TYPE.equals(consensusTag.getType());</span>
    }
    /**
     * Get the new name this contig should be named according to the given
     * rename tag.
     * @param contigRenameTag a {@link ConsensusAceTag} that denotes
     * the contig has been renamed.
     * @return the new name that the contig should be renamed to.
     * @throws NullPointerException if contigRenameTag is null.
     * @throws IllegalArgumentException if the given tag is not a contig rename
     * tag or if the tag text does not match the known pattern for 
     * contig renames.
     */
    public static String getRenamedContigId(ConsensusAceTag contigRenameTag){
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if(!isContigRename(contigRenameTag)){</span>
<span class="nc" id="L228">            throw new IllegalArgumentException(&quot;not a contig rename&quot;);</span>
        }
<span class="nc" id="L230">        String data= contigRenameTag.getData();</span>
<span class="nc" id="L231">        Matcher matcher = CONTIG_RENAME_PATTERN.matcher(data);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if(matcher.find()){</span>
<span class="nc" id="L233">            return matcher.group(1);</span>
        }
<span class="nc" id="L235">        throw new IllegalArgumentException(&quot;consensus tag does not contain rename info : &quot;+contigRenameTag);</span>
    }
    /**
     * Gets the latest ace file with the given prefix in the given edit_dir.
     * 
     *&lt;p/&gt;Consed labels each version of the ace file with a incrementing
     *value so {@code prefix.ace.2} is newer than {@code prefix.ace.1}.
     * @param editDir the consed edit_dir folder to inspect.
     * If this parameter is null, then this method will
     * return null.
     * @param filenamePrefix the beginning part of the file name to filter,
     * incase there are more than 1 groups of versioned assemblies.
     * @return the File object representing the latest version of the ace file
     * with the given prefix in the given edit_dir; {@code null}
     * if no such file exists or if editDir is also {@code null}.
     */
    public static File getLatestAceFile(File editDir, final String filenamePrefix){
    	//need to also check that it does not exist
<span class="nc bnc" id="L253" title="All 4 branches missed.">    	if(editDir==null || !editDir.exists()){</span>
<span class="nc" id="L254">    		return null;</span>
    	}
<span class="nc" id="L256">        int highestAceFileVersion=Integer.MIN_VALUE;</span>
<span class="nc" id="L257">        File highestAceFile=null;</span>
        try{
<span class="nc bnc" id="L259" title="All 2 branches missed.">        for(File file : editDir.listFiles(new FileFilter() {</span>
            
            @Override
            public boolean accept(File file) {
<span class="nc" id="L263">                String name = file.getName();</span>
<span class="nc bnc" id="L264" title="All 4 branches missed.">                return name.startsWith(filenamePrefix) &amp;&amp; CONSED_ACE_PATTERN.matcher(name).find();</span>
            }
        
     })){
           
<span class="nc" id="L269">            int version = getAceVersionFor(file);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            if(version &gt; highestAceFileVersion){</span>
<span class="nc" id="L271">                highestAceFileVersion=version;</span>
<span class="nc" id="L272">                highestAceFile = file;</span>
            }
        }
<span class="nc" id="L275">        return highestAceFile;</span>
<span class="nc" id="L276">        }catch(NullPointerException e){</span>
<span class="nc" id="L277">        	throw e;</span>
        }
    }
    public static File getPhdDirFor(File consedDir){
<span class="nc" id="L281">        verifyNotNull(consedDir);</span>
<span class="nc" id="L282">        return new File(consedDir,&quot;phd_dir&quot;);</span>
    }
	private static void verifyNotNull(File consedDir) {
<span class="nc bnc" id="L285" title="All 2 branches missed.">		if(consedDir==null){</span>
<span class="nc" id="L286">            throw new NullPointerException(&quot;consedDir can not be null&quot;);</span>
        }
<span class="nc" id="L288">	}</span>
    public static File getEditDirFor(File consedDir){
<span class="nc" id="L290">        verifyNotNull(consedDir);</span>
<span class="nc" id="L291">        return new File(consedDir,&quot;edit_dir&quot;);</span>
    }
    public static File getChromatDirFor(File consedDir){
<span class="nc" id="L294">        verifyNotNull(consedDir);</span>
<span class="nc" id="L295">        return new File(consedDir,&quot;chromat_dir&quot;);</span>
    }
    public static File getPhdBallDirFor(File consedDir){
<span class="nc" id="L298">        verifyNotNull(consedDir);</span>
<span class="nc" id="L299">        return new File(consedDir,&quot;phdball_dir&quot;);</span>
    }
    public static int getAceVersionFor(File consedAceFile){
<span class="nc" id="L302">        String name = consedAceFile.getName();</span>
<span class="nc" id="L303">        Matcher matcher = CONSED_ACE_VERSION_PATTERN.matcher(name);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if(!matcher.matches()){</span>
<span class="nc" id="L305">            throw new IllegalArgumentException(&quot;could not parse version from &quot;+ name);</span>
        }
<span class="nc" id="L307">        return Integer.parseInt(matcher.group(3));</span>
    }
    
    public static String generateNextAceVersionNameFor(File consedAceFile){
<span class="nc" id="L311">        String name = consedAceFile.getName();</span>
<span class="nc" id="L312">        Matcher matcher = CONSED_ACE_VERSION_PATTERN.matcher(name);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if(!matcher.matches()){</span>
<span class="nc" id="L314">            throw new IllegalArgumentException(&quot;could not parse version from &quot;+ name);</span>
        }
<span class="nc" id="L316">        String prefix = matcher.group(2);</span>
<span class="nc" id="L317">        int version= Integer.parseInt(matcher.group(3));</span>
        
<span class="nc bnc" id="L319" title="All 2 branches missed.">        return String.format(&quot;%sace.%d&quot;,</span>
                prefix==null?&quot;&quot;: prefix+&quot;.&quot;, 
<span class="nc" id="L321">                        version+1);</span>
    }
    
<span class="nc" id="L324">    public static enum ClipPointsType{</span>
<span class="nc" id="L325">    	VALID,</span>
<span class="nc" id="L326">    	NEGATIVE_VALID_RANGE,</span>
<span class="nc" id="L327">    	ALL_LOW_QUALITY,</span>
<span class="nc" id="L328">    	NO_HIGH_QUALITY_ALIGNMENT_INTERSECTION</span>
    	;
    	
    	public static ClipPointsType getType(int qualLeft, int qualRight,
				int alignLeft, int alignRight) {
<span class="nc bnc" id="L333" title="All 4 branches missed.">			if(qualLeft == -1 &amp;&amp; qualRight ==-1){</span>
<span class="nc" id="L334">				return ClipPointsType.ALL_LOW_QUALITY;</span>
	        }
<span class="nc bnc" id="L336" title="All 2 branches missed.">	        if((qualRight-qualLeft) &lt;0){</span>
	            //invalid converted ace file? 
<span class="nc" id="L338">	            return ClipPointsType.NEGATIVE_VALID_RANGE;</span>
	        }    
	        
	        //dkatzel 4/2011 - There have been cases when qual coords and align coords
	        //do not match; usually qual is a sub set of align
	        //but occasionally, qual goes beyond the align coords.
	        //I guess this happens in a referenced based alignment for
	        //reads at the edges when the reads have good quality 
	        //beyond the reference.
	        //It might also be possible that the read has been 
	        //edited and that could have changed the coordinates.
	        //Therefore intersect the qual and align coords
	        //to find the region we are interested in
<span class="nc" id="L351">	        Range qualityRange = Range.of(CoordinateSystem.RESIDUE_BASED, qualLeft,qualRight);</span>
<span class="nc" id="L352">	        Range alignmentRange = Range.of(CoordinateSystem.RESIDUE_BASED, alignLeft,alignRight);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">	        if(qualityRange.intersects(alignmentRange)){</span>
<span class="nc" id="L354">	        	return ClipPointsType.VALID;</span>
	        }else{	        
	        	//no intersection! 
	        	//I've only seen this on really bad quality
	        	//////////////////////////////////////////////////////////
	        	//dkatzel - 2012-01-26
	        	//email response from David Gordon (author of consed)
	        	//regarding what to do if these ranges don't overlap
	        	//From David Gordon:
	        	//the first 2 numbers indicate the high quality segment
	        	//(roughly corresponding to that above quality 13).
	        	//The last 2 numbers indicates the portion of the read aligned
	        	//to the consensus sequence.
	        	//
	        	//Hence there is a very short high quality segment 
	        	//634-649 (only 16 bases).  And the portion of the 
	        	//read aligned to the consensus is 851-1758 is very low quality.
	        	//
	        	//Consed treats these reads like any others.  
	        	//The &quot;dim&quot; menu on the Aligned Reads Window 
	        	//indicates what portion of the read to dim.  
	        	//If you set it on dim both low quality and unaligned, 
	        	//this entire read would be dimmed.
	        	/////////////////////////////////////////////////////////
	        	//dkatzel -therefore if consed dims the entire read
	        	//that's enough justification for me to throw the read out
<span class="nc" id="L380">	        	return ClipPointsType.NO_HIGH_QUALITY_ALIGNMENT_INTERSECTION;</span>
	        }
		}
    }
    
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>