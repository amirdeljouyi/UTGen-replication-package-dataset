<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FastqRecordWriterBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.trace.fastq</a> &gt; <span class="el_source">FastqRecordWriterBuilder.java</span></div><h1>FastqRecordWriterBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.trace.fastq;

import java.io.BufferedOutputStream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.charset.Charset;
import java.util.Iterator;

import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.util.Builder;
/**
 * {@code FastqRecordWriterBuilder}
 * is a {@link Builder} that 
 * builds an instance of {@link FastqRecordWriter}.
 * @author dkatzel
 *
 */
public final class FastqRecordWriterBuilder implements Builder&lt;FastqRecordWriter&gt;{
	
	private static final String CR = &quot;\n&quot;;
	private static final int ALL_ON_ONE_LINE =-1;
	
<span class="nc" id="L51">	private static final Charset DEFAULT_CHARSET = IOUtil.UTF_8;</span>
<span class="nc" id="L52">	private  static final FastqQualityCodec DEFAULT_CODEC = FastqQualityCodec.SANGER;</span>
	private final OutputStream out;
<span class="nc" id="L54">	private int numberOfBasesPerLine=ALL_ON_ONE_LINE;</span>
<span class="nc" id="L55">	private boolean writeIdOnQualityLine=false;</span>
<span class="nc" id="L56">	private FastqQualityCodec codec = DEFAULT_CODEC;</span>
<span class="nc" id="L57">	private Charset charSet = DEFAULT_CHARSET;</span>
	/**
	 * Create a new {@link FastqRecordWriterBuilder} that will use
	 * the given {@link OutputStream} to write
	 * out the fastq records.
	 * @param out the {@link OutputStream} to use;
	 * can not be null.
	 * @throws NullPointerException if out is null.
	 */
<span class="nc" id="L66">	public FastqRecordWriterBuilder(OutputStream out){</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">		if(out==null){</span>
<span class="nc" id="L68">			throw new NullPointerException(&quot;outputstream can not be null&quot;);</span>
		}
<span class="nc" id="L70">		this.out = out;</span>
<span class="nc" id="L71">	}</span>
	
	/**
	 * Create a new {@link FastqRecordWriterBuilder} that will use
	 * the given File to write
	 * out the fastq records.  Any contents
	 * that previously existed in this file
	 * will be overwritten.  If the path for the given
	 * File does not yet exist, then it will be created.
	 * @param outputFile the File to use;
	 * can not be null.
	 * @throws NullPointerException if outputFile is null.
	 * @throws IOException if there is a problem creating the new file. 
	 * or cannot be opened for any other reason.
	 */
<span class="nc" id="L86">	public FastqRecordWriterBuilder(File outputFile) throws IOException{</span>
<span class="nc" id="L87">		IOUtil.mkdirs(outputFile.getParentFile());</span>
<span class="nc" id="L88">		this.out =new BufferedOutputStream(new FileOutputStream(outputFile));</span>
<span class="nc" id="L89">	}</span>
	/**
	 * Change the {@link Charset} used
	 * to write out the fasta record.
	 * If this method is not called,
	 * then the CharSet will default to
	 * UTF-8.
	 * @param charset the {@link Charset} to use;
	 * can not be null.
	 * @return this.
	 * @throws NullPointerException if charset is null.
	 */
	public FastqRecordWriterBuilder charset(Charset charset){
<span class="nc bnc" id="L102" title="All 2 branches missed.">		if(charset ==null){</span>
<span class="nc" id="L103">			throw new NullPointerException(&quot;charset can not be null&quot;);</span>
		}
<span class="nc" id="L105">		this.charSet=charset;</span>
<span class="nc" id="L106">		return this;</span>
	}
	/**
	 * Change the method that quality values
	 * are encoded by providing a {@link FastqQualityCodec}
	 * implementation.  If this method is not called,
	 * this writer will default to {@link FastqQualityCodec#SANGER}.
	 * @param codec the {@link FastqQualityCodec} to use
	 * when writing out the encoded quality sequence;
	 * can not be null.
	 * @return this.
	 * Throws {@link NullPointerException} if codec is null.
	 */
	public FastqRecordWriterBuilder qualityCodec(FastqQualityCodec codec){
<span class="nc bnc" id="L120" title="All 2 branches missed.">		if(codec ==null){</span>
<span class="nc" id="L121">			throw new NullPointerException(&quot;codec can not be null&quot;);</span>
		}
<span class="nc" id="L123">		this.codec=codec;</span>
<span class="nc" id="L124">		return this;</span>
	}
	/**
	 * If this method is called
	 * then the id of the fastq records
	 * will be duplicated on the fastq quality deflines.
	 * This is not recommended since it will usually 
	 * add several megabytes to the file size and only
	 * contain duplicate data.  (The id of the record
	 * will also be on the nucleotide sequence defline).
	 * @return this.
	 */
	public FastqRecordWriterBuilder duplicateIdOnQualityDefLine(){
<span class="nc" id="L137">		this.writeIdOnQualityLine=true;</span>
<span class="nc" id="L138">		return this;</span>
	}
	/**
	 * Change the number of bases per line
	 * to write for each fastq record.
	 * If this method is not called,
	 * then then the each nucleotide and quality sequence will
	 * be written out on one line each.
	 * @param basesPerLine the basesPerLine to use
	 * must be &gt;=1.
	 * @return this.
	 * @throws IllegalArgumentException if basesPerLine &lt;1.
	 */
	public FastqRecordWriterBuilder basesPerLine(int basesPerLine){
<span class="nc bnc" id="L152" title="All 2 branches missed.">		if(basesPerLine&lt;1){</span>
<span class="nc" id="L153">			throw new IllegalArgumentException(&quot;number per line must be &gt;=1&quot;);</span>
		}
<span class="nc" id="L155">		numberOfBasesPerLine = basesPerLine;</span>
<span class="nc" id="L156">		return this;</span>
	}
	@Override
	public FastqRecordWriter build() {
<span class="nc" id="L160">		return new FastqRecordWriterImpl(out, charSet, </span>
				codec, writeIdOnQualityLine, numberOfBasesPerLine);
	}
	
	
	
	private static final class FastqRecordWriterImpl implements FastqRecordWriter{
		
		
		private final Writer writer;
		private final FastqQualityCodec codec;
		private final boolean writeIdOnQualityLine;
		private final int numberOfBasesPerLine;
		
		private FastqRecordWriterImpl(OutputStream out, Charset charset,
				FastqQualityCodec codec, boolean writeIdOnQualityLine,
<span class="nc" id="L176">				int numberOfBasesPerLine){</span>
			//wrap in OutputStream Writer to do char encodings
			//for us.  If we did String#getBytes(Charset) instead
			//for each write call that could put unwanted
			//char encoding headers in each record
			//which would be incorrect.  This way
			//the char encoding headers (if any) will
			//only appear at the beginning of the inputstream
<span class="nc" id="L184">			this.writer =  new BufferedWriter(new OutputStreamWriter(out,charset));</span>
<span class="nc" id="L185">			this.codec = codec;</span>
<span class="nc" id="L186">			this.writeIdOnQualityLine = writeIdOnQualityLine;</span>
<span class="nc" id="L187">			this.numberOfBasesPerLine = numberOfBasesPerLine;</span>
<span class="nc" id="L188">		}</span>
		
		
		@Override
		public void close() throws IOException {
			//just incase the implementation of
			//OutputStream is buffering we need to explicitly
			//call flush
<span class="nc" id="L196">			writer.flush();</span>
<span class="nc" id="L197">			writer.close();</span>
			
<span class="nc" id="L199">		}</span>
	
		@Override
		public void write(FastqRecord record) throws IOException {
<span class="nc" id="L203">			write(record.getId(), record.getNucleotideSequence(), record.getQualitySequence(), record.getComment());</span>
			
<span class="nc" id="L205">		}</span>
	
		@Override
		public void write(String id, NucleotideSequence nucleotides,
				QualitySequence qualities) throws IOException {
<span class="nc" id="L210">			write(id,nucleotides,qualities,null);</span>
			
<span class="nc" id="L212">		}</span>
	
		@Override
		public void write(String id, NucleotideSequence sequence,
				QualitySequence qualities, String optionalComment)
				throws IOException {
<span class="nc bnc" id="L218" title="All 2 branches missed.">			if(id ==null){</span>
<span class="nc" id="L219">				throw new NullPointerException(&quot;id can not be null&quot;);</span>
			}
<span class="nc bnc" id="L221" title="All 2 branches missed.">			if(sequence ==null){</span>
<span class="nc" id="L222">				throw new NullPointerException(&quot;nucleotide sequence can not be null&quot;);</span>
			}
<span class="nc bnc" id="L224" title="All 2 branches missed.">			if(qualities ==null){</span>
<span class="nc" id="L225">				throw new NullPointerException(&quot;quality sequence can not be null&quot;);</span>
			}
<span class="nc" id="L227">			long nucLength = sequence.getLength();</span>
<span class="nc" id="L228">			long qualLength = qualities.getLength();</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">			if(nucLength != qualLength){</span>
<span class="nc" id="L230">				throw new IllegalArgumentException(</span>
<span class="nc" id="L231">						String.format(&quot;nucleotide and quality sequences must be same length: %d vs %d&quot;,nucLength, qualLength));</span>
			}
<span class="nc" id="L233">			final String formattedString =toFormattedString(id, sequence, qualities, optionalComment);</span>
			
<span class="nc" id="L235">			writer.write(formattedString);</span>
	
<span class="nc" id="L237">		}</span>
	
		private CharSequence encodeNucleotides(NucleotideSequence sequence){
<span class="nc bnc" id="L240" title="All 2 branches missed.">			if(numberOfBasesPerLine==ALL_ON_ONE_LINE){</span>
<span class="nc" id="L241">				return sequence.toString();</span>
			}
			
<span class="nc" id="L244">			Iterator&lt;Nucleotide&gt; iter = sequence.iterator();</span>
<span class="nc" id="L245">			int numBases = (int)sequence.getLength();</span>
<span class="nc" id="L246">			int numberOfLines = numBases/numberOfBasesPerLine +1;</span>
<span class="nc" id="L247">			StringBuilder builder = new StringBuilder(numBases+numberOfLines);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">			if(iter.hasNext()){</span>
<span class="nc" id="L249">				builder.append(iter.next());</span>
			}
<span class="nc" id="L251">			int i=1;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">			while(iter.hasNext()){</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">				if(i%numberOfBasesPerLine==0){</span>
<span class="nc" id="L254">					builder.append(CR);</span>
				}
<span class="nc" id="L256">				builder.append(iter.next());</span>
<span class="nc" id="L257">				i++;</span>
			}
<span class="nc" id="L259">			return builder;</span>
		}
		private CharSequence encodeQualities(QualitySequence qualities){
<span class="nc" id="L262">			String encodedQualities = codec.encode(qualities);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">			if(numberOfBasesPerLine==ALL_ON_ONE_LINE){</span>
<span class="nc" id="L264">				return encodedQualities;</span>
			}
<span class="nc" id="L266">			int numberOfLines = encodedQualities.length()/numberOfBasesPerLine +1;</span>
<span class="nc" id="L267">			StringBuilder builder = new StringBuilder(encodedQualities.length()+numberOfLines);</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">			for(int i=0; i&lt;encodedQualities.length();i++){</span>
<span class="nc bnc" id="L269" title="All 4 branches missed.">				if(i&gt;0 &amp;&amp; i%numberOfBasesPerLine ==0){</span>
<span class="nc" id="L270">					builder.append(CR);</span>
				}
<span class="nc" id="L272">				builder.append(encodedQualities.charAt(i));</span>
			}
			
<span class="nc" id="L275">			return builder;</span>
		}
		private String toFormattedString(String id, NucleotideSequence sequence,
				QualitySequence qualities, String optionalComment) {
<span class="nc bnc" id="L279" title="All 2 branches missed.">			boolean hasComment = optionalComment != null;</span>
	
<span class="nc" id="L281">			StringBuilder builder = new StringBuilder(&quot;@&quot;).append(id);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">			if (hasComment) {</span>
<span class="nc" id="L283">				builder.append(' ').append(optionalComment);</span>
			}
<span class="nc" id="L285">			builder.append(CR).append(encodeNucleotides(sequence)).append(CR).append('+');</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">			if (writeIdOnQualityLine) {</span>
<span class="nc" id="L287">				builder.append(id);</span>
			}
<span class="nc" id="L289">			builder.append(CR).append(encodeQualities(qualities)).append(CR);</span>
<span class="nc" id="L290">			return builder.toString();</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>