<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractChurchillWatermanConsensusCaller.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.util.consensus</a> &gt; <span class="el_source">AbstractChurchillWatermanConsensusCaller.java</span></div><h1>AbstractChurchillWatermanConsensusCaller.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Jun 4, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.assembly.util.consensus;

import static org.jcvi.jillion.assembly.util.consensus.ConsensusUtil.BASES_TO_CONSIDER;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.jcvi.jillion.assembly.util.Slice;
import org.jcvi.jillion.assembly.util.SliceElement;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.residue.nt.Nucleotide;
/**
 * Calculate Consensus for a slice using Bayes formula and the procedure from
 * &lt;pre&gt;
 * Churchill, G.A. and Waterman, M.S.
 * &quot;The accuracy of DNA sequences: Estimating sequence quality.&quot;
 * Genomics 14, pp.89-98 (1992)
 * &lt;/pre&gt;
 * @author dkatzel
 *
 *
 */
abstract class AbstractChurchillWatermanConsensusCaller extends AbstractConsensusCaller{
    
   
   


    public AbstractChurchillWatermanConsensusCaller(
            PhredQuality highQualityThreshold) {
<span class="nc" id="L63">        super(highQualityThreshold);</span>
<span class="nc" id="L64">    }</span>
    
    /**
     * Get the consensus for the given Slice which
     * is guaranteed to have coverage.
     * @param normalizedConsensusProbabilities the {@link ConsensusProbabilities}
     * containing the probabilities of each non-ambiguous base
     * normalized to total 100%.
     * @param slice the {@link Slice} to compute the consensus of.
     * @return a {@link Nucleotide} that is the consensus of all the bases in this
     * slice; the return may be an ambiguous {@link Nucleotide}.
     */
    protected abstract Nucleotide getConsensus(ConsensusProbabilities normalizedConsensusProbabilities,Slice slice) ;
 
    
    @Override
    public final ConsensusResult callConsensusWithCoverage(Slice slice) {
<span class="nc" id="L81">        Map&lt;Nucleotide, Integer&gt; qualityValueSumMap = generateQualityValueSumMap(slice);</span>
<span class="nc" id="L82">        ConsensusProbabilities normalizedErrorProbabilityStruct = generateNormalizedProbabilityStruct(qualityValueSumMap);</span>
<span class="nc" id="L83">        Nucleotide consensus=  getConsensus(normalizedErrorProbabilityStruct,slice);</span>
<span class="nc" id="L84">        return new DefaultConsensusResult(consensus,</span>
                
<span class="nc" id="L86">                getErrorProbability(normalizedErrorProbabilityStruct,</span>
                        slice));
    }


    private int getErrorProbability(
            ConsensusProbabilities normalizedErrorProbabilityStruct,
            Slice slice) {
<span class="nc" id="L94">        double normalizedProbability= getProbabilityFor(normalizedErrorProbabilityStruct);</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if(normalizedProbability == 0.0D){</span>
            //special case if we only have matches, then sum slice qualities
<span class="nc" id="L97">            int sum =0;</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">            for(SliceElement element : slice){</span>
<span class="nc" id="L99">                sum += element.getQuality().getQualityScore();</span>
<span class="nc" id="L100">            }</span>
<span class="nc" id="L101">            return sum;</span>
        }
<span class="nc" id="L103">            return PhredQuality.computeQualityScore(normalizedProbability);</span>
    }

   
    
    private double getProbabilityFor(ConsensusProbabilities normalizedErrorProbabilityStruct){
        //find lowest
<span class="nc" id="L110">        Double lowest = Double.MAX_VALUE;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">        for(Entry&lt;Nucleotide, Double&gt; entry: normalizedErrorProbabilityStruct.entrySet()){</span>
<span class="nc" id="L112">            Double currentValue = entry.getValue();</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">            if(currentValue.compareTo(lowest) &lt;0){</span>
<span class="nc" id="L114">                lowest = currentValue;</span>
            }
<span class="nc" id="L116">        }</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if(lowest.equals(Double.MAX_VALUE)){</span>
            //no probabilities
<span class="nc" id="L119">            return 0D;</span>
        }
<span class="nc" id="L121">        return lowest;</span>
    }
    private ConsensusProbabilities generateNormalizedProbabilityStruct(
            Map&lt;Nucleotide, Integer&gt; qualityValueSumMap) {
<span class="nc" id="L125">        List&lt;ConsensusProbabilities&gt; probabilityStructs = createProbabilityStructsForEachBase(qualityValueSumMap);</span>
<span class="nc" id="L126">        ConsensusProbabilities rawErrorProbabilityStruct = createRawErrorProbabilityStruct(probabilityStructs);</span>
<span class="nc" id="L127">        return rawErrorProbabilityStruct.normalize();</span>
    }
    private ConsensusProbabilities createRawErrorProbabilityStruct(
            List&lt;ConsensusProbabilities&gt; probabilityStructs) {
<span class="nc" id="L131">        Map&lt;Nucleotide, Double&gt; rawErrorProbabilityMap = new EnumMap&lt;Nucleotide, Double&gt;(Nucleotide.class);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        for(Nucleotide base : ConsensusUtil.BASES_TO_CONSIDER){</span>
<span class="nc" id="L133">            rawErrorProbabilityMap.put(base, calculateRawErrorProbabilityFor(base, probabilityStructs));</span>
<span class="nc" id="L134">        }        </span>
<span class="nc" id="L135">        return new ConsensusProbabilities(rawErrorProbabilityMap);</span>
    }

    private List&lt;ConsensusProbabilities&gt; createProbabilityStructsForEachBase(
            Map&lt;Nucleotide, Integer&gt; qualityValueSumMap) {
<span class="nc" id="L140">        List&lt;ConsensusProbabilities&gt; probabilityStructs= new ArrayList&lt;ConsensusProbabilities&gt;();</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">        for(Nucleotide base : ConsensusUtil.BASES_TO_CONSIDER){</span>
<span class="nc" id="L142">            probabilityStructs.add(new ConsensusProbabilities(base, qualityValueSumMap.get(base)));</span>
<span class="nc" id="L143">        }</span>
               
<span class="nc" id="L145">        return probabilityStructs;</span>
    }

    private double calculateRawErrorProbabilityFor(Nucleotide base,
            List&lt;ConsensusProbabilities&gt; probabilityStructs) {
<span class="nc" id="L150">        double result = 1D;</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        for(ConsensusProbabilities struct : probabilityStructs){</span>
<span class="nc" id="L152">            result *=struct.getProbabilityFor(base);</span>
<span class="nc" id="L153">        }</span>
<span class="nc" id="L154">        return result;</span>
    }
   
    protected final Set&lt;Nucleotide&gt; getBasesUsedTowardsAmbiguity(
            ConsensusProbabilities normalizedErrorProbabilityStruct, int baseCount) {
        double errorProbabilityOfAmbiguity;
<span class="nc" id="L160">        double sumOfProbabilitySuccess=0D;</span>
<span class="nc" id="L161">        Set&lt;Nucleotide&gt; basesUsed = EnumSet.noneOf(Nucleotide.class);</span>
<span class="nc" id="L162">        List&lt;Nucleotide&gt; basesToConsider = new ArrayList&lt;Nucleotide&gt;(BASES_TO_CONSIDER);</span>
<span class="nc" id="L163">        Collections.sort(basesToConsider, new LowestProbabilityComparator(normalizedErrorProbabilityStruct));</span>
        do
        {
<span class="nc" id="L166">            Nucleotide baseWithLowestErrorProbability = basesToConsider.remove(0);</span>
<span class="nc" id="L167">            sumOfProbabilitySuccess += (1 - normalizedErrorProbabilityStruct.getProbabilityFor(</span>
                    baseWithLowestErrorProbability));
<span class="nc" id="L169">            basesUsed.add(baseWithLowestErrorProbability);</span>
<span class="nc" id="L170">            errorProbabilityOfAmbiguity = 1-sumOfProbabilitySuccess;</span>
<span class="nc bnc" id="L171" title="All 4 branches missed.">        }while( sumOfProbabilitySuccess &lt;1D &amp;&amp; underThreshold(errorProbabilityOfAmbiguity)</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">                &amp;&amp; basesUsed.size()&lt; baseCount );</span>
        
<span class="nc" id="L174">        return basesUsed;</span>
    }
    
    private boolean underThreshold(double errorProbability){
<span class="nc bnc" id="L178" title="All 2 branches missed.">        return PhredQuality.computeQualityScore(errorProbability) &lt; getHighQualityThreshold().getQualityScore();</span>
     }
    /**
     * Sorts {@link ConsensusProbabilities} by comparing the 
     * probability of the given {@link Nucleotide}.
     * @author dkatzel
     *
     *
     */
    private static class LowestProbabilityComparator implements Comparator&lt;Nucleotide&gt;{
        private final ConsensusProbabilities probabilityStruct;
<span class="nc" id="L189">        LowestProbabilityComparator(ConsensusProbabilities probabilityStruct){</span>
<span class="nc" id="L190">            this.probabilityStruct = probabilityStruct;</span>
<span class="nc" id="L191">        }</span>
        @Override
        public int compare(Nucleotide o1, Nucleotide o2) {
<span class="nc" id="L194">            return probabilityStruct.getProbabilityFor(o1).compareTo(probabilityStruct.getProbabilityFor(o2));</span>
        }
        
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>