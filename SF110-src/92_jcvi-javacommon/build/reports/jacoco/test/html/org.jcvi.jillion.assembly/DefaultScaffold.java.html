<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultScaffold.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly</a> &gt; <span class="el_source">DefaultScaffold.java</span></div><h1>DefaultScaffold.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Mar 24, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.assembly;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

import org.jcvi.jillion.assembly.util.CoverageMap;
import org.jcvi.jillion.assembly.util.CoverageMapBuilder;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.Ranges;
/**
 * {@code DefaultScaffold} is a {@link Scaffold}
 * implementation that stores all {@link PlacedContig}s
 * data internally in various {@link Map}s and {@link Set}s.
 * @author dkatzel
 *
 */
public final class DefaultScaffold  implements Scaffold{
	
	
	
    private final String id;
    private final SortedSet&lt;PlacedContig&gt; placedContigs;
    private final Map&lt;String, PlacedContig&gt; contigbyId;
    CoverageMap&lt;PlacedContig&gt; contigMap;
    private final long length;
    /**
     * Create a new {@link ScaffoldBuilder} instance.  
     * This instance will not yet have any contigs.
     * @param id the id of the Scaffold to be built.
     * This will be the value returned by {@link Scaffold#getId()}.
     * @return a new empty {@link ScaffoldBuilder}; never null.
     */
    public static ScaffoldBuilder createBuilder(String id){
<span class="nc" id="L69">		return new Builder(id);</span>
	}
<span class="nc" id="L71">    private  DefaultScaffold(String id, SortedSet&lt;PlacedContig&gt; placedContigs){</span>
<span class="nc" id="L72">        this.id = id;</span>
<span class="nc" id="L73">        this.placedContigs= placedContigs;</span>
<span class="nc" id="L74">        contigbyId = new HashMap&lt;String, PlacedContig&gt;();</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">        for(PlacedContig contig : placedContigs){</span>
<span class="nc" id="L76">            contigbyId.put(contig.getContigId(), contig);</span>
<span class="nc" id="L77">        }</span>
<span class="nc" id="L78">        List&lt;Range&gt; ranges = new ArrayList&lt;Range&gt;(placedContigs.size());</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">        for(PlacedContig contig : placedContigs){</span>
<span class="nc" id="L80">            ranges.add(Range.of(contig.getBegin(), contig.getEnd()));</span>
<span class="nc" id="L81">        }</span>
<span class="nc" id="L82">        length = Ranges.createInclusiveRange(ranges).getLength();</span>
<span class="nc" id="L83">        contigMap =new CoverageMapBuilder&lt;PlacedContig&gt;(placedContigs).build();</span>
<span class="nc" id="L84">    }</span>
    @Override
    public PlacedContig getPlacedContig(String id) {
<span class="nc" id="L87">        return contigbyId.get(id);</span>
    }

    @Override
    public Set&lt;PlacedContig&gt; getPlacedContigs() {
<span class="nc" id="L92">        return placedContigs;</span>
    }
    @Override
    public String getId() {
<span class="nc" id="L96">        return id;</span>
    }
    
    @Override
    public long getLength() {
<span class="nc" id="L101">        return length;</span>
    }
    @Override
    public int getNumberOfContigs() {
<span class="nc" id="L105">        return placedContigs.size();</span>
    }
    @Override
    public CoverageMap&lt;PlacedContig&gt; getContigCoverageMap() {
<span class="nc" id="L109">        return contigMap;</span>
    }
    /**
     * {@inheritDoc}
     */
     @Override
     public boolean hasContig(String contigId) {
<span class="nc" id="L116">         return contigbyId.containsKey(contigId);</span>
     }
    /**
     * Converts contig range coordinates into scaffold range coordinates
     * based on contig's scaffold location and orientation
     * @param placedContigId target scaffold contig
     * @param placedContigRange contig coordinate range to convert of scaffold coordinates
     * @return scaffold coordinates corresponding to input contig id/range values
     * @throws NoSuchElementException if scaffold does not contain target contig
     * @throws IllegalArgumentException if target contig is not oriented in the forward
     * or reverse direction or if the range to be converted is not a subrange of the scaffold's
     * placed contig
     */
    @Override
    public Range convertContigRangeToScaffoldRange(String placedContigId, Range placedContigRange){
<span class="nc" id="L131">        PlacedContig placedContig = getPlacedContig(placedContigId);</span>

        // make sure the source contig exists in the scaffold
<span class="nc bnc" id="L134" title="All 2 branches missed.">        if ( placedContig == null ) {</span>
<span class="nc" id="L135">            throw new NoSuchElementException(&quot;Scaffold &quot; + getId()</span>
                + &quot; does not contain the placed contig &quot; + placedContigId);
        }

        // make sure the specified range falls within the placed contig's range
<span class="nc" id="L140">        Range normalizedPlacedContigRange = Range.of(0,placedContig.getLength()-1);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">        if ( !placedContigRange.isSubRangeOf(normalizedPlacedContigRange) ) {</span>
<span class="nc" id="L142">            throw new IllegalArgumentException(&quot;Specified contig range &quot; + placedContigRange</span>
                + &quot; is not a subrange of its parent placed contig &quot; + placedContig
                + &quot;(normalized range &quot; + normalizedPlacedContigRange + &quot;)&quot;);
        }
        final Range.Builder rangeBuilder; 
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if ( placedContig.getDirection() == Direction.FORWARD ) {</span>
<span class="nc" id="L148">        	rangeBuilder= new Range.Builder(placedContigRange);</span>
        } else{
        	//contig is reversed
<span class="nc" id="L151">        	Range reverseComplementRange = AssemblyUtil.reverseComplementValidRange(placedContigRange, placedContig.getLength());</span>
<span class="nc" id="L152">			rangeBuilder= new Range.Builder(reverseComplementRange);</span>
        }
<span class="nc" id="L154">        rangeBuilder.shift(placedContig.getBegin());</span>
<span class="nc" id="L155">        return rangeBuilder.build();</span>
    }
    
    @Override
    public int hashCode() {
<span class="nc" id="L160">        final int prime = 31;</span>
<span class="nc" id="L161">        int result = 1;</span>
<span class="nc" id="L162">        result = prime * result</span>
<span class="nc" id="L163">                + contigbyId.hashCode();</span>
<span class="nc" id="L164">        result = prime * result + id.hashCode();</span>
<span class="nc" id="L165">        result = prime * result + (int) (length ^ (length &gt;&gt;&gt; 32));</span>
<span class="nc" id="L166">        result = prime * result</span>
<span class="nc" id="L167">                + placedContigs.hashCode();</span>
<span class="nc" id="L168">        return result;</span>
    }
    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (this == obj){</span>
<span class="nc" id="L173">            return true;</span>
        }
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (obj == null){</span>
<span class="nc" id="L176">            return false;</span>
        }
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if (!(obj instanceof DefaultScaffold)){</span>
<span class="nc" id="L179">            return false;</span>
        }
<span class="nc" id="L181">        DefaultScaffold other = (DefaultScaffold) obj;</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if(!contigbyId.equals(other.contigbyId)){</span>
<span class="nc" id="L183">            return false;</span>
        }
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (!id.equals(other.id)){</span>
<span class="nc" id="L186">            return false;</span>
        }
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (length != other.length){</span>
<span class="nc" id="L189">            return false;</span>
        }
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (!placedContigs.equals(other.placedContigs)){</span>
<span class="nc" id="L192">            return false;</span>
        }
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (!contigMap.equals(other.contigMap)){</span>
<span class="nc" id="L195">            return false;</span>
        }
<span class="nc" id="L197">        return true;</span>
    }
    private static final class PlacedContigComparator implements
		Comparator&lt;PlacedContig&gt; , Serializable{

		private static final long serialVersionUID = 101208868003843457L;

	@Override
	public int compare(PlacedContig o1, PlacedContig o2) {
<span class="nc" id="L206">		int rangeCmp = Range.Comparators.ARRIVAL.compare(o1.asRange(), o2.asRange());</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">		if(rangeCmp !=0){</span>
<span class="nc" id="L208">			return rangeCmp;</span>
		}
<span class="nc" id="L210">		return o1.getContigId().compareTo(o2.getContigId());</span>
	}
}

    private static final class Builder implements ScaffoldBuilder{
      
		private final String id;
        private SortedSet&lt;PlacedContig&gt; contigs;
<span class="nc" id="L218">        private boolean shiftContigs=false;</span>
<span class="nc" id="L219">        private boolean built=false;</span>
        
<span class="nc" id="L221">        private Builder(String id){</span>
<span class="nc" id="L222">            this.id =id;</span>
<span class="nc" id="L223">            contigs = new TreeSet&lt;PlacedContig&gt;( new PlacedContigComparator());</span>
<span class="nc" id="L224">        }</span>
        
        private synchronized void throwErrorIfBuilt(){
<span class="nc bnc" id="L227" title="All 2 branches missed.">        	if(built){</span>
<span class="nc" id="L228">        		throw new IllegalStateException(&quot;already built&quot;);</span>
        	}
<span class="nc" id="L230">        }</span>
        /**
		 * {@inheritDoc}
		 */
        @Override
		public synchronized Builder add(PlacedContig placedContig){
<span class="nc" id="L236">        	throwErrorIfBuilt();</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        	if(placedContig ==null){</span>
<span class="nc" id="L238">        		throw new NullPointerException(&quot;placed contig can not be null&quot;);</span>
        	}
<span class="nc" id="L240">            contigs.add(placedContig);</span>
<span class="nc" id="L241">            return this;</span>
        }
        /**
		 * {@inheritDoc}
		 */
        @Override
		public synchronized Builder add(String contigId, Range contigRange, Direction contigDirection){
<span class="nc" id="L248">           return add(new DefaultPlacedContig(contigId, contigRange,contigDirection));</span>
        }
        /**
		 * {@inheritDoc}
		 */
        @Override
		public synchronized Builder add(String contigId, Range contigRange){
<span class="nc" id="L255">            return add(contigId, contigRange, Direction.FORWARD);</span>
        }
        /**
		 * {@inheritDoc}
		 */
        @Override
		public synchronized ScaffoldBuilder shiftContigsToOrigin(boolean shiftContigs){
<span class="nc" id="L262">        	throwErrorIfBuilt();</span>
<span class="nc" id="L263">            this.shiftContigs = shiftContigs;</span>
<span class="nc" id="L264">            return this;</span>
        }
        /**
		 * {@inheritDoc}
		 */
        @Override
		public synchronized DefaultScaffold build(){
<span class="nc" id="L271">        	throwErrorIfBuilt();</span>
<span class="nc bnc" id="L272" title="All 4 branches missed.">            if(shiftContigs &amp;&amp; !contigs.isEmpty()){</span>
<span class="nc" id="L273">                SortedSet&lt;PlacedContig&gt; shiftedContigs = new TreeSet&lt;PlacedContig&gt;(new PlacedContigComparator());</span>
<span class="nc" id="L274">                PlacedContig firstContig = contigs.first();</span>
<span class="nc" id="L275">                long shiftOffset = -firstContig.getBegin();</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">                for(PlacedContig contig : contigs){</span>
<span class="nc" id="L277">                    shiftedContigs.add(</span>
<span class="nc" id="L278">                    		new DefaultPlacedContig(contig.getContigId(),</span>
<span class="nc" id="L279">                    				new Range.Builder(contig.getValidRange())</span>
<span class="nc" id="L280">                    							.shift(shiftOffset)</span>
<span class="nc" id="L281">                    							.build(),</span>
<span class="nc" id="L282">                    				contig.getDirection()));</span>
<span class="nc" id="L283">                }</span>
<span class="nc" id="L284">                contigs = shiftedContigs;</span>
            }
<span class="nc" id="L286">            built=true;</span>
<span class="nc" id="L287">            return new DefaultScaffold(id, contigs);</span>
        }
        
    }


    /**
    * {@inheritDoc}
    */
    @Override
    public Iterator&lt;String&gt; getContigIds() {
<span class="nc" id="L298">        return contigbyId.keySet().iterator();</span>
    }
    @Override
    public String toString() {
<span class="nc" id="L302">        StringBuilder builder2 = new StringBuilder(75);</span>
<span class="nc" id="L303">        builder2.append(&quot;DefaultScaffold [id=&quot;).append(id).append(&quot;, length=&quot;)</span>
<span class="nc" id="L304">                .append(length).append(&quot;, placedContigs=&quot;)</span>
<span class="nc" id="L305">                .append(placedContigs).append(']');</span>
<span class="nc" id="L306">        return builder2.toString();</span>
    }


   
   

   

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>