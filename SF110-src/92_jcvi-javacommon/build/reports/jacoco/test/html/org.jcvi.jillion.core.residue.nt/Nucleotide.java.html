<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Nucleotide.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core.residue.nt</a> &gt; <span class="el_source">Nucleotide.java</span></div><h1>Nucleotide.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Jan 14, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.core.residue.nt;

import java.util.Collection;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.jcvi.jillion.core.residue.Residue;
/**
 * {@code Nucleotide} is a {@link Residue}
 * implementation for DNA Nucleotides.
 * @author dkatzel
 *
 *
 */
<span class="nc" id="L43">public enum Nucleotide implements Residue {</span>
    //order is in ambiguity traversal order that is most efficient.
<span class="nc" id="L45">    Unknown(Character.valueOf('N')),</span>
<span class="nc" id="L46">    NotThymine(Character.valueOf('V')),</span>
<span class="nc" id="L47">    NotGuanine(Character.valueOf('H')),</span>
<span class="nc" id="L48">    NotCytosine(Character.valueOf('D')),</span>
<span class="nc" id="L49">    NotAdenine(Character.valueOf('B')),</span>
<span class="nc" id="L50">    Weak(Character.valueOf('W')),</span>
<span class="nc" id="L51">    Amino(Character.valueOf('M')),   </span>
<span class="nc" id="L52">    Purine(Character.valueOf('R')),</span>
<span class="nc" id="L53">    Strong(Character.valueOf('S')),  </span>
<span class="nc" id="L54">    Pyrimidine(Character.valueOf('Y')),   </span>
<span class="nc" id="L55">    Keto(Character.valueOf('K')),    </span>
<span class="nc" id="L56">    Gap(Character.valueOf('-')),</span>
<span class="nc" id="L57">    Adenine(Character.valueOf('A')),</span>
<span class="nc" id="L58">    Cytosine(Character.valueOf('C')),</span>
<span class="nc" id="L59">    Guanine(Character.valueOf('G')),</span>
<span class="nc" id="L60">    Thymine(Character.valueOf('T')),</span>
    
    ;

    private static final Map&lt;Nucleotide,Set&lt;Nucleotide&gt;&gt; AMBIGUITY_TO_CONSTIUENT;
    private static final Map&lt;Nucleotide,Set&lt;Nucleotide&gt;&gt; CONSTIUENT_TO_AMBIGUITY;
   
    static{
        
       
<span class="nc" id="L70">        AMBIGUITY_TO_CONSTIUENT = new EnumMap&lt;Nucleotide, Set&lt;Nucleotide&gt;&gt;(Nucleotide.class);</span>
       
<span class="nc" id="L72">        AMBIGUITY_TO_CONSTIUENT.put(Unknown, EnumSet.of(Adenine,Cytosine,Guanine,Thymine));</span>
<span class="nc" id="L73">        AMBIGUITY_TO_CONSTIUENT.put(NotThymine, EnumSet.of(Adenine,Cytosine,Guanine));</span>
<span class="nc" id="L74">        AMBIGUITY_TO_CONSTIUENT.put(NotGuanine, EnumSet.of(Adenine,Cytosine,Thymine));</span>
<span class="nc" id="L75">        AMBIGUITY_TO_CONSTIUENT.put(NotCytosine, EnumSet.of(Adenine,Guanine,Thymine));</span>
<span class="nc" id="L76">        AMBIGUITY_TO_CONSTIUENT.put(NotAdenine, EnumSet.of(Cytosine,Guanine,Thymine));</span>
        
<span class="nc" id="L78">        AMBIGUITY_TO_CONSTIUENT.put(Weak, EnumSet.of(Adenine,Thymine));</span>
<span class="nc" id="L79">        AMBIGUITY_TO_CONSTIUENT.put(Amino, EnumSet.of(Adenine,Cytosine));</span>
        
<span class="nc" id="L81">        AMBIGUITY_TO_CONSTIUENT.put(Purine, EnumSet.of(Adenine,Guanine));</span>
<span class="nc" id="L82">        AMBIGUITY_TO_CONSTIUENT.put(Strong, EnumSet.of(Cytosine,Guanine));</span>
        
<span class="nc" id="L84">        AMBIGUITY_TO_CONSTIUENT.put(Pyrimidine, EnumSet.of(Cytosine,Thymine));</span>
<span class="nc" id="L85">        AMBIGUITY_TO_CONSTIUENT.put(Keto, EnumSet.of(Guanine,Thymine));</span>
        
<span class="nc" id="L87">        AMBIGUITY_TO_CONSTIUENT.put(Adenine, EnumSet.of(Adenine));</span>
<span class="nc" id="L88">        AMBIGUITY_TO_CONSTIUENT.put(Cytosine, EnumSet.of(Cytosine));</span>
<span class="nc" id="L89">        AMBIGUITY_TO_CONSTIUENT.put(Guanine, EnumSet.of(Guanine));</span>
<span class="nc" id="L90">        AMBIGUITY_TO_CONSTIUENT.put(Thymine, EnumSet.of(Thymine));</span>

        
<span class="nc" id="L93">        CONSTIUENT_TO_AMBIGUITY = new EnumMap&lt;Nucleotide, Set&lt;Nucleotide&gt;&gt;(Nucleotide.class);</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">        for(Nucleotide n : EnumSet.of(Adenine,Cytosine,Guanine,Thymine)){</span>
<span class="nc" id="L95">            CONSTIUENT_TO_AMBIGUITY.put(n, EnumSet.noneOf(Nucleotide.class));</span>
<span class="nc" id="L96">        }</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">        for(Entry&lt;Nucleotide, Set&lt;Nucleotide&gt;&gt; entry : AMBIGUITY_TO_CONSTIUENT.entrySet()){</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">            for(Nucleotide n : entry.getValue()){</span>
<span class="nc" id="L99">                final Nucleotide toAdd = entry.getKey();</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">                if(toAdd != n){</span>
<span class="nc" id="L101">                    CONSTIUENT_TO_AMBIGUITY.get(n).add(toAdd);</span>
                }
<span class="nc" id="L103">            }</span>
<span class="nc" id="L104">        }</span>
<span class="nc" id="L105">    }</span>
    
  
    
    private final Character c;
    
<span class="nc" id="L111">    private Nucleotide(Character c){</span>
<span class="nc" id="L112">        this.c = c;</span>
<span class="nc" id="L113">    }</span>
    /**
     * Return the Character equivalent of this
     * {@link Nucleotide}.  For example
     * calling this method for {@link #Adenine}
     * will return 'A'.
     * @return the Character equivalent of this.
     */
    @Override
    public Character getCharacter() {
<span class="nc" id="L123">        return c;</span>
    }

    /**
     * Get the complement this {@link Nucleotide}.
     * @return the complement of this.
     */
    public Nucleotide complement() {
<span class="nc" id="L131">    	Nucleotide ret=null;</span>
<span class="nc bnc" id="L132" title="All 17 branches missed.">    	switch(this){</span>
<span class="nc" id="L133">    		case Unknown : ret = Unknown;</span>
<span class="nc" id="L134">							break;</span>
<span class="nc" id="L135">    		case NotThymine : ret = NotAdenine;</span>
<span class="nc" id="L136">    						break;</span>
<span class="nc" id="L137">    		case NotGuanine : ret = NotCytosine;</span>
<span class="nc" id="L138">    						break;</span>
<span class="nc" id="L139">    		case NotCytosine : ret = NotGuanine;</span>
<span class="nc" id="L140">								break;</span>
<span class="nc" id="L141">    		case NotAdenine : ret = NotThymine;</span>
<span class="nc" id="L142">							break; </span>
<span class="nc" id="L143">    		case Weak : ret = Weak;</span>
<span class="nc" id="L144">								break; 		</span>
<span class="nc" id="L145">    		case Amino : ret = Keto;</span>
<span class="nc" id="L146">							break; </span>
<span class="nc" id="L147">    		case Purine : ret = Pyrimidine;</span>
<span class="nc" id="L148">								break; </span>
<span class="nc" id="L149">    		case Strong : ret = Strong;</span>
<span class="nc" id="L150">							break; </span>
<span class="nc" id="L151">    		case Pyrimidine : ret = Purine;</span>
<span class="nc" id="L152">							break; </span>
<span class="nc" id="L153">    		case Keto : ret = Amino;</span>
<span class="nc" id="L154">							break; </span>
<span class="nc" id="L155">    		case Gap : ret = Gap;</span>
<span class="nc" id="L156">							break;				</span>
<span class="nc" id="L157">    		case Adenine : ret = Thymine;</span>
<span class="nc" id="L158">    						break;</span>
<span class="nc" id="L159">    		case Cytosine : ret = Guanine;</span>
<span class="nc" id="L160">								break;</span>
<span class="nc" id="L161">    		case Guanine : ret = Cytosine;</span>
<span class="nc" id="L162">								break;</span>
<span class="nc" id="L163">    		case Thymine : ret = Adenine;</span>
    						break;
    	}
<span class="nc" id="L166">       return ret;</span>
    }
    
    /**
     * Get the {@link Nucleotide} for the given
     * String  representation.  If the given String is more than
     * one character long, only the first character will be considered.
     * For example,
     * {@link #parse(String) parse(&quot;A&quot;)} will return
     * {@link #Adenine}. This method is able to parse both
     * '*' (consed) and '-' (TIGR) as gap characters. 
     * @param base the nucleotide as a String of length 1.
     * @return a {@link Nucleotide} equivalent.
     * @throws IllegalArgumentException if the given
     * character can not be mapped to a {@link Nucleotide}.
     */
    public static Nucleotide parse(String base){
<span class="nc" id="L183">        return parse(base.charAt(0));</span>
    }
    /**
     * Get the {@link Nucleotide} for the given
     * character representation.  For example,
     * {@link #parse(char) parse('A')} will return
     * {@link #Adenine}.  This method is able to parse both
     * '*' (consed) and '-' (TIGR) as gap characters. 
     * @param base the nucleotide as a character.
     * @return a {@link Nucleotide} equivalent.
     * @throws IllegalArgumentException if the given
     * character can not be mapped to a {@link Nucleotide}.
     */
    public static Nucleotide parse(char base){
        //dkatzel - 2013-03-21
    	//profiling indicated that parsing to Nucleotides was slow.
    	//changed auto-boxed Map lookup to switch statement.
    	//This switch includes all characters upper and lowercase
    	//that can be a Nucleotide 
    	//AND ALL CHARACTERS IN BETWEEN.
    	//This is an optimization to allow the 
    	//compiler to use a tableswitch opcode
    	//instead of the more general purpose
    	//lookupswitch opcode.
    	//tableswitch is an O(1) lookup
    	//while lookupswitch is O(n) where n
    	//is the number of case statements in the switch.
    	//tableswitch requires consecutive case values.
    	//DO NOT CHANGE THE ORDER OF THE CASE STATEMENTS
    	//the cases have to be in ascii order
    	//so the JVM can do offset arithmetic
    	//to jump immediately to the correct case
    	//for an O(1) lookup, changing the order
    	//might not allow that. 
    	//(not sure if compiler is smart enough to re-order)
    	//
    	//for more information:
    	//The book Beautiful Code Chapter 6
    	//or
    	//http://www.artima.com/underthehood/flowP.html
    	final Nucleotide ret;
<span class="nc bnc" id="L224" title="All 80 branches missed.">    	switch(base){</span>
    	//we support gap characters from both consed and TIGR
    	//so we need to start with special characters
<span class="nc" id="L227">    		case '*': ret = Gap;</span>
<span class="nc" id="L228">					break;</span>
<span class="nc" id="L229">    		case '+': ret = null;</span>
<span class="nc" id="L230">						break;</span>
<span class="nc" id="L231">    		case ',': ret = null;</span>
<span class="nc" id="L232">					break;</span>
<span class="nc" id="L233">    		case '-': ret = Gap;</span>
<span class="nc" id="L234">					break;		</span>
<span class="nc" id="L235">    		case '.': ret = null;</span>
<span class="nc" id="L236">						break;	</span>
<span class="nc" id="L237">    		case '/': ret = null;</span>
<span class="nc" id="L238">						break;	</span>
			//numbers
<span class="nc" id="L240">    		case '0': ret = null;</span>
<span class="nc" id="L241">						break;	</span>
<span class="nc" id="L242">    		case '1': ret = null;</span>
<span class="nc" id="L243">						break;</span>
<span class="nc" id="L244">    		case '2': ret = null;</span>
<span class="nc" id="L245">						break;</span>
<span class="nc" id="L246">    		case '3': ret = null;</span>
<span class="nc" id="L247">						break;</span>
<span class="nc" id="L248">    		case '4': ret = null;</span>
<span class="nc" id="L249">						break;</span>
<span class="nc" id="L250">    		case '5': ret = null;</span>
<span class="nc" id="L251">						break;</span>
<span class="nc" id="L252">    		case '6': ret = null;</span>
<span class="nc" id="L253">						break;</span>
<span class="nc" id="L254">    		case '7': ret = null;</span>
<span class="nc" id="L255">						break;</span>
<span class="nc" id="L256">    		case '8': ret = null;</span>
<span class="nc" id="L257">						break;</span>
<span class="nc" id="L258">    		case '9': ret = null;</span>
<span class="nc" id="L259">						break;</span>
<span class="nc" id="L260">    		case ':': ret = null;</span>
<span class="nc" id="L261">						break;</span>
<span class="nc" id="L262">    		case ';': ret = null;</span>
<span class="nc" id="L263">						break;</span>
<span class="nc" id="L264">    		case '&lt;': ret = null;</span>
<span class="nc" id="L265">						break;</span>
<span class="nc" id="L266">    		case '=': ret = null;</span>
<span class="nc" id="L267">						break;</span>
<span class="nc" id="L268">    		case '&gt;': ret = null;</span>
<span class="nc" id="L269">						break;</span>
<span class="nc" id="L270">    		case '?': ret = null;</span>
<span class="nc" id="L271">						break;</span>
			//uppercase letters
			case 'A':
<span class="nc" id="L274">				ret = Adenine;</span>
<span class="nc" id="L275">				break;</span>
			case 'B':
<span class="nc" id="L277">				ret = NotAdenine;</span>
<span class="nc" id="L278">				break;</span>
			case 'C':
<span class="nc" id="L280">				ret = Cytosine;</span>
<span class="nc" id="L281">				break;</span>
			case 'D':
<span class="nc" id="L283">				ret = NotCytosine;</span>
<span class="nc" id="L284">				break;</span>
			case 'E':
<span class="nc" id="L286">				ret = null;</span>
<span class="nc" id="L287">				break;</span>
			case 'F':
<span class="nc" id="L289">				ret = null;</span>
<span class="nc" id="L290">				break;</span>
			case 'G':
<span class="nc" id="L292">				ret = Guanine;</span>
<span class="nc" id="L293">				break;</span>
			case 'H':
<span class="nc" id="L295">				ret = NotGuanine;</span>
<span class="nc" id="L296">				break;</span>
			case 'I':
<span class="nc" id="L298">				ret = null;</span>
<span class="nc" id="L299">				break;</span>
			case 'J':
<span class="nc" id="L301">				ret = null;</span>
<span class="nc" id="L302">				break;</span>
			case 'K':
<span class="nc" id="L304">				ret = Keto;</span>
<span class="nc" id="L305">				break;</span>
			case 'L':
<span class="nc" id="L307">				ret = null;</span>
<span class="nc" id="L308">				break;</span>
			case 'M':
<span class="nc" id="L310">				ret = Amino;</span>
<span class="nc" id="L311">				break;</span>
			case 'N':
<span class="nc" id="L313">				ret = Unknown;</span>
<span class="nc" id="L314">				break;</span>
			case 'O':
<span class="nc" id="L316">				ret = null;</span>
<span class="nc" id="L317">				break;</span>
			case 'P':
<span class="nc" id="L319">				ret = null;</span>
<span class="nc" id="L320">				break;</span>
			case 'Q':
<span class="nc" id="L322">				ret = null;</span>
<span class="nc" id="L323">				break;</span>
			case 'R':
<span class="nc" id="L325">				ret = Purine;</span>
<span class="nc" id="L326">				break;</span>
			case 'S':
<span class="nc" id="L328">				ret = Strong;</span>
<span class="nc" id="L329">				break;</span>
			case 'T':
<span class="nc" id="L331">				ret = Thymine;</span>
<span class="nc" id="L332">				break;</span>
			case 'U':
<span class="nc" id="L334">				ret = null;</span>
<span class="nc" id="L335">				break;</span>
			case 'V':
<span class="nc" id="L337">				ret = NotThymine;</span>
<span class="nc" id="L338">				break;</span>
			case 'W':
<span class="nc" id="L340">				ret = Weak;</span>
<span class="nc" id="L341">				break;</span>
			case 'X':
<span class="nc" id="L343">				ret = Unknown;</span>
<span class="nc" id="L344">				break;</span>
			case 'Y':
<span class="nc" id="L346">				ret = Pyrimidine;</span>
<span class="nc" id="L347">				break;</span>
			case 'Z':
<span class="nc" id="L349">				ret = null;</span>
<span class="nc" id="L350">				break;</span>
			//have to include all special characters in between
			case '[':
<span class="nc" id="L353">				ret = null;</span>
<span class="nc" id="L354">				break;</span>
			case '\\':
<span class="nc" id="L356">				ret = null;</span>
<span class="nc" id="L357">				break;</span>
			case ']':
<span class="nc" id="L359">				ret = null;</span>
<span class="nc" id="L360">				break;</span>
			case '^':
<span class="nc" id="L362">				ret = null;</span>
<span class="nc" id="L363">				break;</span>
			case '_':
<span class="nc" id="L365">				ret = null;</span>
<span class="nc" id="L366">				break;</span>
			case '`':
<span class="nc" id="L368">				ret = null;</span>
<span class="nc" id="L369">				break;</span>
    	//lowercase
<span class="nc" id="L371">    		case 'a' : ret = Adenine;</span>
<span class="nc" id="L372">    					break;</span>
<span class="nc" id="L373">    		case 'b' : ret = NotAdenine;</span>
<span class="nc" id="L374">    					break;</span>
<span class="nc" id="L375">    		case 'c' : ret =Cytosine;</span>
<span class="nc" id="L376">    					break;</span>
<span class="nc" id="L377">    		case 'd' : ret = NotCytosine;</span>
<span class="nc" id="L378">    					break;</span>
<span class="nc" id="L379">    		case 'e' : ret = null;</span>
<span class="nc" id="L380">    					break;</span>
<span class="nc" id="L381">    		case 'f' : ret = null;</span>
<span class="nc" id="L382">						break;</span>
<span class="nc" id="L383">    		case 'g' : ret = Guanine;</span>
<span class="nc" id="L384">						break;	</span>
<span class="nc" id="L385">    		case 'h' : ret = NotGuanine;</span>
<span class="nc" id="L386">						break;</span>
<span class="nc" id="L387">    		case 'i' : ret = null;</span>
<span class="nc" id="L388">						break;</span>
<span class="nc" id="L389">    		case 'j' : ret = null;</span>
<span class="nc" id="L390">						break;	</span>
<span class="nc" id="L391">    		case 'k' : ret = Keto;</span>
<span class="nc" id="L392">						break;</span>
<span class="nc" id="L393">    		case 'l' : ret = null;</span>
<span class="nc" id="L394">						break;</span>
<span class="nc" id="L395">    		case 'm' : ret = Amino;</span>
<span class="nc" id="L396">						break;</span>
<span class="nc" id="L397">    		case 'n' : ret = Unknown;</span>
<span class="nc" id="L398">						break;</span>
<span class="nc" id="L399">    		case 'o' : ret = null;</span>
<span class="nc" id="L400">						break;</span>
<span class="nc" id="L401">    		case 'p' : ret = null;</span>
<span class="nc" id="L402">						break;</span>
<span class="nc" id="L403">    		case 'q' : ret = null;</span>
<span class="nc" id="L404">						break;</span>
<span class="nc" id="L405">    		case 'r' : ret = Purine;</span>
<span class="nc" id="L406">						break;</span>
<span class="nc" id="L407">    		case 's' : ret = Strong;</span>
<span class="nc" id="L408">						break;</span>
<span class="nc" id="L409">    		case 't' : ret = Thymine;</span>
<span class="nc" id="L410">						break;</span>
<span class="nc" id="L411">    		case 'u' : ret = null;</span>
<span class="nc" id="L412">						break;</span>
<span class="nc" id="L413">    		case 'v' : ret = NotThymine;</span>
<span class="nc" id="L414">						break;</span>
<span class="nc" id="L415">    		case 'w' : ret = Weak;</span>
<span class="nc" id="L416">						break;</span>
<span class="nc" id="L417">    		case 'x' : ret = Unknown;</span>
<span class="nc" id="L418">						break;</span>
<span class="nc" id="L419">    		case 'y' : ret = Pyrimidine;</span>
<span class="nc" id="L420">						break;</span>
<span class="nc" id="L421">			default : ret = null;</span>
						break;
			
    	}
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if(ret==null){</span>
<span class="nc" id="L426">        throw new IllegalArgumentException(&quot;invalid character &quot; + base + &quot; ascii value &quot; + (int)base);</span>
        }
<span class="nc" id="L428">        return ret;</span>
    }
    /**
     * Returns this Nucleotide as a single character String.  For example {@link #Adenine} 
     * will return &quot;A&quot;.
     */
    @Override
    public String toString() {
<span class="nc" id="L436">        return c.toString();</span>
    }
    /**
     * Is This Nucleotide a gap?
     * @return {@code true} if it is a gap;
     * {@code false} otherwise.
     */
    public boolean isGap(){
<span class="nc bnc" id="L444" title="All 2 branches missed.">        return this == Gap;</span>
    }
    /**
     * Is This Nucleotide an ambiguity?
     * @return {@code true} if it is am ambiguity;
     * {@code false} otherwise.
     */
    public boolean isAmbiguity(){
<span class="nc bnc" id="L452" title="All 10 branches missed.">        return !isGap() &amp;&amp; this !=Adenine  </span>
         &amp;&amp; this !=Cytosine &amp;&amp; this != Guanine &amp;&amp; this != Thymine;
    }
    
    @Override
	public byte getOrdinalAsByte() {
<span class="nc" id="L458">		return (byte)ordinal();</span>
	}
   
    
    
    /**
     * Get the Set containing all ambiguous {@link Nucleotide}s that
     * could be created from this
     * {@link Nucleotide} (plus others).
     * @return the Set of ambiguous {@link Nucleotide}s that
     * could be created from this or an empty set if
     * the given {@link Nucleotide} is already
     * an ambiguity. 
     */
    public Set&lt;Nucleotide&gt; getAllPossibleAmbiguities(){
        
<span class="nc bnc" id="L474" title="All 2 branches missed.">        if(CONSTIUENT_TO_AMBIGUITY.containsKey(this)){</span>
<span class="nc" id="L475">            return EnumSet.copyOf(CONSTIUENT_TO_AMBIGUITY.get(this));</span>
        }
<span class="nc" id="L477">        return EnumSet.noneOf(Nucleotide.class);</span>
    }
    /**
     * Give the ambiguity {@link Nucleotide} for
     * the corresponding collection of unambiguous {@link Nucleotide}s
     * 
     * @param unambiguiousBases collection of unambiguous {@link Nucleotide}s
     * to be turned into a single ambiguity.
     * @return the ambiguity {@link Nucleotide} or {@link #Gap}
     * if no ambiguity exists for all the given unambiguous bases.
     * @throws NullPointerException if unambiguiousBases is null.
     * @see #getBasesFor()
     */
    public static Nucleotide getAmbiguityFor(Collection&lt;Nucleotide&gt; unambiguiousBases){
<span class="nc bnc" id="L491" title="All 2 branches missed.">        if(unambiguiousBases ==null){</span>
<span class="nc" id="L492">            throw new NullPointerException(&quot;unambiguousBases can not be null&quot;);</span>
        }
<span class="nc bnc" id="L494" title="All 2 branches missed.">        for(Entry&lt;Nucleotide, Set&lt;Nucleotide&gt;&gt; entry : AMBIGUITY_TO_CONSTIUENT.entrySet()){</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">            if(unambiguiousBases.containsAll(entry.getValue())){</span>
<span class="nc" id="L496">                return entry.getKey();</span>
            }
<span class="nc" id="L498">        }</span>
<span class="nc" id="L499">        return Gap;        </span>
    }
    /**
     * Get the non-ambiguous bases that make up this
     * {@link Nucleotide}.
     * If this Nucleotide is ambiguous, then
     * the returned {@link Set} will contain
     * all the {@link Nucleotide}s
     * that make up this ambiguity.
     * Calling this method on a non-ambiguous
     * {@link Nucleotide} will return
     * a Set containing a single element, this.
     * For example calling this method
     * on
     * {@link Nucleotide#Purine}
     * will return a set containing
     * the two {@link Nucleotide}s
     * {@link Nucleotide#Adenine} and
     * {@link Nucleotide#Guanine}.
     * &lt;p/&gt;
     * This method mirrors {@link #getAmbiguityFor(Collection)}
     * such that the input of one of these methods should
     * be the return value of the other.
     * &lt;pre&gt; 
     * Nucleotide n = ...;
     * n == Nucleotide.getAmbiguityFor(n.getBasesFor());
     * &lt;/pre&gt; 
     * @return a {@link Set} of Nucleotides
     * will never be null or empty.
     */
    public Set&lt;Nucleotide&gt; getBasesFor(){
<span class="nc bnc" id="L530" title="All 2 branches missed.">    	if(this== Gap){</span>
<span class="nc" id="L531">    		return EnumSet.of(Gap);</span>
    	}
<span class="nc" id="L533">    	return AMBIGUITY_TO_CONSTIUENT.get(this);</span>
    }
    
    /**
     * Two {@link Nucleotide}s match if one of the {@link Nucleotide}'s
     * set of unambiguous bases
     * is a complete subset of the other.
     * For example, V (which is A,C or G) would
     * match A, C, G, M, R, S and N. However, V would not
     * match W since that could also represent a T.
     * @param other the other Nucleotide to match.
     * @return {@code true} if this Nucleotide matches the other given
     * {@link Nucleotide}; {@code false} otherwise.
     */
    public boolean matches(Nucleotide other){
<span class="nc bnc" id="L548" title="All 2 branches missed.">    	if(other ==null){</span>
<span class="nc" id="L549">    		throw new NullPointerException(&quot;other can not be null&quot;);</span>
    	}
<span class="nc bnc" id="L551" title="All 2 branches missed.">    	if(this==other){</span>
<span class="nc" id="L552">    		return true;</span>
    	}

<span class="nc" id="L555">    	Set&lt;Nucleotide&gt; basesForOther =other.getBasesFor();</span>
<span class="nc" id="L556">    	Set&lt;Nucleotide&gt; basesForThis =getBasesFor();</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">    	return basesForThis.containsAll(basesForOther)</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">    			|| basesForOther.containsAll(basesForThis);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>