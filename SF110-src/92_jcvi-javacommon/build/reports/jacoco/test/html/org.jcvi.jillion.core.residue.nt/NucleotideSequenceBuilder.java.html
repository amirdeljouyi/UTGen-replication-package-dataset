<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NucleotideSequenceBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core.residue.nt</a> &gt; <span class="el_source">NucleotideSequenceBuilder.java</span></div><h1>NucleotideSequenceBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.core.residue.nt;

import java.util.BitSet;
import java.util.Collections;
import java.util.Iterator;
import java.util.NoSuchElementException;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.residue.ResidueSequenceBuilder;

/**
 * {@code NucleotideSequenceBuilder}  is a way to
 * construct a {@link NucleotideSequence}
 * similar to how a {@link StringBuilder} can be used
 * to create a String.  The contents of the NucleotideSequence
 * can be changed by method calls.  This class
 * is not thread safe.
 * @author dkatzel
 *
 *
 */
public final class NucleotideSequenceBuilder implements ResidueSequenceBuilder&lt;Nucleotide,NucleotideSequence&gt;{
<span class="nc" id="L43">    private static final byte GAP_VALUE = Nucleotide.Gap.getOrdinalAsByte();</span>
<span class="nc" id="L44">    private static final byte N_VALUE = Nucleotide.Unknown.getOrdinalAsByte();</span>
<span class="nc" id="L45">    private static final byte A_VALUE = Nucleotide.Adenine.getOrdinalAsByte();</span>
<span class="nc" id="L46">    private static final byte C_VALUE = Nucleotide.Cytosine.getOrdinalAsByte();</span>
<span class="nc" id="L47">    private static final byte G_VALUE = Nucleotide.Guanine.getOrdinalAsByte();</span>
<span class="nc" id="L48">    private static final byte T_VALUE = Nucleotide.Thymine.getOrdinalAsByte();</span>
    /**
     * We store the current values of our sequence as bits in
     * a {@link BitSet}.  This allows us to put multiple nucleotides
     * inside a single byte.
     */
    private BitSet bits;
    /**
     * The CodecDecider will keep track of what types of
     * bases we have and how many in order to decide
     * the best codec to use when we
     * build our immutable NucleotideSequence
     * via  {@link #build()}.
     */
    private CodecDecider codecDecider;
    /**
     * Points to the next bit that will
     * be set if we append to our {@link BitSet}.
     * This also acts as the value of our length of bits written.
     * We need to keep track of this ourselves 
     * since {@link BitSet} automatically
     * grows and provides lots of padding to improve
     * I/O performance, and doesn't keep track
     * of the actual number of bits written so far.
     */
<span class="nc" id="L73">    private int tail=0;</span>
    /**
     * Currently we can store each base
     * in {@value} bits.
     */
    private static final int NUM_BITS_PER_VALUE=4;
    /**
     * Cache of the nucleotides in ordinal order
     * for quick lookups.
     */
<span class="nc" id="L83">    private static Nucleotide[] NUCLEOTIDE_VALUES = Nucleotide.values();</span>
    /**
     * Creates a new NucleotideSequenceBuilder instance
     * which currently contains no nucleotides.
     */
<span class="nc" id="L88">    public NucleotideSequenceBuilder(){</span>
<span class="nc" id="L89">        bits = new BitSet();</span>
<span class="nc" id="L90">        codecDecider = new CodecDecider();</span>
<span class="nc" id="L91">    }</span>
    /**
     * Creates a new NucleotideSequenceBuilder instance
     * which currently contains no nucleotides.
     * @param initialCapacity the initial capacity 
     * of the array backing the {@link NucleotideSequence}
     * (will be grown if sequence gets too large)
     * @throws IllegalArgumentException if initialCapacity &lt; 1.
     */
<span class="nc" id="L100">    public NucleotideSequenceBuilder(int initialCapacity){</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">        if(initialCapacity&lt;1){</span>
<span class="nc" id="L102">            throw new IllegalArgumentException(&quot;initial capacity must be &gt;=1&quot;);</span>
        }
<span class="nc" id="L104">        bits = new BitSet(initialCapacity*NUM_BITS_PER_VALUE);</span>
<span class="nc" id="L105">        codecDecider = new CodecDecider();</span>
<span class="nc" id="L106">    }</span>
    /**
     * Creates a new NucleotideSequenceBuilder instance
     * which currently contains the given sequence.
     * @param sequence the initial nucleotide sequence.
     * @throws NullPointerException if sequence is null.
     */
<span class="nc" id="L113">    public NucleotideSequenceBuilder(Iterable&lt;Nucleotide&gt; sequence){</span>
<span class="nc" id="L114">        assertNotNull(sequence);</span>
<span class="nc" id="L115">        NewValues newValues = new NewValues(sequence);</span>
<span class="nc" id="L116">        this.bits = newValues.getBits();</span>
<span class="nc" id="L117">        codecDecider = new CodecDecider(newValues);</span>
<span class="nc" id="L118">        this.tail = newValues.getLength()*NUM_BITS_PER_VALUE;</span>
<span class="nc" id="L119">    }</span>
    /**
     * Creates a new NucleotideSequenceBuilder instance
     * which currently contains the given sequence.
     *  Any whitespace in the input string will be ignored.
     *  This method is able to parse both
     * '*' (consed) and '-' (TIGR) as gap characters. 
     * @param sequence the initial nucleotide sequence.
     * @throws NullPointerException if sequence is null.
     * @throws IllegalArgumentException if any non-whitespace
     * in character in the sequence can not be converted
     * into a {@link Nucleotide}.
     */
<span class="nc" id="L132">    public NucleotideSequenceBuilder(String sequence){</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">    	if(sequence ==null){</span>
<span class="nc" id="L134">    		throw new NullPointerException(&quot;sequence can not be null&quot;);</span>
    	}
<span class="nc" id="L136">    	NewValues newValues = new NewValues(sequence);</span>
<span class="nc" id="L137">        this.bits = newValues.getBits();</span>
<span class="nc" id="L138">        codecDecider = new CodecDecider(newValues);</span>
<span class="nc" id="L139">        this.tail = newValues.getLength()*NUM_BITS_PER_VALUE;  </span>
<span class="nc" id="L140">    }</span>
    /**
     * Creates a new NucleotideSequenceBuilder instance
     * which currently contains the given single nucleotide.
     * @param singleNucleotide the initial nucleotide sequence.
     * @throws NullPointerException if singleNucleotide is null.
     */
<span class="nc" id="L147">    public NucleotideSequenceBuilder(Nucleotide singleNucleotide){</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">    	if(singleNucleotide ==null){</span>
<span class="nc" id="L149">    		throw new NullPointerException(&quot;singleNucleotide can not be null&quot;);</span>
    	}
<span class="nc" id="L151">    	NewValues newValues = new NewValues(singleNucleotide);</span>
<span class="nc" id="L152">        this.bits = newValues.getBits();</span>
<span class="nc" id="L153">        codecDecider = new CodecDecider(newValues);</span>
<span class="nc" id="L154">        this.tail = newValues.getLength()*NUM_BITS_PER_VALUE;  </span>
<span class="nc" id="L155">    }</span>

    
    
<span class="nc" id="L159">    private NucleotideSequenceBuilder(BitSet subBits, int numberOfBitsUsed) {</span>
<span class="nc" id="L160">    	NewValues newValues = new NewValues(subBits,numberOfBitsUsed);</span>
<span class="nc" id="L161">        this.bits = newValues.getBits();</span>
<span class="nc" id="L162">        this.codecDecider = new CodecDecider(newValues);</span>
<span class="nc" id="L163">        this.tail = numberOfBitsUsed;</span>
<span class="nc" id="L164">	}</span>
<span class="nc" id="L165">    private NucleotideSequenceBuilder(BitSet subBits, int numberOfBitsUsed, CodecDecider codecDecider) {</span>
<span class="nc" id="L166">    	NewValues newValues = new NewValues(subBits,numberOfBitsUsed);</span>
<span class="nc" id="L167">        this.bits = newValues.getBits();</span>
<span class="nc" id="L168">        this.codecDecider = codecDecider.copy();</span>
<span class="nc" id="L169">        this.tail = numberOfBitsUsed;</span>
<span class="nc" id="L170">	}</span>
	/**
     * Appends the given base to the end
     * of the builder's mutable sequence.
     * @param base a single nucleotide sequence to be appended
     * to the end our builder.
     * @throws NullPointerException if base is null.
     */
    public NucleotideSequenceBuilder append(Nucleotide base){
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if(base==null){</span>
<span class="nc" id="L180">            throw new NullPointerException(&quot;base can not be null&quot;);</span>
        }
<span class="nc" id="L182">        return append(Collections.singleton(base));</span>
    }
    /**
     * Appends the given sequence to the end
     * of the builder's mutable sequence.
     * @param sequence the nucleotide sequence to be appended
     * to the end our builder.
     * @throws NullPointerException if sequence is null.
     */
    public NucleotideSequenceBuilder append(Iterable&lt;Nucleotide&gt; sequence){
<span class="nc" id="L192">        assertNotNull(sequence);</span>
<span class="nc" id="L193">        NewValues newValues = new NewValues(sequence);</span>
<span class="nc" id="L194">        return append(newValues);</span>
    }
	private NucleotideSequenceBuilder append(NewValues newValues) {
<span class="nc" id="L197">		BitSet newBits = newValues.getBits();</span>
<span class="nc" id="L198">        int length = newBits.length();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">		for(int i=0; i&lt;length; i++){</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        	if(newBits.get(i)){</span>
<span class="nc" id="L201">        		bits.set(tail+i);</span>
        	}
        }
<span class="nc" id="L204">        tail += newValues.getLength()*NUM_BITS_PER_VALUE;</span>
<span class="nc" id="L205">        this.codecDecider.increment(newValues);</span>
<span class="nc" id="L206">        return this;</span>
	}
    
    /**
     * Appends the current contents of the given {@link NucleotideSequenceBuilder} to the end
     * of the builder's mutable sequence.  Any further modifications to the passed in builder
     * will not be reflected in this builder.  This is an equivalent but more efficient way operation
     * as {@code this.append(otherBuilder.build())}
     * 
     * @param otherBuilder the {@link NucleotideSequenceBuilder} whose current
     * nucleotides are to be appended.
     * @throws NullPointerException if otherBuilder is null.
     * @throws IllegalArgumentException if otherBuilder is not a NucleotideSequenceBuilder.
     */
    public NucleotideSequenceBuilder append(NucleotideSequenceBuilder otherBuilder){
        
<span class="nc" id="L222">    	assertNotNull(otherBuilder);    	</span>
<span class="nc" id="L223">    	NewValues newValues = new NewValues(otherBuilder.bits, otherBuilder.tail);</span>
<span class="nc" id="L224">        return append(newValues);</span>
    }
   
    
    /**
     * Appends the given sequence to the end
     * of the builder's mutable sequence.
     * Any whitespace in the input string will be ignored.
     *  This method is able to parse both
     * '*' (consed) and '-' (TIGR) as gap characters. 
     * @param sequence the nucleotide sequence to be appended
     * to the end our builder.
     * @throws NullPointerException if sequence is null.
     */
    public NucleotideSequenceBuilder append(String sequence){
<span class="nc bnc" id="L239" title="All 2 branches missed.">    	if(sequence ==null){</span>
<span class="nc" id="L240">    		throw new NullPointerException(&quot;sequence can not be null&quot;);</span>
    	}
<span class="nc" id="L242">        return append(new NewValues(sequence));</span>
    }
    /**
     * Inserts the given sequence to the builder's mutable sequence
     * starting at the given offset.  If any nucleotides existed
     * downstream of this offset before this insert method
     * was executed, then those nucleotides will be shifted by n
     * bases where n is the length of the given sequence to insert.
     * Any whitespace in the input string will be ignored.
     *  This method is able to parse both
     * '*' (consed) and '-' (TIGR) as gap characters. 
     * @param offset the GAPPED offset into this mutable sequence
     * to begin insertion.
     * @param sequence the nucleotide sequence to be 
     * inserted at the given offset.
     * @throws NullPointerException if sequence is null.
     * @throws IllegalArgumentException if offset is invalid.
     */
    public NucleotideSequenceBuilder insert(int offset, String sequence){
<span class="nc" id="L261">    	 assertInsertionParametersValid(offset, sequence);</span>
<span class="nc" id="L262">    	return insert(offset, new NewValues(sequence));</span>
    }
    private void assertNotNull(Object sequence) {
<span class="nc bnc" id="L265" title="All 2 branches missed.">        if(sequence ==null){</span>
<span class="nc" id="L266">            throw new NullPointerException(&quot;sequence can not be null&quot;);</span>
        }
<span class="nc" id="L268">    }</span>
    /**
     * Get the current length of the mutable
     * sequence. 
     * @return the current length
     * of the nucleotide sequence.
     */
    public long getLength(){
<span class="nc" id="L276">        return codecDecider.getCurrentLength();</span>
    }
    
    @Override
	public long getUngappedLength() {
<span class="nc" id="L281">		return codecDecider.getCurrentLength() - codecDecider.numberOfGaps;</span>
	}
    /**
     * Replace the Nucleotide at the given offset with a different nucleotide.
     * @param offset the gapped offset to modify.
     * @param replacement the new {@link Nucleotide} to replace the old
     * {@link Nucleotide} at that location.
     * @return this
     * @throws NullPointerException if replacement is null.
     * @throws IllegalArgumentException if offset is invalid.
     */
    public NucleotideSequenceBuilder replace(int offset, Nucleotide replacement){
<span class="nc" id="L293">    	int length = tail/NUM_BITS_PER_VALUE;</span>
<span class="nc bnc" id="L294" title="All 4 branches missed.">        if(offset &lt;0 || offset &gt;= length){</span>
<span class="nc" id="L295">            throw new IllegalArgumentException(</span>
<span class="nc" id="L296">                    String.format(&quot;offset %d out of range (length = %d)&quot;,length,offset));</span>
        }
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if(replacement ==null){</span>
<span class="nc" id="L299">            throw new NullPointerException(&quot;replacement base can not be null&quot;);</span>
        }
<span class="nc" id="L301">        return privateReplace(offset, replacement);</span>
    }
    /**
     * Method that actually performs the replace which assumes all
     * of the input values are valid.
     * @param offset
     * @param replacement
     * @return
     */
	private NucleotideSequenceBuilder privateReplace(int offset,
			Nucleotide replacement) {
<span class="nc" id="L312">		byte value = (byte)replacement.ordinal();</span>
<span class="nc" id="L313">        int bitStartOffset = offset*NUM_BITS_PER_VALUE;</span>
<span class="nc" id="L314">        int bitEndOffset = bitStartOffset+NUM_BITS_PER_VALUE;</span>
<span class="nc" id="L315">		BitSet subBits = bits.get(bitStartOffset, bitEndOffset);</span>
<span class="nc" id="L316">		final byte oldValue = getNucleotideOrdinalFor(subBits, 0);</span>
		
		
<span class="nc" id="L319">        codecDecider.replace(oldValue, value);</span>
<span class="nc" id="L320">        bits.clear(bitStartOffset, bitEndOffset);</span>
<span class="nc" id="L321">        NewValues newValues = new NewValues(replacement);</span>
<span class="nc" id="L322">        BitSet newBits = newValues.getBits();</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        for(int i=0; i&lt; NUM_BITS_PER_VALUE; i++){</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">        	 if(newBits.get(i)){</span>
<span class="nc" id="L325">             	bits.set(bitStartOffset+i);</span>
             }
        }      
<span class="nc" id="L328">        return this;</span>
	}
    /**
     * Deletes the nucleotides from the given range of this 
     * partially constructed NucleotideSequence.  If the given
     * range is empty, then the nucleotideSequence will not
     * be modified. If the range extends beyond the currently
     * built sequence, then this will delete until the end of
     * the sequence.
     * @param range the range to delete can not be null.
     * @return this.
     * @throws NullPointerException if range is null.
     * @throws IllegalArgumentException if range's start is negative
     * or greater than this nucleotide sequence's current length.
     */
    public NucleotideSequenceBuilder delete(Range range){
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if(range ==null){</span>
<span class="nc" id="L345">            throw new NullPointerException(&quot;range can not be null&quot;);</span>
        }
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if(!range.isEmpty()){</span>
<span class="nc" id="L348">            Range bitRange = convertBaseRangeIntoBitRange(range);</span>
<span class="nc" id="L349">            int numberOfDeletedBits = (int)bitRange.getLength();</span>
<span class="nc" id="L350">			BitSet subBits = bits.get((int)bitRange.getBegin(), (int)bitRange.getEnd()+1);</span>
<span class="nc" id="L351">			NewValues newValues = new NewValues(subBits, numberOfDeletedBits);</span>
<span class="nc" id="L352">            delete(bitRange, numberOfDeletedBits, newValues);</span>
              
        }
<span class="nc" id="L355">        return this;</span>
    }
	private Range convertBaseRangeIntoBitRange(Range range) {
<span class="nc" id="L358">		int start = (int)range.getBegin();</span>
<span class="nc" id="L359">		assertStartCoordinateIsValid(start);   </span>
<span class="nc" id="L360">		int bitOffsetOfStart = start*NUM_BITS_PER_VALUE;</span>
<span class="nc" id="L361">		int maxEnd = Math.min((tail-1)/NUM_BITS_PER_VALUE, (int)range.getEnd());</span>
<span class="nc" id="L362">		int bitOffsetOfEnd = maxEnd * NUM_BITS_PER_VALUE+3;</span>
		
<span class="nc" id="L364">		return Range.of(bitOffsetOfStart,bitOffsetOfEnd);</span>
	}
	private void assertStartCoordinateIsValid(int start) {
<span class="nc bnc" id="L367" title="All 2 branches missed.">		if(start&lt;0){</span>
<span class="nc" id="L368">		    throw new IllegalArgumentException(&quot;range can not have negatives coordinates: &quot;+ start);</span>
		}
<span class="nc bnc" id="L370" title="All 2 branches missed.">		if(start&gt; getLength()){</span>
<span class="nc" id="L371">		    throw new IllegalArgumentException(</span>
<span class="nc" id="L372">		            String.format(&quot;range can not start beyond current length (%d) : %d&quot;, getLength(),start));</span>
		}
<span class="nc" id="L374">	}</span>
	private void delete(Range bitRange,
			int numberOfDeletedBits, NewValues newValues) {
<span class="nc" id="L377">		BitSet shrunkBits = new BitSet(tail-numberOfDeletedBits);</span>
<span class="nc" id="L378">		int bitOffsetOfStart = (int) bitRange.getBegin();</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">		for(int i=0; i&lt;bitOffsetOfStart; i++){</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">			if(bits.get(i)){</span>
<span class="nc" id="L381">				shrunkBits.set(i);</span>
			}
		}
<span class="nc bnc" id="L384" title="All 2 branches missed.">		for(int i=(int)bitRange.getEnd()+1, j=0; i&lt;tail; i++, j++){</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">			if(bits.get(i)){</span>
<span class="nc" id="L386">				shrunkBits.set(bitOffsetOfStart + j);</span>
			}
		}
		
<span class="nc" id="L390">		this.codecDecider.decrement(newValues);</span>
<span class="nc" id="L391">		tail -= numberOfDeletedBits;</span>
<span class="nc" id="L392">		this.bits = shrunkBits;</span>
<span class="nc" id="L393">	}</span>
    
    @Override
	public Nucleotide get(int offset) {
<span class="nc bnc" id="L397" title="All 2 branches missed.">    	if(offset&lt;0){</span>
<span class="nc" id="L398">            throw new IllegalArgumentException(&quot;offset can not have negatives coordinates: &quot;+ offset);</span>
        }
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if(offset&gt; getLength()){</span>
<span class="nc" id="L401">            throw new IllegalArgumentException(</span>
<span class="nc" id="L402">                    String.format(&quot;offset can not start beyond current length (%d) : %d&quot;, getLength(),offset));</span>
        }
<span class="nc" id="L404">		return NUCLEOTIDE_VALUES[getNucleotideOrdinalFor(bits,offset)];</span>
	}
	public int getNumGaps(){
<span class="nc" id="L407">        return codecDecider.getNumberOfGaps();</span>
    }
    
    public int getNumNs(){
<span class="nc" id="L411">        return codecDecider.getNumberOfNs();</span>
    }
    public int getNumAmbiguities(){
<span class="nc" id="L414">        return codecDecider.getNumberOfAmbiguities();</span>
    }
    
    /**
     * Inserts the given sequence the beginning
     * of the builder's mutable sequence.
     * This is the same as calling 
     * {@link #insert(int, String) insert(0,sequence)}
     * @param sequence the nucleotide sequence to be 
     * inserted at the beginning.
     * @return this.
     * @throws NullPointerException if sequence is null.
     * @see #insert(int, String)
     */
    public NucleotideSequenceBuilder prepend(String sequence){
<span class="nc" id="L429">        return insert(0, sequence);</span>
    }
    /**
     * Inserts the given sequence to the builder's mutable sequence
     * starting at the given offset.  If any nucleotides existed
     * downstream of this offset before this insert method
     * was executed, then those nucleotides will be shifted by n
     * bases where n is the length of the given sequence to insert.
     * @param offset the &lt;strong&gt;gapped&lt;/strong&gt; offset into this mutable sequence
     * to begin insertion.  If the offset = the current length then this insertion
     * is treated as an append.
     * @param sequence the nucleotide sequence to be 
     * inserted at the given offset.
     * @return this
     * @throws NullPointerException if sequence is null.
     * @throws IllegalArgumentException if offset &lt;0 or &gt; current sequence length.
     */
    public NucleotideSequenceBuilder insert(int offset, Iterable&lt;Nucleotide&gt; sequence){
<span class="nc" id="L447">        assertInsertionParametersValid(offset, sequence);   </span>
<span class="nc" id="L448">        NewValues newValues = new NewValues(sequence);</span>
<span class="nc" id="L449">        return insert(offset, newValues);</span>
    }
	private void assertInsertionParametersValid(int offset,
			Object sequence) {
<span class="nc" id="L453">		assertNotNull(sequence);</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if(offset&lt;0){</span>
<span class="nc" id="L455">            throw new IllegalArgumentException(&quot;offset can not have negatives coordinates: &quot;+ offset);</span>
        }
<span class="nc bnc" id="L457" title="All 2 branches missed.">        if(offset&gt; getLength()){</span>
<span class="nc" id="L458">            throw new IllegalArgumentException(</span>
<span class="nc" id="L459">                    String.format(&quot;offset can not start beyond current length (%d) : %d&quot;, getLength(),offset));</span>
        }
<span class="nc" id="L461">	}</span>
	private NucleotideSequenceBuilder insert(int offset, NewValues newValues) {
<span class="nc" id="L463">		BitSet insertedBits = newValues.getBits();</span>
<span class="nc" id="L464">        int numberOfInsertedBits = newValues.getLength()*NUM_BITS_PER_VALUE;</span>
<span class="nc" id="L465">		BitSet expandedBits = new BitSet(tail+numberOfInsertedBits);</span>
<span class="nc" id="L466">        int bitValueOfOffset = offset*NUM_BITS_PER_VALUE;</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">        for(int i=0; i&lt; bitValueOfOffset; i++){</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">        	if(bits.get(i)){</span>
<span class="nc" id="L469">        		expandedBits.set(i);</span>
        	}
        }
<span class="nc bnc" id="L472" title="All 2 branches missed.">        for(int i=0; i&lt; numberOfInsertedBits; i++ ){</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">        	if(insertedBits.get(i)){</span>
<span class="nc" id="L474">        		expandedBits.set(bitValueOfOffset+i);</span>
        	}
        }
<span class="nc bnc" id="L477" title="All 2 branches missed.">        for(int i=bitValueOfOffset; i&lt; tail; i++){</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        	if(bits.get(i)){</span>
<span class="nc" id="L479">        		expandedBits.set(i+numberOfInsertedBits);</span>
        	}
        }
<span class="nc" id="L482">        this.codecDecider.increment(newValues);</span>
<span class="nc" id="L483">        tail +=numberOfInsertedBits;</span>
<span class="nc" id="L484">        this.bits = expandedBits;</span>
<span class="nc" id="L485">        return this;</span>
	}
    /**
     * Inserts the contents of the given other  {@link NucleotideSequenceBuilder}
     *  into this builder's mutable sequence
     * starting at the given offset.  If any nucleotides existed
     * downstream of this offset before this insert method
     * was executed, then those nucleotides will be shifted by n
     * bases where n is the length of the given sequence to insert.
     * Any further modifications to the passed in builder
     * will not be reflected in this builder.  This is an equivalent but more efficient operation
     * as {@code this.insert(offset, otherBuilder.build())}
     * 
     * @param offset the &lt;strong&gt;gapped&lt;/strong&gt; offset into this mutable sequence
     * to begin insertion.
     * @param otherBuilder the {@link NucleotideSequenceBuilder} whose current
     * nucleotides are to be inserted at the given offset.
     * @return this
     * @throws NullPointerException if otherBuilder is null.
     * @throws IllegalArgumentException if offset &lt;0 or &gt; current sequence length or if otherBuilder is not a NucleotideSequenceBuilder.
     */
    public NucleotideSequenceBuilder insert(int offset, ResidueSequenceBuilder&lt;Nucleotide, NucleotideSequence&gt; otherBuilder){
<span class="nc" id="L507">        assertNotNull(otherBuilder);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if(!(otherBuilder instanceof NucleotideSequenceBuilder)){</span>
<span class="nc" id="L509">        	throw new IllegalArgumentException(&quot;otherBuilder must be a NucleotideSequenceBuilder&quot;);</span>
        }
<span class="nc bnc" id="L511" title="All 2 branches missed.">        if(offset&lt;0){</span>
<span class="nc" id="L512">            throw new IllegalArgumentException(&quot;offset can not have negatives coordinates: &quot;+ offset);</span>
        }
<span class="nc bnc" id="L514" title="All 2 branches missed.">        if(offset&gt;= getLength()){</span>
<span class="nc" id="L515">            throw new IllegalArgumentException(</span>
<span class="nc" id="L516">                    String.format(&quot;offset can not start beyond current length (%d) : %d&quot;, getLength(),offset));</span>
        }   
<span class="nc" id="L518">        NucleotideSequenceBuilder otherSequenceBuilder = (NucleotideSequenceBuilder)otherBuilder;</span>
<span class="nc" id="L519">        NewValues newValues = new NewValues(otherSequenceBuilder.bits, otherSequenceBuilder.tail);</span>
<span class="nc" id="L520">        return insert(offset, newValues);</span>
    }
    
   
    
    /**
     * Inserts the given {@link Nucleotide} to the builder's mutable sequence
     * at the given offset.  If any nucleotides existed
     * downstream of this offset before this insert method
     * was executed, then those nucleotides will be shifted by 1
     * base.
     * @param offset the GAPPED offset into this mutable sequence
     * to begin insertion.
     * @param base the {@link Nucleotide} to be 
     * inserted at the given offset.
     * @return this
     * @throws NullPointerException if base is null.
     * @throws IllegalArgumentException if offset &lt;0 or &gt; current sequence length.
     */
    public NucleotideSequenceBuilder insert(int offset, Nucleotide base){
<span class="nc bnc" id="L540" title="All 2 branches missed.">    	if(base ==null){</span>
<span class="nc" id="L541">    		throw new NullPointerException(&quot;base can not be null&quot;);</span>
    	}
<span class="nc" id="L543">        return insert(offset, Collections.singleton(base));</span>
     }
    /**
     * Inserts the given sequence the beginning
     * of the builder's mutable sequence.
     * This is the same as calling 
     * {@link #insert(int, Iterable) insert(0,sequence)}
     * @param sequence the nucleotide sequence to be 
     * inserted at the beginning.
     * @return this.
     * @throws NullPointerException if sequence is null.
     * @see #insert(int, Iterable)
     */
    public NucleotideSequenceBuilder prepend(Iterable&lt;Nucleotide&gt; sequence){
<span class="nc" id="L557">        return insert(0, sequence);</span>
    }
    
    /**
     * Inserts the current contents of the given {@link NucleotideSequenceBuilder}
     * to the beginning
     * of this builder's mutable sequence.
     * This is the same as calling 
     * {@link #insert(int, ResidueSequenceBuilder) insert(0,otherBuilder)}
     * @param otherBuilder {@link NucleotideSequenceBuilder} whose current
     * nucleotides are to be inserted at the beginning.
     * @return this.
     * @throws NullPointerException if otherBuilder is null.
     * @see #insert(int, ResidueSequenceBuilder)
     */
    public NucleotideSequenceBuilder prepend(ResidueSequenceBuilder&lt;Nucleotide, NucleotideSequence&gt; otherBuilder){
<span class="nc" id="L573">        return insert(0, otherBuilder);</span>
    }
    /**
    * {@inheritDoc}
    * &lt;p&gt;
    * Create a new {@link NucleotideSequence} instance
    * from the current mutable nucleotides.  This method
    * does not destroy any temp data so this method
    * could be called multiple times each time 
    * creating a new {@link NucleotideSequence}.
    * @return a new NucleotideSequence never null
    * but may be empty.
    */
    @Override
    public NucleotideSequence build() {    
    		
<span class="nc bnc" id="L589" title="All 2 branches missed.">        	if(codecDecider.hasAlignedReference()){</span>
<span class="nc" id="L590">        		return new DefaultReferenceEncodedNucleotideSequence(</span>
<span class="nc" id="L591">        				codecDecider.alignedReference.reference, this, codecDecider.alignedReference.offset);</span>
        	
        	}
        	
<span class="nc" id="L595">        	NucleotideCodec optimalCodec = codecDecider.getOptimalCodec();</span>
<span class="nc" id="L596">        	byte[] encodedBytes =optimalCodec.encode(codecDecider.currentLength, iterator());</span>
<span class="nc" id="L597">        	NucleotideSequence seq= new DefaultNucleotideSequence(optimalCodec, encodedBytes);</span>
        	
<span class="nc" id="L599">        	return seq;</span>

    }
    @Override
    public Iterator&lt;Nucleotide&gt; iterator() {
<span class="nc" id="L604">    	return new Iterator&lt;Nucleotide&gt;(){</span>
<span class="nc" id="L605">            private final int end = codecDecider.currentLength*NUM_BITS_PER_VALUE-1;</span>
<span class="nc" id="L606">            private int currentOffset=0;</span>
<span class="nc" id="L607">            private final BitSet bits = NucleotideSequenceBuilder.this.bits.get(0,tail);</span>
			@Override
			public boolean hasNext() {
<span class="nc bnc" id="L610" title="All 2 branches missed.">				return currentOffset&lt;end;</span>
			}
			@Override
			public Nucleotide next() {
<span class="nc bnc" id="L614" title="All 2 branches missed.">				if(!hasNext()){</span>
<span class="nc" id="L615">					throw new NoSuchElementException();</span>
				}
<span class="nc" id="L617">				Nucleotide next = NUCLEOTIDE_VALUES[getNucleotideOrdinalFor(bits,currentOffset)];</span>
<span class="nc" id="L618">				currentOffset+= NUM_BITS_PER_VALUE;</span>
<span class="nc" id="L619">				return next;</span>
			}
			@Override
			public void remove() {
<span class="nc" id="L623">				throw new UnsupportedOperationException();</span>
				
			}
    	};
    	
	}
	/**
     * Return the built {@link NucleotideSequence} as {@link ReferenceMappedNucleotideSequence} 
     * assuming {@link #setReferenceHint(NucleotideSequence, int)} has been set.
     * This is the same as {@code (ReferenceEncodedNucleotideSequence) build()}
     * @return the built NucleotideSequence as a {@link ReferenceMappedNucleotideSequence}.
     * @throws IllegalStateException if a reference
     * has not been provided via the {@link #setReferenceHint(NucleotideSequence, int)}
     */
    public ReferenceMappedNucleotideSequence buildReferenceEncodedNucleotideSequence() {    
<span class="nc bnc" id="L638" title="All 2 branches missed.">    	if(!codecDecider.hasAlignedReference()){</span>
<span class="nc" id="L639">    		throw new IllegalStateException(&quot;must provide reference&quot;);</span>
    	}
<span class="nc" id="L641">        return (ReferenceMappedNucleotideSequence)build();</span>
    }
   
    /**
     * Provide another {@link NucleotideSequence} and a start coordinate
     * that can be used as a reference alignment for this sequence to be built.
     * This information may or may not be actually used during {@link #build()}
     *  to construct a more memory efficient
     * {@link NucleotideSequence} implementation.  The given sequence and start coordinate
     * provided should be the coordinates used in the final fully built sequence.
     * &lt;br/&gt;
     * For example:
     * &lt;pre&gt;
     * 
     * NucleotideSequence reference = ... //reference = A-GCCGTT
     * 
     *  new NucleotideSequenceBuilder(&quot;CGGC&quot;)
     *  		.setReference(reference, 2)
                .reverseCompliment()
                .append(&quot;N&quot;);     
     * &lt;/pre&gt;
     * might use the part of the reference &quot;GCCGT&quot;
     * that aligns to this sequence being built with only one SNP (T -&gt;N )
     * to save memory. 
     * 
     * @param referenceSequence the reference sequence 
     * that aligns well to this sequence and that may be used
     * to improve memory performance.  A reference
     * can be a contig or scaffold consensus or anything else
     * that will have a high percent identity for the length 
     * of this sequence being built. This sequence and the reference
     * sequence must be in the same orientation to align well.  Can not be null.
     * @param gappedStartOffset the &lt;strong&gt;gapped&lt;/strong&gt; offset into
     * this reference where the final version of this built sequence will
     * start to align. Can not be negative or start beyond
     * the length of this reference.
     * @return this.
     * @throws NullPointerException if referenceSequence is null.
     * @throws IllegalArgumentException if gappedStartOffset is &lt;0 or beyond the reference.
     */
    public NucleotideSequenceBuilder setReferenceHint(NucleotideSequence referenceSequence, int gappedStartOffset){
<span class="nc" id="L682">    	codecDecider.alignedReference(new AlignedReference(referenceSequence, gappedStartOffset));</span>
<span class="nc" id="L683">    	return this;</span>
    }
    /**
     * Create a new NucleotideSequence instance
     * from containing only current mutable nucleotides
     * in the given range.  If the range extends beyond the current
     * sequence, then this will build all the bases until the end of
     * the sequence.
     * @param range the range of nucleotides to build (gapped).
     * @return a new NucleotideSequence never null
     * but may be empty.
     */
    public NucleotideSequence build(Range range) {
<span class="nc" id="L696">    	Range bitRange = convertBaseRangeIntoBitRange(range);</span>
<span class="nc" id="L697">        int numberOfDeletedBits = (int)bitRange.getLength()-1;</span>
<span class="nc" id="L698">		BitSet subBits = bits.get((int)bitRange.getBegin(), (int)bitRange.getEnd()+1);</span>
<span class="nc" id="L699">		NucleotideSequenceBuilder builder = new NucleotideSequenceBuilder(subBits,numberOfDeletedBits);</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">		if(codecDecider.hasAlignedReference()){</span>
<span class="nc" id="L701">			builder.setReferenceHint(codecDecider.alignedReference.reference, codecDecider.alignedReference.offset+ (int)range.getBegin());</span>
		}
<span class="nc" id="L703">		return builder.build();</span>
    }
    
    /**
     * {@inheritDoc}
     * 
     * If a previous reference hint is provided
     * via {@link #setReferenceHint(NucleotideSequence, int)},
     * then the reference coordinates will be automatically
     * adjusted to compensate for the new trimmed sequence.
     * 
     * @param range the range of nucleotides to keep (gapped).
     * @return this.
     */
    @Override
    public NucleotideSequenceBuilder trim(Range range){
<span class="nc bnc" id="L719" title="All 4 branches missed.">    	if(range.getEnd() &lt;0 || range.isEmpty()){</span>
<span class="nc" id="L720">    		return delete(Range.ofLength(this.getLength()));</span>
    	}
<span class="nc" id="L722">    	Range trimRange = range.intersection(Range.ofLength(getLength()));</span>
    	
<span class="nc" id="L724">    	Range bitRange = convertBaseRangeIntoBitRange(trimRange);</span>
<span class="nc" id="L725">        int numberOfBitsUsed = (int)bitRange.getLength();</span>
<span class="nc" id="L726">		BitSet subBits = bits.get((int)bitRange.getBegin(), (int)bitRange.getEnd()+1);</span>
<span class="nc" id="L727">		NucleotideSequenceBuilder builder = new NucleotideSequenceBuilder(subBits,numberOfBitsUsed);</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">		if(codecDecider.hasAlignedReference()){</span>
<span class="nc" id="L729">			builder.setReferenceHint(codecDecider.alignedReference.reference, codecDecider.alignedReference.offset+ (int)range.getBegin());</span>
		}
<span class="nc" id="L731">		this.bits = subBits;</span>
<span class="nc" id="L732">        this.codecDecider = builder.codecDecider;</span>
<span class="nc" id="L733">        this.tail = numberOfBitsUsed;</span>
<span class="nc" id="L734">		return this;</span>
    }
   
    
   
	private Nucleotide getNucleotideFor(int bitStartOffset) {
<span class="nc" id="L740">		int ordinal = getNucleotideOrdinalFor(bitStartOffset);</span>
<span class="nc" id="L741">		return NUCLEOTIDE_VALUES[ordinal];</span>
	}
	private byte getNucleotideOrdinalFor(BitSet bits, int bitStartOffset) {
		
<span class="nc bnc" id="L745" title="All 2 branches missed.">		int bit3 =bits.get(bitStartOffset)?8:0; </span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">		int bit2 =bits.get(bitStartOffset+1)?4:0; </span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">		int bit1 =bits.get(bitStartOffset+2)?2:0; </span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">		int bit0 =bits.get(bitStartOffset+3)?1:0;</span>
<span class="nc" id="L749">		return (byte)(bit3+bit2+bit1+bit0);</span>
	}
	private byte getNucleotideOrdinalFor(int bitStartOffset) {
<span class="nc" id="L752">		return getNucleotideOrdinalFor(bits, bitStartOffset);</span>
	}
    
	/**
	 * 
	 * {@inheritDoc}
	 */
	public NucleotideSequenceBuilder copy(){
<span class="nc" id="L760">		BitSet copyOfBits = bits.get(0,tail);		</span>
<span class="nc" id="L761">		return new NucleotideSequenceBuilder(copyOfBits, tail,codecDecider);</span>
	}
    
   
	@Override
	public int hashCode() {
<span class="nc" id="L767">		final int prime = 31;</span>
<span class="nc" id="L768">		int result = 1;</span>
<span class="nc" id="L769">		result = prime * result + bits.get(0, tail).hashCode();</span>
<span class="nc" id="L770">		return result;</span>
	}
	/**
	 * Two {@link NucleotideSequenceBuilder}s are equal
	 * if they currently both contain
	 * the exact same Nucleotide sequence.
	 * {@inheritDoc}
	 */
	@Override
	public boolean equals(Object obj) {
<span class="nc bnc" id="L780" title="All 2 branches missed.">		if (this == obj) {</span>
<span class="nc" id="L781">			return true;</span>
		}
<span class="nc bnc" id="L783" title="All 2 branches missed.">		if (obj == null) {</span>
<span class="nc" id="L784">			return false;</span>
		}
<span class="nc bnc" id="L786" title="All 2 branches missed.">		if (!(obj instanceof NucleotideSequenceBuilder)) {</span>
<span class="nc" id="L787">			return false;</span>
		}
<span class="nc" id="L789">		NucleotideSequenceBuilder other = (NucleotideSequenceBuilder) obj;</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">		if(tail !=other.tail){</span>
<span class="nc" id="L791">			return false;</span>
		}
<span class="nc" id="L793">		BitSet ourPopulatedBits =bits.get(0, tail);</span>
<span class="nc" id="L794">		BitSet otherPopulatedBits =other.bits.get(0, other.tail);</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">		if (!ourPopulatedBits.equals(otherPopulatedBits)) {</span>
<span class="nc" id="L796">			return false;</span>
		}
<span class="nc" id="L798">		return true;</span>
	}
	
	
	/**
     * Get the current Nucleotides sequence as 
     * one long String without any whitespace.
     * For example:
     * &lt;pre&gt;
     *  new NucleotideSequenceBuilder(&quot;ACGT&quot;)
     *  .append(&quot;-TAG&quot;)
     *  .toString();
     * &lt;/pre&gt;
     * will return &quot;ACGT-TAG&quot;.
     */
    @Override
    public String toString(){
<span class="nc" id="L815">    	StringBuilder builder = new StringBuilder(codecDecider.getCurrentLength());</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">    	for(int i=0; i&lt;tail; i+=NUM_BITS_PER_VALUE){</span>
<span class="nc" id="L817">        	Nucleotide base = getNucleotideFor(i);</span>
<span class="nc" id="L818">        	builder.append(base);</span>
        }
<span class="nc" id="L820">        return builder.toString();</span>
    }
    /**
     * Reverse complement all the nucleotides currently in this builder.
     * Calling this method will only reverse complement bases that 
     * already exist in this builder; any additional operations
     * to insert bases will not be affected.
     * &lt;p/&gt;
     * For example:
     * &lt;pre&gt;
     *      new NucleotideSequenceBuilder(&quot;CGGC&quot;)
                .reverseComplement()
                .append(&quot;N&quot;);                
     * &lt;/pre&gt;
     * will generate a Sequence &quot;GCCGN&quot;.
     * @return this.
     */
    public NucleotideSequenceBuilder reverseComplement(){
<span class="nc" id="L838">        int currentLength = codecDecider.getCurrentLength();</span>
<span class="nc" id="L839">        int pivotOffset = currentLength/2;</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">        for(int i=0; i&lt;pivotOffset; i++){</span>
<span class="nc" id="L841">            int compOffset = currentLength-1-i;</span>
<span class="nc" id="L842">            int startBitOfI = i*NUM_BITS_PER_VALUE;</span>
<span class="nc" id="L843">            Nucleotide tmp = getNucleotideFor(startBitOfI).complement();</span>
<span class="nc" id="L844">            int startBitOfComplementOffset = compOffset*NUM_BITS_PER_VALUE;</span>
<span class="nc" id="L845">            byte complementOrdinal = (byte) getNucleotideFor(startBitOfComplementOffset).complement().ordinal();</span>
<span class="nc" id="L846">            setBitsFor(startBitOfI, complementOrdinal);</span>
<span class="nc" id="L847">            setBitsFor(startBitOfComplementOffset, (byte) tmp.ordinal());</span>
        }
<span class="nc bnc" id="L849" title="All 2 branches missed.">        if(currentLength%2!=0){</span>
<span class="nc" id="L850">        	int bitOffset = pivotOffset*NUM_BITS_PER_VALUE;</span>
<span class="nc" id="L851">        	byte complementOrdinal = (byte) getNucleotideFor(bitOffset).complement().ordinal();</span>
<span class="nc" id="L852">        	setBitsFor(bitOffset, complementOrdinal);</span>
        }
<span class="nc" id="L854">        return this;</span>
    }
    /**
     * Complements all the nucleotides currently in this builder
     * but does not reverse the sequence.
     * Calling this method will only complement bases that 
     * already exist in this builder; any additional operations
     * to insert bases will not be affected.
     * &lt;p/&gt;
     * For example:
     * &lt;pre&gt;
     *      new NucleotideSequenceBuilder(&quot;ATGT&quot;)
                .compliment()
                .append(&quot;N&quot;);                
     * &lt;/pre&gt;
     * will generate a Sequence &quot;TACAN&quot;.
     * @return this.
     */
    public NucleotideSequenceBuilder complement(){
<span class="nc" id="L873">        int currentLength = codecDecider.getCurrentLength();</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">        for(int i=0; i&lt;currentLength; i++){</span>
<span class="nc" id="L875">            int startBitOfI = i*NUM_BITS_PER_VALUE;</span>
<span class="nc" id="L876">            Nucleotide complement = getNucleotideFor(startBitOfI).complement();</span>
<span class="nc" id="L877">            byte complementOrdinal = (byte) complement.ordinal();</span>
<span class="nc" id="L878">            setBitsFor(startBitOfI, complementOrdinal);</span>
        }
<span class="nc" id="L880">        return this;</span>
    }
    
    
	private void setBitsFor(int offset, byte twoBitValue) {
<span class="nc" id="L885">		setBitsFor(bits, offset, twoBitValue);</span>
<span class="nc" id="L886">	}</span>
	
	private void setBitsFor(BitSet bits, int offset, byte fourBitValue) {
<span class="nc" id="L889">		bits.clear(offset, offset+NUM_BITS_PER_VALUE);</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">		if((fourBitValue &amp; 0x8 ) !=0){</span>
<span class="nc" id="L891">			bits.set(offset);            	</span>
		}
<span class="nc bnc" id="L893" title="All 2 branches missed.">		if((fourBitValue &amp; 0x4 ) !=0){</span>
<span class="nc" id="L894">			bits.set(offset+1);            	</span>
		}
<span class="nc bnc" id="L896" title="All 2 branches missed.">		if((fourBitValue &amp; 0x2 ) !=0){</span>
<span class="nc" id="L897">			bits.set(offset+2);            	</span>
		}
<span class="nc bnc" id="L899" title="All 2 branches missed.">		if((fourBitValue &amp; 0x1 ) !=0){</span>
<span class="nc" id="L900">			bits.set(offset+3);            	</span>
		}
<span class="nc" id="L902">	}</span>
    
    /**
     * {@inheritDoc}
     * 
     * @see #reverseComplement()
     */
    @Override
	public NucleotideSequenceBuilder reverse() {
<span class="nc" id="L911">    	int currentLength = codecDecider.getCurrentLength();</span>
<span class="nc" id="L912">        int pivotOffset = currentLength/2;</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">        for(int i=0; i&lt;pivotOffset; i++){</span>
<span class="nc" id="L914">            int jOffset = currentLength-1-i;</span>
<span class="nc" id="L915">            int startBitOfI = i*NUM_BITS_PER_VALUE;</span>
<span class="nc" id="L916">            byte ordinalOfI = getNucleotideFor(startBitOfI).getOrdinalAsByte();</span>
<span class="nc" id="L917">            int startBitOfJ = jOffset*NUM_BITS_PER_VALUE;</span>
<span class="nc" id="L918">            byte ordinalOfJ = getNucleotideFor(startBitOfJ).getOrdinalAsByte();</span>
<span class="nc" id="L919">            setBitsFor(startBitOfI, ordinalOfJ);</span>
<span class="nc" id="L920">            setBitsFor(startBitOfJ, ordinalOfI);</span>
        }
<span class="nc" id="L922">		return this;</span>
	}
	/**
     * Remove all gaps currently present in this builder.
     * @return this.
     */
    public NucleotideSequenceBuilder ungap(){
<span class="nc" id="L929">        final int numGaps = codecDecider.getNumberOfGaps();</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">        if(numGaps&gt;0){</span>
<span class="nc" id="L931">        	BitSet newBits = new BitSet(tail);</span>
<span class="nc" id="L932">            int newOffset=0;</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">            for(int oldOffset=0; oldOffset&lt;tail; oldOffset+=NUM_BITS_PER_VALUE){</span>
<span class="nc" id="L934">            	byte ordinal = getNucleotideOrdinalFor(oldOffset);</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">            	if(ordinal !=GAP_VALUE){</span>
<span class="nc" id="L936">            		setBitsFor(newBits, newOffset, ordinal);</span>
<span class="nc" id="L937">            		newOffset+=NUM_BITS_PER_VALUE;</span>
            	}                
            }
<span class="nc" id="L940">           bits = newBits;</span>
<span class="nc" id="L941">           tail = newOffset;</span>
<span class="nc" id="L942">           codecDecider.ungap();</span>
        }
<span class="nc" id="L944">        return this;</span>
    }

    /**
     * This class keeps track of the number of special
     * nucleotides (gaps, N, ambiguities etc)
     * that we have so far in our sequence.
     * We can use this information during
     * {@link #build()} to determine the best
     * {@link NucleotideCodec} to use.
     * @author dkatzel
     */
    private static final class CodecDecider{
<span class="nc" id="L957">        private int numberOfGaps=0;</span>
<span class="nc" id="L958">        private int numberOfAmbiguities=0;</span>
<span class="nc" id="L959">        private int numberOfNs=0;</span>
<span class="nc" id="L960">        private int currentLength=0;</span>
<span class="nc" id="L961">        private AlignedReference alignedReference=null;</span>
<span class="nc" id="L962">        CodecDecider(){</span>
        	//needs to be initialized
<span class="nc" id="L964">        }</span>
<span class="nc" id="L965">        CodecDecider(NewValues newValues){</span>
<span class="nc" id="L966">        	increment(newValues);</span>
<span class="nc" id="L967">        }</span>
        CodecDecider copy(){
<span class="nc" id="L969">        	CodecDecider copy = new CodecDecider();</span>
<span class="nc" id="L970">        	copy.numberOfAmbiguities = numberOfAmbiguities;</span>
<span class="nc" id="L971">        	copy.numberOfGaps = numberOfGaps;</span>
<span class="nc" id="L972">        	copy.currentLength= currentLength;</span>
<span class="nc" id="L973">        	copy.numberOfNs = numberOfNs;</span>
<span class="nc" id="L974">        	copy.alignedReference = alignedReference;</span>
<span class="nc" id="L975">        	return copy;</span>
        	
        }
        
        
        void alignedReference(AlignedReference ref){
<span class="nc" id="L981">        	this.alignedReference = ref;</span>
<span class="nc" id="L982">        }</span>
        
        boolean hasAlignedReference(){
<span class="nc bnc" id="L985" title="All 2 branches missed.">        	return alignedReference!=null;</span>
        }
        NucleotideCodec getOptimalCodec() {
        	
<span class="nc bnc" id="L989" title="All 6 branches missed.">            if(numberOfAmbiguities&gt;0 || (numberOfGaps&gt;0 &amp;&amp; numberOfNs &gt;0)){</span>
<span class="nc" id="L990">                return DefaultNucleotideCodec.INSTANCE;</span>
            }
<span class="nc" id="L992">            int fourBitBufferSize =currentLength/2;</span>
<span class="nc" id="L993">            int twoBitBufferSize = TwoBitEncodedNucleotideCodec.getNumberOfEncodedBytesFor(currentLength,</span>
<span class="nc" id="L994">            		Math.max(numberOfGaps, numberOfNs));</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">            if(fourBitBufferSize &lt; twoBitBufferSize){</span>
<span class="nc" id="L996">            	return DefaultNucleotideCodec.INSTANCE;</span>
            }
<span class="nc bnc" id="L998" title="All 2 branches missed.">            if(numberOfGaps==0 ){</span>
<span class="nc" id="L999">            	return ACGTNNucloetideCodec.INSTANCE;</span>
            }
<span class="nc" id="L1001">            return NoAmbiguitiesEncodedNucleotideCodec.INSTANCE;</span>
        }
        
        public void increment(NewValues newValues) {
<span class="nc" id="L1005">			numberOfGaps +=newValues.getNumberOfGaps();</span>
<span class="nc" id="L1006">			numberOfNs += newValues.getNumberOfNs();</span>
<span class="nc" id="L1007">			currentLength += newValues.getLength();</span>
<span class="nc" id="L1008">			numberOfAmbiguities += newValues.getnumberOfAmiguities();</span>
<span class="nc" id="L1009">		}</span>
        
        public void decrement(NewValues newValues) {
<span class="nc" id="L1012">			numberOfGaps -=newValues.getNumberOfGaps();</span>
<span class="nc" id="L1013">			numberOfNs -= newValues.getNumberOfNs();</span>
<span class="nc" id="L1014">			currentLength -= newValues.getLength();</span>
<span class="nc" id="L1015">			numberOfAmbiguities -= newValues.getnumberOfAmiguities();</span>
<span class="nc" id="L1016">		}</span>

		
        public void replace(byte oldValue, byte newValue) {
<span class="nc" id="L1020">            handleValue(oldValue,false);</span>
<span class="nc" id="L1021">            handleValue(newValue,true);</span>
<span class="nc" id="L1022">        }</span>

       
        
        void handleValue(int value, boolean increment) {
<span class="nc bnc" id="L1027" title="All 2 branches missed.">            if(value == GAP_VALUE){</span>
<span class="nc" id="L1028">                handleGap(increment);</span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">            }else if(value == N_VALUE){</span>
<span class="nc" id="L1030">                handleN(increment);</span>
<span class="nc bnc" id="L1031" title="All 4 branches missed.">            }else if(value != A_VALUE &amp;&amp; value != C_VALUE </span>
<span class="nc bnc" id="L1032" title="All 4 branches missed.">                    &amp;&amp; value != G_VALUE &amp;&amp; value != T_VALUE){</span>
<span class="nc" id="L1033">                handleAmbiguity(increment);                </span>
            }
<span class="nc" id="L1035">        }</span>

        private void handleAmbiguity(boolean increment) {
<span class="nc bnc" id="L1038" title="All 2 branches missed.">            if(increment){</span>
<span class="nc" id="L1039">                numberOfAmbiguities++;</span>
            }else{
<span class="nc" id="L1041">                numberOfAmbiguities--;</span>
            }
<span class="nc" id="L1043">        }</span>

        private void handleN(boolean increment) {
<span class="nc bnc" id="L1046" title="All 2 branches missed.">            if(increment){</span>
<span class="nc" id="L1047">            numberOfNs++;</span>
            }else{
<span class="nc" id="L1049">                numberOfNs--;</span>
            }
<span class="nc" id="L1051">        }</span>

        private void handleGap(boolean increment) {
<span class="nc bnc" id="L1054" title="All 2 branches missed.">            if(increment){</span>
<span class="nc" id="L1055">                numberOfGaps++;</span>
            }else{
<span class="nc" id="L1057">                numberOfGaps--;</span>
            }
<span class="nc" id="L1059">        }</span>
        
        
        void ungap(){
<span class="nc" id="L1063">            currentLength-=numberOfGaps;</span>
<span class="nc" id="L1064">            numberOfGaps=0;</span>
            
<span class="nc" id="L1066">        }</span>
        /**
         * @return the numberOfGaps
         */
        int getNumberOfGaps() {
<span class="nc" id="L1071">            return numberOfGaps;</span>
        }
        /**
         * @return the numberOfAmbiguities
         */
        int getNumberOfAmbiguities() {
<span class="nc" id="L1077">            return numberOfAmbiguities;</span>
        }
        /**
         * @return the numberOfNs
         */
        int getNumberOfNs() {
<span class="nc" id="L1083">            return numberOfNs;</span>
        }
        /**
         * @return the currentLength
         */
        int getCurrentLength() {
<span class="nc" id="L1089">            return currentLength;</span>
        }
        
        
    }
    
    
    private static class AlignedReference{
    	private final NucleotideSequence reference;
    	private final int offset;
<span class="nc" id="L1099">		public AlignedReference(NucleotideSequence reference, int offset) {</span>
<span class="nc" id="L1100">			long length = reference.getLength();</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">			if(offset &gt; length){</span>
<span class="nc" id="L1102">				throw new IllegalArgumentException(</span>
<span class="nc" id="L1103">						String.format(&quot;invalid offset %d is beyond reference length %d&quot;, offset, length));</span>
			}
<span class="nc" id="L1105">			this.reference = reference;</span>
<span class="nc" id="L1106">			this.offset = offset;</span>
<span class="nc" id="L1107">		}</span>
    	
    }
    
    private class NewValues{
    	private final  BitSet bits;
    	private int length;
    	private int numberOfGaps;
    	private int numberOfACGTs;
    	private int numberOfNs;
    	
    	
<span class="nc" id="L1119">    	public NewValues(BitSet encodedBits, int numberOfBitsUsed){</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">    		for(int i=0; i&lt; numberOfBitsUsed; i+=NUM_BITS_PER_VALUE){</span>
<span class="nc" id="L1121">    			handleOrdinal(getNucleotideOrdinalFor(encodedBits,i));    			</span>
    		}
<span class="nc" id="L1123">    		this.bits = encodedBits;</span>
<span class="nc" id="L1124">    	}</span>
<span class="nc" id="L1125">    	public NewValues(Nucleotide nucleotide){</span>
<span class="nc" id="L1126">    		bits = new BitSet();</span>
<span class="nc" id="L1127">            handle(nucleotide, 0);</span>
<span class="nc" id="L1128">    	}</span>
<span class="nc" id="L1129">    	public NewValues(String sequence){</span>
<span class="nc" id="L1130">    		bits = new BitSet();</span>
<span class="nc" id="L1131">            int offset=0;</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">    		for(int i=0; i&lt;sequence.length(); i++){</span>
<span class="nc" id="L1133">    			char c = sequence.charAt(i);</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">    			if(!Character.isWhitespace(c)){</span>
<span class="nc" id="L1135">    				Nucleotide n = Nucleotide.parse(c);</span>
<span class="nc" id="L1136">    				handle(n, offset);</span>
<span class="nc" id="L1137">                	offset+=NUM_BITS_PER_VALUE;</span>
    			}
    		}
<span class="nc" id="L1140">    	}</span>
<span class="nc" id="L1141">    	public NewValues(Iterable&lt;Nucleotide&gt; nucleotides){</span>
<span class="nc" id="L1142">    		bits = new BitSet();</span>
<span class="nc" id="L1143">            int offset=0;</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">            for(Nucleotide n : nucleotides){</span>
<span class="nc" id="L1145">            	handle(n, offset);</span>
<span class="nc" id="L1146">            	offset+=NUM_BITS_PER_VALUE;            	</span>
<span class="nc" id="L1147">            }</span>
<span class="nc" id="L1148">    	}</span>
		private void handle(Nucleotide n, int offset) {
<span class="nc" id="L1150">			byte value=n.getOrdinalAsByte();</span>
			
<span class="nc bnc" id="L1152" title="All 2 branches missed.">			if((value &amp; 0x1) !=0){</span>
<span class="nc" id="L1153">				bits.set(offset+3);</span>
			}
<span class="nc bnc" id="L1155" title="All 2 branches missed.">			if((value &amp; 0x2) !=0){</span>
<span class="nc" id="L1156">				bits.set(offset+2);</span>
			}
<span class="nc bnc" id="L1158" title="All 2 branches missed.">			if((value &amp; 0x4) !=0){</span>
<span class="nc" id="L1159">				bits.set(offset+1);</span>
			}
<span class="nc bnc" id="L1161" title="All 2 branches missed.">			if((value &amp; 0x8) !=0){</span>
<span class="nc" id="L1162">				bits.set(offset);</span>
			}
<span class="nc" id="L1164">			handleOrdinal(value);</span>
<span class="nc" id="L1165">		}</span>

		private void handleOrdinal(byte ordinal) {
<span class="nc" id="L1168">			length++;</span>
			//order of if statements has been optimized using profiler 
			
<span class="nc bnc" id="L1171" title="All 8 branches missed.">			if (ordinal == A_VALUE || ordinal == C_VALUE || ordinal == G_VALUE|| ordinal == T_VALUE){</span>
<span class="nc" id="L1172">				numberOfACGTs++;</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">			}else if(ordinal == GAP_VALUE){</span>
<span class="nc" id="L1174">				numberOfGaps++;</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">			}else if(ordinal ==N_VALUE){</span>
<span class="nc" id="L1176">				numberOfNs++;</span>
			}
<span class="nc" id="L1178">		}</span>

		public int getnumberOfAmiguities() {
<span class="nc" id="L1181">			return length - (numberOfGaps + numberOfNs+ numberOfACGTs);</span>
		}

		public BitSet getBits() {
<span class="nc" id="L1185">			return bits;</span>
		}

		public int getLength() {
<span class="nc" id="L1189">			return length;</span>
		}

		public int getNumberOfGaps() {
<span class="nc" id="L1193">			return numberOfGaps;</span>
		}

		public int getNumberOfNs() {
<span class="nc" id="L1197">			return numberOfNs;</span>
		}
    	
    	
    	
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>