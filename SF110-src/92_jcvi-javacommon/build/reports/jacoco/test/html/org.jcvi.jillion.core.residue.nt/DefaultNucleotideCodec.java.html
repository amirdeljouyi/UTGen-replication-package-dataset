<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultNucleotideCodec.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.core.residue.nt</a> &gt; <span class="el_source">DefaultNucleotideCodec.java</span></div><h1>DefaultNucleotideCodec.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
/*
 * Created on Jan 14, 2009
 *
 * @author dkatzel
 */
package org.jcvi.jillion.core.residue.nt;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collection;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NoSuchElementException;

import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.internal.core.GlyphCodec;
/**
 * &lt;code&gt;DefaultNucleotideGlyphCodec&lt;/code&gt; is the implementation
 * of {@link GlyphCodec} that can converts {@link Nucleotide}s
 * into a 4 bit representation.  This allows 2 {@link Nucleotide}s
 * to be packed into a single byte.
 * @author dkatzel
 *
 *
 */
<span class="nc" id="L50">public enum DefaultNucleotideCodec implements NucleotideCodec{</span>
    /**
     * Singleton instance.
     */
<span class="nc" id="L54">    INSTANCE;</span>
    /**
     * Maintains the mapping of each glyph singleton with
     * its assigned glyphcode value.  The glyphcodes have been specially
     * set to simplify reverse complementing.
     */
<span class="nc" id="L60">    private static final Map&lt;Byte, Nucleotide&gt; BYTE_TO_GLYPH_MAP = new HashMap&lt;Byte, Nucleotide&gt;();</span>
    /**
     * Maintains the mapping of each glyph singleton with
     * its assigned glyphcode value.  The glyphcodes have been specially
     * set to simplify reverse complementing.
     */
<span class="nc" id="L66">    private static final Map&lt;Nucleotide, Byte&gt; GLYPH_TO_BYTE_MAP = new EnumMap&lt;Nucleotide, Byte&gt;(Nucleotide.class);</span>
    /**
     * The header will contain an int value specifying how many glyphs are encoded.
     */
    private static final int HEADER_LENGTH = 4;
    
    /**
     * The header will contain an int value specifying how many glyphs are encoded.
     */
    private static final int BITS_PER_GLYPH = 4;
    
<span class="nc" id="L77">    private static final Nucleotide[] ORDINAL_VALUES = Nucleotide.values();</span>
    
<span class="nc" id="L79">    private final int singleGlyphEncodedSize = computeEncodedSize(1);</span>
    
    
    /**
     * populate the maps.
     * Each byte key has been specially assigned so
     * that flipping the bits (then bit masking)
     * returns the byte value for the key of the reverse complement
     * glyph where applicable.
     */
    static{
        //special case for
        //Gap and Unknown since they complement to themselves
<span class="nc" id="L92">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x00), Nucleotide.Gap);</span>
<span class="nc" id="L93">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x0F), Nucleotide.Unknown);</span>
        //everything else has a complement
<span class="nc" id="L95">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x01), Nucleotide.Adenine);</span>
<span class="nc" id="L96">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x0E), Nucleotide.Thymine);</span>
<span class="nc" id="L97">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x02), Nucleotide.Guanine);</span>
<span class="nc" id="L98">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x0D), Nucleotide.Cytosine);</span>

<span class="nc" id="L100">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x03), Nucleotide.Pyrimidine);</span>
<span class="nc" id="L101">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x0C), Nucleotide.Purine);</span>
<span class="nc" id="L102">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x04), Nucleotide.Weak);</span>
<span class="nc" id="L103">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x0B), Nucleotide.Strong);</span>
<span class="nc" id="L104">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x05), Nucleotide.Keto);</span>
<span class="nc" id="L105">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x0A), Nucleotide.Amino);</span>
<span class="nc" id="L106">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x06), Nucleotide.NotCytosine);</span>
<span class="nc" id="L107">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x09), Nucleotide.NotGuanine);</span>
<span class="nc" id="L108">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x07), Nucleotide.NotThymine);</span>
<span class="nc" id="L109">        BYTE_TO_GLYPH_MAP.put(Byte.valueOf((byte)0x08), Nucleotide.NotAdenine);</span>
        //populate the reverse mapping
<span class="nc bnc" id="L111" title="All 2 branches missed.">        for(Entry&lt;Byte, Nucleotide&gt; entry : BYTE_TO_GLYPH_MAP.entrySet()){</span>
<span class="nc" id="L112">            GLYPH_TO_BYTE_MAP.put(entry.getValue(), entry.getKey());           </span>
<span class="nc" id="L113">        }</span>
<span class="nc" id="L114">    }</span>
   
    @Override
    public Nucleotide decode(byte[] encodedGlyphs, long index){
<span class="nc" id="L118">        final byte getByteForGlyph = getEncodedByteForGlyph(encodedGlyphs,index);</span>
<span class="nc" id="L119">        return decode(getByteForGlyph, isEven(index));</span>
    }
    private Nucleotide decode(final byte getByteForGlyph, boolean isFirstNibble) {
<span class="nc" id="L122">        byte[] next2 = decodeNext2Values(getByteForGlyph);</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if(isFirstNibble){</span>
<span class="nc" id="L124">            return ORDINAL_VALUES[next2[0]];</span>
        }
<span class="nc" id="L126">        return ORDINAL_VALUES[next2[1]];</span>
    }
    private byte getEncodedByteForGlyph(byte[] encodedGlyphs, long index) {
<span class="nc" id="L129">        final int encodedIndex = computeEncodedIndexForGlyph(index);</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if(encodedIndex &gt;= encodedGlyphs.length){</span>
<span class="nc" id="L131">            throw new IndexOutOfBoundsException(&quot;index &quot;+index + &quot; corresponds to encodedIndex &quot;+encodedIndex + &quot;  encodedglyph length is &quot;+encodedGlyphs.length);</span>
        }
<span class="nc" id="L133">        return  encodedGlyphs[encodedIndex];</span>
    }
    private int computeEncodedIndexForGlyph(long index) {
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if(index&lt;0){</span>
<span class="nc" id="L137">            throw new IndexOutOfBoundsException(&quot;index can not be negative: &quot;+index);</span>
        }
<span class="nc" id="L139">        return (int)(HEADER_LENGTH+index/2);</span>
    }
    @Override
    public byte[] encode(int numberOfNucleotides,Iterator&lt;Nucleotide&gt; nucleotides) {        
<span class="nc" id="L143">        int encodedSize = computeEncodedSize(numberOfNucleotides);</span>
<span class="nc" id="L144">        return encodeGlyphs(nucleotides, numberOfNucleotides, encodedSize);</span>
        
    }
    @Override
    public byte[] encode(Collection&lt;Nucleotide&gt; glyphs) {
<span class="nc" id="L149">        final int unEncodedSize = glyphs.size();</span>
        
<span class="nc" id="L151">        int encodedSize = computeEncodedSize(unEncodedSize);</span>
<span class="nc" id="L152">        return encodeGlyphs(glyphs.iterator(), unEncodedSize, encodedSize);</span>
        
    }
    /**
     * Convenience method to encode a single basecall.
     * @param glyph
     * @return
     */
    @Override
    public byte[] encode(Nucleotide glyph) {
<span class="nc" id="L162">        ByteBuffer result = ByteBuffer.allocate(singleGlyphEncodedSize);</span>
<span class="nc" id="L163">        result.putInt(1);</span>
<span class="nc" id="L164">        encodeLastValue(glyph, result);</span>
<span class="nc" id="L165">        return result.array();</span>
        
    }
    private byte[] encodeGlyphs(Iterator&lt;Nucleotide&gt; iterator,
            final int unEncodedSize, int encodedSize) {
<span class="nc" id="L170">        ByteBuffer result = ByteBuffer.allocate(encodedSize);</span>
<span class="nc" id="L171">        result.putInt(unEncodedSize);</span>
<span class="nc" id="L172">        encodeAllButTheLastByte(iterator, unEncodedSize, result);</span>
<span class="nc" id="L173">        encodeFinalByte(iterator, unEncodedSize, result);</span>
<span class="nc" id="L174">        return result.array();</span>
    }
    /**
     * pack every 2 glyphs into a single byte.  this method
     * encodes all glyphs upto but not including the final byte
     * since the final byte is a special case.
     * @param glyphs
     * @param unEncodedSize
     * @param result
     */
    private void encodeAllButTheLastByte(Iterator&lt;Nucleotide&gt; glyphs,
            final int unEncodedSize, ByteBuffer result) {
<span class="nc bnc" id="L186" title="All 2 branches missed.">        for(int i=0; i&lt;unEncodedSize-2; i+=2){</span>
<span class="nc" id="L187">            encodeNext2Values(glyphs, result);</span>
        }
<span class="nc" id="L189">    }</span>
    /**
     * the final encoded byte is a special case because
     * there may only be a single glyph inside if
     * the unencoded size is odd.
     * @param glyphs
     * @param unEncodedSize
     * @param result
     */
    private void encodeFinalByte(Iterator&lt;Nucleotide&gt; glyphs,
            final int unEncodedSize, ByteBuffer result) {
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if(unEncodedSize&gt;0){</span>
<span class="nc" id="L201">            final boolean even = isEven(unEncodedSize);</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">            if(even){</span>
<span class="nc" id="L203">                encodeNext2Values(glyphs, result);</span>
            }
            else{
<span class="nc" id="L206">                encodeLastValue(glyphs.next(), result);</span>
            }
        }
<span class="nc" id="L209">    }</span>
    private int computeEncodedSize(final int size) {
<span class="nc bnc" id="L211" title="All 2 branches missed.">        return HEADER_LENGTH + size/2 + (isEven(size)?0:1);</span>
    }
    private boolean isEven(final long size) {
<span class="nc bnc" id="L214" title="All 2 branches missed.">        return size%2==0;</span>
    }
    private void encodeLastValue(Nucleotide glyph, ByteBuffer result) {
<span class="nc" id="L217">        byte hi = GLYPH_TO_BYTE_MAP.get(glyph);</span>
<span class="nc" id="L218">        result.put((byte) ((hi&lt;&lt;BITS_PER_GLYPH) &amp;0xFF));</span>
<span class="nc" id="L219">    }</span>
    private void encodeNext2Values(Iterator&lt;Nucleotide&gt; glyphs, ByteBuffer result) {
<span class="nc" id="L221">        byte hi = GLYPH_TO_BYTE_MAP.get(glyphs.next());</span>
<span class="nc" id="L222">        byte low = GLYPH_TO_BYTE_MAP.get(glyphs.next());</span>
<span class="nc" id="L223">        result.put((byte) ((hi&lt;&lt;BITS_PER_GLYPH | low) &amp;0xFF));</span>
<span class="nc" id="L224">    }</span>
    private byte[] decodeNext2Values(byte b) {
<span class="nc" id="L226">        byte hi = (byte)(b&gt;&gt;&gt;BITS_PER_GLYPH &amp;0x0F);</span>
<span class="nc" id="L227">        byte low = (byte)(b &amp; 0x0F);</span>
<span class="nc" id="L228">       return new byte[]{BYTE_TO_GLYPH_MAP.get(hi).getOrdinalAsByte(),BYTE_TO_GLYPH_MAP.get(low).getOrdinalAsByte()};</span>
    }
    
    @Override
    public int decodedLengthOf(byte[] encodedGlyphs) {
<span class="nc" id="L233">        ByteBuffer buf = ByteBuffer.wrap(encodedGlyphs);</span>
<span class="nc" id="L234">        return buf.getInt();</span>
    }
    
    /**
    * {@inheritDoc}
    */
    @Override
    public List&lt;Integer&gt; getGapOffsets(byte[] encodedGlyphs) {
<span class="nc" id="L242">    	Iterator&lt;Nucleotide&gt; iter = iterator(encodedGlyphs);</span>
<span class="nc" id="L243">    	List&lt;Integer&gt; gaps = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L244">    	int i=0;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">    	while(iter.hasNext()){</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">    		if(iter.next() == Nucleotide.Gap){</span>
<span class="nc" id="L247">    			gaps.add(Integer.valueOf(i));</span>
    		}
<span class="nc" id="L249">    		i++;</span>
    	}
<span class="nc" id="L251">        return gaps;</span>
    }
 
    /**
    * {@inheritDoc}
    */
    @Override
    public int getNumberOfGaps(byte[] encodedGlyphs) {
<span class="nc" id="L259">    	Iterator&lt;Nucleotide&gt; iter = iterator(encodedGlyphs);</span>
    	
<span class="nc" id="L261">    	int numGaps=0;</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">    	while(iter.hasNext()){</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">    		if(iter.next() == Nucleotide.Gap){</span>
<span class="nc" id="L264">    			numGaps++;</span>
    		}
    	}
<span class="nc" id="L267">    	return numGaps;</span>
    }
    /**
    * {@inheritDoc}
    */
    @Override
    public boolean isGap(byte[] encodedGlyphs, int gappedOffset) {
<span class="nc" id="L274">        return getGapOffsets(encodedGlyphs).contains(Integer.valueOf(gappedOffset));</span>
    }
    /**
    * {@inheritDoc}
    */
    @Override
    public long getUngappedLength(byte[] encodedGlyphs) {
<span class="nc" id="L281">      return decodedLengthOf(encodedGlyphs) - getNumberOfGaps(encodedGlyphs);</span>
    }
   
   
  
    /**
    * {@inheritDoc}
    */
    @Override
    public int getUngappedOffsetFor(byte[] encodedGlyphs, int gappedOffset) {
<span class="nc" id="L291">        return gappedOffset - getNumberOfGapsUntil(encodedGlyphs,gappedOffset);</span>
    }
    /**
    * {@inheritDoc}
    */
    @Override
    public int getGappedOffsetFor(byte[] encodedGlyphs, int ungappedOffset) {
      
<span class="nc" id="L299">    	int currentGappedOffset=0;</span>
<span class="nc" id="L300">    	int currentUngappedOffset=0;</span>
<span class="nc" id="L301">    	Iterator&lt;Nucleotide&gt; iter = iterator(encodedGlyphs);</span>
<span class="nc bnc" id="L302" title="All 4 branches missed.">    	while(iter.hasNext() &amp;&amp; ungappedOffset&lt;currentUngappedOffset){</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">    		if(iter.next()!=Nucleotide.Gap){</span>
<span class="nc" id="L304">    			currentUngappedOffset++;</span>
    		}
<span class="nc" id="L306">    		currentGappedOffset++;</span>
    	}
        
<span class="nc" id="L309">        return currentGappedOffset;</span>
    }
    /**
    * {@inheritDoc}
    */
    @Override
    public int getNumberOfGapsUntil(byte[] encodedGlyphs, int gappedOffset) {
<span class="nc" id="L316">        int numberOfGaps=0;</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">        for(Integer gapIndex :getGapOffsets(encodedGlyphs)){</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">            if(gapIndex.intValue() &lt;=gappedOffset){</span>
<span class="nc" id="L319">                numberOfGaps++;</span>
            }
<span class="nc" id="L321">        }</span>
<span class="nc" id="L322">        return numberOfGaps;</span>
    }
	@Override
	public Iterator&lt;Nucleotide&gt; iterator(byte[] encodedGlyphs) {		
<span class="nc" id="L326">		return new IteratorImpl(encodedGlyphs);</span>
	}
	
	@Override
	public Iterator&lt;Nucleotide&gt; iterator(byte[] encodedData, Range range) {
<span class="nc" id="L331">		return new IteratorImpl(encodedData, range);</span>
	}
	@Override
	public String toString(byte[] encodedData) {
		
<span class="nc" id="L336">		int length = decodedLengthOf(encodedData);</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">		if(length==0){</span>
<span class="nc" id="L338">			return &quot;&quot;;</span>
		}
<span class="nc" id="L340">		int currentOffset=0;</span>
<span class="nc" id="L341">		StringBuilder builder = new StringBuilder(length);</span>
		byte encodedByte;
		byte[] currentDecodedBytes ;
<span class="nc bnc" id="L344" title="All 2 branches missed.">		while(currentOffset &lt; length-2){</span>
<span class="nc" id="L345">			encodedByte = encodedData[computeEncodedIndexForGlyph(currentOffset)];</span>
<span class="nc" id="L346">			currentDecodedBytes = decodeNext2Values(encodedByte);</span>
<span class="nc" id="L347">			builder.append(ORDINAL_VALUES[currentDecodedBytes[0]]);</span>
<span class="nc" id="L348">			builder.append(ORDINAL_VALUES[currentDecodedBytes[1]]);</span>
<span class="nc" id="L349">			currentOffset+=2;</span>
		}
<span class="nc" id="L351">		encodedByte = encodedData[computeEncodedIndexForGlyph(currentOffset)];</span>
<span class="nc" id="L352">		currentDecodedBytes = decodeNext2Values(encodedByte);</span>
<span class="nc" id="L353">		builder.append(ORDINAL_VALUES[currentDecodedBytes[0]]);</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">		if(isEven(length)){</span>
<span class="nc" id="L355">			builder.append(ORDINAL_VALUES[currentDecodedBytes[1]]);</span>
		}
<span class="nc" id="L357">		return builder.toString();</span>
	}

	private class IteratorImpl implements Iterator&lt;Nucleotide&gt;{
		private final byte[] encodedData;
		private final int length;
<span class="nc" id="L363">		private int currentOffset=0;</span>
		private byte[] currentDecodedBytes;
		
<span class="nc" id="L366">		public IteratorImpl(byte[] encodedData, Range range) {</span>
<span class="nc" id="L367">			this.encodedData = encodedData;</span>
<span class="nc" id="L368">			int seqLength = decodedLengthOf(encodedData);</span>
<span class="nc bnc" id="L369" title="All 4 branches missed.">			if(range.getBegin()&lt;0 || range.getEnd()&gt;=seqLength){</span>
<span class="nc" id="L370">				throw new IndexOutOfBoundsException(&quot;range &quot;+range +&quot; is out of range of sequence which is only &quot;+ new Range.Builder(seqLength).build());</span>
			}
<span class="nc" id="L372">			currentOffset = (int)range.getBegin();</span>
<span class="nc" id="L373">			length = (int)range.getEnd()+1;</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">			if(hasNext()){</span>
<span class="nc" id="L375">				byte encodedByte = encodedData[computeEncodedIndexForGlyph(currentOffset)];</span>
<span class="nc" id="L376">				currentDecodedBytes = decodeNext2Values(encodedByte);</span>
			}
<span class="nc" id="L378">		}</span>
<span class="nc" id="L379">		public IteratorImpl(byte[] encodedData) {</span>
<span class="nc" id="L380">			this.encodedData = encodedData;</span>
<span class="nc" id="L381">			this.length = decodedLengthOf(encodedData);</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">			if(hasNext()){</span>
<span class="nc" id="L383">				byte encodedByte = encodedData[computeEncodedIndexForGlyph(0)];</span>
<span class="nc" id="L384">				currentDecodedBytes = decodeNext2Values(encodedByte);</span>
			}
<span class="nc" id="L386">		}</span>

		@Override
		public boolean hasNext() {
<span class="nc bnc" id="L390" title="All 2 branches missed.">			return currentOffset &lt;length;</span>
		}

		@Override
		public Nucleotide next() {
<span class="nc bnc" id="L395" title="All 2 branches missed.">			if(!hasNext()){</span>
<span class="nc" id="L396">				throw new NoSuchElementException(&quot;no more elements&quot;);</span>
			}
			final Nucleotide ret;
<span class="nc bnc" id="L399" title="All 2 branches missed.">			if(isEven(currentOffset)){</span>
<span class="nc" id="L400">				ret= ORDINAL_VALUES[currentDecodedBytes[0]];</span>
			}else{
<span class="nc" id="L402">				ret = ORDINAL_VALUES[currentDecodedBytes[1]];</span>
			}
<span class="nc" id="L404">			currentOffset++;</span>
<span class="nc bnc" id="L405" title="All 4 branches missed.">			if(isEven(currentOffset) &amp;&amp; hasNext()){</span>
<span class="nc" id="L406">				byte encodedByte = encodedData[computeEncodedIndexForGlyph(currentOffset)];</span>
<span class="nc" id="L407">				currentDecodedBytes = decodeNext2Values(encodedByte);</span>
			}
<span class="nc" id="L409">			return ret;</span>
		}

		@Override
		public void remove() {
<span class="nc" id="L414">			throw new UnsupportedOperationException(&quot;can not modify immutable sequence&quot;);</span>
			
		}
		
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>