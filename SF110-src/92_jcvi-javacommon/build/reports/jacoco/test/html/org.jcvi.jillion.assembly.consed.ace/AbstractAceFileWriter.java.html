<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractAceFileWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">92_jcvi-javacommon</a> &gt; <a href="index.source.html" class="el_package">org.jcvi.jillion.assembly.consed.ace</a> &gt; <span class="el_source">AbstractAceFileWriter.java</span></div><h1>AbstractAceFileWriter.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2013 J. Craig Venter Institute.
 * 	This file is part of Jillion
 * 
 * 	 Jillion is free software: you can redistribute it and/or modify
 * 	it under the terms of the GNU General Public License as published by
 * 	the Free Software Foundation, either version 3 of the License, or
 * 	(at your option) any later version.
 * 	
 * 	 Jillion is distributed in the hope that it will be useful,
 * 	but WITHOUT ANY WARRANTY; without even the implied warranty of
 * 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * 	GNU General Public License for more details.
 * 	
 * 	You should have received a copy of the GNU General Public License
 * 	along with  Jillion.  If not, see http://www.gnu.org/licenses
 * 
 * Contributors:
 *     Danny Katzel - initial API and implementation
 ******************************************************************************/
package org.jcvi.jillion.assembly.consed.ace;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.jcvi.jillion.assembly.AssembledRead;
import org.jcvi.jillion.assembly.AssemblyUtil;
import org.jcvi.jillion.assembly.Contig;
import org.jcvi.jillion.assembly.consed.phd.Phd;
import org.jcvi.jillion.assembly.consed.phd.PhdDataStore;
import org.jcvi.jillion.core.Direction;
import org.jcvi.jillion.core.Range;
import org.jcvi.jillion.core.Range.CoordinateSystem;
import org.jcvi.jillion.core.datastore.DataStoreException;
import org.jcvi.jillion.core.io.IOUtil;
import org.jcvi.jillion.core.qual.PhredQuality;
import org.jcvi.jillion.core.qual.QualitySequence;
import org.jcvi.jillion.core.residue.nt.NucleotideSequence;
import org.jcvi.jillion.core.util.iter.StreamingIterator;
import org.jcvi.jillion.internal.core.util.JillionUtil;
/**
 * {@code AbstractAceFileWriter}
 * handles most of the work of writing
 * out an Ace formatted file.
 * @author dkatzel
 *
 */
abstract class AbstractAceFileWriter implements AceFileWriter{
	protected static final String CR = &quot;\n&quot;;
	
	protected static final int DEFAULT_BUFFER_SIZE = 2&lt;&lt;14; 
	private final boolean createBsRecords;
	
<span class="nc" id="L58">	 protected AbstractAceFileWriter(boolean createBsRecords) {</span>
<span class="nc" id="L59">		this.createBsRecords = createBsRecords;</span>
<span class="nc" id="L60">	}</span>

	protected void writeAceContigHeader(Writer tempWriter, String contigId, long consensusLength, long numberOfReads,
	    		int numberOfBaseSegments, boolean isComplimented) throws IOException{
<span class="nc" id="L64">	    	String formattedHeader = String.format(&quot;CO %s %d %d %d %s\n&quot;, </span>
	                contigId, 
<span class="nc" id="L66">	                consensusLength,</span>
<span class="nc" id="L67">	                numberOfReads,</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">	                numberOfBaseSegments,</span>
	                isComplimented? &quot;C&quot;:&quot;U&quot;);
	    	
<span class="nc" id="L71">	    	tempWriter.write(formattedHeader);</span>
<span class="nc" id="L72">	    }</span>

	public void write(Writer tempWriter, AceContig contig, PhdDataStore phdDataStore) throws IOException {		
<span class="nc" id="L75">		final NucleotideSequence consensus = contig.getConsensusSequence();</span>
<span class="nc" id="L76">        writeAceContigHeader(tempWriter,</span>
<span class="nc" id="L77">                contig.getId(), </span>
<span class="nc" id="L78">                consensus.getLength(),</span>
<span class="nc" id="L79">                contig.getNumberOfReads(),</span>
                0,
<span class="nc" id="L81">                contig.isComplemented());</span>
<span class="nc" id="L82">        tempWriter.write(String.format(&quot;%s\n\n\n&quot;,AceFileUtil.convertToAcePaddedBasecalls(consensus)));</span>
<span class="nc" id="L83">        writeConsensusQualities(tempWriter,contig.getConsensusQualitySequence());</span>
       
<span class="nc" id="L85">        tempWriter.write(CR);</span>
<span class="nc" id="L86">        List&lt;IdAlignedReadInfo&gt; assembledFroms = IdAlignedReadInfo.getSortedAssembledFromsFor(contig);</span>
<span class="nc" id="L87">        StringBuilder assembledFromBuilder = new StringBuilder();</span>
<span class="nc" id="L88">        StringBuilder placedReadBuilder = new StringBuilder();</span>
        
<span class="nc bnc" id="L90" title="All 2 branches missed.">        for(IdAlignedReadInfo assembledFrom : assembledFroms){</span>
<span class="nc" id="L91">            String id = assembledFrom.getId();</span>
           
<span class="nc" id="L93">            final AceAssembledRead realPlacedRead = contig.getRead(id);</span>
<span class="nc" id="L94">             long fullLength = realPlacedRead.getReadInfo().getUngappedFullLength();</span>
<span class="nc" id="L95">            assembledFromBuilder.append(createAssembledFromRecord(realPlacedRead,fullLength));</span>
<span class="nc" id="L96">            placedReadBuilder.append(createPlacedReadRecord(realPlacedRead,phdDataStore));</span>
<span class="nc" id="L97">        }</span>
       
<span class="nc" id="L99">        placedReadBuilder.append(CR);</span>
<span class="nc" id="L100">        tempWriter.write(assembledFromBuilder.toString());</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">        if(createBsRecords){</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        	for(AceBaseSegment bs : BaseSegmentUtil.computeBestSegmentsFor(contig)){</span>
<span class="nc" id="L103">        		Range gappedRange = bs.getGappedConsensusRange();</span>
<span class="nc" id="L104">        		tempWriter.write(String.format(&quot;BS %d %d %s\n&quot;, </span>
<span class="nc" id="L105">        				gappedRange.getBegin(CoordinateSystem.RESIDUE_BASED),</span>
<span class="nc" id="L106">        				gappedRange.getEnd(CoordinateSystem.RESIDUE_BASED),</span>
<span class="nc" id="L107">        				bs.getReadName()));</span>
<span class="nc" id="L108">        	}</span>
        }
<span class="nc" id="L110">        tempWriter.write(CR);</span>
<span class="nc" id="L111">        tempWriter.write(placedReadBuilder.toString());</span>

		
<span class="nc" id="L114">	}</span>
	
	private void writeConsensusQualities(Writer tempWriter, QualitySequence consensusQualities) throws IOException {
<span class="nc bnc" id="L117" title="All 2 branches missed.">			if(consensusQualities ==null){</span>
<span class="nc" id="L118">				throw new NullPointerException(&quot;consensus qualities can not be null&quot;);</span>
			}
<span class="nc" id="L120">			int qualityLength = (int)consensusQualities.getLength();</span>
<span class="nc" id="L121">			int numberOfLines = qualityLength/50+1;</span>
<span class="nc" id="L122">			StringBuilder formattedString = new StringBuilder(3+ 3* qualityLength+numberOfLines);</span>
<span class="nc" id="L123">			formattedString.append(&quot;BQ\n&quot;);</span>
<span class="nc" id="L124">			Iterator&lt;PhredQuality&gt; iter = consensusQualities.iterator();</span>
<span class="nc" id="L125">			int i=1;</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">			while(i &lt;qualityLength){</span>
<span class="nc" id="L127">				formattedString.append(String.format(&quot;%02d&quot;,iter.next().getQualityScore()));</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">				if(i%50==0){</span>
<span class="nc" id="L129">					formattedString.append(CR);</span>
				}else{
<span class="nc" id="L131">					formattedString.append(' ');</span>
				}
<span class="nc" id="L133">				i++;</span>
			}
			//last quality handled specially so we don't add an extra CR
<span class="nc" id="L136">			formattedString.append(String.format(&quot;%02d&quot;,iter.next().getQualityScore()));</span>
<span class="nc" id="L137">			formattedString.append(CR);</span>
<span class="nc" id="L138">			tempWriter.write(formattedString.toString());</span>
		
<span class="nc" id="L140">	}</span>

	private String createAssembledFromRecord(AceAssembledRead read, long fullLength){
<span class="nc" id="L143">    	IdAlignedReadInfo assembledFrom = IdAlignedReadInfo.createFrom(read, fullLength);</span>
<span class="nc" id="L144">        return String.format(&quot;AF %s %s %d\n&quot;,</span>
<span class="nc" id="L145">                assembledFrom.getId(),</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">                assembledFrom.getDirection()==Direction.FORWARD? &quot;U&quot;:&quot;C&quot;,</span>
<span class="nc" id="L147">                        assembledFrom.getStartOffset());</span>
    }
    
    
    private String createPlacedReadRecord(AceAssembledRead read, PhdDataStore phdDatastore) throws IOException{
    	 Phd phd;
		try {
<span class="nc" id="L154">			phd = phdDatastore.get(read.getId());</span>
<span class="nc" id="L155">		} catch (DataStoreException e) {</span>
<span class="nc" id="L156">			throw new IOException(&quot;error writing quality values for read &quot;+ read.getId(),e);</span>
<span class="nc" id="L157">		}</span>
<span class="nc" id="L158">        return AceFileUtil.createAcePlacedReadRecord(</span>
<span class="nc" id="L159">                read.getId(),read,</span>
                phd, 
<span class="nc" id="L161">                read.getPhdInfo());</span>
        
    }
	
	private static final class IdAlignedReadInfo implements Comparable&lt;IdAlignedReadInfo&gt;{
    	private static final int TO_STRING_BUFFER_SIZE = 30;
		private final String id;
	    private final byte dir;
	    private final int startOffset;
<span class="nc" id="L170">	    private static final Direction[] DIRECTION_VALUES = Direction.values();</span>
	    public static IdAlignedReadInfo createFrom(AssembledRead read, long ungappedFullLength){
	        final Range validRange;
<span class="nc" id="L173">	        Direction dir = read.getDirection();</span>
<span class="nc" id="L174">	        Range readValidRange = read.getReadInfo().getValidRange();</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">	        if(dir==Direction.REVERSE){</span>
<span class="nc" id="L176">	            validRange = AssemblyUtil.reverseComplementValidRange(readValidRange, ungappedFullLength);</span>
	        }
	        else{
<span class="nc" id="L179">	            validRange = readValidRange;</span>
	        }
<span class="nc" id="L181">	        return new IdAlignedReadInfo(read.getId(), </span>
<span class="nc" id="L182">	                (int)(read.getGappedStartOffset()-validRange.getBegin()+1),dir);</span>
	    }
	    
	    public static List&lt;IdAlignedReadInfo&gt; getSortedAssembledFromsFor(
	            Contig&lt;AceAssembledRead&gt; contig){
<span class="nc" id="L187">	        List&lt;IdAlignedReadInfo&gt; assembledFroms = new ArrayList&lt;IdAlignedReadInfo&gt;((int)contig.getNumberOfReads());</span>
<span class="nc" id="L188">	        StreamingIterator&lt;AceAssembledRead&gt; iter = null;</span>
	        try{
<span class="nc" id="L190">	        	iter = contig.getReadIterator();</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">	        	while(iter.hasNext()){</span>
<span class="nc" id="L192">	        		AceAssembledRead read = iter.next();</span>
<span class="nc" id="L193">	        		long fullLength =read.getReadInfo().getUngappedFullLength();</span>
<span class="nc" id="L194">		            assembledFroms.add(IdAlignedReadInfo.createFrom(read, fullLength));</span>
<span class="nc" id="L195">	        	}</span>
	        }finally{
<span class="nc" id="L197">	        	IOUtil.closeAndIgnoreErrors(iter);</span>
	        }
<span class="nc" id="L199">	        Collections.sort(assembledFroms);</span>
<span class="nc" id="L200">	        return assembledFroms;</span>
	    }
	    
<span class="nc" id="L203">		private IdAlignedReadInfo(String id, int startOffset, Direction dir) {</span>
<span class="nc" id="L204">			this.id = id;</span>
<span class="nc" id="L205">			this.dir = (byte)dir.ordinal();</span>
<span class="nc" id="L206">			this.startOffset = startOffset;</span>
<span class="nc" id="L207">		}</span>


		@Override
	    public int hashCode() {
<span class="nc" id="L212">	        final int prime = 31;</span>
<span class="nc" id="L213">	        int result = 1;</span>
<span class="nc" id="L214">	        result = prime * result + id.hashCode();</span>
<span class="nc" id="L215">	        return result;</span>
	    }
	    @Override
	    public boolean equals(Object obj) {
<span class="nc bnc" id="L219" title="All 2 branches missed.">	        if (this == obj){</span>
<span class="nc" id="L220">	            return true;</span>
	        }
<span class="nc bnc" id="L222" title="All 2 branches missed.">	        if (obj == null){</span>
<span class="nc" id="L223">	            return false;</span>
	        }
<span class="nc bnc" id="L225" title="All 2 branches missed.">	        if (!(obj instanceof IdAlignedReadInfo)){</span>
<span class="nc" id="L226">	            return false;</span>
	        }
<span class="nc" id="L228">	        IdAlignedReadInfo other = (IdAlignedReadInfo) obj;</span>
<span class="nc" id="L229">	        return id.equals(other.getId());</span>
	    }
	    public String getId() {
<span class="nc" id="L232">	        return id;</span>
	    }

	    public int getStartOffset() {
<span class="nc" id="L236">	        return startOffset;</span>
	    }
	    
	    public Direction getDirection(){
<span class="nc" id="L240">	        return DIRECTION_VALUES[dir];</span>
	    }
	    @Override
	    public String toString() {
<span class="nc" id="L244">	        StringBuilder builder = new StringBuilder(TO_STRING_BUFFER_SIZE);</span>
<span class="nc" id="L245">	        builder.append(id).append(' ')</span>
<span class="nc" id="L246">	        		.append(startOffset)</span>
<span class="nc" id="L247">	        		.append(&quot;is complemented? &quot;)</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">	        		.append(getDirection() ==Direction.REVERSE);</span>
<span class="nc" id="L249">	        return builder.toString();</span>
	    }
	    /**
	    * Compares two AssembledFrom instances and compares them based on start offset
	    * then by Id.  This should match the order of AssembledFrom records 
	    * (and reads) in an .ace file.
	    */
	    @Override
	    public int compareTo(IdAlignedReadInfo o) {
<span class="nc" id="L258">	    	return JillionUtil.compare(getStartOffset(), o.getStartOffset());	    	     </span>
	        
	    }
    	
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>