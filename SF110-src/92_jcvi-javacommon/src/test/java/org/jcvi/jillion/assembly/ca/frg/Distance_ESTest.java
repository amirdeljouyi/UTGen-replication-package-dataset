/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Fri Mar 15 04:16:19 GMT 2024
 */

package org.jcvi.jillion.assembly.ca.frg;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.jcvi.jillion.assembly.ca.frg.Distance;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class Distance_ESTest extends Distance_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTransformIntoCeleraAssemblerDistanceReturningDistanceWhereGetStdDevIsZero() throws Throwable  {
      // No Comments were added
      Distance arg0 = Distance.buildDistance(724, 724);
      Distance transformIntoCeleraAssemblerDistance = Distance.transformIntoCeleraAssemblerDistance(arg0);
      assertEquals(0.0F, transformIntoCeleraAssemblerDistance.getStdDev(), 0.01F);
      assertEquals(724, transformIntoCeleraAssemblerDistance.getMax());
      assertEquals(724.0F, arg0.getMean(), 0.01F);
      assertEquals(724, transformIntoCeleraAssemblerDistance.getMin());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testTransformIntoCeleraAssemblerDistance() throws Throwable  {
      // Given a distance of 1042 and a standard deviation of 129
      Distance arg0 = Distance.buildDistance(1042, 129);
      
      // When transforming the distance into Celera Assembler format
      Distance transformIntoCeleraAssemblerDistance = Distance.transformIntoCeleraAssemblerDistance(arg0);
      
      // Then the transformed distance should have a maximum of 129
      assertEquals(129, transformIntoCeleraAssemblerDistance.getMax());
      
      // And a minimum of 1042
      assertEquals(1042, transformIntoCeleraAssemblerDistance.getMin());
      
      // And the standard deviation should be within 1% of the original value
      assertEquals((-152.16667F), transformIntoCeleraAssemblerDistance.getStdDev(), 0.01F);
      
      // And the mean should be within 1% of the original value
      assertEquals(585.5F, transformIntoCeleraAssemblerDistance.getMean(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetStdDevReturningPositive() throws Throwable  {
      // Given a distance of -2807 meters with an uncertainty of 0 meters
      Distance buildDistance = Distance.buildDistance(-2807, 0);
      
      // When the mean, min, max and standard deviation of the distance are calculated
      float mean = buildDistance.getMean();
      int min = buildDistance.getMin();
      int max = buildDistance.getMax();
      float stdDev = buildDistance.getStdDev();
      
      // Then the mean should be -1403.5 meters, the minimum value should be -2807, the maximum value should be 0, and the standard deviation should be 467.83334 meters
      assertEquals(-1403.5F, mean, 0.01F);
      assertEquals(-2807, min);
      assertEquals(0, max);
      assertEquals(467.83334F, stdDev, 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetStdDevReturningNegative() throws Throwable  {
      // Given a Distance with values 6555 and -3448
      Distance distance = Distance.buildDistance(6555, (-3448));
      
      // When the stdDev method is called on the Distance object
      float stdDev = distance.getStdDev();
      
      // Then the returned value should be close to -1667.1666F
      assertEquals((-1667.1666F), stdDev, 0.01F);
      
      // And the mean of the Distance object should be close to 1553.5F
      assertEquals(1553.5F, distance.getMean(), 0.01F);
      
      // And the min value of the Distance object should be 6555
      assertEquals(6555, distance.getMin());
      
      // And the max value of the Distance object should be -3448
      assertEquals((-3448), distance.getMax());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMinReturningPositive() throws Throwable  {
      // Given a distance with values for mean, standard deviation, and minimum
      Distance buildDistance = Distance.buildDistance(1566.0851F, (-1.0F));
      
      // When the getMin method is called
      int min = buildDistance.getMin();
      
      // Then the minimum value is returned
      assertEquals(1563, min);
      
      // And the other methods return the expected values
      assertEquals(1566.0851F, buildDistance.getMean(), 0.01F);
      assertEquals(1569, buildDistance.getMax());
      assertEquals((-1.0F), buildDistance.getStdDev(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMeanReturningZero() throws Throwable  {
      // Given a Distance object with values (-238, 1, 0.0F, 1.0F)
      Distance buildDistance = Distance.buildDistance(-238, 1, 0.0F, 1.0F);
      
      // When the mean is calculated
      float mean = buildDistance.getMean();
      
      // Then the mean should be equal to 1.0F with a tolerance of 0.01F
      assertEquals(1.0F, mean, 0.01F);
      
      // And when the standard deviation is calculated
      float stdDev = buildDistance.getStdDev();
      
      // Then the standard deviation should be equal to 1.0F with a tolerance of 0.01F
      assertEquals(1.0F, stdDev, 0.01F);
      
      // And when the maximum value is calculated
      int max = buildDistance.getMax();
      
      // Then the maximum value should be equal to 1
      assertEquals(1, max);
      
      // And when the minimum value is calculated
      float min = buildDistance.getMin();
      
      // Then the minimum value should be equal to 0.0F with a tolerance of 0.01F
      assertEquals(0.0F, min, 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMeanReturningPositive() throws Throwable  {
      // rollbacked to evosuite
      Distance buildDistance = Distance.buildDistance(6555, (-3448));
      float mean = buildDistance.getMean();
      assertEquals((-3448), buildDistance.getMax());
      assertEquals(1553.5F, mean, 0.01F);
      assertEquals(6555, buildDistance.getMin());
      assertEquals((-1667.1666F), buildDistance.getStdDev(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMaxReturningZero() throws Throwable  {
      // Given a distance of 6555 meters with a maximum value of 0
      Distance buildDistance = Distance.buildDistance(6555, 0);
      
      // When the max value is retrieved
      int max = buildDistance.getMax();
      
      // Then the expected maximum value of 0 is returned
      assertEquals(0, max);
      
      // And when the minimum value is retrieved
      int min = buildDistance.getMin();
      
      // Then the expected minimum value of 6555 is returned
      assertEquals(6555, min);
      
      // And when the mean value is retrieved
      float mean = buildDistance.getMean();
      
      // Then the expected mean value of 3277.5 is returned with a tolerance of 0.01F
      assertEquals(3277.5F, mean, 0.01F);
      
      // And when the standard deviation value is retrieved
      float stdDev = buildDistance.getStdDev();
      
      // Then the expected standard deviation value of -1092.5F is returned with a tolerance of 0.01F
      assertEquals(-1092.5F, stdDev, 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMaxReturningPositive() throws Throwable  {
      // No Comments were added
      Distance buildDistance = Distance.buildDistance(724, 724);
      int max = buildDistance.getMax();
      assertEquals(724.0F, buildDistance.getMean(), 0.01F);
      assertEquals(0.0F, buildDistance.getStdDev(), 0.01F);
      assertEquals(724, buildDistance.getMin());
      assertEquals(724, max);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBuildDistanceTaking4ArgumentsReturningDistanceWhereGetMeanIsNegative() throws Throwable  {
      // rollbacked to evosuite
      Distance buildDistance = Distance.buildDistance((-1395), 0, (float) (-49), 169.2F);
      assertEquals((-49.0F), buildDistance.getMean(), 0.01F);
      assertEquals(169.2F, buildDistance.getStdDev(), 0.01F);
      assertEquals(0, buildDistance.getMax());
      assertEquals((-1395), buildDistance.getMin());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBuildDistanceTaking4ArgumentsReturningDistanceWhereGetMaxIsPositive() throws Throwable  {
      // Given a Distance object with values for max, mean, standard deviation, and minimum
      Distance buildDistance = Distance.buildDistance(0, 6555, 125.91027F, 0.0F);
      
      // When the getMax method is called on the Distance object
      int actualMax = buildDistance.getMax();
      
      // Then the maximum value should be equal to 6555
      assertEquals(6555, actualMax);
      
      // When the getStdDev method is called on the Distance object
      float actualStdDev = buildDistance.getStdDev();
      
      // Then the standard deviation should be close to 0.01F
      assertEquals(0.01F, actualStdDev, 0.01F);
      
      // When the getMin method is called on the Distance object
      int actualMin = buildDistance.getMin();
      
      // Then the minimum value should be equal to 0
      assertEquals(0, actualMin);
      
      // When the getMean method is called on the Distance object
      float actualMean = buildDistance.getMean();
      
      // Then the mean value should be close to 125.91027F
      assertEquals(125.91027F, actualMean, 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBuildDistanceTaking2IntsReturningDistanceWhereGetMeanIsZero() throws Throwable  {
      // Given a distance with mean, minimum, and maximum values
      Distance buildDistance = Distance.buildDistance(1, (-1));
      
      // When calculating the standard deviation of the distance
      float stdDev = buildDistance.getStdDev();
      
      // Then the standard deviation should be negative one-third of the range
      assertEquals((-0.33333334F), stdDev, 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBuildDistanceTaking2IntsReturningDistanceWhereGetMinIsZero() throws Throwable  {
      // Given a Distance object with mean = 0, max = 1634, and min = 0
      Distance arg0 = Distance.buildDistance(0, 1634);
      
      // When we transform this distance into Celera Assembler's distance format
      Distance transformIntoCeleraAssemblerDistance = Distance.transformIntoCeleraAssemblerDistance(arg0);
      
      // Then the transformed distance should have mean = 817.0F, max = 1634, min = 0, and stdDev = 272.33334F
      assertEquals(817.0F, transformIntoCeleraAssemblerDistance.getMean(), 0.01F);
      assertEquals(1634, transformIntoCeleraAssemblerDistance.getMax());
      assertEquals(0, transformIntoCeleraAssemblerDistance.getMin());
      assertEquals(272.33334F, transformIntoCeleraAssemblerDistance.getStdDev(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBuildDistanceTaking2FloatsReturningDistanceWhereGetMaxIsPositive() throws Throwable  {
      // Given a distance of 3290.25 meters with a standard deviation of 6.0 meters
      Distance buildDistance = Distance.buildDistance(3290.25F, 6.0F);
      
      // When the min value is requested
      int actualMin = buildDistance.getMin();
      
      // Then the expected min value of 3272 is returned
      assertEquals(3272, actualMin);
      
      // When the standard deviation is requested
      float actualStdDev = buildDistance.getStdDev();
      
      // Then the expected standard deviation of 6.0 meters is returned
      assertEquals(6.0F, actualStdDev, 0.01F);
      
      // When the max value is requested
      int actualMax = buildDistance.getMax();
      
      // Then the expected max value of 3308 is returned
      assertEquals(3308, actualMax);
      
      // When the mean value is requested
      float actualMean = buildDistance.getMean();
      
      // Then the expected mean value of 3290.25 meters is returned
      assertEquals(3290.25F, actualMean, 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBuildDistanceTaking2FloatsReturningDistanceWhereGetMinIsZero() throws Throwable  {
      // rollbacked to evosuite
      Distance buildDistance = Distance.buildDistance(0.0F, (float) 0);
      assertEquals(0.0F, buildDistance.getMean(), 0.01F);
      assertEquals(0, buildDistance.getMax());
      assertEquals(0.0F, buildDistance.getStdDev(), 0.01F);
      assertEquals(0, buildDistance.getMin());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBuildDistanceTaking2FloatsReturningDistanceWhereGetMaxIsNegative() throws Throwable  {
      // This test is checking the functionality of the Distance class by creating a new instance with a mean of -1515 and no standard deviation. It then checks that the getMean, getMin, getMax, and getStdDev methods are returning the expected values.
      Distance buildDistance = Distance.buildDistance((float) (-1515), 0.0F);
      assertEquals((-1515.0F), buildDistance.getMean(), 0.01F);
      assertEquals((-1515), buildDistance.getMin());
      assertEquals((-1515), buildDistance.getMax());
      assertEquals(0.0F, buildDistance.getStdDev(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMaxReturningNegative() throws Throwable  {
      // No Comments were added
      Distance buildDistance = Distance.buildDistance(6555, (-3448));
      int max = buildDistance.getMax();
      assertEquals(6555, buildDistance.getMin());
      assertEquals(1553.5F, buildDistance.getMean(), 0.01F);
      assertEquals((-1667.1666F), buildDistance.getStdDev(), 0.01F);
      assertEquals((-3448), max);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMinReturningNegative() throws Throwable  {
      // Create a new instance of the Distance class with negative values
      Distance buildDistance = Distance.buildDistance((-238), (-238));
      
      // Get the minimum and maximum values from the Distance object
      int min = buildDistance.getMin();
      int max = buildDistance.getMax();
      
      // Assert that the minimum value is equal to the negative of the maximum value
      assertEquals(min, -max);
      
      // Assert that the standard deviation of the Distance object is equal to zero
      assertEquals(0.0F, buildDistance.getStdDev(), 0.01F);
      
      // Assert that the mean of the Distance object is equal to the negative of the maximum value
      assertEquals((-max), buildDistance.getMean(), 0.01F);
      
      // Assert that the minimum value is equal to the negative of the maximum value
      assertEquals(min, -max);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetStdDevReturningZero() throws Throwable  {
      // No Comments were added
      Distance buildDistance = Distance.buildDistance((-238), (-238));
      float stdDev = buildDistance.getStdDev();
      assertEquals((-238), buildDistance.getMin());
      assertEquals(0.0F, stdDev, 0.01F);
      assertEquals((-238), buildDistance.getMax());
      assertEquals((-238.0F), buildDistance.getMean(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMeanReturningNegative() throws Throwable  {
      // No Comments were added
      Distance buildDistance = Distance.buildDistance((-238), (-238));
      float mean = buildDistance.getMean();
      assertEquals(0.0F, buildDistance.getStdDev(), 0.01F);
      assertEquals((-238.0F), mean, 0.01F);
      assertEquals((-238), buildDistance.getMin());
      assertEquals((-238), buildDistance.getMax());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBuildDistanceTaking2IntsReturningDistanceWhereGetStdDevIsZero() throws Throwable  {
      // Given two distances with the same values
      Distance buildDistance = Distance.buildDistance((-49), (-49));
      Distance arg0 = Distance.buildDistance((-49), (-49));
      
      // When we compare them for equality
      boolean equals = buildDistance.equals(arg0);
      
      // Then they should be equal
      assertTrue(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBuildDistanceTaking4ArgumentsReturningDistanceWhereGetMinIsPositive() throws Throwable  {
      // Test that two distances with the same values are equal.
      Distance buildDistance = Distance.buildDistance(0, 0, (float) 0, (float) 0);
      Distance arg0 = Distance.buildDistance(1092705414, 0, (float) 0, (-106.4841F));
      assertFalse(buildDistance.equals(arg0));
      // Test that two distances with different values are not equal.
      assertNotEquals((-106.4841F), arg0.getStdDev(), 0.01F);
      assertNotEquals(0, arg0.getMax());
      assertNotEquals(1092705414, arg0.getMin());
      assertNotEquals(0.0F, arg0.getMean(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBuildDistanceTaking4ArgumentsReturningDistanceWhereGetMaxIsNegative() throws Throwable  {
      // Given a distance with negative values
      Distance buildDistance = Distance.buildDistance(-2360, -2360);
      
      // When we call the equals method with another distance object
      Distance arg0 = Distance.buildDistance(-2360, -2360, 1.0F, -835.97F);
      boolean equals = buildDistance.equals(arg0);
      
      // Then we expect the following values:
      assertEquals(0.0F, buildDistance.getStdDev(), 0.01F);
      assertEquals(-2360, arg0.getMin());
      assertEquals(-2360, arg0.getMax());
      assertEquals(-2360, buildDistance.getMin());
      assertEquals(1.0F, arg0.getMean(), 0.01F);
      assertFalse(equals);
      assertEquals(-2360.0F, buildDistance.getMean(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsReturningFalse() throws Throwable  {
      // Create two Distance objects with different values
      Distance buildDistance = Distance.buildDistance((-49), (-49));
      Distance arg0 = Distance.buildDistance((-49), (-845));
      
      // Assert that the mean of the second object is equal to -447.0F
      assertEquals((-447.0F), arg0.getMean(), 0.01F);
      
      // Assert that the first object does not equal the second object
      assertFalse(buildDistance.equals(arg0));
      
      // Assert that the min value of the second object is equal to -49
      assertEquals((-49), arg0.getMin());
      
      // Assert that the standard deviation of the second object is equal to -132.6667F
      assertEquals((-132.66667F), arg0.getStdDev(), 0.01F);
      
      // Assert that the max value of the second object is equal to -845
      assertEquals((-845), arg0.getMax());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsWithNonNull() throws Throwable  {
      // Given a Distance object with some values
      Distance buildDistance = Distance.buildDistance(-2807, 0);
      
      // When the equals method is called with an Object that is not a Distance instance
      Object arg0 = new Object();
      boolean equals = buildDistance.equals(arg0);
      
      // Then the result should be false
      assertFalse(equals);
      
      // And the values of the original Distance object should be maintained
      assertEquals(-2807, buildDistance.getMin());
      assertEquals(467.83334F, buildDistance.getStdDev(), 0.01F);
      assertEquals(0, buildDistance.getMax());
      assertEquals(-1403.5F, buildDistance.getMean(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEqualsWithNull() throws Throwable  {
      // Given a Distance object with mean=0, stdDev=-2765.95, max=0, min=0
      Distance buildDistance = Distance.buildDistance(0, 0, (float) 0, (-2765.95F));
      
      // When the equals method is called with null as an argument
      boolean equals = buildDistance.equals((Object) null);
      
      // Then the result should be false
      assertFalse(equals);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEquals() throws Throwable  {
      // This test creates a Distance object with two values and verifies that it is equal to itself
      Distance arg0 = Distance.buildDistance((-2386.8723F), (-2386.8723F));
      boolean equals = arg0.equals(arg0);
      assertEquals((-2386.8723F), arg0.getMean(), 0.01F); // Verify that the mean of the Distance object is equal to the expected value
      assertEquals((-2386.8723F), arg0.getStdDev(), 0.01F); // Verify that the standard deviation of the Distance object is equal to the expected value
      assertEquals(4773, arg0.getMax()); // Verify that the maximum value of the Distance object is equal to the expected value
      assertTrue(equals); // Verify that the Distance object is equal to itself
      assertEquals((-9547), arg0.getMin()); // Verify that the minimum value of the Distance object is equal to the expected value
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testBuildDistanceTaking4Arguments() throws Throwable  {
      // Given: We have a Distance object with some values
      Distance arg0 = Distance.buildDistance(0, 0, (float) 0, (-2765.95F));
      
      // When: We transform the Distance into a Celera Assembler distance
      Distance transformIntoCeleraAssemblerDistance = Distance.transformIntoCeleraAssemblerDistance(arg0);
      
      // Then: The transformed distance should have the same mean, standard deviation, max, and min as the original distance
      assertEquals(0.0F, transformIntoCeleraAssemblerDistance.getMean(), 0.01F);
      assertEquals((-2765.95F), transformIntoCeleraAssemblerDistance.getStdDev(), 0.01F);
      assertEquals(0, transformIntoCeleraAssemblerDistance.getMax());
      assertEquals(0, transformIntoCeleraAssemblerDistance.getMin());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMinReturningZero() throws Throwable  {
      // rollbacked to evosuite
      Distance buildDistance = Distance.buildDistance(0, 0, (float) 0, 6.0F);
      int min = buildDistance.getMin();
      assertEquals(0, min);
      assertEquals(0, buildDistance.getMax());
      assertEquals(6.0F, buildDistance.getStdDev(), 0.01F);
      assertEquals(0.0F, buildDistance.getMean(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHashCode() throws Throwable  {
      // Create a Distance object with negative values for max, min and mean
      Distance buildDistance = Distance.buildDistance(-49, -49);
      
      // Check that the hashCode method returns the expected value
      assertEquals(-49, buildDistance.hashCode());
      
      // Check that the getMax method returns the expected value
      assertEquals(-49, buildDistance.getMax());
      
      // Check that the getStdDev method returns the expected value with a tolerance of 0.01F
      assertEquals(0.0F, buildDistance.getStdDev(), 0.01F);
      
      // Check that the getMin method returns the expected value
      assertEquals(-49, buildDistance.getMin());
      
      // Check that the getMean method returns the expected value with a tolerance of 0.01F
      assertEquals(-49.0F, buildDistance.getMean(), 0.01F);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testToString() throws Throwable  {
      // Given: A Distance object with min and max values of -49
      Distance buildDistance = Distance.buildDistance(-49, -49);
      
      // When: We call the toString method on the Distance object
      String string = buildDistance.toString();
      
      // Then: The resulting string should be "-49.000, std: 0.000"
      assertEquals("-49.000, std: 0.000", string);
      
      // Then: We expect the min and max values of the Distance object to be -49
      assertEquals(-49, buildDistance.getMin());
      assertEquals(-49, buildDistance.getMax());
  }
}
