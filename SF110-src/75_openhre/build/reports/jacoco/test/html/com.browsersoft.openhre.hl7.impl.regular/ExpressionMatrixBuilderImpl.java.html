<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExpressionMatrixBuilderImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">75_openhre</a> &gt; <a href="index.source.html" class="el_package">com.browsersoft.openhre.hl7.impl.regular</a> &gt; <span class="el_source">ExpressionMatrixBuilderImpl.java</span></div><h1>ExpressionMatrixBuilderImpl.java</h1><pre class="source lang-java linenums">/*
 *   ====================================================================
 *                 Open Source Health Records Exchange
 *   ====================================================================
 *
 *   Copyright (C) 2006 Browsersoft Inc.
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License, version 2,
 *   as published by the Free Software Foundation.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   The GNU General Public License is available at
 *   http://www.fsf.org/licensing/licenses/gpl.html
 *
 *   Email: info@openhre.org
 *   Web:   http://www.openhre.org
 */

package com.browsersoft.openhre.hl7.impl.regular;

import com.browsersoft.openhre.hl7.api.regular.Expression;
import com.browsersoft.openhre.hl7.api.regular.ExpressionMatrix;
import com.browsersoft.openhre.hl7.api.regular.ExpressionMatrixBuilder;
import com.browsersoft.openhre.hl7.api.regular.ExpressionPart;
import com.browsersoft.openhre.hl7.api.regular.InvalidExpressionException;

<span class="nc" id="L32">public class ExpressionMatrixBuilderImpl implements ExpressionMatrixBuilder {</span>

    private static final int GROUP_TYPE_NORMAL = 0;
    private static final int GROUP_TYPE_OPTIONAL = 1;

    public ExpressionMatrix buildMatrix( Expression expression ) throws InvalidExpressionException {

<span class="nc" id="L39">        ExpressionMatrix matrix = new ExpressionMatrixImpl();</span>
<span class="nc" id="L40">        int numberOfElements = expression.getNumberOfElementTypes();</span>

<span class="nc" id="L42">        matrix.creatMatrix(numberOfElements);</span>

<span class="nc" id="L44">        buildProcess(matrix, expression);</span>

<span class="nc" id="L46">        return matrix;</span>

    }

    private void buildProcess( ExpressionMatrix matrix, Expression expression ) throws InvalidExpressionException {
        //first node
<span class="nc" id="L52">        matrix.addNewNode();</span>

<span class="nc" id="L54">        processSubExpression(matrix, expression, 0, expression.size() - 1, GROUP_TYPE_NORMAL);</span>

<span class="nc" id="L56">    }</span>

    private ExpressionNodeList processSubExpression( ExpressionMatrix matrix, Expression expression, int start, int end, int typeOfGroup ) throws InvalidExpressionException {

<span class="nc" id="L60">        NodeStack repeatableStack = new NodeStack();</span>

<span class="nc" id="L62">        ExpressionNodeList terminalNodes = new ExpressionNodeList();</span>
<span class="nc" id="L63">        int startNode = getActualIndexOfNode(expression, start, end);</span>
<span class="nc" id="L64">        terminalNodes.addItem(startNode);</span>

<span class="nc" id="L66">        int realStart = start;</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">        if ( typeOfGroup != GROUP_TYPE_NORMAL ) {</span>
<span class="nc" id="L68">            realStart++;</span>
        }

<span class="nc bnc" id="L71" title="All 2 branches missed.">        for ( int i = realStart; i &lt;= end; i++ ) {</span>

<span class="nc" id="L73">            ExpressionPart part = expression.getItem(i);</span>
<span class="nc bnc" id="L74" title="All 5 branches missed.">            switch ( part.getType() ) {</span>

                case ExpressionPart.OPEN_REPEATABLE: {
<span class="nc" id="L77">                    repeatableStack.push( getActualIndexOfNode(expression, i, end) );</span>
<span class="nc" id="L78">                    break;</span>
                }
                case ExpressionPart.OPEN_OPTIONAL: {

<span class="nc" id="L82">                    int endOfGroup = getEndOfGroup(expression, i);</span>
<span class="nc" id="L83">                    ExpressionNodeList terminalsFromGroup = processSubExpression(matrix, expression, i, endOfGroup, GROUP_TYPE_OPTIONAL);</span>
<span class="nc" id="L84">                    int startNodeOfGroup = getActualIndexOfNode(expression, i, endOfGroup);</span>

<span class="nc" id="L86">                    ConnectionList connections = getAllConnectionsFromNode(matrix, startNodeOfGroup);</span>

<span class="nc bnc" id="L88" title="All 2 branches missed.">                    for ( int j = 0; j &lt; terminalNodes.size(); j++ ) {</span>

<span class="nc" id="L90">                        int terminalItem = terminalNodes.getItem(j);</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">                        if ( terminalItem != startNodeOfGroup ) {</span>

<span class="nc bnc" id="L93" title="All 2 branches missed.">                            for ( int k = 0; k &lt; connections.size(); k++ ) {</span>
<span class="nc" id="L94">                                Connection connection = connections.getItem(k);</span>
<span class="nc" id="L95">                                matrix.setValue(terminalItem, connection.getElementID(), connection.getTo());</span>
                            }

                        }

                    }

<span class="nc" id="L102">                    terminalNodes.addExpressionList(terminalsFromGroup);</span>

<span class="nc" id="L104">                    i = endOfGroup;</span>

<span class="nc" id="L106">                    break;</span>
                }
                case ExpressionPart.ELEMENT: {
<span class="nc" id="L109">                    matrix.addNewNode();</span>
<span class="nc" id="L110">                    int indexOfNodeAfterElement = part.getElementID() + 1;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">                    for ( int j = 0; j &lt; terminalNodes.size(); j++ ) {</span>
<span class="nc" id="L112">                        matrix.setValue(terminalNodes.getItem(j), part.getElementID(), indexOfNodeAfterElement);</span>
                    }
<span class="nc" id="L114">                    terminalNodes.clearAll();</span>
<span class="nc" id="L115">                    terminalNodes.addItem(indexOfNodeAfterElement);</span>
<span class="nc" id="L116">                    break;</span>
                }
                case ExpressionPart.CLOSE_REPEATABLE: {

<span class="nc" id="L120">                    int repeatableBeginNode = repeatableStack.pop();</span>

<span class="nc" id="L122">                    ConnectionList connections = getAllConnectionsFromNode(matrix, repeatableBeginNode);</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">                    for ( int j = 0; j &lt; terminalNodes.size(); j++ ) {</span>

<span class="nc" id="L126">                        int terminalItem = terminalNodes.getItem(j);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">                        if ( terminalItem &gt; repeatableBeginNode ) {</span>

<span class="nc bnc" id="L129" title="All 2 branches missed.">                            for ( int k = 0; k &lt; connections.size(); k++ ) {</span>
<span class="nc" id="L130">                                Connection connection = connections.getItem(k);</span>
<span class="nc" id="L131">                                matrix.setValue(terminalItem, connection.getElementID(), connection.getTo());</span>
                            }

                        }

                    }

<span class="nc" id="L138">                    break;</span>
                }

            }
        }

<span class="nc bnc" id="L144" title="All 2 branches missed.">        if ( typeOfGroup == GROUP_TYPE_OPTIONAL ) {</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">            if ( !terminalNodes.isInList(startNode) ) {</span>
<span class="nc" id="L146">                terminalNodes.addItem(startNode);</span>
            }
        }

<span class="nc" id="L150">        return terminalNodes;</span>

    }


    private ConnectionList getAllConnectionsFromNode( ExpressionMatrix matrix, int node ) {

<span class="nc" id="L157">        ConnectionList list = new ConnectionList();</span>

<span class="nc bnc" id="L159" title="All 2 branches missed.">        for ( int j = 0; j &lt; matrix.getNumberOfElements(); j++ ) {</span>
<span class="nc" id="L160">            int connection = matrix.getValue(node, j);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            if ( connection != (-1) ) {</span>
<span class="nc" id="L162">                Connection connectionObject = new Connection();</span>
<span class="nc" id="L163">                connectionObject.setElementID(j);</span>
<span class="nc" id="L164">                connectionObject.setTo(connection);</span>
<span class="nc" id="L165">                connectionObject.setFrom(node);</span>
<span class="nc" id="L166">                list.addItem(connectionObject);</span>
            }
        }

<span class="nc" id="L170">        return list;</span>

    }

    private int getActualIndexOfNode( Expression expression, int index, int max ) throws InvalidExpressionException {
<span class="nc bnc" id="L175" title="All 2 branches missed.">        for ( int j = index; j &lt;= max; j++ ) {</span>
<span class="nc" id="L176">            ExpressionPart p = expression.getItem(j);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            if ( p.getType() == ExpressionPart.ELEMENT ) {</span>
<span class="nc" id="L178">                return p.getElementID();</span>
            }
        }
<span class="nc" id="L181">        throw new InvalidExpressionException();</span>
    }

    private int getEndOfGroup( Expression expression, int start ) throws InvalidExpressionException {

<span class="nc" id="L186">        ExpressionPart partStart = expression.getItem(start);</span>
<span class="nc" id="L187">        int openType = partStart.getType();</span>
<span class="nc" id="L188">        int closeType = -1;</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">        if ( openType == ExpressionPart.OPEN_OPTIONAL ) {</span>
<span class="nc" id="L191">            closeType = ExpressionPart.CLOSE_OPTIONAL;</span>
        }
<span class="nc bnc" id="L193" title="All 2 branches missed.">        if ( openType == ExpressionPart.OPEN_REPEATABLE ) {</span>
<span class="nc" id="L194">            closeType = ExpressionPart.CLOSE_REPEATABLE;</span>
        }

<span class="nc" id="L197">        int level = 0;</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">        for ( int i = start; i &lt; expression.size(); i++ ) {</span>

<span class="nc" id="L200">            ExpressionPart part = expression.getItem(i);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">            if ( part.getType() == openType ) {</span>
<span class="nc" id="L202">                level++;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            } else if ( part.getType() == closeType ) {</span>
<span class="nc" id="L204">                level--;</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                if ( level == 0 ) {</span>
<span class="nc" id="L206">                    return i;</span>
                }
            }

        }

<span class="nc" id="L212">        throw new InvalidExpressionException();</span>

    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>