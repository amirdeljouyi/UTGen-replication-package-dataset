/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Wed Mar 13 10:59:12 GMT 2024
 */

package com.lts.io;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import com.lts.io.DirectoryScanner;
import java.io.File;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class DirectoryScanner_ESTest extends DirectoryScanner_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSlowScanThrowsNullPointerException() throws Throwable  {
      DirectoryScanner directoryScanner = new DirectoryScanner();
      
      // Undeclared exception!
      try {
      directoryScanner.slowScan();
      fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      // Verify that the thrown exception is an instance of the expected type
      verifyException("com.lts.io.DirectoryScanner", e);
      
      // Check if the message in the exception is null
      assertEquals(null, e.getMessage());}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchPatternStartReturningFalse() throws Throwable  {
      // rollbacked to evosuite
      boolean matchPatternStart = DirectoryScanner.matchPatternStart("**A/#*#", "**/CVS");
      assertFalse(matchPatternStart);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsIncludedReturningFalse() throws Throwable  {
      // Given a DirectoryScanner instance with an includes array containing empty strings and "hB?",
      DirectoryScanner directoryScanner = new DirectoryScanner();
      String[] stringArray = new String[2];
      directoryScanner.includes = stringArray;
      stringArray[0] = "";
      stringArray[1] = "hB?";
      
      // When the isIncluded method is called with the argument "a4jaH+Xt5=yuD 7%xr,"
      boolean included = directoryScanner.isIncluded("a4jaH+Xt5=yuD 7%xr,");
      
      // Then the method should return false because the input string does not match any of the included patterns
      assertFalse(included);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsExcludedReturningTrue() throws Throwable  {
      // Create a new DirectoryScanner instance
      DirectoryScanner directoryScanner = new DirectoryScanner();
      
      // Define an array of file patterns to exclude
      String[] excludedPatterns = new String[1];
      excludedPatterns[0] = "**/";
      directoryScanner.setExcludes(excludedPatterns);
      
      // Test whether a given file path is excluded
      boolean excluded = directoryScanner.isExcluded("**/");
      
      // Assert that the file path is indeed excluded
      assertTrue(excluded);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsExcludedReturningFalse() throws Throwable  {
      // Given a DirectoryScanner instance with an empty exclude list,
      DirectoryScanner directoryScanner = new DirectoryScanner();
      String[] arg0 = new String[0];
      directoryScanner.setExcludes(arg0);
      
      // When the isExcluded method is called with a file name that does not match any of the excluded patterns,
      boolean excluded = directoryScanner.isExcluded("czW5}[I%;D");
      
      // Then it should return false, indicating that the file is not excluded.
      assertFalse(excluded);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetBasedirReturningFileWhereLengthIsPositive() throws Throwable  {
      // Given a file name "lHU" and an array of bytes with length 5
      EvoSuiteFile arg0 = new EvoSuiteFile("lHU");
      byte[] arg1 = new byte[5];
      
      // When the method appendDataToFile is called on the file object with the given arguments
      FileSystemHandling.appendDataToFile(arg0, arg1);
      
      // Then the free space of the directory should be 0L
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.setBasedir("lHU");
      File basedir = directoryScanner.getBasedir();
      assertEquals(0L, basedir.getFreeSpace());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetBasedirReturningFileWhereIsDirectoryIsTrue() throws Throwable  {
      // Given: We have a directory scanner that has been initialized with a base directory
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.setBasedir("");
      
      // When: We retrieve the basedir of the directory scanner
      File basedir = directoryScanner.getBasedir();
      
      // Then: The basedir should be an empty directory with no files
      assertEquals(0L, basedir.length());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetBasedirReturningFileWhereLastModifiedIsZero() throws Throwable  {
      // Given a DirectoryScanner instance that scans for files in a specific directory
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.setBasedir("/**/.cvsignore");
      File basedir = directoryScanner.getBasedir();
      
      // When the DirectoryScanner is initialized with a base directory that contains a .cvsignore file
      
      // Then the name of the basedir should be ".cvsignore"
      assertEquals(".cvsignore", basedir.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testScandirThrowsException() throws Throwable  {
      // rollbacked to evosuite
      DirectoryScanner directoryScanner = new DirectoryScanner();
      File arg0 = MockFile.createTempFile("*jt`/CVS*", "*jt`/CVS*");
      try { 
        directoryScanner.scandir(arg0, "*jt`/CVS*", true);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // IO error scanning directory /tmp/*jt`/CVS*0*jt`/CVS*
         //
         verifyException("com.lts.io.DirectoryScanner", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetBasedirTakingFile() throws Throwable  {
      // Given: a directory scanner and a file object representing the base directory to scan
      DirectoryScanner directoryScanner = new DirectoryScanner();
      MockFile basedir = new MockFile("helloWorld");
      
      // When: setting the base directory for the scanner
      directoryScanner.setBasedir(basedir);
      
      // Then: the length of the file object representing the base directory should be zero
      assertEquals(0L, basedir.length());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAddDefaultExcludes() throws Throwable  {
      // rollbacked to evosuite
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.addDefaultExcludes();
      directoryScanner.addDefaultExcludes();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetExcludedDirectoriesReturningNonEmptyArray() throws Throwable  {
      // Given: A directory scanner with a base directory and exclude patterns
      DirectoryScanner directoryScanner = new DirectoryScanner();
      String basedir = "*t/CVS/*";
      String[] excludes = new String[] { "*" };
      directoryScanner.setBasedir(basedir);
      directoryScanner.setExcludes(excludes);
      
      // When: The scan method is called with the exclude patterns
      directoryScanner.scan();
      
      // Then: The excluded directories should be returned correctly
      String[] excludedDirectories = directoryScanner.getExcludedDirectories();
      assertEquals(1, excludedDirectories.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNotIncludedDirectoriesReturningNonEmptyArray() throws Throwable  {
      // Given a DirectoryScanner instance with a basedir of **#/CV<Y/** and includes of **#/CV<Y/**
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.setBasedir("**#/CV<Y/**");
      String[] includes = new String[5];
      includes[0] = "**#/CV<Y/**";
      includes[1] = "**#/CV<Y/**";
      includes[2] = "**#/CV<Y/**";
      includes[3] = "**#/CV<Y/**";
      includes[4] = "**#/CV<Y/**";
      directoryScanner.setIncludes(includes);
      
      // When the scan method is called
      MockFile arg2 = new MockFile("**#/CV<Y/**", "**#/CV<Y/**");
      MockFile.createTempFile("**#/CV<Y/**", "**#/CV<Y/**", (File) arg2);
      directoryScanner.scan();
      
      // Then the notIncludedDirectories array should have a length of 1
      String[] notIncludedDirectories = directoryScanner.getNotIncludedDirectories();
      assertEquals(1, notIncludedDirectories.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetIncludedDirectoriesReturningEmptyArray() throws Throwable  {
      // Given: A directory scanner is created with a base directory set to an empty string
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.setBasedir("");
      
      // When: The scan method is called on the directory scanner
      directoryScanner.scan();
      
      // Then: The included directories array should be empty
      String[] includedDirectories = directoryScanner.getIncludedDirectories();
      assertEquals(0, includedDirectories.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNotIncludedFilesReturningNonEmptyArray() throws Throwable  {
      // rollbacked to evosuite
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.setBasedir("~@OM0Fej");
      MockFile arg2 = new MockFile("~@OM0Fej");
      MockFile.createTempFile("~@OM0Fej", "~@OM0Fej", (File) arg2);
      directoryScanner.scan();
      String[] notIncludedFiles = directoryScanner.getNotIncludedFiles();
      assertEquals(1, notIncludedFiles.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNotIncludedFilesReturningEmptyArray() throws Throwable  {
      // rollbacked to evosuite
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.setBasedir("");
      directoryScanner.scan();
      String[] notIncludedFiles = directoryScanner.getNotIncludedFiles();
      assertEquals(0, notIncludedFiles.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetIncludedFilesReturningNonEmptyArray() throws Throwable  {
      // rollbacked to evosuite
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.setBasedir("*t/b%[fS/*");
      MockFile arg2 = new MockFile("*t/b%[fS/*", "*t/b%[fS/*");
      MockFile.createTempFile("*t/b%[fS/*", "*t/b%[fS/*", (File) arg2);
      directoryScanner.scan();
      String[] includedFiles = directoryScanner.getIncludedFiles();
      assertEquals(1, includedFiles.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetIncludedDirectoriesReturningNonEmptyArray() throws Throwable  {
      // Given a DirectoryScanner instance,
      DirectoryScanner directoryScanner = new DirectoryScanner();
      
      // And a basedir to scan,
      String baseDir = "";
      directoryScanner.setBasedir(baseDir);
      
      // When the scan() method is called,
      directoryScanner.scan();
      
      // Then the scandir(arg0, "**/%*%", false) method should be called with the correct arguments,
      MockFile arg0 = new MockFile("", "");
      directoryScanner.scandir(arg0, "**/%*%", false);
      
      // And the includedDirectories array should have a length of 7,
      String[] includedDirectories = directoryScanner.getIncludedDirectories();
      assertEquals(7, includedDirectories.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetExcludedFilesReturningEmptyArray() throws Throwable  {
      // DirectoryScanner is used to scan a directory and its subdirectories for files that match certain criteria
      DirectoryScanner directoryScanner = new DirectoryScanner();
      
      // Set the base directory to scan
      directoryScanner.setBasedir("src");
      
      // Create a temporary file in the base directory with the name "CVS"
      MockFile arg2 = new MockFile("src", "CVS");
      MockFile.createTempFile("src", "CVS", (File) arg2);
      
      // Scan the base directory and its subdirectories for files that match certain criteria
      directoryScanner.scan();
      
      // Get the list of excluded files from the scan
      String[] excludedFiles = directoryScanner.getExcludedFiles();
      
      // Assert that no files are excluded from the scan
      assertEquals(0, excludedFiles.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetExcludedFilesAndScandir() throws Throwable  {
      // Given: A DirectoryScanner instance with a basedir of "*"t/CVS/*"
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.setBasedir("*t/CVS/*");
      
      // When: The scan() method is called on the DirectoryScanner instance
      directoryScanner.scan();
      
      // Then: Assert that the scan() method returns a list of files and directories in the basedir
      assertNotNull(directoryScanner.getIncludedFiles());
      assertNotNull(directoryScanner.getExcludedFiles());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testScanThrowsIllegalStateException0() throws Throwable  {
      // Create a temporary file that is not a directory.
      File createTempFile = MockFile.createTempFile("com.lts.io.DirectoryScanner", "notADirectory");
      
      // Configure the directory scanner with the invalid basedir.
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.basedir = createTempFile;
      
      // Try to scan the directory, which should throw an IllegalStateException.
      try {
      directoryScanner.scan();
      fail("Expecting exception: IllegalStateException");
      } catch (IllegalStateException e) {
      // Verify that the correct exception was thrown.
      verifyException("com.lts.io.DirectoryScanner", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetBasedirTakingString() throws Throwable  {
      // Given: a DirectoryScanner instance with a basedir that does not exist
      DirectoryScanner directoryScanner = new DirectoryScanner();
      String nonExistentBasedir = "non-existent-basedir";
      directoryScanner.setBasedir(nonExistentBasedir);
      
      // When: the scan() method is called
      try {
      directoryScanner.scan();
      
      // Then: an IllegalStateException should be thrown, indicating that the basedir does not exist
      fail("Expecting exception: IllegalStateException");
      } catch (IllegalStateException e) {
      verifyException("com.lts.io.DirectoryScanner", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testScanThrowsIllegalStateException1() throws Throwable  {
      // Given a DirectoryScanner instance without a base directory set
      DirectoryScanner directoryScanner = new DirectoryScanner();
      
      // When scan is called on the instance with no base directory set
      try {
      directoryScanner.scan();
      fail("Expecting exception: IllegalStateException");
      } catch(IllegalStateException e) {
      // Then an IllegalStateException is thrown because the base directory has not been set
      verifyException("com.lts.io.DirectoryScanner", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetExcludes() throws Throwable  {
      DirectoryScanner directoryScanner = new DirectoryScanner();
      String[] includes = new String[1];
      includes[0] = "*/";
      directoryScanner.setIncludes(includes);
      assertEquals(1, includes.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetExcludesWithNull() throws Throwable  {
      // rollbacked to evosuite
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.setExcludes((String[]) null);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetIncludes() throws Throwable  {
      // Given a directory scanner object with an empty list of includes
      DirectoryScanner directoryScanner = new DirectoryScanner();
      String[] arg0 = new String[1];
      
      // When the includes are set to a list containing "**/"
      directoryScanner.setIncludes(arg0);
      
      // Then the length of the list should be 1
      assertEquals(1, arg0.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetIncludesWithNull() throws Throwable  {
      // rollbacked to evosuite
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.setIncludes((String[]) null);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchPathAndMatchPathReturningTrue0() throws Throwable  {
      // Test that two paths match when they should
      boolean matchPath = DirectoryScanner.matchPath("dataseB0*?Gc*", "dataseB0*?Gc*");
      assertTrue(matchPath);
      
      // Verify that the two paths match correctly by using a wildcard
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchAndMatchReturningFalse0() throws Throwable  {
      // Test that the method returns false when given an invalid pattern
      boolean match = DirectoryScanner.match("**/*bS/**", "/");
      assertFalse(match);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchAndMatchReturningFalse1() throws Throwable  {
      // Test that the glob pattern "**/*a*" matches all files with an 'a' in their name
      boolean match = DirectoryScanner.match("**/*a*", "*");
      assertFalse(match);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchAndMatchReturningTrue0() throws Throwable  {
      // Test that the method returns true when given a matching pattern
      boolean match = DirectoryScanner.match("*~", "~");
      assertTrue(match);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchPatternStartReturningTrue() throws Throwable  {
      // Test that the matchPatternStart method correctly matches a pattern with a wildcard at the start of the string
      boolean matchPatternStart = DirectoryScanner.matchPatternStart("*?/CVS/*", "*?/CVS/*");
      assertTrue(matchPatternStart);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchAndMatchReturningFalse2() throws Throwable  {
      // Test that the method returns false when the input pattern contains a tilde character.
      boolean match = DirectoryScanner.match("**/*a~", "~");
      assertFalse(match);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchAndMatchReturningTrueAndMatchWithEmptyString() throws Throwable  {
      // Arrange
      String pattern = "";
      // Act
      boolean match = DirectoryScanner.match("**", pattern);
      // Assert
      assertTrue(match);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchAndMatchReturningTrue1() throws Throwable  {
      // This tests that the DirectoryScanner matches patterns with =?->CI* syntax.
      boolean match = DirectoryScanner.match("=?->CI*", "=?->CI*");
      assertTrue(match);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchAndMatchReturningFalseAndMatchWithEmptyString() throws Throwable  {
      // Given a directory scanner that matches files based on wildcard patterns
      DirectoryScanner scanner = new DirectoryScanner();
      
      // When we match an empty string with a wildcard pattern "6*"
      boolean match = scanner.match("6*", "");
      
      // Then the result should be false, as there are no matching files
      assertFalse(match);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchPathAndMatchPathReturningTrue1() throws Throwable  {
      // This test verifies that the `matchPath` method in the `DirectoryScanner` class correctly matches
      // paths that contain the string "CV"
      boolean matchPath = DirectoryScanner.matchPath("**/CV/**", "**/CV/**");
      assertTrue(matchPath);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsIncludedReturningTrue() throws Throwable  {
      // Given a DirectoryScanner with a pattern to match "hB?"
      DirectoryScanner directoryScanner = new DirectoryScanner();
      String[] includes = new String[]{"hB?"};
      directoryScanner.setIncludes(includes);
      
      // When we check if the path "hB?" is included in the scanner
      boolean included = directoryScanner.isIncluded("hB?");
      
      // Then it should be included because it matches the pattern
      assertTrue(included);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetExcludedFilesReturningNonEmptyArray() throws Throwable  {
      // Given: A directory scanner with default excludes set
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.addDefaultExcludes();
      
      // When: The basedir is set to "**/%*%"
      directoryScanner.setBasedir("**/%*%");
      
      // Then: The scanner should not exclude any files
      String[] excludedFiles = directoryScanner.getExcludedFiles();
      assertEquals(0, excludedFiles.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchPathAndMatchPathReturningTrue2() throws Throwable  {
      // Test that the matchPath method returns true for two asterisk patterns
      boolean matchPath = DirectoryScanner.matchPath("**//**", "**//**");
      assertTrue(matchPath);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testScan() throws Throwable  {
      // rollbacked to evosuite
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.setBasedir("*u*~");
      MockFile arg2 = new MockFile("*u*~");
      directoryScanner.addDefaultExcludes();
      MockFile.createTempFile("*u*~", "*u*~", (File) arg2);
      directoryScanner.scan();
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchPathAndMatchPathReturningFalse0() throws Throwable  {
      // Verify that the path pattern does not match a file with the given filename
      boolean matchPath = DirectoryScanner.matchPath("**/*.txt", "**/src/main/java/com/example/myapp/");
      assertFalse(matchPath);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchPathAndMatchPathReturningFalse1() throws Throwable  {
      // Test that the method returns false when the given pattern does not match any path in the directory
      boolean matchPath = DirectoryScanner.matchPath("**/VS/*", "*.java");
      assertFalse(matchPath);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchPathAndMatchPathReturningFalse2() throws Throwable  {
      // No Comments were added
      boolean matchPath = DirectoryScanner.matchPath("/**/CVS/**", "/");
      assertFalse(matchPath);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMatchPathAndMatchPathReturningFalse3() throws Throwable  {
      // Test that two non-matching patterns do not match
      boolean matchPath = DirectoryScanner.matchPath("dataSetB01?Gc*", "dataSetB02?Gc*");
      assertFalse(matchPath);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetNotIncludedDirectoriesReturningEmptyArray() throws Throwable  {
      // Given: The DirectoryScanner is set up to scan the CV2021 folder
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.setBasedir("**#/CV2021/**");
      
      // When: The DirectoryScanner scans the basedir and creates a temporary file
      MockFile arg2 = new MockFile("**#/CV2021/**", "**#/CV2021/**");
      MockFile.createTempFile("**#/CV2021/**", "**#/CV2021/**", (File) arg2);
      directoryScanner.scan();
      
      // Then: The DirectoryScanner should not include any directories and should have excluded the temporary file
      String[] notIncludedDirectories = directoryScanner.getNotIncludedDirectories();
      assertEquals(0, notIncludedDirectories.length);
      
      String[] excludedDirectories = directoryScanner.getExcludedDirectories();
      assertEquals(0, excludedDirectories.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCouldHoldIncludedReturningFalse() throws Throwable  {
      // No Comments were added
      DirectoryScanner directoryScanner = new DirectoryScanner();
      String[] arg0 = new String[9];
      arg0[0] = "U`'Tzyv QUN7-jn~Pq#";
      arg0[1] = "13e3Md5q1MvJ(";
      arg0[2] = "3*\rU[z*}|,=(/2m";
      arg0[3] = "nr";
      arg0[4] = "*$\"J[cr(t";
      arg0[5] = "_q*L/l";
      arg0[6] = "";
      arg0[7] = "";
      arg0[8] = " *9I$@(";
      directoryScanner.setIncludes(arg0);
      boolean couldHoldIncluded = directoryScanner.couldHoldIncluded("n");
      assertFalse(couldHoldIncluded);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetExcludedDirectories() throws Throwable  {
      // Given a DirectoryScanner instance
      DirectoryScanner directoryScanner = new DirectoryScanner();
      
      // And a set of include patterns for the scanner
      String[] includePatterns = new String[3];
      includePatterns[0] = "*t/CVS/*";
      includePatterns[1] = "*t/CVS/*";
      includePatterns[2] = "*t/CVS/*";
      directoryScanner.setIncludes(includePatterns);
      
      // And a base directory for the scanner
      String baseDirectory = "*t/CVS/*";
      directoryScanner.setBasedir(baseDirectory);
      
      // When the scanner is invoked with the include patterns and base directory
      directoryScanner.scan();
      
      // Then the scanner should return a list of files that match the include patterns
      String[] includedFiles = directoryScanner.getIncludedFiles();
      assertNotSame(includedFiles, includePatterns);
      
      // And the excluded directories should be empty
      String[] excludedDirectories = directoryScanner.getExcludedDirectories();
      assertEquals(excludedDirectories.length, 0);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetIncludedFilesReturningEmptyArray() throws Throwable  {
      // Given
      DirectoryScanner directoryScanner = new DirectoryScanner();
      directoryScanner.setBasedir("C:\\Test");
      MockFile arg2 = new MockFile("C:\\Test", "C:\\Test");
      MockFile.createTempFile("C:\\Test", "C:\\Test", (File) arg2);
      
      // When
      directoryScanner.scan();
      
      // Then
      String[] includedFiles = directoryScanner.getIncludedFiles();
      assertEquals(0, includedFiles.length);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCouldHoldIncludedReturningTrue() throws Throwable  {
      // Given a DirectoryScanner instance with a set of includes
      DirectoryScanner directoryScanner = new DirectoryScanner();
      String[] arg0 = new String[1];
      arg0[0] = "**/*.txt";
      directoryScanner.setIncludes(arg0);
      
      // When the method couldHoldIncluded is called with a file pattern that matches the includes
      boolean couldHoldIncluded = directoryScanner.couldHoldIncluded("**/*.txt");
      
      // Then the method should return true, indicating that the scanner can hold the included files
      assertTrue(couldHoldIncluded);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetBasedirReturningNull() throws Throwable  {
      // Given: A new DirectoryScanner instance
      DirectoryScanner directoryScanner = new DirectoryScanner();
      
      // When: The getBasedir method is called on the instance
      File basedir = directoryScanner.getBasedir();
      
      // Then: The result should be null
      assertNull(basedir);
  }
}
