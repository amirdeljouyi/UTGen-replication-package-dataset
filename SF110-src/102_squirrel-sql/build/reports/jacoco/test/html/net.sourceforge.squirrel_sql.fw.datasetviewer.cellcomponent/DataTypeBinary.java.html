<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataTypeBinary.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">102_squirrel-sql</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent</a> &gt; <span class="el_source">DataTypeBinary.java</span></div><h1>DataTypeBinary.java</h1><pre class="source lang-java linenums">package net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent;

/*
 * Copyright (C) 2001-2003 Colin Bell
 * colbell@users.sourceforge.net
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.text.JTextComponent;

import net.sourceforge.squirrel_sql.fw.datasetviewer.CellDataPopup;
import net.sourceforge.squirrel_sql.fw.datasetviewer.ColumnDisplayDefinition;
import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.whereClause.IWhereClausePart;
import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.whereClause.IsNullWhereClausePart;
import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.whereClause.EmptyWhereClausePart;
import net.sourceforge.squirrel_sql.fw.sql.ISQLDatabaseMetaData;
import net.sourceforge.squirrel_sql.fw.util.StringUtilities;

/**
 * @author gwg
 *
 * This class provides the display components for handling Binary data types,
 * specifically SQL types BINARY, VARBINARY, and LONGVARBINARY.
 * The display components are for:
 * &lt;UL&gt;
 * &lt;LI&gt; read-only display within a table cell
 * &lt;LI&gt; editing within a table cell
 * &lt;LI&gt; read-only or editing display within a separate window
 * &lt;/UL&gt;
 * The class also contains 
 * &lt;UL&gt;
 * &lt;LI&gt; a function to compare two display values
 * to see if they are equal.  This is needed because the display format
 * may not be the same as the internal format, and all internal object
 * types may not provide an appropriate equals() function.
 * &lt;LI&gt; a function to return a printable text form of the cell contents,
 * which is used in the text version of the table.
 * &lt;/UL&gt;
 * &lt;P&gt;
 * The components returned from this class extend RestorableJTextField
 * and RestorableJTextArea for use in editing table cells that
 * contain values of this data type.  It provides the special behavior for null
 * handling and resetting the cell to the original value.
 */

public class DataTypeBinary extends BaseDataTypeComponent
 	implements IDataTypeComponent
{
	/* whether nulls are allowed or not */
	private boolean _isNullable;

	/* table of which we are part (needed for creating popup dialog) */
	private JTable _table;
	
	/* The JTextComponent that is being used for editing */
	private IRestorableTextComponent _textComponent;
	
	/* The CellRenderer used for this data type */
	//??? For now, use the same renderer as everyone else.
	//??
	//?? IN FUTURE: change this to use a new instance of renderer
	//?? for this data type.
<span class="nc" id="L88">	private DefaultColumnRenderer _renderer = DefaultColumnRenderer.getInstance();</span>


	/**
	 * Constructor - save the data needed by this data type.
	 */
<span class="nc" id="L94">	public DataTypeBinary(JTable table, ColumnDisplayDefinition colDef) {</span>
<span class="nc" id="L95">		_table = table;</span>
<span class="nc" id="L96">		_colDef = colDef;</span>
<span class="nc" id="L97">		_isNullable = colDef.isNullable();</span>
<span class="nc" id="L98">	}</span>
	
	/**
	 * Return the name of the java class used to hold this data type.
	 */
	public String getClassName() {
<span class="nc" id="L104">		return &quot;[Ljava.lang.Byte&quot;;</span>
	}

	/**
	 * Determine if two objects of this data type contain the same value.
	 * Neither of the objects is null
	 */
	public boolean areEqual(Object obj1, Object obj2) {
<span class="nc" id="L112">        Byte[] b1 = null;</span>
<span class="nc" id="L113">        Byte[] b2 = null;</span>
<span class="nc bnc" id="L114" title="All 4 branches missed.">        if (obj1 == null &amp;&amp; obj2 == null) {</span>
<span class="nc" id="L115">            return true;</span>
        }
<span class="nc bnc" id="L117" title="All 8 branches missed.">        if ( (obj1 != null &amp;&amp; obj2 == null) </span>
                || (obj1 == null &amp;&amp; obj2 != null) ) 
        {
<span class="nc" id="L120">            return false;</span>
        }
<span class="nc bnc" id="L122" title="All 2 branches missed.">        if (obj1 instanceof Byte[]) {</span>
<span class="nc" id="L123">            b1 = (Byte[])obj1;</span>
        } else {
<span class="nc" id="L125">            b1 = StringUtilities.getByteArray(obj1.toString().getBytes());</span>
        }
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (obj2 instanceof Byte[]) {</span>
<span class="nc" id="L128">            b2 = (Byte[])obj2;</span>
        } else {
<span class="nc" id="L130">            b2 = StringUtilities.getByteArray(obj2.toString().getBytes());</span>
        }
		
<span class="nc bnc" id="L133" title="All 2 branches missed.">		for (int i=0; i&lt;b1.length; i++)</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">			if (b1[i] != b2[i])</span>
<span class="nc" id="L135">				return false;</span>
				
<span class="nc" id="L137">		return true;</span>
	}

	/*
	 * First we have the methods for in-cell and Text-table operations
	 */
	 
	/**
	 * Render a value into text for this DataType.
	 */
	public String renderObject(Object value) {
		// The SQL Results page puts text into the table cells
		// rather than objects of the appropriate type, so we
		// need to convert befor proceeding
		Byte[] useValue;
<span class="nc bnc" id="L152" title="All 2 branches missed.">		if (value instanceof java.lang.String) {</span>
<span class="nc" id="L153">			byte[] bytes = ((String)value).getBytes();</span>
<span class="nc" id="L154">			useValue = new Byte[bytes.length];</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">			for (int i=0; i&lt;bytes.length; i++) {</span>
<span class="nc" id="L156">				useValue[i] = Byte.valueOf(bytes[i]);</span>
            }
<span class="nc" id="L158">		}</span>
<span class="nc" id="L159">		else useValue = (Byte[])value;</span>
		// use the default settings for the conversion
<span class="nc" id="L161">		return (String)_renderer.renderObject(</span>
<span class="nc" id="L162">			BinaryDisplayConverter.convertToString(useValue,</span>
			BinaryDisplayConverter.HEX, false));
	}
	
	/**
	 * This Data Type can be edited in a table cell.
	 */
	public boolean isEditableInCell(Object originalValue) {
<span class="nc" id="L170">		return true;	</span>
	}

	/**
	 * See if a value in a column has been limited in some way and
	 * needs to be re-read before being used for editing.
	 * For read-only tables this may actually return true since we want
	 * to be able to view the entire contents of the cell even if it was not
	 * completely loaded during the initial table setup.
	 */
	public boolean needToReRead(Object originalValue) {
		// this DataType does not limit the data read during the initial load of the table,
		// so there is no need to re-read the complete data later
<span class="nc" id="L183">		return false;</span>
	}
	
	/**
	 * Return a JTextField usable in a CellEditor.
	 */
	public JTextField getJTextField() {
<span class="nc" id="L190">		_textComponent = new RestorableJTextField();</span>
		
		// special handling of operations while editing this data type
<span class="nc" id="L193">		((RestorableJTextField)_textComponent).addKeyListener(new KeyTextHandler());</span>
				
		//
		// handle mouse events for double-click creation of popup dialog.
		// This happens only in the JTextField, not the JTextArea, so we can
		// make this an inner class within this method rather than a separate
		// inner class as is done with the KeyTextHandler class.
		//
<span class="nc" id="L201">		((RestorableJTextField)_textComponent).addMouseListener(new MouseAdapter()</span>
<span class="nc" id="L202">		{</span>
			public void mousePressed(MouseEvent evt)
			{
<span class="nc bnc" id="L205" title="All 2 branches missed.">				if (evt.getClickCount() == 2)</span>
				{
<span class="nc" id="L207">					MouseEvent tableEvt = SwingUtilities.convertMouseEvent(</span>
<span class="nc" id="L208">						(RestorableJTextField)DataTypeBinary.this._textComponent,</span>
<span class="nc" id="L209">						evt, DataTypeBinary.this._table);</span>
<span class="nc" id="L210">					CellDataPopup.showDialog(DataTypeBinary.this._table,</span>
						DataTypeBinary.this._colDef, tableEvt, true);
				}
<span class="nc" id="L213">			}</span>
		});	// end of mouse listener

<span class="nc" id="L216">		return (JTextField)_textComponent;</span>
	}


	/**
	 * Implement the interface for validating and converting to internal object.
	 * Null is a valid successful return, so errors are indicated only by
	 * existance or not of a message in the messageBuffer.
	 */
	public Object validateAndConvert(String value, Object originalValue, StringBuffer messageBuffer) {
		// handle null, which is shown as the special string &quot;&lt;null&gt;&quot;
<span class="nc bnc" id="L227" title="All 6 branches missed.">		if (value == null || value.equals(&quot;&lt;null&gt;&quot;) || value.equals(&quot;&quot;))</span>
<span class="nc" id="L228">			return null;</span>

		// Do the conversion into the object in a safe manner
		try {
<span class="nc" id="L232">			Object obj = BinaryDisplayConverter.convertToBytes(value,</span>
				BinaryDisplayConverter.HEX, false);
<span class="nc" id="L234">			return obj;</span>
		}
<span class="nc" id="L236">		catch (Exception e) {</span>
<span class="nc" id="L237">			messageBuffer.append(e.toString()+&quot;\n&quot;);</span>
			//?? do we need the message also, or is it automatically part of the toString()?
			//messageBuffer.append(e.getMessage());
<span class="nc" id="L240">			return null;</span>
		}
	}

	/**
	 * If true, this tells the PopupEditableIOPanel to use the
	 * binary editing panel rather than a pure text panel.
	 * The binary editing panel assumes the data is an array of bytes,
	 * converts it into text form, allows the user to change how that
	 * data is displayed (e.g. Hex, Decimal, etc.), and converts
	 * the data back from text to bytes when the user editing is completed.
	 * If this returns false, this DataType class must
	 * convert the internal data into a text string that
	 * can be displayed (and edited, if allowed) in a TextField
	 * or TextArea, and must handle all
	 * user key strokes related to editing of that data.
	 */
	public boolean useBinaryEditingPanel() {
<span class="nc" id="L258">		return true;</span>
	}
	 

	/*
	 * Now the functions for the Popup-related operations.
	 */
	
	/**
	 * Returns true if data type may be edited in the popup,
	 * false if not.
	 */
	public boolean isEditableInPopup(Object originalValue) {
<span class="nc" id="L271">		return true;</span>
	}

	/*
	 * Return a JTextArea usable in the CellPopupDialog
	 * and fill in the value.
	 */
	 public JTextArea getJTextArea(Object value) {
<span class="nc" id="L279">		_textComponent = new RestorableJTextArea();</span>
		
		// value is a simple string representation of the data,
		// the same one used in Text and in-cell operations.
<span class="nc" id="L283">		((RestorableJTextArea)_textComponent).setText(renderObject(value));</span>
		
		// special handling of operations while editing this data type
<span class="nc" id="L286">		((RestorableJTextArea)_textComponent).addKeyListener(new KeyTextHandler());</span>
		
<span class="nc" id="L288">		return (RestorableJTextArea)_textComponent;</span>
	 }

	/**
	 * Validating and converting in Popup is identical to cell-related operation.
	 */
	public Object validateAndConvertInPopup(String value, Object originalValue, StringBuffer messageBuffer) {
<span class="nc" id="L295">		return validateAndConvert(value, originalValue, messageBuffer);</span>
	}

	/*
	 * The following is used in both cell and popup operations.
	 */	
	
	/*
	 * Internal class for handling key events during editing
	 * of both JTextField and JTextArea.
	 */
<span class="nc" id="L306">	 private class KeyTextHandler extends BaseKeyTextHandler {</span>
	 	public void keyTyped(KeyEvent e) {
<span class="nc" id="L308">				char c = e.getKeyChar();</span>
				
				// as a coding convenience, create a reference to the text component
				// that is typecast to JTextComponent.  this is not essential, as we
				// could typecast every reference, but this makes the code cleaner
<span class="nc" id="L313">				JTextComponent _theComponent = (JTextComponent)DataTypeBinary.this._textComponent;</span>
<span class="nc" id="L314">				String text = _theComponent.getText();</span>
												
				// tabs and newlines get put into the text before this check,
				// so remove them
				// This only applies to Popup editing since these chars are
				// not passed to this level by the in-cell editor.
<span class="nc bnc" id="L320" title="All 4 branches missed.">				if (c == KeyEvent.VK_TAB || c == KeyEvent.VK_ENTER) {</span>
					// remove all instances of the offending char
<span class="nc" id="L322">					int index = text.indexOf(c);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">					if (index != -1) {</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">						if (index == text.length() -1) {</span>
<span class="nc" id="L325">							text = text.substring(0, text.length()-1);	// truncate string</span>
						}
						else {
<span class="nc" id="L328">							text = text.substring(0, index) + text.substring(index+1);</span>
						}
<span class="nc" id="L330">						((IRestorableTextComponent)_theComponent).updateText( text);</span>
<span class="nc" id="L331">						_beepHelper.beep(_theComponent);</span>
					}
<span class="nc" id="L333">					e.consume();</span>
				}

				// handle cases of null
				// The processing is different when nulls are allowed and when they are not.
				//

<span class="nc bnc" id="L340" title="All 2 branches missed.">				if ( DataTypeBinary.this._isNullable) {</span>

					// user enters something when field is null
<span class="nc bnc" id="L343" title="All 2 branches missed.">					if (text.equals(&quot;&lt;null&gt;&quot;)) {</span>
<span class="nc bnc" id="L344" title="All 4 branches missed.">						if ((c==KeyEvent.VK_BACK_SPACE) || (c == KeyEvent.VK_DELETE)) {</span>
							// delete when null =&gt; original value
<span class="nc" id="L346">							DataTypeBinary.this._textComponent.restoreText();</span>
<span class="nc" id="L347">							e.consume();</span>
						}
						else {
							// non-delete when null =&gt; clear field and add text
<span class="nc" id="L351">							DataTypeBinary.this._textComponent.updateText(&quot;&quot;);</span>
							// fall through to normal processing of this key stroke
						}
					}
					else {
						// check for user deletes last thing in field
<span class="nc bnc" id="L357" title="All 4 branches missed.">						if ((c == KeyEvent.VK_BACK_SPACE) || (c == KeyEvent.VK_DELETE)) {</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">							if (text.length() &lt;= 1 ) {</span>
								// about to delete last thing in field, so replace with null
<span class="nc" id="L360">								DataTypeBinary.this._textComponent.updateText(&quot;&lt;null&gt;&quot;);</span>
<span class="nc" id="L361">								e.consume();</span>
							}
						}
					}
				}
				else {
                    // field is not nullable
                    //
<span class="nc" id="L369">                    handleNotNullableField(text, c, e, _textComponent);</span>
				}
<span class="nc" id="L371">			}</span>
		}


	
	
	/*
	 * DataBase-related functions
	 */
	 
	 /**
	  * On input from the DB, read the data from the ResultSet into the appropriate
	  * type of object to be stored in the table cell.
	  */
	public Object readResultSet(ResultSet rs, int index, boolean limitDataRead)
		throws java.sql.SQLException {
		
<span class="nc" id="L388">		byte[] data = rs.getBytes(index);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">		if (rs.wasNull())</span>
<span class="nc" id="L390">			return null;</span>
		else {
<span class="nc" id="L392">			Byte[] internal = new Byte[data.length];</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">			for (int i=0; i&lt;data.length; i++) {</span>
<span class="nc" id="L394">				internal[i] = Byte.valueOf(data[i]);</span>
            }
<span class="nc" id="L396">			return internal;</span>
		}
	}


	/**
	 * When updating the database, generate a string form of this object value
	 * that can be used in the WHERE clause to match the value in the database.
	 * A return value of null means that this column cannot be used in the WHERE
	 * clause, while a return of &quot;null&quot; (or &quot;is null&quot;, etc) means that the column
	 * can be used in the WHERE clause and the value is actually a null value.
	 * This function must also include the column label so that its output
	 * is of the form:
	 * 	&quot;columnName = value&quot;
	 * or
	 * 	&quot;columnName is null&quot;
	 * or whatever is appropriate for this column in the database.
	 */
	public IWhereClausePart getWhereClauseValue(Object value, ISQLDatabaseMetaData md) {
<span class="nc bnc" id="L415" title="All 6 branches missed.">		if (value == null || value.toString() == null || value.toString().length() == 0){</span>
<span class="nc" id="L416">			return new IsNullWhereClausePart(_colDef);</span>
		}else{
			//?? There does not seem to be any standard way to represent
			//?? binary data in a WHERE clause...
			// tell caller we cannot use this in Where clause
			// TODO Review, if this DataType could not be used in a where clause
<span class="nc" id="L422">			return new EmptyWhereClausePart();</span>
		}
	}
	
	
	/**
	 * When updating the database, insert the appropriate datatype into the
	 * prepared statment at the given variable position.
	 */
	public void setPreparedStatementValue(PreparedStatement pstmt, Object value, int position)
		throws java.sql.SQLException {
<span class="nc bnc" id="L433" title="All 2 branches missed.">		if (value == null) {</span>
<span class="nc" id="L434">			pstmt.setNull(position, _colDef.getSqlType());</span>
		}
		else {
<span class="nc" id="L437">			Byte[] internal = (Byte[])value;</span>
<span class="nc" id="L438">			byte[] dbValue = new byte[internal.length];</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">			for (int i=0; i&lt;internal.length; i++)</span>
<span class="nc" id="L440">				dbValue[i] = internal[i].byteValue();</span>
<span class="nc" id="L441">			pstmt.setBytes(position, dbValue);</span>
		}
<span class="nc" id="L443">	}</span>
	
	/**
	 * Get a default value for the table used to input data for a new row
	 * to be inserted into the DB.
	 */
	public Object getDefaultValue(String dbDefaultValue) {
<span class="nc bnc" id="L450" title="All 2 branches missed.">		if (dbDefaultValue != null) {</span>
			// try to use the DB default value
<span class="nc" id="L452">			StringBuffer mbuf = new StringBuffer();</span>
<span class="nc" id="L453">			Object newObject = validateAndConvert(dbDefaultValue, null, mbuf);</span>
			
			// if there was a problem with converting, then just fall through
			// and continue as if there was no default given in the DB.
			// Otherwise, use the converted object
<span class="nc bnc" id="L458" title="All 2 branches missed.">			if (mbuf.length() == 0)</span>
<span class="nc" id="L459">				return newObject;</span>
		}
		
		// no default in DB.  If nullable, use null.
<span class="nc bnc" id="L463" title="All 2 branches missed.">		if (_isNullable)</span>
<span class="nc" id="L464">			return null;</span>
		
		// field is not nullable, so create a reasonable default value
<span class="nc" id="L467">		return new Byte[0];</span>
	}
	
	
	/*
	 * File IO related functions
	 */
	 
	 
	 /**
	  * Say whether or not object can be exported to and imported from
	  * a file.  We put both export and import together in one test
	  * on the assumption that all conversions can be done both ways.
	  */
	 public boolean canDoFileIO() {
<span class="nc" id="L482">	 	return true;</span>
	 }
	 
	 /**
	  * Read a file and construct a valid object from its contents.
	  * Errors are returned by throwing an IOException containing the
	  * cause of the problem as its message.
	  * &lt;P&gt;
	  * DataType is responsible for validating that the imported
	  * data can be converted to an object, and then must return
	  * a text string that can be used in the Popup window text area.
	  * This object-to-text conversion is the same as is done by
	  * the DataType object internally in the getJTextArea() method.
	  */
	public String importObject(FileInputStream inStream)
	 	throws IOException {
	 	

<span class="nc" id="L500">	 	int fileSize = inStream.available();</span>
	 	
<span class="nc" id="L502">	 	byte[] buf = new byte[fileSize];</span>
	 	
<span class="nc" id="L504">	 	int count = inStream.read(buf);</span>
	 	
<span class="nc bnc" id="L506" title="All 2 branches missed.">	 	if (count != fileSize)</span>
<span class="nc" id="L507">	 		throw new IOException(</span>
	 			&quot;Could read only &quot;+ count +
	 			&quot; bytes from a total file size of &quot; + fileSize +
	 			&quot;. Import failed.&quot;);
	 	
	 	// Convert bytes to Bytes
<span class="nc" id="L513">	 	Byte[] bBytes = new Byte[count];</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">	 	for (int i=0; i&lt;count; i++) {</span>
<span class="nc" id="L515">	 		bBytes[i] = Byte.valueOf(buf[i]);</span>
        }
	 	// return the text converted from the file 
<span class="nc" id="L518">	 	return BinaryDisplayConverter.convertToString(bBytes,</span>
	 		BinaryDisplayConverter.HEX, false);
	}

	 	 
	 /**
	  * Construct an appropriate external representation of the object
	  * and write it to a file.
	  * Errors are returned by throwing an IOException containing the
	  * cause of the problem as its message.
	  * &lt;P&gt;
	  * DataType is responsible for validating that the given text
	  * text from a Popup JTextArea can be converted to an object.
	  * This text-to-object conversion is the same as validateAndConvertInPopup,
	  * which may be used internally by the object to do the validation.
	  * &lt;P&gt;
	  * The DataType object must flush and close the output stream before returning.
	  * Typically it will create another object (e.g. an OutputWriter), and
	  * that is the object that must be flushed and closed.
	  */
	 public void exportObject(FileOutputStream outStream, String text)
	 	throws IOException {
	 	
<span class="nc" id="L541">		Byte[] bBytes = BinaryDisplayConverter.convertToBytes(text,</span>
			BinaryDisplayConverter.HEX, false);
	 	
	 	// check that the text is a valid representation
<span class="nc" id="L545">	 	StringBuffer messageBuffer = new StringBuffer();</span>
<span class="nc" id="L546">	 	validateAndConvertInPopup(text, null, messageBuffer);</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">	 	if (messageBuffer.length() &gt; 0) {</span>
	 		// there was an error in the conversion
<span class="nc" id="L549">	 		throw new IOException(new String(messageBuffer));</span>
	 	}
	 	
	 	// Convert Bytes to bytes
<span class="nc" id="L553">	 	byte[] bytes = new byte[bBytes.length];</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">	 	for (int i=0; i&lt;bytes.length; i++)</span>
<span class="nc" id="L555">	 		bytes[i] = bBytes[i].byteValue();</span>
	 	
	 	// just send the text to the output file
<span class="nc" id="L558">		outStream.write(bytes);</span>
<span class="nc" id="L559">		outStream.flush();</span>
<span class="nc" id="L560">		outStream.close();</span>
<span class="nc" id="L561">	 }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>