<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataTypeBlob.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">102_squirrel-sql</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent</a> &gt; <span class="el_source">DataTypeBlob.java</span></div><h1>DataTypeBlob.java</h1><pre class="source lang-java linenums">package net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent;
/*
 * Copyright (C) 2001-2003 Colin Bell
 * colbell@users.sourceforge.net
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
import java.awt.event.*;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.JTextArea;
import javax.swing.SwingUtilities;
import javax.swing.text.JTextComponent;
import javax.swing.BorderFactory;
import javax.swing.JCheckBox;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Blob;
import java.io.ByteArrayInputStream;

import net.sourceforge.squirrel_sql.fw.gui.RightLabel;
import net.sourceforge.squirrel_sql.fw.gui.ReadTypeCombo;
import net.sourceforge.squirrel_sql.fw.gui.IntegerField;
import net.sourceforge.squirrel_sql.fw.gui.OkJPanel;

import net.sourceforge.squirrel_sql.fw.datasetviewer.CellDataPopup;
import net.sourceforge.squirrel_sql.fw.datasetviewer.ColumnDisplayDefinition;
import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.whereClause.IWhereClausePart;
import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.whereClause.IsNullWhereClausePart;
import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.whereClause.EmptyWhereClausePart;
import net.sourceforge.squirrel_sql.fw.sql.ISQLDatabaseMetaData;
import net.sourceforge.squirrel_sql.fw.util.StringManager;
import net.sourceforge.squirrel_sql.fw.util.StringManagerFactory;

/**
 * @author gwg
 *
 * This class provides the display components for handling Blob data types,
 * specifically SQL type BLOB.
 * The display components are for:
 * &lt;UL&gt;
 * &lt;LI&gt; read-only display within a table cell
 * &lt;LI&gt; editing within a table cell
 * &lt;LI&gt; read-only or editing display within a separate window
 * &lt;/UL&gt;
 * The class also contains 
 * &lt;UL&gt;
 * &lt;LI&gt; a function to compare two display values
 * to see if they are equal.  This is needed because the display format
 * may not be the same as the internal format, and all internal object
 * types may not provide an appropriate equals() function.
 * &lt;LI&gt; a function to return a printable text form of the cell contents,
 * which is used in the text version of the table.
 * &lt;/UL&gt;
 * &lt;P&gt;
 * The components returned from this class extend RestorableJTextField
 * and RestorableJTextArea for use in editing table cells that
 * contain values of this data type.  It provides the special behavior for null
 * handling and resetting the cell to the original value.
 */

public class DataTypeBlob extends BaseDataTypeComponent
	implements IDataTypeComponent
{

<span class="nc" id="L89">	private static final StringManager s_stringMgr =</span>
<span class="nc" id="L90">		StringManagerFactory.getStringManager(DataTypeBlob.class);</span>

	/* whether nulls are allowed or not */
	private boolean _isNullable;

	/* table of which we are part (needed for creating popup dialog) */
	private JTable _table;

	/* The JTextComponent that is being used for editing */
	private IRestorableTextComponent _textComponent;

	/* The CellRenderer used for this data type */
	//??? For now, use the same renderer as everyone else.
	//??
	//?? IN FUTURE: change this to use a new instance of renederer
	//?? for this data type.
<span class="nc" id="L106">	private DefaultColumnRenderer _renderer = DefaultColumnRenderer.getInstance();</span>

	/**
	 * Name of this class, which is needed because the class name is needed
	 * by the static method getControlPanel, so we cannot use something
	 * like getClass() to find this name.
	 */
	private static final String thisClassName =
		&quot;net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.DataTypeBlob&quot;;


	/** Default length of BLOB to read */
<span class="nc" id="L118">	private static int LARGE_COLUMN_DEFAULT_READ_LENGTH = 255;</span>

	/*
	 * Properties settable by the user
	 */
	 // flag for whether we have already loaded the properties or not
<span class="nc" id="L124">	 private static boolean propertiesAlreadyLoaded = false;</span>


	/** Read the contents of Blobs from Result sets when first loading the tables. */
<span class="nc" id="L128">	private static boolean _readBlobs = false;</span>

	/**
	 * If &lt;TT&gt;_readBlobs&lt;/TT&gt; is &lt;TT&gt;true&lt;/TT&gt; this specifies if the complete
	 * BLOB should be read in.
	 */
<span class="nc" id="L134">	private static boolean _readCompleteBlobs = false;</span>

	/**
	 * If &lt;TT&gt;_readBlobs&lt;/TT&gt; is &lt;TT&gt;true&lt;/TT&gt; and &lt;TT&gt;_readCompleteBlobs&lt;/TT&gt;
	 * is &lt;tt&gt;false&lt;/TT&gt; then this specifies the number of characters to read.
	 */
<span class="nc" id="L140">	private static int _readBlobsSize = LARGE_COLUMN_DEFAULT_READ_LENGTH;</span>





	/**
	 * Constructor - save the data needed by this data type.
	 */
<span class="nc" id="L149">	public DataTypeBlob(JTable table, ColumnDisplayDefinition colDef) {</span>
<span class="nc" id="L150">		_table = table;</span>
<span class="nc" id="L151">		_colDef = colDef;</span>
<span class="nc" id="L152">		_isNullable = colDef.isNullable();</span>

<span class="nc" id="L154">		loadProperties();</span>
<span class="nc" id="L155">	}</span>

	/** Internal function to get the user-settable properties from the DTProperties,
	 * if they exist, and to ensure that defaults are set if the properties have
	 * not yet been created.
	 * &lt;P&gt;
	 * This method may be called from different places depending on whether
	 * an instance of this class is created before the user brings up the Session
	 * Properties window.  In either case, the data is static and is set only
	 * the first time we are called.
	 */
	private static void loadProperties() {

		//set the property values
		// Note: this may have already been done by another instance of
		// this DataType created to handle a different column.
<span class="nc bnc" id="L171" title="All 2 branches missed.">		if (propertiesAlreadyLoaded == false) {</span>
			// get parameters previously set by user, or set default values
<span class="nc" id="L173">			_readBlobs = false;	// set to the default</span>
<span class="nc" id="L174">			String readBlobsString = DTProperties.get(</span>
				thisClassName, &quot;readBlobs&quot;);
<span class="nc bnc" id="L176" title="All 4 branches missed.">			if (readBlobsString != null &amp;&amp; readBlobsString.equals(&quot;true&quot;))</span>
<span class="nc" id="L177">				_readBlobs = true;</span>

<span class="nc" id="L179">			_readCompleteBlobs = false;	// set to the default</span>
<span class="nc" id="L180">			String readCompleteBlobsString = DTProperties.get(</span>
				thisClassName, &quot;readCompleteBlobs&quot;);
<span class="nc bnc" id="L182" title="All 4 branches missed.">			if (readCompleteBlobsString != null &amp;&amp; readCompleteBlobsString.equals(&quot;true&quot;))</span>
<span class="nc" id="L183">				_readCompleteBlobs = true;</span>

<span class="nc" id="L185">			_readBlobsSize = LARGE_COLUMN_DEFAULT_READ_LENGTH;	// set to default</span>
<span class="nc" id="L186">			String readBlobsSizeString = DTProperties.get(</span>
				thisClassName, &quot;readBlobsSize&quot;);
<span class="nc bnc" id="L188" title="All 2 branches missed.">			if (readBlobsSizeString != null)</span>
<span class="nc" id="L189">				_readBlobsSize = Integer.parseInt(readBlobsSizeString);</span>

<span class="nc" id="L191">			propertiesAlreadyLoaded = true;</span>
		}
<span class="nc" id="L193">	}</span>

	/**
	 * Return the name of the java class used to hold this data type.
	 */
	public String getClassName() {
<span class="nc" id="L199">		return &quot;net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.BlobDescriptor&quot;;</span>
	}

	/*
	 * First we have the methods for in-cell and Text-table operations
	 */

	/**
	 * Render a value into text for this DataType.
	 */
	public String renderObject(Object value) {
<span class="nc" id="L210">		return (String)_renderer.renderObject(value);</span>
	}

	/**
	 * This Data Type can be edited in a table cell.
	 * This function is not called during the initial table load, or during
	 * normal table operations.
	 * It is called only when the user enters the cell, either to examine
	 * or to edit the data.
	 * The user may have set the DataType properties to
	 * minimize the data read during the initial table load (to speed it up),
	 * but when they enter this cell we would like to show them the entire
	 * contents of the BLOB.
	 * Therefore we use a call to this function as a trigger to make sure
	 * that we have all of the BLOB data, if that is possible.
	 */
	public boolean isEditableInCell(Object originalValue) {
<span class="nc bnc" id="L227" title="All 2 branches missed.">		if (!_readBlobs) {</span>
<span class="nc" id="L228">			return false;</span>
		}
<span class="nc" id="L230">		return wholeBlobRead((BlobDescriptor)originalValue);</span>
	}

	/**
	 * See if a value in a column has been limited in some way and
	 * needs to be re-read before being used for editing.
	 * For read-only tables this may actually return true since we want
	 * to be able to view the entire contents of the cell even if it was not
	 * completely loaded during the initial table setup.
	 */
	public boolean needToReRead(Object originalValue) {
		// BLOBs are different from normal data types in that what is actually
		// read from the DB is a descriptor pointing to the data rather than the
		// data itself.  During the initial load of the table, the values read from the
		// descriptor may have been limited, but the descriptor itself has been
		// completely read,  Therefore we do not need to re-read the datum
		// from the Database because we know that we have the entire
		// descriptor.  If the contents of the BLOB have been limited during
		// the initial table load, that will be discovered when we check if
		// the cell is editable and the full data will be read at that time using
		// this descriptor.
<span class="nc" id="L251">		return false;</span>
	}

	/**
	 * Return a JTextField usable in a CellEditor.
	 */
	public JTextField getJTextField() {
<span class="nc" id="L258">		_textComponent = new RestorableJTextField();</span>

		// special handling of operations while editing this data type
<span class="nc" id="L261">		((RestorableJTextField)_textComponent).addKeyListener(new KeyTextHandler());</span>

		//
		// handle mouse events for double-click creation of popup dialog.
		// This happens only in the JTextField, not the JTextArea, so we can
		// make this an inner class within this method rather than a separate
		// inner class as is done with the KeyTextHandler class.
		//
<span class="nc" id="L269">		((RestorableJTextField)_textComponent).addMouseListener(new MouseAdapter()</span>
<span class="nc" id="L270">		{</span>
			public void mousePressed(MouseEvent evt)
			{
<span class="nc bnc" id="L273" title="All 2 branches missed.">				if (evt.getClickCount() == 2)</span>
				{
<span class="nc" id="L275">					MouseEvent tableEvt = SwingUtilities.convertMouseEvent(</span>
<span class="nc" id="L276">						(RestorableJTextField)DataTypeBlob.this._textComponent,</span>
<span class="nc" id="L277">						evt, DataTypeBlob.this._table);</span>
<span class="nc" id="L278">					CellDataPopup.showDialog(DataTypeBlob.this._table,</span>
						DataTypeBlob.this._colDef, tableEvt, true);
				}
<span class="nc" id="L281">			}</span>
		});	// end of mouse listener

<span class="nc" id="L284">		return (JTextField)_textComponent;</span>
	}

	/**
	 * Implement the interface for validating and converting to internal object.
	 * Null is a valid successful return, so errors are indicated only by
	 * existance or not of a message in the messageBuffer.
	 * If originalValue is null, then we are just checking that the data is
	 * in a valid format (for file import/export) and not actually converting
	 * the data.
	 */
	public Object validateAndConvert(String value, Object originalValue, StringBuffer messageBuffer) {
		// handle null, which is shown as the special string &quot;&lt;null&gt;&quot;
<span class="nc bnc" id="L297" title="All 2 branches missed.">		if (value.equals(&quot;&lt;null&gt;&quot;))</span>
<span class="nc" id="L298">			return null;</span>

		// Do the conversion into the object in a safe manner

		//First convert the string representation into the binary bytes it is describing
		Byte[] byteClassData;
		try {
<span class="nc" id="L305">					byteClassData = BinaryDisplayConverter.convertToBytes(value,</span>
						BinaryDisplayConverter.HEX, false);
		}
<span class="nc" id="L308">		catch (Exception e) {</span>
<span class="nc" id="L309">			messageBuffer.append(e.toString()+&quot;\n&quot;);</span>
			//?? do we need the message also, or is it automatically part of the toString()?
			//messageBuffer.append(e.getMessage());
<span class="nc" id="L312">			return null;</span>
<span class="nc" id="L313">		}</span>

<span class="nc" id="L315">		byte[] byteData = new byte[byteClassData.length];</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">		for (int i=0; i&lt;byteClassData.length; i++)</span>
<span class="nc" id="L317">			byteData[i] = byteClassData[i].byteValue();</span>

		// if the original object is not null, then it contains a Blob object
		// that we need to re-use, since that is the DBs reference to the blob data area.
		// Otherwise, we set the original Blob to null, and the write method needs to
		// know to set the field to null.
		BlobDescriptor bdesc;
<span class="nc bnc" id="L324" title="All 2 branches missed.">		if (originalValue == null) {</span>
			// no existing blob to re-use
<span class="nc" id="L326">			bdesc = new BlobDescriptor(null, byteData, true, true, 0);</span>
		}
		else {
			// for convenience, cast the existing object
<span class="nc" id="L330">			bdesc = (BlobDescriptor)originalValue;</span>

			// create new object to hold the different value, but use the same internal BLOB pointer
			// as the original
<span class="nc" id="L334">			bdesc = new BlobDescriptor(bdesc.getBlob(), byteData, true, true, 0);</span>
		}
<span class="nc" id="L336">		return bdesc;</span>

	}

	/**
	 * If true, this tells the PopupEditableIOPanel to use the
	 * binary editing panel rather than a pure text panel.
	 * The binary editing panel assumes the data is an array of bytes,
	 * converts it into text form, allows the user to change how that
	 * data is displayed (e.g. Hex, Decimal, etc.), and converts
	 * the data back from text to bytes when the user editing is completed.
	 * If this returns false, this DataType class must
	 * convert the internal data into a text string that
	 * can be displayed (and edited, if allowed) in a TextField
	 * or TextArea, and must handle all
	 * user key strokes related to editing of that data.
	 */
	public boolean useBinaryEditingPanel() {
<span class="nc" id="L354">		return true;</span>
	}


	/*
		 * Now the functions for the Popup-related operations.
		 */

	/**
	 * Returns true if data type may be edited in the popup,
	 * false if not.
	 */
	public boolean isEditableInPopup(Object originalValue) {
		// If all of the data has been read, then the blob can be edited in the Popup,
		// otherwise it cannot
<span class="nc" id="L369">		return wholeBlobRead((BlobDescriptor)originalValue);</span>
	}

	/*
	 * Return a JTextArea usable in the CellPopupDialog
	 * and fill in the value.
	 */
	 public JTextArea getJTextArea(Object value) {
<span class="nc" id="L377">		_textComponent = new RestorableJTextArea();</span>


		// value is a simple string representation of the data,
		// the same one used in Text and in-cell operations.
<span class="nc" id="L382">		((RestorableJTextArea)_textComponent).setText(renderObject(value));</span>

		// special handling of operations while editing this data type
<span class="nc" id="L385">		((RestorableJTextArea)_textComponent).addKeyListener(new KeyTextHandler());</span>

<span class="nc" id="L387">		return (RestorableJTextArea)_textComponent;</span>
	 }

	/**
	 * Validating and converting in Popup is identical to cell-related operation.
	 */
	public Object validateAndConvertInPopup(String value, Object originalValue, StringBuffer messageBuffer) {
<span class="nc" id="L394">		return validateAndConvert(value, originalValue, messageBuffer);</span>
	}

	/*
	 * The following is used in both cell and popup operations.
	 */

	/*
		 * Internal class for handling key events during editing
		 * of both JTextField and JTextArea.
		 */
<span class="nc" id="L405">	 private class KeyTextHandler extends BaseKeyTextHandler {</span>
		 public void keyTyped(KeyEvent e) {
<span class="nc" id="L407">				char c = e.getKeyChar();</span>

				// as a coding convenience, create a reference to the text component
				// that is typecast to JTextComponent.  this is not essential, as we
				// could typecast every reference, but this makes the code cleaner
<span class="nc" id="L412">				JTextComponent _theComponent = (JTextComponent)DataTypeBlob.this._textComponent;</span>
<span class="nc" id="L413">				String text = _theComponent.getText();</span>


				// handle cases of null
				// The processing is different when nulls are allowed and when they are not.
				//

<span class="nc bnc" id="L420" title="All 2 branches missed.">				if ( DataTypeBlob.this._isNullable) {</span>

					// user enters something when field is null
<span class="nc bnc" id="L423" title="All 2 branches missed.">					if (text.equals(&quot;&lt;null&gt;&quot;)) {</span>
<span class="nc bnc" id="L424" title="All 4 branches missed.">						if ((c==KeyEvent.VK_BACK_SPACE) || (c == KeyEvent.VK_DELETE)) {</span>
							// delete when null =&gt; original value
<span class="nc" id="L426">							DataTypeBlob.this._textComponent.restoreText();</span>
<span class="nc" id="L427">							e.consume();</span>
						}
						else {
							// non-delete when null =&gt; clear field and add text
<span class="nc" id="L431">							DataTypeBlob.this._textComponent.updateText(&quot;&quot;);</span>
							// fall through to normal processing of this key stroke
						}
					}
					else {
						// check for user deletes last thing in field
<span class="nc bnc" id="L437" title="All 4 branches missed.">						if ((c == KeyEvent.VK_BACK_SPACE) || (c == KeyEvent.VK_DELETE)) {</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">							if (text.length() &lt;= 1 ) {</span>
								// about to delete last thing in field, so replace with null
<span class="nc" id="L440">								DataTypeBlob.this._textComponent.updateText(&quot;&lt;null&gt;&quot;);</span>
<span class="nc" id="L441">								e.consume();</span>
							}
						}
					}
				}
				else {
                    // field is not nullable
                    //
<span class="nc" id="L449">                    handleNotNullableField(text, c, e, _textComponent);</span>
				}
<span class="nc" id="L451">			}</span>
		}

	/*
	 * Make sure the entire BLOB data is read in.
	 * Return true if it has been read successfully, and false if not.
	 */
	private boolean wholeBlobRead(BlobDescriptor bdesc) {
<span class="nc bnc" id="L459" title="All 2 branches missed.">		if (bdesc == null)</span>
<span class="nc" id="L460">			return true;	// can use an empty blob for editing</span>

<span class="nc bnc" id="L462" title="All 2 branches missed.">		if (bdesc.getWholeBlobRead())</span>
<span class="nc" id="L463">			return true;	// the whole blob has been previously read in</span>

		// data was not fully read in before, so try to do that now
		try {
<span class="nc" id="L467">			System.out.println(&quot;reading bytes from BLOB&quot;);</span>
<span class="nc" id="L468">			byte[] data = bdesc.getBlob().getBytes(1, (int)bdesc.getBlob().length());</span>

			// read succeeded, so reset the BlobDescriptor to match
<span class="nc" id="L471">			bdesc.setBlobRead(true);</span>
<span class="nc" id="L472">			bdesc.setData(data);</span>
<span class="nc" id="L473">			bdesc.setWholeBlobRead(true);</span>
<span class="nc" id="L474">			bdesc.setUserSetBlobLimit(0);</span>

			// we successfully read the whole thing
<span class="nc" id="L477">			 return true;</span>
		}
<span class="nc" id="L479">		catch (Exception ex) {</span>
<span class="nc" id="L480">			bdesc.setBlobRead(false);</span>
<span class="nc" id="L481">			bdesc.setWholeBlobRead(false);</span>
<span class="nc" id="L482">			bdesc.setData(null);</span>
			//?? What to do with this error?
			//?? error message = &quot;Could not read the complete data. Error was: &quot;+ex.getMessage());
<span class="nc" id="L485">			return false;</span>
		}
	}

	/*
	 * DataBase-related functions
	 */

	public Object readResultSet(ResultSet rs, int index, boolean limitDataRead)
		throws java.sql.SQLException {

<span class="nc" id="L496">		return staticReadResultSet(rs, index);</span>
	}

	 /**
	  * On input from the DB, read the data from the ResultSet into the appropriate
	  * type of object to be stored in the table cell.
	  */
	public static Object staticReadResultSet(ResultSet rs, int index)
		throws java.sql.SQLException {

		// We always get the BLOB, even when we are not reading the contents.
		// Since the BLOB is just a pointer to the BLOB data rather than the
		// data itself, this operation should not take much time (as opposed
		// to getting all of the data in the blob).
<span class="nc" id="L510">		Blob blob = rs.getBlob(index);</span>

<span class="nc bnc" id="L512" title="All 2 branches missed.">		if (rs.wasNull())</span>
<span class="nc" id="L513">			return null;</span>

		// BLOB exists, so try to read the data from it
		// based on the user's directions
<span class="nc bnc" id="L517" title="All 2 branches missed.">		if (_readBlobs)</span>
		{
			// User said to read at least some of the data from the blob
<span class="nc" id="L520">			byte[] blobData = null;</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">			if (blob != null)</span>
			{
<span class="nc" id="L523">				int len = (int)blob.length();</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">				if (len &gt; 0)</span>
				{
<span class="nc" id="L526">					int charsToRead = len;</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">					if (! _readCompleteBlobs)</span>
					{
<span class="nc" id="L529">						charsToRead = _readBlobsSize;</span>
					}
<span class="nc bnc" id="L531" title="All 2 branches missed.">					if (charsToRead &gt; len)</span>
					{
<span class="nc" id="L533">						charsToRead = len;</span>
					}
<span class="nc" id="L535">					blobData = blob.getBytes(1, charsToRead);</span>
				}
			}

			// determine whether we read all there was in the blob or not
<span class="nc" id="L540">			boolean wholeBlobRead = false;</span>
<span class="nc bnc" id="L541" title="All 4 branches missed.">			if (_readCompleteBlobs ||</span>
				blobData.length &lt; _readBlobsSize)
<span class="nc" id="L543">				wholeBlobRead = true;</span>

<span class="nc" id="L545">			return new BlobDescriptor(blob, blobData, true, wholeBlobRead,</span>
				_readBlobsSize);
		}
		else
		{
			// user said not to read any of the data from the blob
<span class="nc" id="L551">			return new BlobDescriptor(blob, null, false, false, 0);</span>
		}

	}

	/**
	 * When updating the database, generate a string form of this object value
	 * that can be used in the WHERE clause to match the value in the database.
	 * A return value of null means that this column cannot be used in the WHERE
	 * clause, while a return of &quot;null&quot; (or &quot;is null&quot;, etc) means that the column
	 * can be used in the WHERE clause and the value is actually a null value.
	 * This function must also include the column label so that its output
	 * is of the form:
	 * 	&quot;columnName = value&quot;
	 * or
	 * 	&quot;columnName is null&quot;
	 * or whatever is appropriate for this column in the database.
	 */
	public IWhereClausePart getWhereClauseValue(Object value, ISQLDatabaseMetaData md) {
<span class="nc bnc" id="L570" title="All 4 branches missed.">		if (value == null || ((BlobDescriptor)value).getData() == null)</span>
<span class="nc" id="L571">			return new IsNullWhereClausePart(_colDef);</span>
		else{
			// BLOB cannot be used in WHERE clause
			// TODO Review, if this DataType could not be used in a where clause
<span class="nc" id="L575">			return new EmptyWhereClausePart();</span>
		}
	}


	/**
	 * When updating the database, insert the appropriate datatype into the
	 * prepared statment at the given variable position.
	 */
	public void setPreparedStatementValue(PreparedStatement pstmt, Object value, int position)
		throws java.sql.SQLException {
<span class="nc bnc" id="L586" title="All 4 branches missed.">		if (value == null || ((BlobDescriptor)value).getData() == null) {</span>
<span class="nc" id="L587">			pstmt.setNull(position, _colDef.getSqlType());</span>
		}
		else {
			// for convenience cast the object to BlobDescriptor
<span class="nc" id="L591">			BlobDescriptor bdesc = (BlobDescriptor)value;</span>

			// There are a couple of possible ways to update the data in the DB.
			// The first is to use setString like this:
			//		bdesc.getBlob().setString(0, bdesc.getData());
			// However, the DB2 driver throws an exception saying that that function
			// is not implemented, so we have to use the other method, which is to use a stream.		
<span class="nc" id="L598">			pstmt.setBinaryStream(position, new ByteArrayInputStream(bdesc.getData()), bdesc.getData().length);</span>
		}
<span class="nc" id="L600">	}</span>

	/**
	 * Get a default value for the table used to input data for a new row
	 * to be inserted into the DB.
	 */
	public Object getDefaultValue(String dbDefaultValue) {
<span class="nc bnc" id="L607" title="All 2 branches missed.">		if (dbDefaultValue != null) {</span>
			// try to use the DB default value
<span class="nc" id="L609">			StringBuffer mbuf = new StringBuffer();</span>
<span class="nc" id="L610">			Object newObject = validateAndConvert(dbDefaultValue, null, mbuf);</span>

			// if there was a problem with converting, then just fall through
			// and continue as if there was no default given in the DB.
			// Otherwise, use the converted object
<span class="nc bnc" id="L615" title="All 2 branches missed.">			if (mbuf.length() == 0)</span>
<span class="nc" id="L616">				return newObject;</span>
		}

		// no default in DB.  If nullable, use null.
<span class="nc bnc" id="L620" title="All 2 branches missed.">		if (_isNullable)</span>
<span class="nc" id="L621">			return null;</span>

		// field is not nullable, so create a reasonable default value
<span class="nc" id="L624">		return null;</span>
	}


	/*
		 * File IO related functions
		 */


	 /**
	  * Say whether or not object can be exported to and imported from
	  * a file.  We put both export and import together in one test
	  * on the assumption that all conversions can be done both ways.
	  */
	 public boolean canDoFileIO() {
<span class="nc" id="L639">		 return true;</span>
	 }

	 /**
	  * Read a file and construct a valid object from its contents.
	  * Errors are returned by throwing an IOException containing the
	  * cause of the problem as its message.
	  * &lt;P&gt;
	  * DataType is responsible for validating that the imported
	  * data can be converted to an object, and then must return
	  * a text string that can be used in the Popup window text area.
	  * This object-to-text conversion is the same as is done by
	  * the DataType object internally in the getJTextArea() method.
	  * 
	  * &lt;P&gt;
	  * File is assumed to be and ASCII string of digits
	  * representing a value of this data type.
	  */
	public String importObject(FileInputStream inStream)
		throws IOException {


<span class="nc" id="L661">		int fileSize = inStream.available();</span>

<span class="nc" id="L663">		byte[] buf = new byte[fileSize];</span>

<span class="nc" id="L665">		int count = inStream.read(buf);</span>

<span class="nc bnc" id="L667" title="All 2 branches missed.">		if (count != fileSize) {</span>
<span class="nc" id="L668">			throw new IOException(</span>
				&quot;Could read only &quot;+ count +
				&quot; bytes from a total file size of &quot; + fileSize +
				&quot;. Import failed.&quot;);
		}
		// Convert bytes to Bytes
<span class="nc" id="L674">		Byte[] bBytes = new Byte[count];</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">		for (int i=0; i&lt;count; i++) {</span>
<span class="nc" id="L676">			bBytes[i] = Byte.valueOf(buf[i]);</span>
		}

		// return the text converted from the file 
<span class="nc" id="L680">		return BinaryDisplayConverter.convertToString(bBytes,</span>
			BinaryDisplayConverter.HEX, false);
	}


	 /**
	  * Construct an appropriate external representation of the object
	  * and write it to a file.
	  * Errors are returned by throwing an IOException containing the
	  * cause of the problem as its message.
	  * &lt;P&gt;
	  * DataType is responsible for validating that the given text
	  * text from a Popup JTextArea can be converted to an object.
	  * This text-to-object conversion is the same as validateAndConvertInPopup,
	  * which may be used internally by the object to do the validation.
	  * &lt;P&gt;
	  * The DataType object must flush and close the output stream before returning.
	  * Typically it will create another object (e.g. an OutputWriter), and
	  * that is the object that must be flushed and closed.
	  * 
	  * &lt;P&gt;
	  * File is assumed to be and ASCII string of digits
	  * representing a value of this data type.
	  */
	public void exportObject(FileOutputStream outStream, String text)
		throws IOException {

<span class="nc" id="L707">		Byte[] bBytes = BinaryDisplayConverter.convertToBytes(text,</span>
			BinaryDisplayConverter.HEX, false);

		// check that the text is a valid representation
<span class="nc" id="L711">		StringBuffer messageBuffer = new StringBuffer();</span>
<span class="nc" id="L712">		validateAndConvertInPopup(text, null, messageBuffer);</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">		if (messageBuffer.length() &gt; 0) {</span>
			// there was an error in the conversion
<span class="nc" id="L715">			throw new IOException(new String(messageBuffer));</span>
		}

		// Convert Bytes to bytes
<span class="nc" id="L719">		byte[] bytes = new byte[bBytes.length];</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">		for (int i=0; i&lt;bytes.length; i++)</span>
<span class="nc" id="L721">			bytes[i] = bBytes[i].byteValue();</span>

		// just send the text to the output file
<span class="nc" id="L724">		outStream.write(bytes);</span>
<span class="nc" id="L725">		outStream.flush();</span>
<span class="nc" id="L726">		outStream.close();</span>
<span class="nc" id="L727">	}</span>


	/*
		 * Property change control panel
		 */

	 /**
	  * Generate a JPanel containing controls that allow the user
	  * to adjust the properties for this DataType.
	  * All properties are static accross all instances of this DataType. 
	  * However, the class may choose to apply the information differentially,
	  * such as keeping a list (also entered by the user) of table/column names
	  * for which certain properties should be used.
	  * &lt;P&gt;
	  * This is called ONLY if there is at least one property entered into the DTProperties
	  * for this class.
	  * &lt;P&gt;
	  * Since this method is called by reflection on the Method object derived from this class,
	  * it does not need to be included in the Interface.
	  * It would be nice to include this in the Interface for consistancy, documentation, etc,
	  * but the Interface does not seem to like static methods.
	  */
	 public static OkJPanel getControlPanel() {

		/*
				 * If you add this method to one of the standard DataTypes in the
				 * fw/datasetviewer/cellcomponent directory, you must also add the name
				 * of that DataType class to the list in CellComponentFactory, method
				 * getControlPanels, variable named initialClassNameList.
				 * If the class is being registered with the factory using registerDataType,
				 * then you should not include the class name in the list (it will be found
				 * automatically), but if the DataType is part of the case statement in the
				 * factory method getDataTypeObject, then it does need to be explicitly listed
				 * in the getControlPanels method also.
				 */

		 // if this panel is called before any instances of the class have been
		 // created, we need to load the properties from the DTProperties.
<span class="nc" id="L766">		 loadProperties();</span>

<span class="nc" id="L768">		return new BlobOkJPanel();</span>
	 }



	 /**
	  * Inner class that extends OkJPanel so that we can call the ok()
	  * method to save the data when the user is happy with it.
	  */
	 private static class BlobOkJPanel extends OkJPanel {

	    private static final long serialVersionUID = 2859310264477848330L;

        /*
		 * GUI components - need to be here because they need to be
		 * accessible from the event handlers to alter each other's state.
		 */
		// check box for whether to read contents during table load or not
<span class="nc" id="L786">	    private JCheckBox _showBlobChk = new JCheckBox(</span>
		// i18n[dataTypeBlob.readOnFirstLoad=Read contents when table is first loaded:]
<span class="nc" id="L788">		s_stringMgr.getString(&quot;dataTypeBlob.readOnFirstLoad&quot;));</span>

		// label for type combo - used to enable/disable text associated with the combo
		// i18n[dataTypeBlob.read=Read]
<span class="nc" id="L792">		private RightLabel _typeDropLabel = new RightLabel(s_stringMgr.getString(&quot;dataTypeBlob.read&quot;));</span>

		// Combo box for read-all/read-part of blob
<span class="nc" id="L795">		private ReadTypeCombo _blobTypeDrop = new ReadTypeCombo();</span>

		// text field for how many bytes of Blob to read
<span class="nc" id="L798">		private IntegerField _showBlobSizeField = new IntegerField(5);</span>


<span class="nc" id="L801">		public BlobOkJPanel() {</span>

			/* set up the controls */
			// checkbox for read/not-read on table load
<span class="nc" id="L805">			_showBlobChk.setSelected(_readBlobs);</span>
<span class="nc" id="L806">			_showBlobChk.addChangeListener(new ChangeListener(){</span>
				public void stateChanged(ChangeEvent e) {
<span class="nc" id="L808">				_blobTypeDrop.setEnabled(_showBlobChk.isSelected());</span>
<span class="nc" id="L809">				_typeDropLabel.setEnabled(_showBlobChk.isSelected());</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">				_showBlobSizeField.setEnabled(_showBlobChk.isSelected() &amp;&amp;</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">					(_blobTypeDrop.getSelectedIndex()== 0));</span>
<span class="nc" id="L812">				}</span>
			});

			// Combo box for read-all/read-part of blob
<span class="nc" id="L816">			_blobTypeDrop = new ReadTypeCombo();</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">			_blobTypeDrop.setSelectedIndex( (_readCompleteBlobs) ? 1 : 0 );</span>
<span class="nc" id="L818">			_blobTypeDrop.addActionListener(new ActionListener(){</span>
				public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L820" title="All 2 branches missed.">					_showBlobSizeField.setEnabled(_blobTypeDrop.getSelectedIndex()== 0);</span>
<span class="nc" id="L821">				}</span>
			});

<span class="nc" id="L824">			_showBlobSizeField = new IntegerField(5);</span>
<span class="nc" id="L825">			_showBlobSizeField.setInt(_readBlobsSize);</span>


			// handle cross-connection between fields
<span class="nc" id="L829">			_blobTypeDrop.setEnabled(_readBlobs);</span>
<span class="nc" id="L830">			_typeDropLabel.setEnabled(_readBlobs);</span>
<span class="nc bnc" id="L831" title="All 4 branches missed.">			_showBlobSizeField.setEnabled(_readBlobs &amp;&amp;  ! _readCompleteBlobs);</span>

			/*
			  * Create the panel and add the GUI items to it
			 */

<span class="nc" id="L837">			setLayout(new GridBagLayout());</span>


			// i18n[dataTypeBlob.blobType=BLOB   (SQL type 2004)]
<span class="nc" id="L841">			setBorder(BorderFactory.createTitledBorder(s_stringMgr.getString(&quot;dataTypeBlob.blobType&quot;)));</span>
<span class="nc" id="L842">			final GridBagConstraints gbc = new GridBagConstraints();</span>
<span class="nc" id="L843">			gbc.fill = GridBagConstraints.HORIZONTAL;</span>
<span class="nc" id="L844">			gbc.insets = new Insets(4, 4, 4, 4);</span>
<span class="nc" id="L845">			gbc.anchor = GridBagConstraints.WEST;</span>

<span class="nc" id="L847">			gbc.gridx = 0;</span>
<span class="nc" id="L848">			gbc.gridy = 0;</span>

<span class="nc" id="L850">			gbc.gridwidth = 1;</span>
<span class="nc" id="L851">			add(_showBlobChk, gbc);</span>

<span class="nc" id="L853">			++gbc.gridx;</span>
<span class="nc" id="L854">			add(_typeDropLabel, gbc);</span>

<span class="nc" id="L856">			++gbc.gridx;</span>
<span class="nc" id="L857">			add(_blobTypeDrop, gbc);</span>

<span class="nc" id="L859">			++gbc.gridx;</span>
<span class="nc" id="L860">			add(_showBlobSizeField, gbc);</span>

<span class="nc" id="L862">		} // end of constructor for inner class</span>


		/**
		  * User has clicked OK in the surrounding JPanel,
		  * so save the current state of all variables
		  */
		public void ok() {
			// get the values from the controls and set them in the static properties
<span class="nc" id="L871">			_readBlobs = _showBlobChk.isSelected();</span>
<span class="nc" id="L872">			DTProperties.put(</span>
				thisClassName,
<span class="nc" id="L874">				&quot;readBlobs&quot;, Boolean.valueOf(_readBlobs).toString());</span>


<span class="nc bnc" id="L877" title="All 2 branches missed.">			_readCompleteBlobs = (_blobTypeDrop.getSelectedIndex() == 0) ? false : true;</span>
<span class="nc" id="L878">			DTProperties.put(</span>
				thisClassName,
<span class="nc" id="L880">				&quot;readCompleteBlobs&quot;, Boolean.valueOf(_readCompleteBlobs).toString());</span>

<span class="nc" id="L882">			_readBlobsSize = _showBlobSizeField.getInt();</span>
<span class="nc" id="L883">			DTProperties.put(</span>
				thisClassName,
<span class="nc" id="L885">				&quot;readBlobsSize&quot;, Integer.toString(_readBlobsSize));</span>
<span class="nc" id="L886">		}</span>

	 } // end of inner class
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>