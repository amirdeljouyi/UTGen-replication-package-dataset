<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataTypeUnknown.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">102_squirrel-sql</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent</a> &gt; <span class="el_source">DataTypeUnknown.java</span></div><h1>DataTypeUnknown.java</h1><pre class="source lang-java linenums">package net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent;
/*
 * Copyright (C) 2001-2003 Colin Bell
 * colbell@users.sourceforge.net
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
import java.awt.event.*;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.JTextArea;
import javax.swing.JCheckBox;
import javax.swing.SwingUtilities;
import javax.swing.text.JTextComponent;
import javax.swing.BorderFactory;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import net.sourceforge.squirrel_sql.fw.sql.ISQLDatabaseMetaData;
import net.sourceforge.squirrel_sql.fw.util.StringManager;
import net.sourceforge.squirrel_sql.fw.util.StringManagerFactory;
import net.sourceforge.squirrel_sql.fw.datasetviewer.CellDataPopup;
import net.sourceforge.squirrel_sql.fw.datasetviewer.ColumnDisplayDefinition;
import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.whereClause.IWhereClausePart;
import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.whereClause.IsNullWhereClausePart;
import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.whereClause.EmptyWhereClausePart;
import net.sourceforge.squirrel_sql.fw.gui.OkJPanel;

/**
 * @author gwg
 *
 * This class provides the display components for handling unknown,
 * non-standard, or not-handled-by-SQuirreL data types.
 * &lt;P&gt;
 * The default SQuirreL code can handle only JDBC-standard defined data types.
 * Since this data type represents DBMS-specific enhancements or
 * user-defined data types, we cannot do anything intelligent with the data.
 * We allow the user to select one of two modes of operation:
 * &lt;DL&gt;
 * &lt;LI&gt;
 * we can try to get the contents of the DB element and print it as a string, or,
 * &lt;LI&gt;
 * we will display an appropriately internationalized version of &quot;&lt;Unknown&gt;&quot;.
 * &lt;/DL&gt;
 * In either case, the data will be stored and processed as a String.
 * &lt;P&gt;
 * The user may not edit the contents of this field in either the cell or popup
 * because we do not understand the structure or limitations of the contents,
 * and therefore cannot validate it or put it back into the DB.
 * The field is not used in the WHERE clause because we do not know whether
 * or not it might contain binary data, and because we do not know how to
 * format the data for SQL operations.
 * &lt;P&gt;
 * To handle these data types more intelligently and allow editing on them,
 * DBMS-specific plug-ins will need to be developed to register handlers
 * for instances of this type.
 */

public class DataTypeUnknown extends BaseDataTypeComponent
	implements IDataTypeComponent
{
	/* whether nulls are allowed or not */
	private boolean _isNullable;

	/* table of which we are part (needed for creating popup dialog) */
	private JTable _table;
	
	/* The JTextComponent that is being used for editing */
	private IRestorableTextComponent _textComponent;
	
	/** Internationalized strings for this class, shared/copied from ResultSetReader. */
<span class="nc" id="L89">	private static final StringManager s_stringMgr =</span>
<span class="nc" id="L90">		StringManagerFactory.getStringManager(DataTypeUnknown.class);</span>
	
	/* The CellRenderer used for this data type */
	//??? For now, use the same renderer as everyone else.
	//??
	//?? IN FUTURE: change this to use a new instance of renederer
	//?? for this data type.
<span class="nc" id="L97">	private DefaultColumnRenderer _renderer = DefaultColumnRenderer.getInstance();</span>



	/**
	 * Name of this class, which is needed because the class name is needed
	 * by the static method getControlPanel, so we cannot use something
	 * like getClass() to find this name.
	 */
	private static final String thisClassName =
		&quot;net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.DataTypeUnknown&quot;;

	/*
	 * Properties settable by the user
	 */
	 // flag for whether we have already loaded the properties or not
<span class="nc" id="L113">	 private static boolean propertiesAlreadyLoaded = false;</span>
	 
		 
	/** Read the contents of Other from Result sets when first loading the tables. */
<span class="nc" id="L117">	private static boolean _readUnknown = false;</span>
	
	

	/**
	 * Constructor - save the data needed by this data type.
	 */
<span class="nc" id="L124">	public DataTypeUnknown(JTable table, ColumnDisplayDefinition colDef) {</span>
<span class="nc" id="L125">		_table = table;</span>
<span class="nc" id="L126">		_colDef = colDef;</span>
<span class="nc" id="L127">		_isNullable = colDef.isNullable();</span>

<span class="nc" id="L129">		loadProperties();</span>
<span class="nc" id="L130">	}</span>
	
	/** Internal function to get the user-settable properties from the DTProperties,
	 * if they exist, and to ensure that defaults are set if the properties have
	 * not yet been created.
	 * &lt;P&gt;
	 * This method may be called from different places depending on whether
	 * an instance of this class is created before the user brings up the Session
	 * Properties window.  In either case, the data is static and is set only
	 * the first time we are called.
	 */
	private static void loadProperties() {
		
		//set the property values
		// Note: this may have already been done by another instance of
		// this DataType created to handle a different column.
<span class="nc bnc" id="L146" title="All 2 branches missed.">		if (propertiesAlreadyLoaded == false) {</span>
			// get parameters previously set by user, or set default values
<span class="nc" id="L148">			_readUnknown = false;	// set to the default</span>
<span class="nc" id="L149">			String readUnknownString = DTProperties.get(</span>
				thisClassName, &quot;readUnknown&quot;);
<span class="nc bnc" id="L151" title="All 4 branches missed.">			if (readUnknownString != null &amp;&amp; readUnknownString.equals(&quot;true&quot;))</span>
<span class="nc" id="L152">				_readUnknown = true;</span>

<span class="nc" id="L154">			propertiesAlreadyLoaded = true;</span>
		}
<span class="nc" id="L156">	}</span>
	
	/**
	 * Return the name of the java class used to hold this data type.
	 * For Unknown, this will always be a string.
	 */
	public String getClassName() {
<span class="nc" id="L163">		return &quot;java.lang.String&quot;;</span>
	}

	/*
	 * First we have the methods for in-cell and Text-table operations
	 */
	 
	/**
	 * Render a value into text for this DataType.
	 */
	public String renderObject(Object value) {
<span class="nc" id="L174">		return (String)_renderer.renderObject(value);</span>
	}
	
	/**
	 * This Data Type can be edited in a table cell.
	 */
	public boolean isEditableInCell(Object originalValue) {
<span class="nc" id="L181">		return false;	</span>
	}

	/**
	 * See if a value in a column has been limited in some way and
	 * needs to be re-read before being used for editing.
	 * For read-only tables this may actually return true since we want
	 * to be able to view the entire contents of the cell even if it was not
	 * completely loaded during the initial table setup.
	 */
	public boolean needToReRead(Object originalValue) {
		// this DataType does not limit the data read during the initial load of the table,
		// so there is no need to re-read the complete data later
<span class="nc" id="L194">		return false;</span>
	}
	
	/**
	 * Return a JTextField usable in a CellEditor.
	 */
	public JTextField getJTextField() {
<span class="nc" id="L201">		_textComponent = new RestorableJTextField();</span>
		
		// special handling of operations while editing this data type
<span class="nc" id="L204">		((RestorableJTextField)_textComponent).addKeyListener(new KeyTextHandler());</span>
				
		//
		// handle mouse events for double-click creation of popup dialog.
		// This happens only in the JTextField, not the JTextArea, so we can
		// make this an inner class within this method rather than a separate
		// inner class as is done with the KeyTextHandler class.
		//
<span class="nc" id="L212">		((RestorableJTextField)_textComponent).addMouseListener(new MouseAdapter()</span>
<span class="nc" id="L213">		{</span>
			public void mousePressed(MouseEvent evt)
			{
<span class="nc bnc" id="L216" title="All 2 branches missed.">				if (evt.getClickCount() == 2)</span>
				{
<span class="nc" id="L218">					MouseEvent tableEvt = SwingUtilities.convertMouseEvent(</span>
<span class="nc" id="L219">						(RestorableJTextField)DataTypeUnknown.this._textComponent,</span>
<span class="nc" id="L220">						evt, DataTypeUnknown.this._table);</span>
<span class="nc" id="L221">					CellDataPopup.showDialog(DataTypeUnknown.this._table,</span>
						DataTypeUnknown.this._colDef, tableEvt, true);
				}
<span class="nc" id="L224">			}</span>
		});	// end of mouse listener

<span class="nc" id="L227">		return (JTextField)_textComponent;</span>
	}

	/**
	 * Implement the interface for validating and converting to internal object.
	 * Since we do not know how to convert Unknown objects,
	 * just return null with no error in the messageBuffer
	 */
	public Object validateAndConvert(String value, Object originalValue, StringBuffer messageBuffer) {
<span class="nc" id="L236">		return null;</span>
	}

	/**
	 * If true, this tells the PopupEditableIOPanel to use the
	 * binary editing panel rather than a pure text panel.
	 * The binary editing panel assumes the data is an array of bytes,
	 * converts it into text form, allows the user to change how that
	 * data is displayed (e.g. Hex, Decimal, etc.), and converts
	 * the data back from text to bytes when the user editing is completed.
	 * If this returns false, this DataType class must
	 * convert the internal data into a text string that
	 * can be displayed (and edited, if allowed) in a TextField
	 * or TextArea, and must handle all
	 * user key strokes related to editing of that data.
	 */
	public boolean useBinaryEditingPanel() {
<span class="nc" id="L253">		return false;</span>
	}
	 

	/*
	 * Now the functions for the Popup-related operations.
	 */
	
	/**
	 * Returns true if data type may be edited in the popup,
	 * false if not.
	 */
	public boolean isEditableInPopup(Object originalValue) {
<span class="nc" id="L266">		return false;</span>
	}

	/*
	 * Return a JTextArea usable in the CellPopupDialog
	 * and fill in the value.
	 */
	 public JTextArea getJTextArea(Object value) {
<span class="nc" id="L274">		_textComponent = new RestorableJTextArea();</span>
		
		// value is a simple string representation of the data,
		// the same one used in Text and in-cell operations.
<span class="nc" id="L278">		((RestorableJTextArea)_textComponent).setText(renderObject(value));</span>
		
		// special handling of operations while editing this data type
<span class="nc" id="L281">		((RestorableJTextArea)_textComponent).addKeyListener(new KeyTextHandler());</span>
		
<span class="nc" id="L283">		return (RestorableJTextArea)_textComponent;</span>
	 }

	/**
	 * Validating and converting in Popup is identical to cell-related operation.
	 */
	public Object validateAndConvertInPopup(String value, Object originalValue, StringBuffer messageBuffer) {
<span class="nc" id="L290">		return validateAndConvert(value, originalValue, messageBuffer);</span>
	}

	/*
	 * The following is used in both cell and popup operations.
	 */	
	
	/*
	 * Internal class for handling key events during editing
	 * of both JTextField and JTextArea.
	 * Since the Unknown data type is not editable either in the Cell or in the Popup,
	 * we should never get here, but we have provided appropriate code just in case.
	 */
<span class="nc" id="L303">	 private class KeyTextHandler extends KeyAdapter {</span>
	 	public void keyTyped(KeyEvent e) {
				// as a coding convenience, create a reference to the text component
				// that is typecast to JTextComponent.  this is not essential, as we
				// could typecast every reference, but this makes the code cleaner
<span class="nc" id="L308">				JTextComponent _theComponent = (JTextComponent)DataTypeUnknown.this._textComponent;</span>
<span class="nc" id="L309">				_beepHelper.beep(_theComponent);</span>
<span class="nc" id="L310">				e.consume();</span>
<span class="nc" id="L311">			}</span>
		}


	
	
	/*
	 * DataBase-related functions
	 */
	 
	 /**
	  * On input from the DB, read the data from the ResultSet into the appropriate
	  * type of object to be stored in the table cell.
	  */
	public Object readResultSet(ResultSet rs, int index, boolean limitDataRead)
		throws java.sql.SQLException {

<span class="nc" id="L328">		String data = null;</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">		if (_readUnknown)</span>
		{
			// Running getObject on a java class attempts
			// to load the class in memory which we don't want.
			// getString() just gets the value without loading
			// the class (at least under PostgreSQL).
			//row[i] = _rs.getObject(index);
<span class="nc" id="L336">			data = rs.getString(index);</span>
		}
		else
		{
<span class="nc" id="L340">			data = s_stringMgr.getString(&quot;DataTypeUnknown.unknown&quot;,</span>
<span class="nc" id="L341">			                             _colDef.getSqlType() );</span>
		}
		
<span class="nc bnc" id="L344" title="All 2 branches missed.">		if (rs.wasNull())</span>
<span class="nc" id="L345">			return null;</span>
<span class="nc" id="L346">		else return data;</span>
	}

	/**
	 * When updating the database, generate a string form of this object value
	 * that can be used in the WHERE clause to match the value in the database.
	 * A return value of null means that this column cannot be used in the WHERE
	 * clause, while a return of &quot;null&quot; (or &quot;is null&quot;, etc) means that the column
	 * can be used in the WHERE clause and the value is actually a null value.
	 * This function must also include the column label so that its output
	 * is of the form:
	 * 	&quot;columnName = value&quot;
	 * or
	 * 	&quot;columnName is null&quot;
	 * or whatever is appropriate for this column in the database.
	 */
	public IWhereClausePart getWhereClauseValue(Object value, ISQLDatabaseMetaData md) {
<span class="nc bnc" id="L363" title="All 6 branches missed.">		if (value == null || value.toString() == null || value.toString().length() == 0)</span>
<span class="nc" id="L364">			return new IsNullWhereClausePart(_colDef);</span>
		else
<span class="nc" id="L366">			return new EmptyWhereClausePart();</span>
	}
	
	
	/**
	 * When updating the database, insert the appropriate datatype into the
	 * prepared statment at variable position 1.
	 * This function should never be called for type Unknown
	 */
	public void setPreparedStatementValue(PreparedStatement pstmt, Object value, int position)
		throws java.sql.SQLException {

<span class="nc" id="L378">		throw new java.sql.SQLException(&quot;Can not update data of type OTHER&quot;);</span>
	}
	
	/**
	 * Get a default value for the table used to input data for a new row
	 * to be inserted into the DB.
	 */
	public Object getDefaultValue(String dbDefaultValue) {
<span class="nc bnc" id="L386" title="All 2 branches missed.">		if (dbDefaultValue != null) {</span>
			// try to use the DB default value
<span class="nc" id="L388">			StringBuffer mbuf = new StringBuffer();</span>
<span class="nc" id="L389">			Object newObject = validateAndConvert(dbDefaultValue, null, mbuf);</span>
			
			// if there was a problem with converting, then just fall through
			// and continue as if there was no default given in the DB.
			// Otherwise, use the converted object
<span class="nc bnc" id="L394" title="All 2 branches missed.">			if (mbuf.length() == 0)</span>
<span class="nc" id="L395">				return newObject;</span>
		}
		
		// no default in DB.  If nullable, use null.
<span class="nc bnc" id="L399" title="All 2 branches missed.">		if (_isNullable)</span>
<span class="nc" id="L400">			return null;</span>
		
		// field is not nullable, so create a reasonable default value
		// cannot create default value for unknown data type
<span class="nc" id="L404">		return null;</span>
	}
	
	
	/*
	 * File IO related functions
	 */
	 
	 
	 /**
	  * Say whether or not object can be exported to and imported from
	  * a file.  We put both export and import together in one test
	  * on the assumption that all conversions can be done both ways.
	  * Since we do not understand data of type Unknown, we cannot safely
	  * export or import it.
	  */
	 public boolean canDoFileIO() {
<span class="nc" id="L421">	 	return false;</span>
	 }
	 
	 /**
	  * Read a file and construct a valid object from its contents.
	  * Errors are returned by throwing an IOException containing the
	  * cause of the problem as its message.
	  * &lt;P&gt;
	  * DataType is responsible for validating that the imported
	  * data can be converted to an object, and then must return
	  * a text string that can be used in the Popup window text area.
	  * This object-to-text conversion is the same as is done by
	  * the DataType object internally in the getJTextArea() method.
	  * 
	  * &lt;P&gt;
	  * File is assumed to be and ASCII string of digits
	  * representing a value of this data type.
	  */
	public String importObject(FileInputStream inStream)
	 	throws IOException {
	 	
<span class="nc" id="L442">		throw new IOException(&quot;Can not import data type OTHER&quot;);</span>
	}

	 	 
	 /**
	  * Construct an appropriate external representation of the object
	  * and write it to a file.
	  * Errors are returned by throwing an IOException containing the
	  * cause of the problem as its message.
	  * &lt;P&gt;
	  * DataType is responsible for validating that the given text
	  * text from a Popup JTextArea can be converted to an object.
	  * This text-to-object conversion is the same as validateAndConvertInPopup,
	  * which may be used internally by the object to do the validation.
	  * &lt;P&gt;
	  * The DataType object must flush and close the output stream before returning.
	  * Typically it will create another object (e.g. an OutputWriter), and
	  * that is the object that must be flushed and closed.
	  * 
	  * &lt;P&gt;
	  * File is assumed to be and ASCII string of digits
	  * representing a value of this data type.
	  */
	 public void exportObject(FileOutputStream outStream, String text)
	 	throws IOException {
	 	
<span class="nc" id="L468">		throw new IOException(&quot;Can not export data type OTHER&quot;);</span>
	 }



	/*
	 * Property change control panel
	 */	  
	 
	 /**
	  * Generate a JPanel containing controls that allow the user
	  * to adjust the properties for this DataType.
	  * All properties are static accross all instances of this DataType. 
	  * However, the class may choose to apply the information differentially,
	  * such as keeping a list (also entered by the user) of table/column names
	  * for which certain properties should be used.
	  * &lt;P&gt;
	  * This is called ONLY if there is at least one property entered into the DTProperties
	  * for this class.
	  * &lt;P&gt;
	  * Since this method is called by reflection on the Method object derived from this class,
	  * it does not need to be included in the Interface.
	  * It would be nice to include this in the Interface for consistancy, documentation, etc,
	  * but the Interface does not seem to like static methods.
	  */
	 public static OkJPanel getControlPanel() {
	 	
		/*
		 * If you add this method to one of the standard DataTypes in the
		 * fw/datasetviewer/cellcomponent directory, you must also add the name
		 * of that DataType class to the list in CellComponentFactory, method
		 * getControlPanels, variable named initialClassNameList.
		 * If the class is being registered with the factory using registerDataType,
		 * then you should not include the class name in the list (it will be found
		 * automatically), but if the DataType is part of the case statement in the
		 * factory method getDataTypeObject, then it does need to be explicitly listed
		 * in the getControlPanels method also.
		 */
		 
		 // if this panel is called before any instances of the class have been
		 // created, we need to load the properties from the DTProperties.
<span class="nc" id="L509">		 loadProperties();</span>
		 
<span class="nc" id="L511">		return new UnknownOkJPanel();</span>
	 }
	 
	 
	 
	 /**
	  * Inner class that extends OkJPanel so that we can call the ok()
	  * method to save the data when the user is happy with it.
	  */
	 private static class UnknownOkJPanel extends OkJPanel {
        private static final long serialVersionUID = 1L;
        /*
		 * GUI components - need to be here because they need to be
		 * accessible from the event handlers to alter each other's state.
		 */
		// check box for whether to read contents during table load or not
<span class="nc" id="L527">		private JCheckBox _showUnknownChk = new JCheckBox(</span>
			// i18n[dataTypeUnknown.readContentsOnLoad=Read contents when table is first loaded and display as string]
<span class="nc" id="L529">			s_stringMgr.getString(&quot;dataTypeUnknown.readContentsOnLoad&quot;));</span>


<span class="nc" id="L532">		public UnknownOkJPanel() {</span>
		 	 
			/* set up the controls */
			// checkbox for read/not-read on table load
<span class="nc" id="L536">			_showUnknownChk.setSelected(_readUnknown);</span>

			/*
			 * Create the panel and add the GUI items to it
			 */
 		
<span class="nc" id="L542">			setBorder(BorderFactory.createTitledBorder(</span>
				// i18n[dataTypeUnknown.unknownTypes=Unknown DataTypes   (non-standard SQL type codes)]
<span class="nc" id="L544">				s_stringMgr.getString(&quot;dataTypeUnknown.unknownTypes&quot;)));</span>

<span class="nc" id="L546">			add(_showUnknownChk);</span>

<span class="nc" id="L548">		} // end of constructor for inner class</span>
	 
	 
		/**
		 * User has clicked OK in the surrounding JPanel,
		 * so save the current state of all variables
		 */
		public void ok() {
			// get the values from the controls and set them in the static properties
<span class="nc" id="L557">			_readUnknown = _showUnknownChk.isSelected();</span>
<span class="nc" id="L558">			DTProperties.put(</span>
				thisClassName,
<span class="nc" id="L560">				&quot;readUnknown&quot;, Boolean.valueOf(_readUnknown).toString());</span>
<span class="nc" id="L561">		}</span>
	 
	 } // end of inner class
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>