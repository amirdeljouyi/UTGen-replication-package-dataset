<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataTypeBoolean.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">102_squirrel-sql</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent</a> &gt; <span class="el_source">DataTypeBoolean.java</span></div><h1>DataTypeBoolean.java</h1><pre class="source lang-java linenums">package net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent;

/*
 * Copyright (C) 2001-2003 Colin Bell
 * colbell@users.sourceforge.net
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.text.JTextComponent;

import net.sourceforge.squirrel_sql.fw.datasetviewer.CellDataPopup;
import net.sourceforge.squirrel_sql.fw.datasetviewer.ColumnDisplayDefinition;
import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.whereClause.IWhereClausePart;
import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.whereClause.IsNullWhereClausePart;
import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.whereClause.ParameterWhereClausePart;
import net.sourceforge.squirrel_sql.fw.sql.ISQLDatabaseMetaData;

/**
 * @author gwg This class provides the display components for handling Boolean data types, specifically SQL
 *         type BIT. The display components are for:
 *         &lt;UL&gt;
 *         &lt;LI&gt;read-only display within a table cell
 *         &lt;LI&gt;editing within a table cell
 *         &lt;LI&gt;read-only or editing display within a separate window
 *         &lt;/UL&gt;
 *         The class also contains
 *         &lt;UL&gt;
 *         &lt;LI&gt;a function to compare two display values to see if they are equal. This is needed because the
 *         display format may not be the same as the internal format, and all internal object types may not
 *         provide an appropriate equals() function.
 *         &lt;LI&gt;a function to return a printable text form of the cell contents, which is used in the text
 *         version of the table.
 *         &lt;/UL&gt;
 *         &lt;P&gt;
 *         The components returned from this class extend RestorableJTextField and RestorableJTextArea for use
 *         in editing table cells that contain values of this data type. It provides the special behavior for
 *         null handling and resetting the cell to the original value.
 */

public class DataTypeBoolean extends BaseDataTypeComponent implements IDataTypeComponent
{
	/* whether nulls are allowed or not */
	private boolean _isNullable;

	/* table of which we are part (needed for creating popup dialog) */
	private JTable _table;

	/* The JTextComponent that is being used for editing */
	private IRestorableTextComponent _textComponent;

	/* The CellRenderer used for this data type */
	// ??? For now, use the same renderer as everyone else.
	// ??
	// ?? IN FUTURE: change this to use a new instance of renderer
	// ?? for this data type.
<span class="nc" id="L84">	private DefaultColumnRenderer _renderer = DefaultColumnRenderer.getInstance();</span>

	/**
	 * Constructor - save the data needed by this data type.
	 */
	public DataTypeBoolean(JTable table, ColumnDisplayDefinition colDef)
<span class="nc" id="L90">	{</span>
<span class="nc" id="L91">		_table = table;</span>
<span class="nc" id="L92">		_colDef = colDef;</span>
<span class="nc" id="L93">		_isNullable = colDef.isNullable();</span>
<span class="nc" id="L94">	}</span>

	/**
	 * Return the name of the java class used to hold this data type.
	 */
	public String getClassName()
	{
<span class="nc" id="L101">		return &quot;java.lang.Boolean&quot;;</span>
	}

	/*
	 * First we have the methods for in-cell and Text-table operations
	 */

	/**
	 * Render a value into text for this DataType.
	 */
	public String renderObject(Object value)
	{
<span class="nc" id="L113">		return (String) _renderer.renderObject(value);</span>
	}

	/**
	 * This Data Type can be edited in a table cell.
	 */
	public boolean isEditableInCell(Object originalValue)
	{
<span class="nc" id="L121">		return true;</span>
	}

	/**
	 * See if a value in a column has been limited in some way and needs to be re-read before being used for
	 * editing. For read-only tables this may actually return true since we want to be able to view the entire
	 * contents of the cell even if it was not completely loaded during the initial table setup.
	 */
	public boolean needToReRead(Object originalValue)
	{
		// this DataType does not limit the data read during the initial load of the table,
		// so there is no need to re-read the complete data later
<span class="nc" id="L133">		return false;</span>
	}

	/**
	 * Return a JTextField usable in a CellEditor.
	 */
	public JTextField getJTextField()
	{
<span class="nc" id="L141">		_textComponent = new RestorableJTextField();</span>

		// special handling of operations while editing this data type
<span class="nc" id="L144">		((RestorableJTextField) _textComponent).addKeyListener(new KeyTextHandler());</span>

		//
		// handle mouse events for double-click creation of popup dialog.
		// This happens only in the JTextField, not the JTextArea, so we can
		// make this an inner class within this method rather than a separate
		// inner class as is done with the KeyTextHandler class.
		//
<span class="nc" id="L152">		((RestorableJTextField) _textComponent).addMouseListener(new MouseAdapter()</span>
<span class="nc" id="L153">		{</span>
			public void mousePressed(MouseEvent evt)
			{
<span class="nc bnc" id="L156" title="All 2 branches missed.">				if (evt.getClickCount() == 2)</span>
				{
<span class="nc" id="L158">					MouseEvent tableEvt =</span>
<span class="nc" id="L159">						SwingUtilities.convertMouseEvent(</span>
<span class="nc" id="L160">							(RestorableJTextField) DataTypeBoolean.this._textComponent, evt,</span>
<span class="nc" id="L161">							DataTypeBoolean.this._table);</span>
<span class="nc" id="L162">					CellDataPopup.showDialog(DataTypeBoolean.this._table, DataTypeBoolean.this._colDef, tableEvt,</span>
						true);
				}
<span class="nc" id="L165">			}</span>
		}); // end of mouse listener

<span class="nc" id="L168">		return (JTextField) _textComponent;</span>
	}

	/**
	 * Implement the interface for validating and converting to internal object. Null is a valid successful
	 * return, so errors are indicated only by existance or not of a message in the messageBuffer.
	 */
	public Object validateAndConvert(String value, Object originalValue, StringBuffer messageBuffer)
	{
		// handle null, which is shown as the special string &quot;&lt;null&gt;&quot;
<span class="nc bnc" id="L178" title="All 4 branches missed.">		if (value.equals(&quot;&lt;null&gt;&quot;) || value.equals(&quot;&quot;)) return null;</span>

		// Do the conversion into the object in a safe manner
		try
		{
<span class="nc" id="L183">			Object obj = Boolean.valueOf(value);</span>
<span class="nc" id="L184">			return obj;</span>
		}
<span class="nc" id="L186">		catch (Exception e)</span>
		{
<span class="nc" id="L188">			messageBuffer.append(e.toString() + &quot;\n&quot;);</span>
			// ?? do we need the message also, or is it automatically part of the toString()?
			// messageBuffer.append(e.getMessage());
<span class="nc" id="L191">			return null;</span>
		}
	}

	/**
	 * If true, this tells the PopupEditableIOPanel to use the binary editing panel rather than a pure text
	 * panel. The binary editing panel assumes the data is an array of bytes, converts it into text form,
	 * allows the user to change how that data is displayed (e.g. Hex, Decimal, etc.), and converts the data
	 * back from text to bytes when the user editing is completed. If this returns false, this DataType class
	 * must convert the internal data into a text string that can be displayed (and edited, if allowed) in a
	 * TextField or TextArea, and must handle all user key strokes related to editing of that data.
	 */
	public boolean useBinaryEditingPanel()
	{
<span class="nc" id="L205">		return false;</span>
	}

	/*
	 * Now the functions for the Popup-related operations.
	 */

	/**
	 * Returns true if data type may be edited in the popup, false if not.
	 */
	public boolean isEditableInPopup(Object originalValue)
	{
<span class="nc" id="L217">		return true;</span>
	}

	/*
	 * Return a JTextArea usable in the CellPopupDialog
	 * and fill in the value.
	 */
	public JTextArea getJTextArea(Object value)
	{
<span class="nc" id="L226">		_textComponent = new RestorableJTextArea();</span>

		// value is a simple string representation of the data,
		// the same one used in Text and in-cell operations.
<span class="nc" id="L230">		((RestorableJTextArea) _textComponent).setText(renderObject(value));</span>

		// special handling of operations while editing this data type
<span class="nc" id="L233">		((RestorableJTextArea) _textComponent).addKeyListener(new KeyTextHandler());</span>

<span class="nc" id="L235">		return (RestorableJTextArea) _textComponent;</span>
	}

	/**
	 * Validating and converting in Popup is identical to cell-related operation.
	 */
	public Object validateAndConvertInPopup(String value, Object originalValue, StringBuffer messageBuffer)
	{
<span class="nc" id="L243">		return validateAndConvert(value, originalValue, messageBuffer);</span>
	}

	/*
	 * The following is used in both cell and popup operations.
	 */

	/*
	 * Internal class for handling key events during editing
	 * of both JTextField and JTextArea.
	 */
<span class="nc" id="L254">	private class KeyTextHandler extends KeyAdapter</span>
	{
		public void keyTyped(KeyEvent e)
		{
<span class="nc" id="L258">			char c = e.getKeyChar();</span>

			// as a coding convenience, create a reference to the text component
			// that is typecast to JTextComponent. this is not essential, as we
			// could typecast every reference, but this makes the code cleaner
<span class="nc" id="L263">			JTextComponent _theComponent = (JTextComponent) DataTypeBoolean.this._textComponent;</span>
<span class="nc" id="L264">			String text = _theComponent.getText();</span>

			// let user enter T, t, Y, y, or 1 for true, and
			// F, f, N, n, or 0 for false
<span class="nc bnc" id="L268" title="All 2 branches missed.">			if (&quot;TtYy1&quot;.indexOf(c) &gt; -1)</span>
			{
				// user wants field to be true
<span class="nc" id="L271">				DataTypeBoolean.this._textComponent.updateText(&quot;true&quot;);</span>
<span class="nc" id="L272">				e.consume();</span>
<span class="nc" id="L273">				return;</span>
			}
<span class="nc bnc" id="L275" title="All 2 branches missed.">			if (&quot;FfNn0&quot;.indexOf(c) &gt; -1)</span>
			{
				// user wants field to be false
<span class="nc" id="L278">				DataTypeBoolean.this._textComponent.updateText(&quot;false&quot;);</span>
<span class="nc" id="L279">				e.consume();</span>
<span class="nc" id="L280">				return;</span>
			}

			// tabs and newlines get put into the text before this check,
			// so remove them
			// This only applies to Popup editing since these chars are
			// not passed to this level by the in-cell editor.
<span class="nc bnc" id="L287" title="All 4 branches missed.">			if (c == KeyEvent.VK_TAB || c == KeyEvent.VK_ENTER)</span>
			{
				// remove all instances of the offending char
<span class="nc" id="L290">				int index = text.indexOf(c);</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">				if (index != -1)</span>
				{
<span class="nc bnc" id="L293" title="All 2 branches missed.">					if (index == text.length() - 1)</span>
					{
<span class="nc" id="L295">						text = text.substring(0, text.length() - 1); // truncate string</span>
					}
					else
					{
<span class="nc" id="L299">						text = text.substring(0, index) + text.substring(index + 1);</span>
					}
<span class="nc" id="L301">					((IRestorableTextComponent) _theComponent).updateText(text);</span>
<span class="nc" id="L302">					_beepHelper.beep(_theComponent);</span>
				}
<span class="nc" id="L304">				e.consume();</span>
			}

			// handle cases of null
			// The only legal input in this case is a delete

<span class="nc bnc" id="L310" title="All 6 branches missed.">			if (DataTypeBoolean.this._isNullable &amp;&amp; (c == KeyEvent.VK_BACK_SPACE) || (c == KeyEvent.VK_DELETE))</span>
			{

				// user enters something when field is null
<span class="nc bnc" id="L314" title="All 2 branches missed.">				if (text.equals(&quot;&lt;null&gt;&quot;))</span>
				{
					// delete when null =&gt; original value
<span class="nc" id="L317">					DataTypeBoolean.this._textComponent.restoreText();</span>
<span class="nc" id="L318">					e.consume();</span>
				}
				else
				{
					// when field is not null delete means set to null, so do it
<span class="nc" id="L323">					DataTypeBoolean.this._textComponent.updateText(&quot;&lt;null&gt;&quot;);</span>
<span class="nc" id="L324">					e.consume();</span>
				}
			}
			else
			{
				// field is not nullable or input was not a delete
				//
				// we have already handled all legal input,
				// so just tell user this is being ignored
<span class="nc" id="L333">				_beepHelper.beep(_theComponent);</span>
<span class="nc" id="L334">				e.consume();</span>
			}
<span class="nc" id="L336">		}</span>
	}

	/*
	 * DataBase-related functions
	 */

	/**
	 * On input from the DB, read the data from the ResultSet into the appropriate type of object to be stored
	 * in the table cell.
	 */
	public Object readResultSet(ResultSet rs, int index, boolean limitDataRead) throws java.sql.SQLException
	{

<span class="nc" id="L350">		boolean data = rs.getBoolean(index);</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">		if (rs.wasNull())</span>
		{
<span class="nc" id="L353">			return null;</span>
		}
		else
		{
<span class="nc" id="L357">			return Boolean.valueOf(data);</span>
		}
	}

	/**
	 * When updating the database, generate a string form of this object value that can be used in the WHERE
	 * clause to match the value in the database. A return value of null means that this column cannot be used
	 * in the WHERE clause, while a return of &quot;null&quot; (or &quot;is null&quot;, etc) means that the column can be used in
	 * the WHERE clause and the value is actually a null value. This function must also include the column
	 * label so that its output is of the form: &quot;columnName = value&quot; or &quot;columnName is null&quot; or whatever is
	 * appropriate for this column in the database.
	 */
	public IWhereClausePart getWhereClauseValue(Object value, ISQLDatabaseMetaData md)
	{
<span class="nc bnc" id="L371" title="All 6 branches missed.">		if (value == null || value.toString() == null || value.toString().length() == 0)</span>
		{
<span class="nc" id="L373">			return new IsNullWhereClausePart(_colDef);</span>

		}
		else
		{
<span class="nc" id="L378">			return new ParameterWhereClausePart(_colDef, value, this);</span>
		}
	}

	/**
	 * When updating the database, insert the appropriate datatype into the prepared statment at the given
	 * variable position.
	 */
	public void setPreparedStatementValue(PreparedStatement pstmt, Object value, int position)
		throws java.sql.SQLException
	{
<span class="nc bnc" id="L389" title="All 2 branches missed.">		if (value == null)</span>
		{
<span class="nc" id="L391">			pstmt.setNull(position, _colDef.getSqlType());</span>
		}
		else
		{
<span class="nc" id="L395">			pstmt.setBoolean(position, ((Boolean) value).booleanValue());</span>
		}
<span class="nc" id="L397">	}</span>

	/**
	 * Get a default value for the table used to input data for a new row to be inserted into the DB.
	 */
	public Object getDefaultValue(String dbDefaultValue)
	{
<span class="nc bnc" id="L404" title="All 2 branches missed.">		if (dbDefaultValue != null)</span>
		{
			// try to use the DB default value
<span class="nc" id="L407">			StringBuffer mbuf = new StringBuffer();</span>
<span class="nc" id="L408">			Object newObject = validateAndConvert(dbDefaultValue, null, mbuf);</span>

			// if there was a problem with converting, then just fall through
			// and continue as if there was no default given in the DB.
			// Otherwise, use the converted object
<span class="nc bnc" id="L413" title="All 2 branches missed.">			if (mbuf.length() == 0) return newObject;</span>
		}

		// no default in DB. If nullable, use null.
<span class="nc bnc" id="L417" title="All 2 branches missed.">		if (_isNullable) { return null; }</span>
		// field is not nullable, so create a reasonable default value
<span class="nc" id="L419">		return Boolean.TRUE;</span>
	}

	/*
	 * File IO related functions
	 */

	/**
	 * Say whether or not object can be exported to and imported from a file. We put both export and import
	 * together in one test on the assumption that all conversions can be done both ways.
	 */
	public boolean canDoFileIO()
	{
<span class="nc" id="L432">		return true;</span>
	}

	/**
	 * Read a file and construct a valid object from its contents. Errors are returned by throwing an
	 * IOException containing the cause of the problem as its message.
	 * &lt;P&gt;
	 * DataType is responsible for validating that the imported data can be converted to an object, and then
	 * must return a text string that can be used in the Popup window text area. This object-to-text conversion
	 * is the same as is done by the DataType object internally in the getJTextArea() method.
	 * &lt;P&gt;
	 * File is assumed to be and ASCII string of digits representing a boolean value.
	 */
	public String importObject(FileInputStream inStream) throws IOException
	{

<span class="nc" id="L448">		InputStreamReader inReader = new InputStreamReader(inStream);</span>

<span class="nc" id="L450">		int fileSize = inStream.available();</span>

<span class="nc" id="L452">		char charBuf[] = new char[fileSize];</span>

<span class="nc" id="L454">		int count = inReader.read(charBuf, 0, fileSize);</span>

<span class="nc bnc" id="L456" title="All 2 branches missed.">		if (count != fileSize) throw new IOException(&quot;Could read only &quot; + count</span>
			+ &quot; chars from a total file size of &quot; + fileSize + &quot;. Import failed.&quot;);

		// convert file text into a string
		// Special case: some systems tack a newline at the end of
		// the text read. Assume that if last char is a newline that
		// we want everything else in the line.
		String fileText;
<span class="nc bnc" id="L464" title="All 2 branches missed.">		if (charBuf[count - 1] == KeyEvent.VK_ENTER) fileText = new String(charBuf, 0, count - 1);</span>
<span class="nc" id="L465">		else fileText = new String(charBuf);</span>

		// test that the string is valid by converting it into an
		// object of this data type
<span class="nc" id="L469">		StringBuffer messageBuffer = new StringBuffer();</span>
<span class="nc" id="L470">		validateAndConvertInPopup(fileText, null, messageBuffer);</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">		if (messageBuffer.length() &gt; 0)</span>
		{
			// there was an error in the conversion
<span class="nc" id="L474">			throw new IOException(&quot;Text does not represent data of type &quot; + getClassName() + &quot;.  Text was:\n&quot;</span>
				+ fileText);
		}

		// return the text from the file since it does
		// represent a valid data value
<span class="nc" id="L480">		return fileText;</span>
	}

	/**
	 * Construct an appropriate external representation of the object and write it to a file. Errors are
	 * returned by throwing an IOException containing the cause of the problem as its message.
	 * &lt;P&gt;
	 * DataType is responsible for validating that the given text text from a Popup JTextArea can be converted
	 * to an object. This text-to-object conversion is the same as validateAndConvertInPopup, which may be used
	 * internally by the object to do the validation.
	 * &lt;P&gt;
	 * The DataType object must flush and close the output stream before returning. Typically it will create
	 * another object (e.g. an OutputWriter), and that is the object that must be flushed and closed.
	 * &lt;P&gt;
	 * File is assumed to be and ASCII string of digits representing a value of this data type.
	 */
	public void exportObject(FileOutputStream outStream, String text) throws IOException
	{

<span class="nc" id="L499">		OutputStreamWriter outWriter = new OutputStreamWriter(outStream);</span>

		// check that the text is a valid representation
<span class="nc" id="L502">		StringBuffer messageBuffer = new StringBuffer();</span>
<span class="nc" id="L503">		validateAndConvertInPopup(text, null, messageBuffer);</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">		if (messageBuffer.length() &gt; 0)</span>
		{
			// there was an error in the conversion
<span class="nc" id="L507">			throw new IOException(new String(messageBuffer));</span>
		}

		// just send the text to the output file
<span class="nc" id="L511">		outWriter.write(text);</span>
<span class="nc" id="L512">		outWriter.flush();</span>
<span class="nc" id="L513">		outWriter.close();</span>
<span class="nc" id="L514">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>