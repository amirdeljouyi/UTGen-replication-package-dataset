<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FormattedSourceTab.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">102_squirrel-sql</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.squirrel_sql.client.session.mainpanel.objecttree.tabs</a> &gt; <span class="el_source">FormattedSourceTab.java</span></div><h1>FormattedSourceTab.java</h1><pre class="source lang-java linenums">package net.sourceforge.squirrel_sql.client.session.mainpanel.objecttree.tabs;

/*
 * Copyright (C) 2007 Rob Manning
 * manningr@users.sourceforge.net
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import net.sourceforge.squirrel_sql.client.session.ISession;
import net.sourceforge.squirrel_sql.client.util.codereformat.*;
import net.sourceforge.squirrel_sql.fw.sql.IDatabaseObjectInfo;
import net.sourceforge.squirrel_sql.fw.sql.ISQLConnection;
import net.sourceforge.squirrel_sql.fw.sql.SQLUtilities;
import net.sourceforge.squirrel_sql.fw.util.StringManager;
import net.sourceforge.squirrel_sql.fw.util.StringManagerFactory;
import net.sourceforge.squirrel_sql.fw.util.log.ILogger;
import net.sourceforge.squirrel_sql.fw.util.log.LoggerController;

/**
 * This will provide source code formatting for object source to subclasses. The subclass only needs to call
 * setupFormatter if code reformatting is desired and whether or not to compressWhitespace, which is on by
 * default. Without calling setupFormatter, word-wrapping on word boundaries is still performed and whitespace
 * is compressed, if so configured.
 * 
 * @author manningr
 */
public abstract class FormattedSourceTab extends BaseSourceTab
{

	/** Logger for this class. */
<span class="nc" id="L47">	private final static ILogger s_log = LoggerController.createLogger(FormattedSourceTab.class);</span>

<span class="nc" id="L49">	private static final StringManager s_stringMgr =</span>
<span class="nc" id="L50">		StringManagerFactory.getStringManager(FormattedSourceTab.class);</span>

	/** does the work of formatting */
<span class="nc" id="L53">	private ICodeReformator formatter = null;</span>

	/** whether or not to compress whitespace */
<span class="nc" id="L56">	private boolean compressWhitespace = true;</span>

<span class="nc" id="L58">	private CommentSpec[] commentSpecs =</span>
		new CommentSpec[] { new CommentSpec(&quot;/*&quot;, &quot;*/&quot;), new CommentSpec(&quot;--&quot;, &quot;\n&quot;) };

	/** The String to use to separate statements */
<span class="nc" id="L62">	protected String statementSeparator = null;</span>

	/** Whether or not to appendSeparator before reformatting */
<span class="nc" id="L65">	protected boolean appendSeparator = true;</span>

	static interface i18n
	{
		// i18n[FormatterSourceTab.noSourceAvailable=No object source code is
		// available]
<span class="nc" id="L71">		String NO_SOURCE_AVAILABLE = s_stringMgr.getString(&quot;FormatterSourceTab.noSourceAvailable&quot;);</span>
	}

	public FormattedSourceTab(String hint)
	{
<span class="nc" id="L76">		super(hint);</span>
<span class="nc" id="L77">	}</span>

	/**
	 * Sets up the formatter which formats the source after retrieving it from the ResultSet. If this is not
	 * setup prior to loading, then the formatter will not be used - only whitespace compressed if so enabled.
	 * 
	 * @param stmtSep
	 *           the formatter needs to know what the statement separator is.
	 * @param commentSpecs
	 *           the types of comments that can be found in the source code. This can be null, and if so, the
	 *           standard comment styles are used (i.e. -- and c-style comments)
	 */
	protected void setupFormatter(String stmtSep, CommentSpec[] commentSpecs)
	{
<span class="nc bnc" id="L91" title="All 2 branches missed.">		if (commentSpecs != null)</span>
		{
<span class="nc" id="L93">			this.commentSpecs = commentSpecs;</span>
		}
<span class="nc" id="L95">		statementSeparator = stmtSep;</span>
<span class="nc" id="L96">		formatter = new CodeReformator(CodeReformatorConfigFactory.createConfig(stmtSep, this.commentSpecs));</span>
<span class="nc" id="L97">	}</span>

	/**
	 * Sets up a custom formatter implementation which is used to format the source after retrieving it from 
	 * the ResultSet. If this is not setup prior to loading, then the formatter will not be used - only 
	 * whitespace compressed if so enabled.
	 * 
	 * @param codeReformator
	 * @param stmtSep
	 *           the formatter needs to know what the statement separator is.
	 * @param commentSpecs
	 *           the types of comments that can be found in the source code. This can be null, and if so, the
	 *           standard comment styles are used (i.e. -- and c-style comments)
	 */
	protected void setupFormatter(ICodeReformator codeReformator, String stmtSep, CommentSpec[] commentSpecs)
	{
<span class="nc bnc" id="L113" title="All 2 branches missed.">		if (commentSpecs != null)</span>
		{
<span class="nc" id="L115">			this.commentSpecs = commentSpecs;</span>
		}
<span class="nc" id="L117">		statementSeparator = stmtSep;</span>
<span class="nc" id="L118">		formatter = codeReformator;</span>
<span class="nc" id="L119">	}</span>
	
	
	/**
	 * Whether or not to convert multiple consecutive spaces into a single space.
	 * 
	 * @param compressWhitespace
	 */
	protected void setCompressWhitespace(boolean compressWhitespace)
	{
<span class="nc" id="L129">		this.compressWhitespace = compressWhitespace;</span>
<span class="nc" id="L130">	}</span>

	/**
	 * The panel that displays the formatted source code.
	 */
	private final class FormattedSourcePanel extends BaseSourcePanel
	{
		private static final long serialVersionUID = 1L;

<span class="nc" id="L139">		FormattedSourcePanel(ISession session){</span>
<span class="nc" id="L140">			super(session);</span>
<span class="nc" id="L141">		}</span>

		public void load(ISession session, PreparedStatement stmt)
		{
<span class="nc" id="L145">			getTextArea().setText(&quot;&quot;);</span>

<span class="nc" id="L147">			ResultSet rs = null;</span>
			try
			{
<span class="nc" id="L150">				rs = stmt.executeQuery();</span>
<span class="nc" id="L151">				StringBuilder buf = new StringBuilder(4096);</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">				while (rs.next())</span>
				{
<span class="nc" id="L154">					String line = rs.getString(1);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">					if (line == null)</span>
					{
<span class="nc" id="L157">						s_log.debug(&quot;load: Null object source line; skipping...&quot;);</span>
<span class="nc" id="L158">						continue;</span>
					}
<span class="nc bnc" id="L160" title="All 2 branches missed.">					if (compressWhitespace)</span>
					{
<span class="nc" id="L162">						buf.append(line.trim() + &quot; &quot;);</span>
					}
					else
					{
<span class="nc" id="L166">						buf.append(line);</span>
					}
<span class="nc" id="L168">				}</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">				if (appendSeparator)</span>
				{
<span class="nc" id="L171">					buf.append(&quot;\n&quot;);</span>
<span class="nc" id="L172">					buf.append(statementSeparator);</span>
				}
<span class="nc" id="L174">				String processedResult = processResult(buf);</span>
<span class="nc bnc" id="L175" title="All 4 branches missed.">				if (formatter != null &amp;&amp; buf.length() != 0)</span>
				{
<span class="nc bnc" id="L177" title="All 2 branches missed.">					if (s_log.isDebugEnabled())</span>
					{
<span class="nc" id="L179">						s_log.debug(&quot;Object source code before formatting: &quot; + processedResult);</span>
					}
<span class="nc" id="L181">					getTextArea().setText(format(processedResult));</span>
				}
				else
				{
<span class="nc bnc" id="L185" title="All 2 branches missed.">					if (buf.length() == 0)</span>
					{
<span class="nc" id="L187">						buf.append(i18n.NO_SOURCE_AVAILABLE);</span>
					}
<span class="nc" id="L189">					getTextArea().setText(processedResult);</span>
				}
<span class="nc" id="L191">				getTextArea().setCaretPosition(0);</span>
			}
<span class="nc" id="L193">			catch (Exception ex)</span>
			{
<span class="nc bnc" id="L195" title="All 2 branches missed.">				if (s_log.isDebugEnabled())</span>
				{
<span class="nc" id="L197">					s_log.debug(&quot;Unexpected exception while formatting &quot; + &quot;object source code&quot;, ex);</span>
				}
<span class="nc" id="L199">				session.showErrorMessage(ex);</span>
			}
			finally
			{
<span class="nc" id="L203">				SQLUtilities.closeResultSet(rs);</span>
			}
<span class="nc" id="L205">		}</span>

	}

	/**
	 * This method can be overridden by subclasses if further processing of the result from the query needs to
	 * happen prior to formatting.  By default, no processing is done - the StringBuilder is simply converted
	 * to a string by calling it's toString method.
	 * 
	 * @param buf the StringBuilder that can be procesed.
	 * @return the processed String.
	 */
	protected String processResult(final StringBuilder buf)
	{
<span class="nc" id="L219">		return buf.toString();</span>
	}

	/**
	 * We trap any IllegalStateException from the formatter here. If the SQL source code fails to format, log
	 * it and show the original unformatted version.
	 * 
	 * @param toFormat
	 *           the SQL to format.
	 * @return either formatted or original version of the specified SQL.
	 */
	private String format(String toFormat)
	{
<span class="nc" id="L232">		String result = toFormat;</span>
		try
		{
<span class="nc" id="L235">			result = formatter.reformat(toFormat);</span>
		}
<span class="nc" id="L237">		catch (IllegalStateException e)</span>
		{
<span class="nc" id="L239">			s_log.error(&quot;format: Formatting SQL failed: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L240">		}</span>
<span class="nc" id="L241">		return result;</span>
	}

	/**
	 * @see net.sourceforge.squirrel_sql.client.session.mainpanel.objecttree.tabs.BaseSourceTab#createStatement()
	 */
	@Override
	protected PreparedStatement createStatement() throws SQLException
	{
<span class="nc" id="L250">		final ISession session = getSession();</span>

<span class="nc" id="L252">		ISQLConnection conn = session.getSQLConnection();</span>

<span class="nc" id="L254">		String sqlStatement = getSqlStatement();</span>
<span class="nc" id="L255">		String[] bindValues = getBindValues();</span>

<span class="nc bnc" id="L257" title="All 2 branches missed.">		if (s_log.isDebugEnabled())</span>
		{
<span class="nc" id="L259">			s_log.debug(&quot;Running SQL for index source tab: &quot; + sqlStatement);</span>
<span class="nc" id="L260">			s_log.debug(&quot;With the following bind variable values: &quot;);</span>
<span class="nc" id="L261">			int parameterIndex = 1;</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">			for (String bindValue : bindValues)</span>
			{
<span class="nc" id="L264">				s_log.debug(&quot;[&quot; + (parameterIndex++) + &quot;] =&gt; '&quot; + bindValue + &quot;'&quot;);</span>
			}
		}
<span class="nc" id="L267">		PreparedStatement pstmt = conn.prepareStatement(sqlStatement);</span>

<span class="nc" id="L269">		int parameterIndex = 1;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">		for (String bindValue : bindValues)</span>
		{
<span class="nc" id="L272">			pstmt.setString(parameterIndex++, bindValue);</span>
		}

<span class="nc" id="L275">		return pstmt;</span>
	}

	/**
	 * Subclasses must override to provide the SQL necessary to select the source for the selected
	 * DatabaseObjectInfo. Note: the default implementation of getBindValues provides values for schema and
	 * object simple name. Therefore, it is advantageous if the where clause in the select statement returned
	 * from this method specify first the schema, and then the object name and no more bind variables. If this
	 * is possible, then it isn't necessary for subclasses to override getBindValues.
	 * 
	 * @return an SQL select statement with embedded bind variables (?'s).
	 */
	protected abstract String getSqlStatement();

	/**
	 * This method simply returns a String array containing the schema name and the selected object's simple
	 * name, in that order. If the SQL returned from getSqlStatement must specify a different order, or for
	 * example uses that catalog of the object, instead of or in addition to schema, then this method must be
	 * overridden to return the necessary bind variable values, in the order required by the SQL statement.
	 * 
	 * @return a String array of bind variable values
	 */
	protected String[] getBindValues()
	{
<span class="nc" id="L299">		final IDatabaseObjectInfo doi = getDatabaseObjectInfo();</span>
<span class="nc" id="L300">		return new String[] { doi.getSchemaName(), doi.getSimpleName() };</span>
	}
	
	/**
	 * @see net.sourceforge.squirrel_sql.client.session.mainpanel.objecttree.tabs.BaseSourceTab#createSourcePanel()
	 */
	@Override
	protected BaseSourcePanel createSourcePanel() {
<span class="nc" id="L308">		return new FormattedSourcePanel(getSession());</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>