<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Utilities.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">102_squirrel-sql</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.squirrel_sql.fw.util</a> &gt; <span class="el_source">Utilities.java</span></div><h1>Utilities.java</h1><pre class="source lang-java linenums">package net.sourceforge.squirrel_sql.fw.util;
/*
 * Copyright (C) 2001-2003 Colin Bell
 * colbell@users.sourceforge.net
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamClass;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.NumberFormat;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import net.sourceforge.squirrel_sql.fw.util.log.ILogger;
import net.sourceforge.squirrel_sql.fw.util.log.LoggerController;

/**
 * General purpose utilities functions.
 *
 * @author &lt;A HREF=&quot;mailto:colbell@users.sourceforge.net&quot;&gt;Colin Bell&lt;/A&gt;
 */
public class Utilities
{
   /** Logger for this class. */
<span class="nc" id="L44">   private static ILogger s_log =</span>
<span class="nc" id="L45">      LoggerController.createLogger(Utilities.class);</span>

<span class="nc" id="L47">    private static Pattern spanStartPattern = Pattern.compile(&quot;.*\\&lt;span\\&gt;.*&quot;);</span>
<span class="nc" id="L48">    private static Pattern spanStartSplitPattern = Pattern.compile(&quot;\\&lt;span\\&gt;&quot;);</span>
<span class="nc" id="L49">    private static Pattern spanEndPattern = Pattern.compile(&quot;.*&lt;\\/span\\&gt;.*&quot;);</span>
<span class="nc" id="L50">    private static Pattern spanEndSplitPattern = Pattern.compile(&quot;&lt;\\/span\\&gt;&quot;);</span>
	
   
   
   /**
    * Ctor. &lt;TT&gt;private&lt;/TT&gt; as all methods are static.
    */
   private Utilities()
   {
      super();
   }

   /**
    * Print the current stack trace to &lt;TT&gt;ps&lt;/TT&gt;.
    *
    * @param	ps	The &lt;TT&gt;PrintStream&lt;/TT&gt; to print stack trace to.
    *
    * @throws	IllegalArgumentException	If a null &lt;TT&gt;ps&lt;/TT&gt; passed.
    */
   public static void printStackTrace(PrintStream ps)
   {
<span class="nc bnc" id="L71" title="All 2 branches missed.">      if (ps == null)</span>
      {
<span class="nc" id="L73">         throw new IllegalArgumentException(&quot;PrintStream == null&quot;);</span>
      }

      try
      {
<span class="nc" id="L78">         throw new Exception();</span>
      }
<span class="nc" id="L80">      catch (Exception ex)</span>
      {
<span class="nc" id="L82">         ps.println(getStackTrace(ex));</span>
      }
<span class="nc" id="L84">   }</span>

   /**
    * Return the stack trace from the passed exception as a string
    *
    * @param	th	The exception to retrieve stack trace for.
    */
   public static String getStackTrace(Throwable th)
   {
<span class="nc bnc" id="L93" title="All 2 branches missed.">      if (th == null)</span>
      {
<span class="nc" id="L95">         throw new IllegalArgumentException(&quot;Throwable == null&quot;);</span>
      }

<span class="nc" id="L98">      StringWriter sw = new StringWriter();</span>
      try
      {
<span class="nc" id="L101">         PrintWriter pw = new PrintWriter(sw);</span>
         try
         {
<span class="nc" id="L104">            th.printStackTrace(pw);</span>
<span class="nc" id="L105">            return sw.toString();</span>
         }
         finally
         {
<span class="nc" id="L109">            pw.close();</span>
         }
      }
      finally
      {
         try
         {
<span class="nc" id="L116">            sw.close();</span>
         }
<span class="nc" id="L118">         catch (IOException ex)</span>
         {
<span class="nc" id="L120">            s_log.error(&quot;Unexpected error closing StringWriter&quot;, ex);</span>
<span class="nc" id="L121">         }</span>
      }
   }

   public static Throwable getDeepestThrowable(Throwable t)
   {
<span class="nc" id="L127">      Throwable parent = t;</span>
<span class="nc" id="L128">      Throwable child = t.getCause();</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">      while(null != child)</span>
      {
<span class="nc" id="L131">         parent = child;</span>
<span class="nc" id="L132">         child = parent.getCause();</span>
      }

<span class="nc" id="L135">      return parent;</span>

   }

   /**
    * Change the passed class name to its corresponding file name. E.G.
    * change &amp;quot;Utilities&amp;quot; to &amp;quot;Utilities.class&amp;quot;.
    *
    * @param	name	Class name to be changed.
    *
    * @throws	IllegalArgumentException	If a null &lt;TT&gt;name&lt;/TT&gt; passed.
    */
   public static String changeClassNameToFileName(String name)
   {
<span class="nc bnc" id="L149" title="All 2 branches missed.">      if (name == null)</span>
      {
<span class="nc" id="L151">         throw new IllegalArgumentException(&quot;Class Name == null&quot;);</span>
      }
<span class="nc" id="L153">      return name.replace('.', '/').concat(&quot;.class&quot;);</span>
   }

   /**
    * Change the passed file name to its corresponding class name. E.G.
    * change &amp;quot;Utilities.class&amp;quot; to &amp;quot;Utilities&amp;quot;.
    *
    * @param	name	Class name to be changed. If this does not represent
    *					a Java class then &lt;TT&gt;null&lt;/TT&gt; is returned.
    *
    * @throws IllegalArgumentException	If a null &lt;TT&gt;name&lt;/TT&gt; passed.
    */
   public static String changeFileNameToClassName(String name)
   {
<span class="nc bnc" id="L167" title="All 2 branches missed.">      if (name == null)</span>
      {
<span class="nc" id="L169">         throw new IllegalArgumentException(&quot;File Name == null&quot;);</span>
      }
<span class="nc" id="L171">      String className = null;</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">      if (name.toLowerCase().endsWith(&quot;.class&quot;))</span>
      {
<span class="nc" id="L174">         className = name.replace('/', '.');</span>
<span class="nc" id="L175">         className = className.replace('\\', '.');</span>
<span class="nc" id="L176">         className = className.substring(0, className.length() - 6);</span>
      }
<span class="nc" id="L178">      return className;</span>
   }

   /**
    * Clean the passed string. Replace whitespace characters with a single
    * space. If a &lt;TT&gt;null&lt;/TT&gt; string passed return an empty string. E.G.
    * replace
    *
    * [pre]
    * \t\tselect\t* from\t\ttab01
    * [/pre]
    *
    * with
    *
    * [pre]
    * select * from tab01
    * [/pre]
    *
    * @deprecated	Use &lt;tt&gt;StringUtilities.cleanString(String)&lt;/tt&gt; instead.
    *
    * @param	str	String to be cleaned.
    *
    * @return	Cleaned string.
    */
   public static String cleanString(String str)
   {
<span class="nc" id="L204">      return StringUtilities.cleanString(str);</span>
   }

   /**
    * Return the suffix of the passed file name.
    *
    * @param	fileName	File name to retrieve suffix for.
    *
    * @return	Suffix for &lt;TT&gt;fileName&lt;/TT&gt; or an empty string
    * 			if unable to get the suffix.
    *
    * @throws	IllegalArgumentException	if &lt;TT&gt;null&lt;/TT&gt; file name passed.
    */
   public static String getFileNameSuffix(String fileName)
   {
<span class="nc bnc" id="L219" title="All 2 branches missed.">      if (fileName == null)</span>
      {
<span class="nc" id="L221">         throw new IllegalArgumentException(&quot;file name == null&quot;);</span>
      }
<span class="nc" id="L223">      int pos = fileName.lastIndexOf('.');</span>
<span class="nc bnc" id="L224" title="All 4 branches missed.">      if (pos &gt; 0 &amp;&amp; pos &lt; fileName.length() - 1)</span>
      {
<span class="nc" id="L226">         return fileName.substring(pos + 1);</span>
      }
<span class="nc" id="L228">      return &quot;&quot;;</span>
   }

   public static boolean equalsRespectNull(Object o1, Object o2)
   {
<span class="nc bnc" id="L233" title="All 4 branches missed.">      if(null == o1 &amp;&amp; null == o2)</span>
      {
<span class="nc" id="L235">         return true;</span>
      }
<span class="nc bnc" id="L237" title="All 4 branches missed.">      else if(null == o1 || null == o2)</span>
      {
<span class="nc" id="L239">         return false;</span>
      }
      else
      {
<span class="nc" id="L243">         return o1.equals(o2);</span>
      }

   }


   /**
    * Remove the suffix from the passed file name.
    *
    * @param	fileName	File name to remove suffix from.
    *
    * @return	&lt;TT&gt;fileName&lt;/TT&gt; without a suffix.
    *
    * @throws	IllegalArgumentException	if &lt;TT&gt;null&lt;/TT&gt; file name passed.
    */
   public static String removeFileNameSuffix(String fileName)
   {
<span class="nc bnc" id="L260" title="All 2 branches missed.">      if (fileName == null)</span>
      {
<span class="nc" id="L262">         throw new IllegalArgumentException(&quot;file name == null&quot;);</span>
      }
<span class="nc" id="L264">      int pos = fileName.lastIndexOf('.');</span>
<span class="nc bnc" id="L265" title="All 4 branches missed.">      if (pos &gt; 0 &amp;&amp; pos &lt; fileName.length() - 1)</span>
      {
<span class="nc" id="L267">         return fileName.substring(0, pos);</span>
      }
<span class="nc" id="L269">      return fileName;</span>
   }


   public static String formatSize(long longSize)
   {
<span class="nc" id="L275">      return formatSize(longSize, -1);</span>
   }

   // TODO: i18n
   public static String formatSize(long longSize, int decimalPos)
   {
<span class="nc" id="L281">      NumberFormat fmt = NumberFormat.getNumberInstance();</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">      if (decimalPos &gt;= 0)</span>
      {
<span class="nc" id="L284">         fmt.setMaximumFractionDigits(decimalPos);</span>
      }
<span class="nc" id="L286">      final double size = longSize;</span>
<span class="nc" id="L287">      double val = size / (1024 * 1024);</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">      if (val &gt; 1)</span>
      {
<span class="nc" id="L290">         return fmt.format(val).concat(&quot; MB&quot;);</span>
      }
<span class="nc" id="L292">      val = size / 1024;</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">      if (val &gt; 10)</span>
      {
<span class="nc" id="L295">         return fmt.format(val).concat(&quot; KB&quot;);</span>
      }
<span class="nc" id="L297">      return fmt.format(val).concat(&quot; bytes&quot;);</span>
   }

   /**
    * Split a string based on the given delimiter, but don't remove
    * empty elements.
    *
    * @deprecated	Use &lt;tt&gt;StringUtilities.split(String, char)&lt;/tt&gt;
    *				instead.
    *
    * @param	str			The string to be split.
    * @param	delimiter	Split string based on this delimiter.
    *
    * @return	Array of split strings. Guaranteeded to be not null.
    */
   public static String[] splitString(String str, char delimiter)
   {
<span class="nc" id="L314">      return StringUtilities.split(str, delimiter);</span>
   }

   /**
    * Split a string based on the given delimiter, optionally removing
    * empty elements.
    *
    * @deprecated	Use &lt;tt&gt;StringUtilities.split(String, char, boolean)&lt;/tt&gt;
    *				instead.
    *
    * @param	str			The string to be split.
    * @param	delimiter	Split string based on this delimiter.
    * @param	removeEmpty	If &lt;tt&gt;true&lt;/tt&gt; then remove empty elements.
    *
    * @return	Array of split strings. Guaranteeded to be not null.
    */
   public static String[] splitString(String str, char delimiter,
                                      boolean removeEmpty)
   {
<span class="nc" id="L333">      return StringUtilities.split(str, delimiter, removeEmpty);</span>
   }

   /**
    * Creates a clone of any serializable object. Collections and arrays
    * may be cloned if the entries are serializable.
    *
    * Caution super class members are not cloned if a super class is not serializable.
    */
   public static Object cloneObject(Object toClone, final ClassLoader classLoader)
   {
<span class="nc bnc" id="L344" title="All 2 branches missed.">      if(null == toClone)</span>
      {
<span class="nc" id="L346">         return null;</span>
      }
      else
      {
         try
         {
<span class="nc" id="L352">            ByteArrayOutputStream bOut = new ByteArrayOutputStream();</span>
<span class="nc" id="L353">            ObjectOutputStream oOut = new ObjectOutputStream(bOut);</span>
<span class="nc" id="L354">            oOut.writeObject(toClone);</span>
<span class="nc" id="L355">            oOut.close();</span>
<span class="nc" id="L356">            ByteArrayInputStream bIn = new ByteArrayInputStream(bOut.toByteArray());</span>
<span class="nc" id="L357">            bOut.close();</span>
<span class="nc" id="L358">            ObjectInputStream oIn = new ObjectInputStream(bIn)</span>
<span class="nc" id="L359">            {</span>
               protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException
               {
<span class="nc" id="L362">            	   return Class.forName(desc.getName(), false, classLoader);</span>
               }
            };
<span class="nc" id="L365">            bIn.close();</span>
<span class="nc" id="L366">            Object copy = oIn.readObject();</span>
<span class="nc" id="L367">            oIn.close();</span>

<span class="nc" id="L369">            return copy;</span>
         }
<span class="nc" id="L371">         catch (Exception e)</span>
         {
<span class="nc" id="L373">            throw new RuntimeException(e);</span>
         }

      }
   }

   /**
    * Internationalizes a line with an embedded I18n key in it.  Suppose that 
    * the line looks like:
    * 
    *  This is a line with a &lt;span&gt;embeddedKey&lt;/span&gt; in it. 
    *  
    * Further suppose the our I18NStrings.properties has the line:
    * 
    *   embeddedKey=(string that all would like to read)
    * 
    * This method will return the value:
    * 
    * This is a line with a (string that all would like to read) in it.
    *  
    * Note: This method cannot currently handle more than one embedded I18n 
    *       string in the specified line at this time.  Please put multiple 
    *       keys on separate lines. Otherwise, truncation of the specified 
    *       line could result!  
    * 
    * @param line the line to internationalize
    * @param s_stringMgr the StringManager to use to lookup I18N keys.
    * 
    * @return an internationalized replacement for this line
    */
   public static String replaceI18NSpanLine(String line, 
           StringManager s_stringMgr) {
<span class="nc" id="L405">       String result = line;</span>
<span class="nc" id="L406">       Matcher start = spanStartPattern.matcher(line);</span>
<span class="nc" id="L407">       Matcher end = spanEndPattern.matcher(line);</span>
<span class="nc bnc" id="L408" title="All 4 branches missed.">       if (start.matches() &amp;&amp; end.matches()) {</span>
           // line should look like :
           //
           // This is a line with an &lt;span&gt;embedded key&lt;/span&gt; in it. 
           //
<span class="nc" id="L413">           StringBuffer tmp = new StringBuffer();</span>
<span class="nc" id="L414">           String[] startparts = spanStartSplitPattern.split(line);</span>

<span class="nc" id="L416">           tmp.append(startparts[0]);</span>

           // startparts[1] contains our I18n string key followed by &lt;/span&gt;
<span class="nc" id="L419">           String[] endparts = spanEndSplitPattern.split(startparts[1]);</span>

<span class="nc" id="L421">           String key = endparts[0];</span>

<span class="nc" id="L423">           String value = s_stringMgr.getString(key);</span>
<span class="nc" id="L424">           tmp.append(value);</span>
<span class="nc" id="L425">           tmp.append(endparts[1]);</span>

<span class="nc" id="L427">           result = tmp.toString();</span>
       }
<span class="nc" id="L429">       return result;</span>
   }
   
   /**
	 * This is taken from Eammon McManus' blog:
	 * http://weblogs.java.net/blog/emcmanus/archive/2007/03/getting_rid_of.html This prevents you from having
	 * to place SuppressWarnings throughout your code.
	 * 
	 * @param &lt;T&gt;
	 *           the return type to cast the object to
	 * @param x
	 *           the object to cast.
	 * @return a type-casted version of the specified object.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;T&gt; T cast(Object x) {
<span class="nc" id="L445">	    return (T) x;</span>
	}

	/**
	 * Checks the specified list of argument to see if any are null and throws a runtime exception if one is.
	 * 
	 * @param methodName
	 *           the name of the method checking it's arguments
	 * @param arguments
	 *           the arguments - these should be in name/value pairs
	 */
	public static void checkNull(String methodName, Object... arguments) {
<span class="nc bnc" id="L457" title="All 2 branches missed.">		if (arguments.length % 2 != 0) {</span>
<span class="nc" id="L458">			throw new IllegalArgumentException(&quot;Args must be specified in name/value pairs&quot;); </span>
		}
<span class="nc bnc" id="L460" title="All 2 branches missed.">		for (int i = 0; i &lt; arguments.length-1; i+=2) {</span>
<span class="nc" id="L461">			String name = (String)arguments[i];</span>
<span class="nc" id="L462">			Object value = arguments[i+1];</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">			if (value == null) {</span>
<span class="nc" id="L464">				throw new IllegalArgumentException(methodName+&quot;: Argument &quot;+name+&quot; cannot be null&quot;);</span>
			}
		}
<span class="nc" id="L467">	}</span>
	
	/**
	 * Cause the current thread to sleep for the specified number of milliseconds. Exceptions logged.
	 * 
	 * @param millis number of milliseconds to sleep.
	 */
	public static void sleep(long millis)
	{
<span class="nc bnc" id="L476" title="All 2 branches missed.">		if (millis == 0) {</span>
<span class="nc" id="L477">			return;</span>
		}
		try
		{
<span class="nc" id="L481">			Thread.sleep(millis);</span>
		}
<span class="nc" id="L483">		catch (Exception e)</span>
		{
<span class="nc" id="L485">			s_log.error(e);</span>
<span class="nc" id="L486">		}</span>
<span class="nc" id="L487">	}</span>
	
	/**
	 * Run the garbage collector.  We may eventually want this to execute in an app thread and serialize 
	 * many requests using a queue to avoid a performance hit for too many simultaneous calls.
	 */
	public static void garbageCollect() {
<span class="nc" id="L494">		System.gc();</span>
<span class="nc" id="L495">	}</span>

   public static String escapeHtmlChars(String sql)
   {
<span class="nc" id="L499">      return StringUtilities.escapeHtmlChars(sql);</span>
   }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>