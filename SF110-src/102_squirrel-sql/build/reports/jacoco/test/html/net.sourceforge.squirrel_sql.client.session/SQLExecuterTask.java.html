<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SQLExecuterTask.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">102_squirrel-sql</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.squirrel_sql.client.session</a> &gt; <span class="el_source">SQLExecuterTask.java</span></div><h1>SQLExecuterTask.java</h1><pre class="source lang-java linenums">package net.sourceforge.squirrel_sql.client.session;
/*
 * Copyright (C) 2001-2004 Johan Companger
 * jcompagner@j-com.nl
 *
 * Modifications Copyright (C) 2003-2004 Jason Height
 * jmheight@users.sourceforge.net
 *
 * Modifications copyright (C) 2001-2004 Colin Bell
 * colbell@users.sourceforge.net
 *
 * Modifications copyright (C) 2001-2005 Glenn Griffin
 * gwghome@users.sourceforge.net
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terdims of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.ArrayList;

import javax.swing.SwingUtilities;

import net.sourceforge.squirrel_sql.client.session.event.ISQLExecutionListener;
import net.sourceforge.squirrel_sql.client.session.properties.SessionProperties;
import net.sourceforge.squirrel_sql.client.session.schemainfo.SchemaInfoUpdateCheck;
import net.sourceforge.squirrel_sql.fw.datasetviewer.ColumnDisplayDefinition;
import net.sourceforge.squirrel_sql.fw.datasetviewer.DataSetException;
import net.sourceforge.squirrel_sql.fw.datasetviewer.DataSetUpdateableTableModelListener;
import net.sourceforge.squirrel_sql.fw.datasetviewer.IDataModelImplementationDetails;
import net.sourceforge.squirrel_sql.fw.datasetviewer.IDataSetUpdateableTableModel;
import net.sourceforge.squirrel_sql.fw.sql.IQueryTokenizer;
import net.sourceforge.squirrel_sql.fw.sql.ISQLConnection;
import net.sourceforge.squirrel_sql.fw.sql.ITableInfo;
import net.sourceforge.squirrel_sql.fw.sql.SQLUtilities;
import net.sourceforge.squirrel_sql.fw.sql.TableInfo;
import net.sourceforge.squirrel_sql.fw.util.StringManager;
import net.sourceforge.squirrel_sql.fw.util.StringManagerFactory;
import net.sourceforge.squirrel_sql.fw.util.log.ILogger;
import net.sourceforge.squirrel_sql.fw.util.log.LoggerController;

/**
 * This class can be used to execute SQL.
 * &lt;p/&gt;It implements Runnable so it can be executed as a thread
 * (asynchronus execution)
 *  or standalone in the main Swing thread (synchronus execution).
 */
public class SQLExecuterTask implements Runnable, IDataSetUpdateableTableModel
{


   /** Logger for this class. */
<span class="nc" id="L67">   private static final ILogger s_log = LoggerController.createLogger(SQLExecuterTask.class);</span>

<span class="nc" id="L69">   private static final StringManager s_stringMgr =</span>
<span class="nc" id="L70">       StringManagerFactory.getStringManager(SQLExecuterTask.class);</span>


   /** The call back object*/
   private ISQLExecuterHandler _handler;

   /** Current session. */
   private ISession _session;

   /** SQL passed in to be executed. */
   private String _sql;
   private Statement _stmt;
<span class="nc" id="L82">   private boolean _stopExecution = false;</span>

<span class="nc" id="L84">   private int _currentQueryIndex = 0;</span>
   private ISQLExecutionListener[] _executionListeners;
   private DataSetUpdateableTableModelImpl _dataSetUpdateableTableModel;
   private SchemaInfoUpdateCheck _schemaInfoUpdateCheck;
<span class="nc" id="L88">   private IQueryTokenizer _tokenizer = null;</span>
   /** Whether or not to check if the schema should be updated */
<span class="nc" id="L90">   private boolean schemaCheck = true;</span>

   public SQLExecuterTask(ISession session, String sql,ISQLExecuterHandler handler)
   {
<span class="nc" id="L94">      this(session, sql, handler, new ISQLExecutionListener[0]);</span>
<span class="nc" id="L95">   }</span>

   public SQLExecuterTask(ISession session, String sql, ISQLExecuterHandler handler, ISQLExecutionListener[] executionListeners)
<span class="nc" id="L98">   {</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">      if (sql == null) {</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">          if (s_log.isDebugEnabled()) {</span>
<span class="nc" id="L101">              s_log.debug(&quot;init(): expected non-null sql&quot;);</span>
<span class="nc" id="L102">              return;</span>
          }
      }
<span class="nc" id="L105">      _session = session;</span>
<span class="nc" id="L106">      _schemaInfoUpdateCheck = new SchemaInfoUpdateCheck(_session);</span>
<span class="nc" id="L107">      _sql = sql;</span>
<span class="nc" id="L108">      _tokenizer = _session.getQueryTokenizer();</span>
<span class="nc" id="L109">      _tokenizer.setScriptToTokenize(_sql);</span>
<span class="nc" id="L110">      _handler = handler;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">      if (_handler == null) {</span>
<span class="nc" id="L112">          _handler = new DefaultSQLExecuterHandler(session);</span>
      }
<span class="nc" id="L114">      _executionListeners = executionListeners;</span>
<span class="nc" id="L115">      _dataSetUpdateableTableModel = new DataSetUpdateableTableModelImpl();</span>
<span class="nc" id="L116">      _dataSetUpdateableTableModel.setSession(_session);</span>
<span class="nc" id="L117">   }</span>

   public void setExecutionListeners(ISQLExecutionListener[] executionListeners) {
<span class="nc" id="L120">       _executionListeners = executionListeners;</span>
<span class="nc" id="L121">   }</span>

   /**
    * Returns the number of queries that the tokenizer found in _sql.
    * @return
    */
   public int getQueryCount() {
<span class="nc" id="L128">       return _tokenizer.getQueryCount();</span>
   }

   public void setSchemaCheck(boolean aBoolean) {
<span class="nc" id="L132">       schemaCheck = aBoolean;</span>
<span class="nc" id="L133">   }</span>

   public void run()
   {
<span class="nc bnc" id="L137" title="All 2 branches missed.">       if (_sql == null) {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">           if (s_log.isDebugEnabled()) {</span>
<span class="nc" id="L139">               s_log.debug(&quot;init(): expected non-null sql.  Skipping execution&quot;);</span>
           }
<span class="nc" id="L141">           return;</span>
       }

<span class="nc" id="L144">      String lastExecutedStatement = null;</span>
<span class="nc" id="L145">      int statementCount = 0;</span>
<span class="nc" id="L146">      final SessionProperties props = _session.getProperties();</span>

<span class="nc" id="L148">      ArrayList&lt;String&gt; sqlExecErrorMsgs = new ArrayList&lt;String&gt;();</span>

      try
      {
<span class="nc" id="L152">         final ISQLConnection conn = _session.getSQLConnection();</span>
<span class="nc" id="L153">         _stmt = conn.createStatement();</span>

         try
         {
<span class="nc bnc" id="L157" title="All 4 branches missed.">            if(props.getSQLUseFetchSize() &amp;&amp; props.getSQLFetchSize() &gt; 0)</span>
            {
<span class="nc" id="L159">            	setFetchSize(props);</span>
            }
             
             
<span class="nc" id="L163">            final boolean correctlySupportsMaxRows = conn.getSQLMetaData()</span>
<span class="nc" id="L164">                  .correctlySupportsSetMaxRows();</span>
<span class="nc bnc" id="L165" title="All 4 branches missed.">            if (correctlySupportsMaxRows &amp;&amp; props.getSQLLimitRows())</span>
            {
<span class="nc" id="L167">               setMaxRows(props);</span>
            }

<span class="nc bnc" id="L170" title="All 2 branches missed.">            if(_tokenizer.getQueryCount() == 0)</span>
            {
<span class="nc" id="L172">               throw new IllegalArgumentException(&quot;No SQL selected for execution.&quot;);</span>
            }

<span class="nc" id="L175">            _currentQueryIndex = 0;</span>

            // Process each individual query.
<span class="nc" id="L178">            boolean maxRowsHasBeenSet = correctlySupportsMaxRows;</span>
<span class="nc" id="L179">            int processedStatementCount = 0;</span>
<span class="nc" id="L180">            statementCount = _tokenizer.getQueryCount();</span>

<span class="nc" id="L182">            _handler.sqlStatementCount(statementCount);</span>

<span class="nc bnc" id="L184" title="All 4 branches missed.">            while (_tokenizer.hasQuery() &amp;&amp; !_stopExecution)</span>
            {
<span class="nc" id="L186">               String querySql = _tokenizer.nextQuery();</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">               if (querySql != null)</span>
               {
<span class="nc" id="L189">                  ++processedStatementCount;</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                  if (_handler != null)</span>
                  {
<span class="nc" id="L192">                     _handler.sqlToBeExecuted(querySql);</span>
                  }

                  // Some driver don't correctly support setMaxRows. In
                  // these cases use setMaxRows only if this is a
                  // SELECT.
<span class="nc bnc" id="L198" title="All 2 branches missed.">                  if (!correctlySupportsMaxRows</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">                        &amp;&amp; props.getSQLLimitRows())</span>
                  {
<span class="nc bnc" id="L201" title="All 2 branches missed.">                     if (isSelectStatement(querySql))</span>
                     {
<span class="nc bnc" id="L203" title="All 2 branches missed.">                        if (!maxRowsHasBeenSet)</span>
                        {
<span class="nc" id="L205">                           setMaxRows(props);</span>
<span class="nc" id="L206">                           maxRowsHasBeenSet = true;</span>
                        }
                     }
<span class="nc bnc" id="L209" title="All 2 branches missed.">                     else if (maxRowsHasBeenSet)</span>
                     {
<span class="nc" id="L211">                        _stmt.close();</span>
<span class="nc" id="L212">                        _stmt = conn.createStatement();</span>
<span class="nc" id="L213">                        maxRowsHasBeenSet = false;</span>
                     }
                  }
                  try
                  {
<span class="nc" id="L218">                     lastExecutedStatement = querySql;</span>

<span class="nc bnc" id="L220" title="All 2 branches missed.">                     if (!processQuery(querySql, processedStatementCount, statementCount))</span>
                     {
<span class="nc" id="L222">                        break;</span>
                     }
                  }
<span class="nc" id="L225">                  catch (SQLException ex)</span>
                  {
                     // If the user has cancelled the query, don't bother logging
                     // an error message.  It is likely that the cancel request
                     // interfered with the attempt to fetch results from the
                     // ResultSet, which is to be expected when the Statement is
                     // closed.  So, let's not bug the user with obvious error
                     // messages that we can do nothing about.
<span class="nc bnc" id="L233" title="All 2 branches missed.">                     if (_stopExecution) {</span>
<span class="nc" id="L234">                         break;</span>
                     } else {
<span class="nc bnc" id="L236" title="All 2 branches missed.">                         if (props.getAbortOnError())</span>
                         {
<span class="nc" id="L238">                            throw ex;</span>
                         }
                         else
                         {
<span class="nc bnc" id="L242" title="All 2 branches missed.">                            if(1 &lt; statementCount)</span>
                            {
<span class="nc" id="L244">                               sqlExecErrorMsgs.add(handleError(ex, &quot;Error occured in:\n&quot; + lastExecutedStatement));</span>
                            }
                            else
                            {
<span class="nc" id="L248">                               sqlExecErrorMsgs.add(handleError(ex, null));</span>
                            }
                         }
                     }
<span class="nc" id="L252">                  }</span>
               }
<span class="nc" id="L254">            }</span>

         }
         finally
         {
            try
            {
<span class="nc" id="L261">               _stmt.close();</span>
            }
            finally
            {
<span class="nc" id="L265">               _stmt = null;</span>
            }
         }
      }
<span class="nc" id="L269">      catch (final Throwable ex)</span>
      {
<span class="nc bnc" id="L271" title="All 4 branches missed.">         if(props.getAbortOnError() &amp;&amp; 1 &lt; statementCount)</span>
         {
<span class="nc" id="L273">            sqlExecErrorMsgs.add(handleError(ex, &quot;Error occured in:\n&quot; + lastExecutedStatement));</span>
         }
         else
         {
<span class="nc" id="L277">            sqlExecErrorMsgs.add(handleError(ex, null));</span>
         }

<span class="nc bnc" id="L280" title="All 2 branches missed.">         if(false == ex instanceof SQLException)</span>
         {
<span class="nc" id="L282">            s_log.error(&quot;Unexpected exception when executing SQL: &quot; + ex, ex);</span>
<span class="nc" id="L283">            enableEventQueueOutOfMemoryHandling(ex);</span>
         }

      }
      finally
      {
<span class="nc bnc" id="L289" title="All 2 branches missed.">         if (_stopExecution)</span>
         {
<span class="nc bnc" id="L291" title="All 2 branches missed.">            if (_handler != null)</span>
            {
<span class="nc" id="L293">               _handler.sqlExecutionCancelled();</span>
            }
            try
            {
<span class="nc bnc" id="L297" title="All 2 branches missed.">               if (_stmt != null)</span>
               {
<span class="nc" id="L299">                  _stmt.cancel();</span>
               }
            }
<span class="nc" id="L302">            catch (Throwable th)</span>
            {
<span class="nc" id="L304">               s_log.error(&quot;Error occured cancelling SQL&quot;, th);</span>
<span class="nc" id="L305">            }</span>
         }
<span class="nc bnc" id="L307" title="All 2 branches missed.">         if (_handler != null)</span>
         {
<span class="nc" id="L309">            _handler.sqlCloseExecutionHandler(sqlExecErrorMsgs, lastExecutedStatement);</span>
         }

<span class="nc bnc" id="L312" title="All 2 branches missed.">         if (schemaCheck) {</span>
             try
             {
<span class="nc" id="L315">                _schemaInfoUpdateCheck.flush();</span>
             }
<span class="nc" id="L317">             catch (Throwable t)</span>
             {
<span class="nc" id="L319">                s_log.error(&quot;Could not update cache &quot;, t);</span>
<span class="nc" id="L320">             }</span>
         }

<span class="nc" id="L323">         fireExecutionListenersFinshed();</span>
      }
<span class="nc" id="L325">   }</span>

   private void enableEventQueueOutOfMemoryHandling(final Throwable ex)
   {
<span class="nc bnc" id="L329" title="All 2 branches missed.">      if(ex instanceof OutOfMemoryError)</span>
      {
<span class="nc" id="L331">         Runnable runnable = new Runnable()</span>
<span class="nc" id="L332">         {</span>
            public void run()
            {
<span class="nc" id="L335">               throw new RuntimeException(ex);</span>
            }
         };

<span class="nc" id="L339">         SwingUtilities.invokeLater(runnable);</span>
      }
<span class="nc" id="L341">   }</span>

   /**
	 * Set the fetchSize Arrtibute for the SQL-Statement;
	 */
	private void setFetchSize(SessionProperties props) 
	{
	    try
		{
<span class="nc" id="L350">		   _stmt.setFetchSize(props.getSQLFetchSize());</span>
		}
<span class="nc" id="L352">		catch (Exception e)</span>
		{
<span class="nc" id="L354">		   s_log.error(&quot;Can't Set FetchSize&quot;, e);</span>
<span class="nc" id="L355">		}</span>
<span class="nc" id="L356">	}</span>

	private void setMaxRows(final SessionProperties props)
	{
		try
		{
<span class="nc" id="L362">		   _stmt.setMaxRows(props.getSQLNbrRowsToShow());</span>
		}
<span class="nc" id="L364">		catch (Exception e)</span>
		{
<span class="nc" id="L366">		   s_log.error(&quot;Can't Set MaxRows&quot;, e);</span>
<span class="nc" id="L367">		}</span>
<span class="nc" id="L368">	}</span>

	/**
	 * Returns a boolean indicating whether or not the specified querySql appears to be a SELECT statement.
	 *
	 * @param querySql
	 *           the SQL statement to check
	 * @return true if it is a SELECT statement; false otherwise.
	 */
	private boolean isSelectStatement(String querySql)
	{
<span class="nc" id="L379">		return &quot;SELECT&quot;.length() &lt; querySql.trim()</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">		      .length()</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">		      &amp;&amp; &quot;SELECT&quot;.equalsIgnoreCase(querySql</span>
<span class="nc" id="L382">		            .trim().substring(0,</span>
<span class="nc" id="L383">		                  &quot;SELECT&quot;.length()));</span>
	}

   public void cancel()
   {
<span class="nc bnc" id="L388" title="All 2 branches missed.">      if(_stopExecution)</span>
      {
<span class="nc" id="L390">         return;</span>
      }
<span class="nc" id="L392">      _handler.sqlExecutionCancelled();</span>
      // i18n[SQLResultExecuterPanel.canceleRequested=Query execution cancel requested by user.]
<span class="nc" id="L394">      String msg = s_stringMgr.getString(&quot;SQLResultExecuterPanel.canceleRequested&quot;);</span>
<span class="nc" id="L395">      _session.getApplication().getMessageHandler().showMessage(msg);</span>

<span class="nc" id="L397">      _stopExecution = true;</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">      if (_stmt != null)</span>
      {
<span class="nc" id="L400">         CancelStatementThread cst = new CancelStatementThread(_stmt, _session.getApplication().getMessageHandler());</span>
<span class="nc" id="L401">         cst.tryCancel();</span>
      }
<span class="nc" id="L403">   }</span>

   private boolean processQuery(String sql, int processedStatementCount, int statementCount) throws SQLException
   {
<span class="nc" id="L407">      ++_currentQueryIndex;</span>

<span class="nc" id="L409">      final SQLExecutionInfo exInfo = new SQLExecutionInfo(	_currentQueryIndex, sql, getMaxRows(_stmt));</span>
<span class="nc" id="L410">      boolean firstResultIsResultSet = _stmt.execute(sql);</span>
<span class="nc" id="L411">      exInfo.sqlExecutionComplete();</span>

      // Display any warnings generated by the SQL execution.
<span class="nc" id="L414">      handleAllWarnings(_session.getSQLConnection(), _stmt);</span>

<span class="nc" id="L416">      boolean supportsMultipleResultSets = _session.getSQLConnection().getSQLMetaData().supportsMultipleResultSets();</span>
<span class="nc" id="L417">      boolean inFirstLoop = true;</span>

      // Loop while we either have a ResultSet to process or rows have
      // been updated/inserted/deleted.
      while (true)
      {
         // User has cancelled the query execution.
<span class="nc bnc" id="L424" title="All 2 branches missed.">         if (_stopExecution)</span>
         {
<span class="nc" id="L426">            return false;</span>
         }


<span class="nc" id="L430">         int updateCount = _stmt.getUpdateCount();</span>

<span class="nc" id="L432">         ResultSet res = null;</span>
<span class="nc bnc" id="L433" title="All 4 branches missed.">         if (inFirstLoop &amp;&amp; firstResultIsResultSet)</span>
         {
<span class="nc" id="L435">            res = _stmt.getResultSet();</span>
         }
<span class="nc bnc" id="L437" title="All 2 branches missed.">         else if(false == inFirstLoop)</span>
         {
<span class="nc" id="L439">            res = _stmt.getResultSet();</span>
         }


<span class="nc bnc" id="L443" title="All 2 branches missed.">         if (-1 != updateCount)</span>
         {
<span class="nc bnc" id="L445" title="All 2 branches missed.">            if (_handler != null)</span>
            {
<span class="nc" id="L447">               _handler.sqlDataUpdated(updateCount);</span>
            }
         }
<span class="nc bnc" id="L450" title="All 2 branches missed.">         if (null != res)</span>
         {
<span class="nc" id="L452">         	boolean moreResultsReceived = false;</span>
            while(true)
            {
<span class="nc bnc" id="L455" title="All 2 branches missed.">               if (!processResultSet(res, exInfo))</span>
               {
<span class="nc" id="L457">                  return false;</span>
               }

<span class="nc bnc" id="L460" title="All 2 branches missed.">               if (_stopExecution)</span>
               {
<span class="nc" id="L462">                  return false;</span>
               }
               
               // Each call to _stmt.getMoreResults() places the to the next output.
               // As long as it is a ResultSet, we process it ...
<span class="nc bnc" id="L467" title="All 4 branches missed.">               if(supportsMultipleResultSets &amp;&amp; _stmt.getMoreResults())</span>
               {
<span class="nc" id="L469">                  res = _stmt.getResultSet();</span>
<span class="nc" id="L470">                  moreResultsReceived = true;</span>
               }
               else
               {
                  break;
               }
            }

<span class="nc bnc" id="L478" title="All 2 branches missed.">            if (moreResultsReceived) {</span>
            	// ... now we have reached an output that is not a result. We now have to ask for this 
            	// outputs update count - but only if we received more results.
<span class="nc" id="L481">            	updateCount = _stmt.getUpdateCount();</span>
            }
         }

<span class="nc bnc" id="L485" title="All 2 branches missed.">         if (false == supportsMultipleResultSets)</span>
         {
            // This is (a logically not sufficent) try to cope with the problem that there are the following
            // contradictory rules in the JDBC API Doc:
            // Statement.getResultSet():
            // This method should be called only once per result.
            // Statement.getUpdateCount():
            // This method should be called only once per result.
            // Statement.getMoreResults():
            // There are no more results when the following is true: (!getMoreResults() &amp;&amp; (getUpdateCount() == -1)
            //
            // If getMoreResults() returns false, we don't know if we have more results, we only know that it isn't
            // a result set. Since we called getUpdateCount() before getMoreResults() because we would like to know
            // the update count of the first result, we might not be allowed to call getUpdateCount() again.
            //
            // The Intersystems Cache Driver for example always returns the same updateCount on simple
            // INSERT, UPDATE, DELETE statements not matter if getMoreResults() was called. So updateCount never
            // gets -1 and this will loop forever. When I discussed the issue with the Intersystems people they
            // just told me not to call getUpdateCount() twice. That simple. My hope is that this will cure
            // problems with DBs that just don't care for multiple result sets.
<span class="nc" id="L505">            break;</span>
         }

<span class="nc bnc" id="L508" title="All 4 branches missed.">         if (!_stmt.getMoreResults() &amp;&amp; -1 == updateCount)</span>
         {
            // There is no need to close result sets if we call _stmt.getMoreResults() because it
            // implicitly closes any current ResultSet.
            // ON DB2 version 7.1 it is even harmful to close a ResultSet explicitly.
            // _stmt.getMoreResults() will never return true anymore if you do.
<span class="nc" id="L514">            break;</span>
         }
<span class="nc" id="L516">         inFirstLoop = false;</span>
<span class="nc" id="L517">      }</span>

<span class="nc" id="L519">      fireExecutionListeners(sql);</span>

<span class="nc bnc" id="L521" title="All 2 branches missed.">      if (_handler != null)</span>
      {
<span class="nc" id="L523">         _handler.sqlExecutionComplete(exInfo, processedStatementCount, statementCount);</span>
      }

<span class="nc" id="L526">      EditableSqlCheck edittableCheck = new EditableSqlCheck(exInfo);</span>

<span class="nc bnc" id="L528" title="All 2 branches missed.">      if (edittableCheck.allowsEditing())</span>
      {
<span class="nc" id="L530">         TableInfo ti = getTableName(edittableCheck.getTableNameFromSQL());</span>
<span class="nc" id="L531">         _dataSetUpdateableTableModel.setTableInfo(ti);</span>
<span class="nc" id="L532">      }</span>
      else
      {
<span class="nc" id="L535">         _dataSetUpdateableTableModel.setTableInfo(null);</span>
      }
<span class="nc bnc" id="L537" title="All 2 branches missed.">      if (schemaCheck) {</span>
<span class="nc" id="L538">          _schemaInfoUpdateCheck.addExecutionInfo(exInfo);</span>
      }

<span class="nc" id="L541">      return true;</span>
   }

   /**
    * Some drivers, such as SQLite, don't properly support getMaxRows/setMaxRows for statements.
    *
    * @param stmt the statement to get the max rows that could be returned in a result set for.
    *
    * @return the max number of rows that could be returned by this statement
    */
   private int getMaxRows(Statement stmt) {
<span class="nc" id="L552">   	int result = 0;</span>
   	try
		{
<span class="nc" id="L555">			result = stmt.getMaxRows();</span>
		}
<span class="nc" id="L557">		catch (SQLException e)</span>
		{
<span class="nc bnc" id="L559" title="All 2 branches missed.">			if (s_log.isDebugEnabled()) {</span>
<span class="nc" id="L560">				s_log.debug(&quot;Unexpected exception: &quot;+e.getMessage(), e);</span>
			}
<span class="nc" id="L562">		}</span>
<span class="nc" id="L563">		return result;</span>
   }

   private void fireExecutionListeners(final String sql)
   {
      // This method is called from a thread.
      // In case listeners update Swing controls we invoke later here.
<span class="nc" id="L570">      SwingUtilities.invokeLater(new Runnable()</span>
<span class="nc" id="L571">      {</span>
         public void run()
         {
<span class="nc bnc" id="L574" title="All 2 branches missed.">            for (int i = 0; i &lt; _executionListeners.length; i++)</span>
            {
<span class="nc" id="L576">               _executionListeners[i].statementExecuted(sql);</span>
            }
<span class="nc" id="L578">         }</span>
      });
<span class="nc" id="L580">   }</span>

   private void fireExecutionListenersFinshed()
   {
      // This method is called from a thread.
      // In case listeners update Swing controls we invoke later here.
<span class="nc" id="L586">      SwingUtilities.invokeLater(new Runnable()</span>
<span class="nc" id="L587">      {</span>
         public void run()
         {
<span class="nc bnc" id="L590" title="All 2 branches missed.">            for (int i = 0; i &lt; _executionListeners.length; i++)</span>
            {
<span class="nc" id="L592">               _executionListeners[i].executionFinished();</span>
            }
<span class="nc" id="L594">         }</span>
      });
<span class="nc" id="L596">   }</span>



   private boolean processResultSet(final ResultSet rs, final SQLExecutionInfo exInfo)
   {
<span class="nc bnc" id="L602" title="All 2 branches missed.">      if (_stopExecution)</span>
      {
<span class="nc" id="L604">         return false;</span>
      }

<span class="nc bnc" id="L607" title="All 2 branches missed.">      if (_handler != null) {</span>
            try {
<span class="nc" id="L609">                _handler.sqlResultSetAvailable(rs, exInfo, this);</span>
<span class="nc" id="L610">            } catch (DataSetException ex) {</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">                if (_stopExecution) {</span>
<span class="nc" id="L612">                    return false;</span>
                } else {
<span class="nc" id="L614">                    _session.showMessage(ex);</span>
<span class="nc" id="L615">                    s_log.error(&quot;Error reading ResultSet for SQL: &quot;</span>
<span class="nc" id="L616">                            + exInfo.getSQL(), ex);</span>
                }
<span class="nc" id="L618">            }</span>
        }

<span class="nc" id="L621">      handleResultSetWarnings(rs);</span>
<span class="nc" id="L622">      SQLUtilities.closeResultSet(rs);</span>
<span class="nc" id="L623">      return true;</span>
   }

   private void handleAllWarnings(ISQLConnection conn, Statement stmt)
   {
      // If SQL executing produced warnings then write them out to the session
      // message handler. TODO: This is a pain. PostgreSQL sends &quot;raise
      // notice&quot; messages to the connection, not to the statment so they will
      // be mixed up with warnings from other statements.
<span class="nc" id="L632">      synchronized (conn)</span>
      {
         try
         {
<span class="nc" id="L636">            handleWarnings(conn.getWarnings());</span>
<span class="nc" id="L637">            conn.getConnection().clearWarnings();</span>
         }
<span class="nc" id="L639">         catch (Throwable th)</span>
         {
<span class="nc" id="L641">            s_log.debug(&quot;Driver doesn't handle &quot;</span>
                        + &quot;Connection.getWarnings()/clearWarnings()&quot;, th);
<span class="nc" id="L643">         }</span>
<span class="nc" id="L644">      }</span>

      try
      {
<span class="nc" id="L648">         handleWarnings(stmt.getWarnings());</span>
<span class="nc" id="L649">         stmt.clearWarnings();</span>
      }
<span class="nc" id="L651">      catch (Throwable th)</span>
      {
<span class="nc" id="L653">         s_log.debug(&quot;Driver doesn't handle &quot;</span>
                    + &quot;Statement.getWarnings()/clearWarnings()&quot;, th);
<span class="nc" id="L655">      }</span>
<span class="nc" id="L656">   }</span>

   private void handleResultSetWarnings(ResultSet rs)
   {
      try
      {
<span class="nc" id="L662">         handleWarnings(rs.getWarnings());</span>
      }
<span class="nc" id="L664">      catch (Throwable th)</span>
      {
<span class="nc" id="L666">         s_log.error(&quot;Can't get warnings from ResultSet&quot;, th);</span>
<span class="nc" id="L667">         _session.showMessage(th);</span>
<span class="nc" id="L668">      }</span>
<span class="nc" id="L669">   }</span>

   private void handleWarnings(SQLWarning sw)
   {
<span class="nc bnc" id="L673" title="All 2 branches missed.">      if (_handler != null)</span>
      {
         try
         {
<span class="nc bnc" id="L677" title="All 2 branches missed.">            while (sw != null)</span>
            {
<span class="nc" id="L679">               _handler.sqlExecutionWarning(sw);</span>
<span class="nc" id="L680">               sw = sw.getNextWarning();</span>
            }
         }
<span class="nc" id="L683">         catch (Throwable th)</span>
         {
<span class="nc" id="L685">            s_log.debug(&quot;Driver/DBMS can't handle SQLWarnings&quot;, th);</span>
<span class="nc" id="L686">         }</span>
      }
<span class="nc" id="L688">   }</span>

   private String handleError(Throwable th, String postErrorString)
   {
<span class="nc bnc" id="L692" title="All 2 branches missed.">      if (_handler != null)</span>
      {
<span class="nc" id="L694">         return _handler.sqlExecutionException(th, postErrorString);</span>
      }

<span class="nc" id="L697">      return null;</span>
   }




   /*
     *
     *
     * Implement IDataSetUpdateableModel interface
     * and IDataSetUpdateableTableModel interface
     *
     * TODO: THIS CODE WAS COPIED FROM ContentsTab.  IT SHOULD PROBABLY
     * BE PUT INTO A COMMON LOCATION AND SHARED BY BOTH THIS
     * CLASS AND ContentsTab.
     *
     *
     */


   /**
   * Get the full name info for the table that is being referred to in the
   * SQL query.
   * Since we do not know the catalog, schema, or the actual name used in
   * this DB to refer to &quot;table&quot; types, we cannot filter the initial query on any of
   * those criteria.  Thus the only thing we can do is get all of the names
   * of everything in the DB, then scan for things matching the name of the
   * table as entered by the user in the SQL query.  If there are no objects
   * with that name or multiple objects with that name, we do not allow editing.
   * This method was originally copied from TableTypeExpander.createChildren
   * and heavilly modified.
   *
   * @param	tableNameInSQL	Name of the table as typed by the user in the SQL query.
   *
   * @return	A  &lt;TT&gt;TableInfo&lt;/TT&gt; object for the only DB object
   * 	with the given name, or null if there is none or more than one with that name.
   */
   public TableInfo getTableName(String tableNameFromSQL)
   {
<span class="nc" id="L736">      ITableInfo[] tables = _session.getSchemaInfo().getITableInfos();</span>

      // filter the list of all DB objects looking for things with the given name
<span class="nc bnc" id="L739" title="All 2 branches missed.">      for (int i = 0; i &lt; tables.length; ++i)</span>
      {
<span class="nc" id="L741">         String simpleName = tables[i].getSimpleName().toUpperCase();</span>
<span class="nc" id="L742">         String nameWithSchema = simpleName;</span>
<span class="nc" id="L743">         String nameWithSchemaAndCatalog = simpleName;</span>

<span class="nc bnc" id="L745" title="All 4 branches missed.">         if (null != tables[i].getSchemaName() &amp;&amp; 0 &lt; tables[i].getSchemaName().length())</span>
         {
<span class="nc" id="L747">            nameWithSchema = tables[i].getSchemaName().toUpperCase() + &quot;.&quot; + nameWithSchema;</span>
<span class="nc" id="L748">            nameWithSchemaAndCatalog = nameWithSchema;</span>
         }

<span class="nc bnc" id="L751" title="All 4 branches missed.">         if (null != tables[i].getCatalogName() &amp;&amp; 0 &lt; tables[i].getCatalogName().length())</span>
         {
<span class="nc" id="L753">            nameWithSchemaAndCatalog = tables[i].getCatalogName().toUpperCase() + &quot;.&quot; + nameWithSchema;</span>
         }

<span class="nc bnc" id="L756" title="All 2 branches missed.">         if (simpleName.equals(tableNameFromSQL)</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">            || nameWithSchema.equals(tableNameFromSQL)</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">            || nameWithSchemaAndCatalog.equals(tableNameFromSQL))</span>
         {
<span class="nc" id="L760">            return (TableInfo) tables[i];</span>
         }
      }
      // ok, that didn't work - let's see if the table looks fully qualified.
      // if so, we'll split the name from the schema/catalog and try that.
<span class="nc" id="L765">      String[] parts = tableNameFromSQL.split(&quot;\\.&quot;);</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">      if (parts.length == 2)</span>
      {
<span class="nc" id="L768">         String catalog = parts[0];</span>
<span class="nc" id="L769">         String simpleName = parts[1];</span>
<span class="nc" id="L770">         tables = _session.getSchemaInfo().getITableInfos(catalog, null, simpleName);</span>
<span class="nc bnc" id="L771" title="All 4 branches missed.">         if (tables != null &amp;&amp; tables.length &gt; 0)</span>
         {
<span class="nc" id="L773">            return (TableInfo) tables[0];</span>
         }
         // Ok, maybe catalog was really a schema instead.
<span class="nc" id="L776">         tables = _session.getSchemaInfo().getITableInfos(null, catalog, simpleName);</span>
<span class="nc bnc" id="L777" title="All 4 branches missed.">         if (tables != null &amp;&amp; tables.length &gt; 0)</span>
         {
<span class="nc" id="L779">            return (TableInfo) tables[0];</span>
         }
      }
<span class="nc" id="L782">      return null;</span>

   }


   ////////////////////////////////////////////////////////
   // Implementataion of IDataSetUpdateableTableModel:
   // Delegation to _dataSetUpdateableTableModel
   public String getWarningOnCurrentData(Object[] values, ColumnDisplayDefinition[] colDefs, int col, Object oldValue)
   {
<span class="nc" id="L792">      return _dataSetUpdateableTableModel.getWarningOnCurrentData(values, colDefs, col, oldValue);</span>
   }

   public String getWarningOnProjectedUpdate(Object[] values, ColumnDisplayDefinition[] colDefs, int col, Object newValue)
   {
<span class="nc" id="L797">      return _dataSetUpdateableTableModel.getWarningOnProjectedUpdate(values, colDefs, col, newValue);</span>
   }

   public Object reReadDatum(Object[] values, ColumnDisplayDefinition[] colDefs, int col, StringBuffer message)
   {
<span class="nc" id="L802">      return _dataSetUpdateableTableModel.reReadDatum(values, colDefs, col, message);</span>
   }

   public String updateTableComponent(Object[] values, ColumnDisplayDefinition[] colDefs, int col, Object oldValue, Object newValue)
   {
<span class="nc" id="L807">      return _dataSetUpdateableTableModel.updateTableComponent(values, colDefs, col, oldValue, newValue);</span>
   }

   public int getRowidCol()
   {
<span class="nc" id="L812">      return _dataSetUpdateableTableModel.getRowidCol();</span>
   }

   public String deleteRows(Object[][] rowData, ColumnDisplayDefinition[] colDefs)
   {
<span class="nc" id="L817">      return _dataSetUpdateableTableModel.deleteRows(rowData, colDefs);</span>
   }

   public String[] getDefaultValues(ColumnDisplayDefinition[] colDefs)
   {
<span class="nc" id="L822">      return _dataSetUpdateableTableModel.getDefaultValues(colDefs);</span>
   }

   public String insertRow(Object[] values, ColumnDisplayDefinition[] colDefs)
   {
<span class="nc" id="L827">      return _dataSetUpdateableTableModel.insertRow(values, colDefs);</span>
   }

   public void addListener(DataSetUpdateableTableModelListener l)
   {
<span class="nc" id="L832">      _dataSetUpdateableTableModel.addListener(l);</span>
<span class="nc" id="L833">   }</span>

   public void removeListener(DataSetUpdateableTableModelListener l)
   {
<span class="nc" id="L837">      _dataSetUpdateableTableModel.removeListener(l);</span>
<span class="nc" id="L838">   }</span>

   public void forceEditMode(boolean mode)
   {
<span class="nc" id="L842">      _dataSetUpdateableTableModel.forceEditMode(mode);</span>
<span class="nc" id="L843">   }</span>

   public boolean editModeIsForced()
   {
<span class="nc" id="L847">      return _dataSetUpdateableTableModel.editModeIsForced();</span>
   }

   //
   //////////////////////////////////////////////////////////////////////////////////


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>