<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractDataExportFileWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">102_squirrel-sql</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.squirrel_sql.fw.gui.action.exportData</a> &gt; <span class="el_source">AbstractDataExportFileWriter.java</span></div><h1>AbstractDataExportFileWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2011 Stefan Willinger
 * wis775@users.sourceforge.net
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package net.sourceforge.squirrel_sql.fw.gui.action.exportData;

import java.io.File;
import java.text.NumberFormat;
import java.util.Iterator;
import java.util.concurrent.TimeUnit;

import javax.swing.plaf.SliderUI;

import net.sourceforge.squirrel_sql.fw.gui.action.TableExportCsvController;
import net.sourceforge.squirrel_sql.fw.sql.ProgressAbortCallback;
import net.sourceforge.squirrel_sql.fw.util.StringManager;
import net.sourceforge.squirrel_sql.fw.util.StringManagerFactory;

/**
 * Exports a data structure into a file.
 * This abstract implementation does not know the format of the target file, e.g. XML or CSV. 
 * It rather knows the structure of {@link IExportData} and provide some callback methods for exporting data.
 * A further scope of this abstract class is the interaction with  {@link TableExportCsvController} and {@link ProgressAbortCallback}.
 * A concrete implementation is responsible for formating and writing the data into the target.
 * @author Stefan Willinger
 * @see DataExportCSVWriter
 * @see DataExportExcelWriter
 * @see DataExportXMLWriter
 */
public abstract class AbstractDataExportFileWriter implements IDataExportWriter{
	
	/** Internationalized strings for this class */
<span class="nc" id="L47">	private static final StringManager s_stringMgr =</span>
<span class="nc" id="L48">		StringManagerFactory.getStringManager(AbstractDataExportFileWriter.class);</span>
	
	static interface i18n
	{
		// i18n[AbstractDataExportFileWriter.beginWriting=Begin writing]
<span class="nc" id="L53">		String BEGIN_WRITING = s_stringMgr.getString(&quot;AbstractDataExportFileWriter.beginWriting&quot;);</span>

		String KEY_NUMBER_OF_ROWS_COMPLETED_IN_SECONDS = &quot;AbstractDataExportFileWriter.numberOfRowsCompletedInSeconds&quot;;

		
		// i18n[AbstractDataExportFileWriter.NUMBER_OF_ROWS_COMPLETED=Finished with 100 rows]
		String KEY_FINISHED_LOADING = &quot;AbstractDataExportFileWriter.finishedLoading&quot;;
				
		// i18n[AbstractDataExportFileWriter.NUMBER_OF_ROWS_COMPLETED=Closing the file]
<span class="nc" id="L62">		String CLOSING_THE_FILE = s_stringMgr.getString(&quot;AbstractDataExportFileWriter.closingTheFile&quot;);</span>
		
		// i18n[AbstractDataExportFileWriter.DONE=Done]
<span class="nc" id="L65">		String DONE = s_stringMgr.getString(&quot;AbstractDataExportFileWriter.done&quot;);</span>
	}
	
	
	
	/**
	 * Constant, for updating the progress bar each x seconds.
	 */
	private static final int FEEDBACK_EVRY_N_SECONDS = 2;
	/**
	 * The target file.
	 */
	private File file;
	/**
	 * Controller for exporting data. 
	 */
	private TableExportCsvController ctrl;
	/**
	 * Flag, if the header line should be included
	 */
	private boolean includeHeaders;
	
	/**
	 * Progress controller with the opportunity to abort the operation.
	 */
	private ProgressAbortCallback progressController;
	
	/**
	 * Timestamp of the last update of the progress status. 
	 */
<span class="nc" id="L95">	private long timeOfLastStatusUpdate = 0;</span>

	/**&quot;Begin writing&quot;);
		beforeRows();
	 * Construct this one.
	 * @param file The target file.
	 * @param ctrl The controller to use
	 * @param includeHeaders  Flag, if the header line should be exported
	 * @param progressController ProgressController to use.
	 */
<span class="nc" id="L105">	public AbstractDataExportFileWriter(File file, TableExportCsvController ctrl, boolean includeHeaders, ProgressAbortCallback progressController) {</span>
<span class="nc" id="L106">		this.file = file;</span>
<span class="nc" id="L107">		this.ctrl = ctrl;</span>
<span class="nc" id="L108">		this.includeHeaders = includeHeaders;</span>
<span class="nc" id="L109">		this.progressController = progressController;</span>
<span class="nc" id="L110">	}</span>

	/**
	 * @see net.sourceforge.squirrel_sql.fw.gui.action.exportData.IDataExportWriter#write(net.sourceforge.squirrel_sql.fw.gui.action.exportData.IExportData)
	 */
	public long write(IExportData data) throws Exception {

<span class="nc" id="L117">		beforeWorking(file);</span>

<span class="nc bnc" id="L119" title="All 2 branches missed.">		if (includeHeaders) {</span>
<span class="nc" id="L120">			Iterator&lt;String&gt; headers = data.getHeaders();</span>

<span class="nc" id="L122">			int colIdx = 0;</span>
<span class="nc" id="L123">			beforeHeader();</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">			while (headers.hasNext()) {</span>
<span class="nc" id="L125">				String columnName = (String) headers.next();</span>
<span class="nc" id="L126">				addHeaderCell(colIdx,columnName);</span>
<span class="nc" id="L127">				colIdx++;</span>
<span class="nc" id="L128">			}</span>
<span class="nc" id="L129">			afterHeader();</span>
		}

<span class="nc" id="L132">		Iterator&lt;IExportDataRow&gt; rows = data.getRows();</span>
		
<span class="nc" id="L134">		progress(i18n.BEGIN_WRITING);</span>
<span class="nc" id="L135">		beforeRows();</span>
<span class="nc" id="L136">		long rowsCount = 0;</span>
<span class="nc" id="L137">		NumberFormat nfRowCount = NumberFormat.getInstance();</span>
		

<span class="nc" id="L140">      long begin = System.currentTimeMillis();</span>
<span class="nc bnc" id="L141" title="All 4 branches missed.">		while (rows.hasNext() &amp;&amp; isStop() == false) {</span>
<span class="nc" id="L142">			rowsCount++;</span>
<span class="nc" id="L143">			IExportDataRow aRow = rows.next();</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">			if(isStatusUpdateNecessary()){</span>
<span class="nc" id="L145">				long secondsPassed = (System.currentTimeMillis() - begin) / 1000;</span>
<span class="nc" id="L146">				taskStatus(s_stringMgr.getString(i18n.KEY_NUMBER_OF_ROWS_COMPLETED_IN_SECONDS, nfRowCount.format(rowsCount), secondsPassed));</span>
			}
<span class="nc" id="L148">			beforeRow(aRow.getRowIndex());</span>

<span class="nc" id="L150">			Iterator&lt;IExportDataCell&gt; cells = aRow.getCells();</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">			while (cells.hasNext()) {</span>
<span class="nc" id="L152">				IExportDataCell cell = cells.next();</span>
<span class="nc" id="L153">				addCell(cell);</span>
<span class="nc" id="L154">			}</span>
<span class="nc" id="L155">			afterRow();</span>
<span class="nc" id="L156">		}</span>
<span class="nc" id="L157">		progress(s_stringMgr.getString(i18n.KEY_FINISHED_LOADING, nfRowCount.format(rowsCount)));</span>
<span class="nc" id="L158">		afterRows();</span>
<span class="nc" id="L159">		progress(i18n.CLOSING_THE_FILE);</span>
		// All sheets and cells added. Now write out the workbook
<span class="nc" id="L161">		afterWorking();</span>
		
<span class="nc" id="L163">		progress(i18n.DONE);</span>
		
<span class="nc bnc" id="L165" title="All 2 branches missed.">		if(progressController != null){</span>
<span class="nc" id="L166">			progressController.setFinished();</span>
		}
		
<span class="nc bnc" id="L169" title="All 2 branches missed.">		if (isStop()) {</span>
<span class="nc" id="L170">			return -1;</span>
		} else {
<span class="nc" id="L172">			return rowsCount;</span>
		}

	}

   /**
	 * @return
	 */
	private boolean isStatusUpdateNecessary() {
<span class="nc" id="L181">		long time = System.currentTimeMillis();</span>

<span class="nc bnc" id="L183" title="All 2 branches missed.">		if((timeOfLastStatusUpdate  + TimeUnit.SECONDS.toMillis(FEEDBACK_EVRY_N_SECONDS)) &lt; time){</span>
<span class="nc" id="L184">			timeOfLastStatusUpdate = time;</span>
<span class="nc" id="L185">			return true;</span>
		}else{
<span class="nc" id="L187">			return false;</span>
		}
	}

	/**
	 * Callback before processing the first row.
	 */
	public void beforeRows() {
		// Can be overridden.
<span class="nc" id="L196">	}</span>

	/**
	 * Callback after processing all rows
	 */
	public void afterRows() {
		// Can be overridden.
<span class="nc" id="L203">	}</span>

	
	/**
	 * Callback, before a row is processed.
	 */
	public void beforeRow(int rowIdx) throws Exception{
		// Can be overridden.
		
<span class="nc" id="L212">	}</span>
	/**
	 * Callback, after the processing of a row.
	 * 
	 */
	public void afterRow() throws Exception {
		// Can be overridden.
		
<span class="nc" id="L220">	}</span>

	

	/**
	 * Callback, after all rows are processed.
	 * @throws Exception 
	 * 
	 */
	protected abstract void afterWorking() throws  Exception;

	/**
	 * Adds a cell to a row of data.
	 * @param cell cell to be added
	 * @throws Exception
	 */
	protected abstract void addCell(IExportDataCell cell) throws Exception;

	/**
	 * Callback, before the processing of the header line will start.
	 */
	protected void beforeHeader() throws Exception{
		// Can be overridden.
<span class="nc" id="L243">	}</span>
	
	/**
	 * Adds a header cell into the output data.
	 * @param colIdx the index of the cell
	 * @param columnName the name of the column
	 * @throws Exception 
	 */
	protected abstract void addHeaderCell(int colIdx, String columnName) throws Exception;

	/**
	 * Callback, after we have processed all header cells.
	 */
	protected void afterHeader() throws Exception {
		// Can be overridden.
		
<span class="nc" id="L259">	}</span>

	/**
	 * Callback that indicate, that the work is just started.
	 * Normally, a concrete implementation would do some setup at this point. Like the initializing of a output stream. 
	 * @param file The target file.
	 * @throws Exception if a Exception occurs.
	 */
	protected abstract void beforeWorking(File file) throws Exception;

	/**
	 * @return the file
	 */
	public File getFile() {
<span class="nc" id="L273">		return file;</span>
	}

	/**
	 * @param file the file to set
	 */
	public void setFile(File file) {
<span class="nc" id="L280">		this.file = file;</span>
<span class="nc" id="L281">	}</span>

	/**
	 * @return the ctrl
	 */
	public TableExportCsvController getCtrl() {
<span class="nc" id="L287">		return ctrl;</span>
	}

	/**
	 * @param ctrl the ctrl to set
	 */
	public void setCtrl(TableExportCsvController ctrl) {
<span class="nc" id="L294">		this.ctrl = ctrl;</span>
<span class="nc" id="L295">	}</span>

	/**
	 * @return the includeHeaders
	 */
	public boolean isIncludeHeaders() {
<span class="nc" id="L301">		return includeHeaders;</span>
	}

	/**
	 * @param includeHeaders the includeHeaders to set
	 */
	public void setIncludeHeaders(boolean includeHeaders) {
<span class="nc" id="L308">		this.includeHeaders = includeHeaders;</span>
<span class="nc" id="L309">	}</span>

	/**
	 * Tells the progress controller the current task.
	 * @param task Task to be added to the progress controller.
	 */
	protected void progress(String task){
<span class="nc bnc" id="L316" title="All 2 branches missed.">		if(progressController != null){</span>
<span class="nc" id="L317">			progressController.currentlyLoading(task);</span>
		}
<span class="nc" id="L319">	}</span>

	/**
	 * Tells the progress controller the status of the current task.
	 * @param status Status of a task to be added to the progress controller.
	 */
	protected void taskStatus(String status){
<span class="nc bnc" id="L326" title="All 2 branches missed.">		if(progressController != null){</span>
<span class="nc" id="L327">			progressController.setTaskStatus(status);</span>
		}
<span class="nc" id="L329">	}</span>

	
	/**
	 * Checks, if the work should be stopped.
	 * @return true, if the work should be stopped, otherwise false.
	 */
	protected boolean isStop(){
<span class="nc bnc" id="L337" title="All 2 branches missed.">		if(progressController == null){</span>
<span class="nc" id="L338">			return false;</span>
		}else{
<span class="nc" id="L340">			return progressController.isStop();</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>