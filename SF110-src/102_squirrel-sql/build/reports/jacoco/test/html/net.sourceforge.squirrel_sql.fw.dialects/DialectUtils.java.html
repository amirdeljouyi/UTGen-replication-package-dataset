<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DialectUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">102_squirrel-sql</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.squirrel_sql.fw.dialects</a> &gt; <span class="el_source">DialectUtils.java</span></div><h1>DialectUtils.java</h1><pre class="source lang-java linenums">package net.sourceforge.squirrel_sql.fw.dialects;

/*
 * Copyright (C) 2006 Rob Manning
 * manningr@users.sourceforge.net
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

import java.sql.DatabaseMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map.Entry;
import java.util.Vector;

import net.sourceforge.squirrel_sql.fw.sql.DatabaseObjectType;
import net.sourceforge.squirrel_sql.fw.sql.ForeignKeyColumnInfo;
import net.sourceforge.squirrel_sql.fw.sql.ForeignKeyInfo;
import net.sourceforge.squirrel_sql.fw.sql.ISQLDatabaseMetaData;
import net.sourceforge.squirrel_sql.fw.sql.ITableInfo;
import net.sourceforge.squirrel_sql.fw.sql.IndexInfo;
import net.sourceforge.squirrel_sql.fw.sql.JDBCTypeMapper;
import net.sourceforge.squirrel_sql.fw.sql.PrimaryKeyInfo;
import net.sourceforge.squirrel_sql.fw.sql.TableColumnInfo;
import net.sourceforge.squirrel_sql.fw.util.StringManager;
import net.sourceforge.squirrel_sql.fw.util.StringManagerFactory;
import net.sourceforge.squirrel_sql.fw.util.log.ILogger;
import net.sourceforge.squirrel_sql.fw.util.log.LoggerController;

import org.antlr.stringtemplate.StringTemplate;
import org.apache.commons.lang.StringUtils;
import org.hibernate.HibernateException;

/**
 * A simple utility class in which to place common code shared amongst the dialects. Since the dialects all
 * inherit behavior from specific server dialects, it is not possible to inherit common behavior from a single
 * base class. So, this class is where common code is located.
 * 
 * @author manningr
 */
<span class="nc" id="L59">public class DialectUtils implements StringTemplateConstants</span>
{

	/** Logger for this class. */
<span class="nc" id="L63">	private static final ILogger log = LoggerController.createLogger(DialectUtils.class);</span>

	/** Internationalized strings for this class. */
<span class="nc" id="L66">	private static final StringManager s_stringMgr = StringManagerFactory.getStringManager(DialectUtils.class);</span>

	// alter column clauses

	public static final String ALTER_COLUMN_CLAUSE = &quot;ALTER COLUMN&quot;;

	public static final String MODIFY_COLUMN_CLAUSE = &quot;MODIFY COLUMN&quot;;

	public static final String MODIFY_CLAUSE = &quot;MODIFY&quot;;

	public static final String COLUMN_CLAUSE = &quot;COLUMN&quot;;

	// alter name clauses

	public static final String RENAME_COLUMN_CLAUSE = &quot;RENAME COLUMN&quot;;

	public static final String RENAME_CLAUSE = &quot;RENAME&quot;;

	public static final String RENAME_TO_CLAUSE = &quot;RENAME TO&quot;;

	public static final String TO_CLAUSE = &quot;TO&quot;;

	// alter default clauses

	public static final String DEFAULT_CLAUSE = &quot;DEFAULT&quot;;

	public static final String SET_DEFAULT_CLAUSE = &quot;SET DEFAULT&quot;;

	public static final String SET_CLAUSE = &quot;SET&quot;;

	public static final String ADD_DEFAULT_CLAUSE = &quot;ADD DEFAULT&quot;;

	public static final String DROP_DEFAULT_CLAUSE = &quot;DROP DEFAULT&quot;;

	// alter type clauses

	public static final String TYPE_CLAUSE = &quot;TYPE&quot;;

	public static final String SET_DATA_TYPE_CLAUSE = &quot;SET DATA TYPE&quot;;

	// drop column clauses

	public static final String DROP_CLAUSE = &quot;DROP&quot;;

	public static final String DROP_COLUMN_CLAUSE = &quot;DROP COLUMN&quot;;

	// cascade constraint clauses

	public static final String CASCADE_CLAUSE = &quot;CASCADE&quot;;

	public static final String CASCADE_CONSTRAINTS_CLAUSE = &quot;CASCADE CONSTRAINTS&quot;;

	// sequence clauses

	public static final String CACHE_CLAUSE = &quot;CACHE&quot;;

	public static final String CYCLE_CLAUSE = &quot;CYCLE&quot;;

	public static final String INCREMENT_CLAUSE = &quot;INCREMENT&quot;;

	public static final String INCREMENT_BY_CLAUSE = &quot;INCREMENT BY&quot;;

	public static final String NOCYCLE_CLAUSE = &quot;NOCYCLE&quot;;

	public static final String NO_CYCLE_CLAUSE = &quot;NO CYCLE&quot;;

	public static final String MAXVALUE_CLAUSE = &quot;MAXVALUE&quot;;

	public static final String NO_MAXVALUE_CLAUSE = &quot;NO MAXVALUE&quot;;

	public static final String NOMAXVALUE_CLAUSE = &quot;NOMAXVALUE&quot;;

	public static final String MINVALUE_CLAUSE = &quot;MINVALUE&quot;;

	public static final String NO_MINVALUE_CLAUSE = &quot;NO MINVALUE&quot;;

	public static final String NOMINVALUE_CLAUSE = &quot;NOMINVALUE&quot;;

	// view clauses

	public static final String WITH_CHECK_OPTION_CLAUSE = &quot;WITH CHECK OPTION&quot;;

	// Clauses
	public static final String CREATE_CLAUSE = &quot;CREATE&quot;;

	public static final String ALTER_CLAUSE = &quot;ALTER&quot;;

	public static final String TABLE_CLAUSE = &quot;TABLE&quot;;

	public static final String INDEX_CLAUSE = &quot;INDEX&quot;;

	public static final String VIEW_CLAUSE = &quot;VIEW&quot;;

	public static final String UPDATE_CLAUSE = &quot;UPDATE&quot;;

	public static final String FROM_CLAUSE = &quot;FROM&quot;;

	public static final String WHERE_CLAUSE = &quot;WHERE&quot;;

	public static final String AND_CLAUSE = &quot;AND&quot;;

	public static final String CREATE_TABLE_CLAUSE = CREATE_CLAUSE + &quot; &quot; + TABLE_CLAUSE;

	public static final String ALTER_TABLE_CLAUSE = ALTER_CLAUSE + &quot; &quot; + TABLE_CLAUSE;

	public static final String ALTER_VIEW_CLAUSE = ALTER_CLAUSE + &quot; &quot; + VIEW_CLAUSE;

	public static final String DROP_TABLE_CLAUSE = DROP_CLAUSE + &quot; &quot; + TABLE_CLAUSE;

	public static final String ADD_COLUMN_CLAUSE = &quot;ADD &quot; + COLUMN_CLAUSE;

	public static final String SEQUENCE_CLAUSE = &quot;SEQUENCE&quot;;

	public static final String CREATE_SEQUENCE_CLAUSE = CREATE_CLAUSE + &quot; &quot; + SEQUENCE_CLAUSE;

	public static final String ALTER_SEQUENCE_CLAUSE = ALTER_CLAUSE + &quot; &quot; + SEQUENCE_CLAUSE;

	public static final String DROP_SEQUENCE_CLAUSE = DROP_CLAUSE + &quot; &quot; + SEQUENCE_CLAUSE;

	public static final String CREATE_INDEX_CLAUSE = CREATE_CLAUSE + &quot; &quot; + INDEX_CLAUSE;

	public static final String DROP_INDEX_CLAUSE = DROP_CLAUSE + &quot; &quot; + INDEX_CLAUSE;

	public static final String CREATE_VIEW_CLAUSE = CREATE_CLAUSE + &quot; &quot; + VIEW_CLAUSE;

	public static final String DROP_VIEW_CLAUSE = DROP_CLAUSE + &quot; &quot; + VIEW_CLAUSE;

	public static final String INSERT_INTO_CLAUSE = &quot;INSERT INTO&quot;;

	public static final String PRIMARY_KEY_CLAUSE = &quot;PRIMARY KEY&quot;;

	public static final String FOREIGN_KEY_CLAUSE = &quot;FOREIGN KEY&quot;;

	public static final String NOT_NULL_CLAUSE = &quot;NOT NULL&quot;;

	public static final String UNIQUE_CLAUSE = &quot;UNIQUE&quot;;

	public static final String RESTRICT_CLAUSE = &quot;RESTRICT&quot;;

	public static final String CONSTRAINT_CLAUSE = &quot;CONSTRAINT&quot;;

	public static final String ADD_CONSTRAINT_CLAUSE = &quot;ADD &quot; + CONSTRAINT_CLAUSE;

	public static final String DROP_CONSTRAINT_CLAUSE = &quot;DROP &quot; + CONSTRAINT_CLAUSE;

	// features

	public static final int COLUMN_COMMENT_ALTER_TYPE = 0;

	public static final int COLUMN_DEFAULT_ALTER_TYPE = 1;

	public static final int COLUMN_DROP_TYPE = 2;

	public static final int COLUMN_NAME_ALTER_TYPE = 3;

	public static final int COLUMN_NULL_ALTER_TYPE = 4;

	public static final int COLUMN_TYPE_ALTER_TYPE = 5;

	public static final int ADD_PRIMARY_KEY_TYPE = 6;

	public static final int DROP_PRIMARY_KEY_TYPE = 7;

	public static final int CREATE_TABLE_TYPE = 8;

	public static final int RENAME_TABLE_TYPE = 9;

	public static final int CREATE_VIEW_TYPE = 10;

	public static final int RENAME_VIEW_TYPE = 11;

	public static final int DROP_VIEW_TYPE = 12;

	public static final int CREATE_INDEX_TYPE = 13;

	public static final int DROP_INDEX_TYPE = 14;

	public static final int CREATE_SEQUENCE_TYPE = 15;

	public static final int ALTER_SEQUENCE_TYPE = 16;

	public static final int SEQUENCE_INFORMATION_TYPE = 17;

	public static final int DROP_SEQUENCE_TYPE = 18;

	public static final int ADD_FOREIGN_KEY_TYPE = 19;

	public static final int ADD_UNIQUE_TYPE = 20;

	public static final int ADD_AUTO_INCREMENT_TYPE = 21;

	public static final int DROP_CONSTRAINT_TYPE = 22;

	public static final int INSERT_INTO_TYPE = 23;

	public static final int UPDATE_TYPE = 24;

	public static final int VIEW_DEFINITION_TYPE = 25;

	public static final int ADD_COLUMN_TYPE = 26;

	public static String appendDefaultClause(TableColumnInfo info, StringBuilder buffer)
	{

<span class="nc bnc" id="L270" title="All 4 branches missed.">		if (info.getDefaultValue() != null &amp;&amp; !&quot;&quot;.equals(info.getDefaultValue()))</span>
		{
<span class="nc" id="L272">			buffer.append(&quot; DEFAULT &quot;);</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">			if (JDBCTypeMapper.isNumberType(info.getDataType()))</span>
			{
<span class="nc" id="L275">				buffer.append(info.getDefaultValue());</span>
			}
			else
			{
<span class="nc" id="L279">				buffer.append(&quot;'&quot;);</span>
<span class="nc" id="L280">				buffer.append(info.getDefaultValue());</span>
<span class="nc" id="L281">				buffer.append(&quot;'&quot;);</span>
			}
		}
<span class="nc" id="L284">		return buffer.toString();</span>
	}

	/**
	 * Returns the SQL statement to use to add a comment to the specified column of the specified table.
	 * 
	 * @param tableName
	 *           the name of the table to create the SQL for.
	 * @param columnName
	 *           the name of the column to create the SQL for.
	 * @param comment
	 *           the comment to add.
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect representing the target database.
	 * @return
	 * @throws UnsupportedOperationException
	 *            if the database doesn't support annotating columns with a comment.
	 */
	public static String getColumnCommentAlterSQL(String tableName, String columnName, String comment,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc" id="L309">		final StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L310">		result.append(&quot;COMMENT ON COLUMN &quot;);</span>
<span class="nc" id="L311">		result.append(shapeQualifiableIdentifier(tableName, qualifier, prefs, dialect));</span>
<span class="nc" id="L312">		result.append(&quot;.&quot;);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">		if (prefs.isQuoteColumnNames())</span>
		{
<span class="nc" id="L315">			result.append(shapeIdentifier(columnName, prefs, dialect));</span>
		}
		else
		{
<span class="nc" id="L319">			result.append(columnName);</span>
		}
<span class="nc" id="L321">		result.append(&quot; IS '&quot;);</span>
<span class="nc bnc" id="L322" title="All 4 branches missed.">		if (comment != null &amp;&amp; !&quot;&quot;.equals(comment))</span>
		{
<span class="nc" id="L324">			result.append(comment);</span>
		}
<span class="nc" id="L326">		result.append(&quot;'&quot;);</span>
<span class="nc" id="L327">		return result.toString();</span>
	}

	/**
	 * Returns the SQL statement to use to add a comment to the specified column of the specified table.
	 * 
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect representing the target database.
	 * @param tableName
	 *           the name of the table to create the SQL for.
	 * @param columnName
	 *           the name of the column to create the SQL for.
	 * @param comment
	 *           the comment to add.
	 * @return
	 * @throws UnsupportedOperationException
	 *            if the database doesn't support annotating columns with a comment.
	 */
	public static String getColumnCommentAlterSQL(TableColumnInfo info, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc bnc" id="L352" title="All 2 branches missed.">		if (info == null) { throw new IllegalArgumentException(&quot;parameter info cannot be null&quot;); }</span>
<span class="nc" id="L353">		return getColumnCommentAlterSQL(info.getTableName(), info.getColumnName(), info.getRemarks(),</span>
			qualifier, prefs, dialect);
	}

	/**
	 * @param tableName
	 * @param columnName
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect representing the target database.
	 * @return
	 */
	public static String getColumnDropSQL(String tableName, String columnName,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc" id="L371">		return getColumnDropSQL(tableName, columnName, &quot;DROP&quot;, false, null, qualifier, prefs, dialect);</span>
	}

	/**
	 * @param tableName
	 *           the unqualified table
	 * @param columnName
	 *           the name of the column
	 * @param addConstraintClause
	 *           whether or not to add a constraint clause
	 * @param constraintClause
	 *           the constraint clause to add
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return
	 */
	public static String getColumnDropSQL(String tableName, String columnName, String dropClause,
		boolean addConstraintClause, String constraintClause, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc" id="L393">		final StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L394">		result.append(&quot;ALTER TABLE &quot;);</span>
<span class="nc" id="L395">		result.append(shapeQualifiableIdentifier(tableName, qualifier, prefs, dialect));</span>
<span class="nc" id="L396">		result.append(&quot; &quot;);</span>
<span class="nc" id="L397">		result.append(dropClause);</span>
<span class="nc" id="L398">		result.append(&quot; &quot;);</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">		if (prefs.isQuoteColumnNames())</span>
		{
<span class="nc" id="L401">			result.append(shapeIdentifier(columnName, prefs, dialect));</span>
		}
		else
		{
<span class="nc" id="L405">			result.append(columnName);</span>
		}
<span class="nc bnc" id="L407" title="All 2 branches missed.">		if (addConstraintClause)</span>
		{
<span class="nc" id="L409">			result.append(&quot; &quot;);</span>
<span class="nc" id="L410">			result.append(constraintClause);</span>
		}
<span class="nc" id="L412">		return result.toString();</span>
	}

	/**
	 * Returns the SQL that forms the command to drop the specified table. If cascade contraints is supported
	 * by the dialect and cascadeConstraints is true, then a drop statement with cascade constraints clause
	 * will be formed.
	 * 
	 * @param iTableInfo
	 *           the table to drop
	 * @param supportsCascade
	 *           whether or not the cascade clause should be added.
	 * @param cascadeValue
	 *           whether or not to drop any FKs that may reference the specified table.
	 * @param supportsMatViews
	 *           whether or not the dialect supports materialized views
	 * @param cascadeClause
	 *           what cascade clause to append.
	 * @param isMatView
	 *           true if the tableInfo represents a materialized view.
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect representing the target database.
	 * @return the drop SQL command.
	 */
	public static List&lt;String&gt; getTableDropSQL(ITableInfo iTableInfo, boolean supportsCascade,
		boolean cascadeValue, boolean supportsMatViews, String cascadeClause, boolean isMatView,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc" id="L444">		final StringBuilder result = new StringBuilder();</span>
<span class="nc bnc" id="L445" title="All 4 branches missed.">		if (supportsMatViews &amp;&amp; isMatView)</span>
		{
<span class="nc" id="L447">			result.append(&quot;DROP MATERIALIZED VIEW &quot;);</span>
		}
		else
		{
<span class="nc" id="L451">			result.append(&quot;DROP TABLE &quot;);</span>
		}
<span class="nc" id="L453">		result.append(shapeQualifiableIdentifier(iTableInfo.getSimpleName(), qualifier, prefs, dialect));</span>
<span class="nc bnc" id="L454" title="All 4 branches missed.">		if (supportsCascade &amp;&amp; cascadeValue)</span>
		{
<span class="nc" id="L456">			result.append(&quot; &quot;);</span>
<span class="nc" id="L457">			result.append(cascadeClause);</span>
		}
<span class="nc" id="L459">		return Arrays.asList(new String[] { result.toString() });</span>
	}

	/**
	 * @param info
	 * @param dialect
	 * @return
	 */
	public static String getTypeName(TableColumnInfo info, HibernateDialect dialect)
	{
<span class="nc" id="L469">		return dialect.getTypeName(info.getDataType(), info.getColumnSize(), info.getColumnSize(),</span>
<span class="nc" id="L470">			info.getDecimalDigits());</span>
	}

	/**
	 * Returns the SQL used to alter the specified column to allow/disallow null values. &lt;br&gt;
	 * ALTER TABLE table_name &amp;lt;alterClause&amp;gt; column_name TYPE NULL | NOT NULL &lt;br&gt;
	 * ALTER TABLE table_name &amp;lt;alterClause&amp;gt; column_name NULL | NOT NULL
	 * 
	 * @param info
	 *           the column to modify
	 * @param dialect
	 *           the HibernateDialect representing the target database.
	 * @param alterClause
	 *           the alter column clause (e.g. ALTER COLUMN )
	 * @param specifyType
	 *           whether or not the column type needs to be specified
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return the SQL to execute
	 */
	public static String getColumnNullableAlterSQL(TableColumnInfo info, HibernateDialect dialect,
		String alterClause, boolean specifyType, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs)
	{
<span class="nc" id="L496">		final boolean nullable = info.isNullable().equalsIgnoreCase(&quot;YES&quot;);</span>
<span class="nc" id="L497">		return getColumnNullableAlterSQL(info, nullable, dialect, alterClause, specifyType, qualifier, prefs);</span>
	}

	/**
	 * Returns the SQL used to alter the specified column to allow/disallow null values. &lt;br&gt;
	 * ALTER TABLE table_name &amp;lt;alterClause&amp;gt; column_name TYPE NULL | NOT NULL &lt;br&gt;
	 * ALTER TABLE table_name &amp;lt;alterClause&amp;gt; column_name NULL | NOT NULL
	 * 
	 * @param info
	 *           the column to modify
	 * @param nullable
	 *           whether or not the column should allow nulls
	 * @param dialect
	 *           the HibernateDialect representing the target database.
	 * @param alterClause
	 *           the alter column clause (e.g. ALTER COLUMN )
	 * @param specifyType
	 *           whether or not the column type needs to be specified
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return the SQL to execute
	 */
	public static String getColumnNullableAlterSQL(TableColumnInfo info, boolean nullable,
		HibernateDialect dialect, String alterClause, boolean specifyType, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs)
	{
<span class="nc" id="L525">		final StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L526">		result.append(&quot;ALTER TABLE &quot;);</span>
<span class="nc" id="L527">		result.append(shapeQualifiableIdentifier(info.getTableName(), qualifier, prefs, dialect));</span>
<span class="nc" id="L528">		result.append(&quot; &quot;);</span>
<span class="nc" id="L529">		result.append(alterClause);</span>
<span class="nc" id="L530">		result.append(&quot; &quot;);</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">		if (prefs.isQuoteColumnNames())</span>
		{
<span class="nc" id="L533">			result.append(shapeIdentifier(info.getColumnName(), prefs, dialect));</span>
		}
		else
		{
<span class="nc" id="L537">			result.append(info.getColumnName());</span>
		}
<span class="nc bnc" id="L539" title="All 2 branches missed.">		if (specifyType)</span>
		{
<span class="nc" id="L541">			result.append(&quot; &quot;);</span>
<span class="nc" id="L542">			result.append(getTypeName(info, dialect));</span>
<span class="nc" id="L543">			result.append(&quot; &quot;);</span>
		}
<span class="nc bnc" id="L545" title="All 2 branches missed.">		if (nullable)</span>
		{
<span class="nc" id="L547">			result.append(&quot; NULL&quot;);</span>
		}
		else
		{
<span class="nc" id="L551">			result.append(&quot; NOT NULL&quot;);</span>
		}
<span class="nc" id="L553">		return result.toString();</span>
	}

	/**
	 * Populates the specified ArrayList with SQL statement(s) required to convert each of the columns to not
	 * null. This is typically needed in some databases when adding a primary key (some dbs do this step
	 * automatically)
	 * 
	 * @param colInfos
	 *           the columns to be made not null
	 * @param dialect
	 * @param result
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 */
	public static void getMultiColNotNullSQL(TableColumnInfo[] colInfos, HibernateDialect dialect,
		String alterClause, boolean specifyType, ArrayList&lt;String&gt; result, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs)
	{
<span class="nc bnc" id="L574" title="All 2 branches missed.">		for (final TableColumnInfo colInfo : colInfos)</span>
		{
<span class="nc" id="L576">			final StringBuilder notNullSQL = new StringBuilder();</span>
<span class="nc" id="L577">			notNullSQL.append(&quot;ALTER TABLE &quot;);</span>
<span class="nc" id="L578">			notNullSQL.append(shapeQualifiableIdentifier(colInfo.getTableName(), qualifier, prefs, dialect));</span>
<span class="nc" id="L579">			notNullSQL.append(&quot; &quot;);</span>
<span class="nc" id="L580">			notNullSQL.append(alterClause);</span>
<span class="nc" id="L581">			notNullSQL.append(&quot; &quot;);</span>
<span class="nc" id="L582">			notNullSQL.append(shapeIdentifier(colInfo.getColumnName(), prefs, dialect));</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">			if (specifyType)</span>
			{
<span class="nc" id="L585">				notNullSQL.append(&quot; &quot;);</span>
<span class="nc" id="L586">				notNullSQL.append(DialectUtils.getTypeName(colInfo, dialect));</span>
			}
<span class="nc" id="L588">			notNullSQL.append(&quot; NOT NULL&quot;);</span>
<span class="nc" id="L589">			result.add(notNullSQL.toString());</span>
		}
<span class="nc" id="L591">	}</span>

	/**
	 * Returns the SQL for creating a primary key consisting of the specified colInfos. ALTER TABLE table_name
	 * ADD CONSTRAINT pkName PRIMARY KEY (col,...); or ALTER TABLE table_name ADD CONSTRAINT PRIMARY KEY
	 * (col,...) CONSTRAINT pkName;
	 * 
	 * @param ti
	 *           the ITableInfo representing the table to add a primary key to
	 * @param colInfos
	 *           the TableColumnInfos representing all of the columns that represent a primary key
	 * @param appendConstraintName
	 *           whether or not the pkName (constraint name) should be placed at the end of the statement.
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return
	 */
	public static String getAddPrimaryKeySQL(ITableInfo ti, String pkName, TableColumnInfo[] colInfos,
		boolean appendConstraintName, DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs,
		HibernateDialect dialect)
	{
<span class="nc" id="L614">		final StringBuilder pkSQL = new StringBuilder();</span>

<span class="nc" id="L616">		String shapedPkName = pkName;</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">		if (prefs.isQuoteConstraintNames())</span>
		{
<span class="nc" id="L619">			shapedPkName = shapeIdentifier(pkName, prefs, dialect);</span>
		}

<span class="nc" id="L622">		pkSQL.append(&quot;ALTER TABLE &quot;);</span>
<span class="nc" id="L623">		pkSQL.append(shapeQualifiableIdentifier(ti.getSimpleName(), qualifier, prefs, dialect));</span>
<span class="nc" id="L624">		pkSQL.append(&quot; ADD CONSTRAINT &quot;);</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">		if (!appendConstraintName)</span>
		{
<span class="nc" id="L627">			pkSQL.append(shapedPkName);</span>
		}
<span class="nc" id="L629">		pkSQL.append(&quot; PRIMARY KEY &quot;);</span>
<span class="nc" id="L630">		pkSQL.append(getColumnList(colInfos, qualifier, prefs, dialect));</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">		if (appendConstraintName)</span>
		{
<span class="nc" id="L633">			pkSQL.append(&quot; CONSTRAINT &quot;);</span>
<span class="nc" id="L634">			pkSQL.append(shapedPkName);</span>
		}
<span class="nc" id="L636">		return pkSQL.toString();</span>
	}

	/**
	 * @param fkST
	 * @param fkValuesMap
	 * @param childIndexST
	 * @param ckIndexValuesMap
	 * @param localRefColumns
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return
	 */
	public static String[] getAddForeignKeyConstraintSQL(StringTemplate fkST,
		HashMap&lt;String, String&gt; fkValuesMap, StringTemplate childIndexST,
		HashMap&lt;String, String&gt; ckIndexValuesMap, Collection&lt;String[]&gt; localRefColumns,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{

<span class="nc" id="L657">		final ArrayList&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>

<span class="nc" id="L659">		bindAttributes(dialect, fkST, fkValuesMap, qualifier, prefs);</span>

<span class="nc" id="L661">		final String[] childColumnNames = new String[localRefColumns.size()];</span>
<span class="nc" id="L662">		int i = 0;</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">		for (final String[] localRefColumn : localRefColumns)</span>
		{
<span class="nc" id="L665">			final String childColumnName = localRefColumn[0];</span>
<span class="nc" id="L666">			childColumnNames[i++] = childColumnName;</span>
<span class="nc" id="L667">			final String parentColumnName = localRefColumn[1];</span>
<span class="nc" id="L668">			bindAttribute(dialect, fkST, ST_CHILD_COLUMN_KEY, childColumnName, qualifier, prefs);</span>
<span class="nc" id="L669">			bindAttribute(dialect, fkST, ST_PARENT_COLUMN_KEY, parentColumnName, qualifier, prefs);</span>
<span class="nc" id="L670">		}</span>

<span class="nc" id="L672">		result.add(fkST.toString());</span>

		// Additional Index Creation
<span class="nc bnc" id="L675" title="All 2 branches missed.">		if (childIndexST != null)</span>
		{
<span class="nc" id="L677">			result.add(getAddIndexSQL(dialect, childIndexST, ckIndexValuesMap, childColumnNames, qualifier,</span>
				prefs));
		}

<span class="nc" id="L681">		return result.toArray(new String[result.size()]);</span>
	}

	/**
	 * Gets the SQL command to add a foreign key constraint to a table.
	 * 
	 * @param localTableName
	 *           name of the table where the foreign key should be stored.
	 * @param refTableName
	 *           name of the table where the foreign key should reference to.
	 * @param constraintName
	 *           name of the constraint. Leave it empty and it won't create a CONSTRAINT name.
	 * @param deferrable
	 *           true if the constraint is deferrable, false if not. Can be null for dialects that don't
	 *           support this
	 * @param initiallyDeferred
	 *           true if the constraint is deferrable and initially deferred, false if not. Can be null for
	 *           dialects that don't support this
	 * @param matchFull
	 *           true if the referenced columns using MATCH FULL. Can be null for dialects that don't support
	 *           this
	 * @param autoFKIndex
	 *           true to create an additional INDEX with the given fkIndexName Name.
	 * @param fkIndexName
	 *           name of the foreign key index name.
	 * @param localRefColumns
	 *           local and referenced column collection. In the first Element of the String Array should be the
	 *           local column name and in the second Element the referenced Table column name.
	 * @param onUpdateAction
	 *           update action. For example &quot;RESTRICT&quot;.
	 * @param onDeleteAction
	 *           delete action. For exampel &quot;NO ACTION&quot;.
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return the sql command to add a foreign key constraint.
	 */
	public static String[] getAddForeignKeyConstraintSQL(String localTableName, String refTableName,
		String constraintName, Boolean deferrable, Boolean initiallyDeferred, Boolean matchFull,
		boolean autoFKIndex, String fkIndexName, Collection&lt;String[]&gt; localRefColumns, String onUpdateAction,
		String onDeleteAction, DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs,
		HibernateDialect dialect)
	{
<span class="nc" id="L725">		final ArrayList&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>

		// ALTER TABLE localTableName
		// ADD CONSTRAINT constraintName FOREIGN KEY (localColumn1,
		// localColumn2)
		// REFERENCES referencedTableName (referencedColumn1, referencedColumn2)
		// MATCH FULL ON UPDATE RESTRICT ON DELETE NO ACTION DEFERRABLE
		// INITIALLY DEFERRED;
<span class="nc" id="L733">		final StringBuilder sql = new StringBuilder();</span>

<span class="nc" id="L735">		sql.append(DialectUtils.ALTER_TABLE_CLAUSE + &quot; &quot;);</span>
<span class="nc" id="L736">		sql.append(shapeQualifiableIdentifier(localTableName, qualifier, prefs, dialect));</span>
<span class="nc" id="L737">		sql.append(&quot;\n&quot;);</span>

<span class="nc bnc" id="L739" title="All 4 branches missed.">		if (constraintName != null &amp;&amp; !constraintName.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L741">			sql.append(&quot; &quot;);</span>
<span class="nc" id="L742">			sql.append(DialectUtils.ADD_CONSTRAINT_CLAUSE);</span>
<span class="nc" id="L743">			sql.append(&quot; &quot;);</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">			if (prefs.isQuoteConstraintNames())</span>
			{
<span class="nc" id="L746">				sql.append(shapeIdentifier(constraintName, prefs, dialect));</span>
			}
			else
			{
<span class="nc" id="L750">				sql.append(constraintName);</span>
			}
<span class="nc" id="L752">			sql.append(&quot;\n&quot;);</span>
		}

<span class="nc" id="L755">		sql.append(&quot; &quot;);</span>
<span class="nc" id="L756">		sql.append(DialectUtils.FOREIGN_KEY_CLAUSE);</span>
<span class="nc" id="L757">		sql.append(&quot; (&quot;);</span>

<span class="nc" id="L759">		final ArrayList&lt;String&gt; localColumns = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L760">		final StringBuilder refColumns = new StringBuilder();</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">		for (final String[] columns : localRefColumns)</span>
		{
<span class="nc bnc" id="L763" title="All 2 branches missed.">			if (prefs.isQuoteColumnNames())</span>
			{
<span class="nc" id="L765">				sql.append(shapeIdentifier(columns[0], prefs, dialect));</span>
			}
			else
			{
<span class="nc" id="L769">				sql.append(columns[0]);</span>
			}
<span class="nc" id="L771">			sql.append(&quot;, &quot;);</span>
<span class="nc" id="L772">			localColumns.add(columns[0]);</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">			if (prefs.isQuoteColumnNames())</span>
			{
<span class="nc" id="L775">				refColumns.append(shapeIdentifier(columns[1], prefs, dialect));</span>
			}
			else
			{
<span class="nc" id="L779">				refColumns.append(columns[1]);</span>
			}
<span class="nc" id="L781">			refColumns.append(&quot;, &quot;);</span>
<span class="nc" id="L782">		}</span>
<span class="nc" id="L783">		sql.setLength(sql.length() - 2); // deletes the last &quot;, &quot;</span>
<span class="nc" id="L784">		refColumns.setLength(refColumns.length() - 2); // deletes the last &quot;, &quot;</span>

<span class="nc" id="L786">		sql.append(&quot;)\n REFERENCES &quot;);</span>
<span class="nc" id="L787">		sql.append(shapeQualifiableIdentifier(refTableName, qualifier, prefs, dialect));</span>
<span class="nc" id="L788">		sql.append(&quot; (&quot;);</span>
<span class="nc" id="L789">		sql.append(refColumns.toString());</span>
<span class="nc" id="L790">		sql.append(&quot;)\n&quot;);</span>

		// Options
<span class="nc bnc" id="L793" title="All 4 branches missed.">		if (matchFull != null &amp;&amp; matchFull)</span>
		{
<span class="nc" id="L795">			sql.append(&quot; MATCH FULL&quot;);</span>
		}

<span class="nc bnc" id="L798" title="All 4 branches missed.">		if (onUpdateAction != null &amp;&amp; !onUpdateAction.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L800">			sql.append(&quot; ON UPDATE &quot;);</span>
<span class="nc" id="L801">			sql.append(onUpdateAction);</span>
		}

<span class="nc bnc" id="L804" title="All 4 branches missed.">		if (onDeleteAction != null &amp;&amp; !onDeleteAction.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L806">			sql.append(&quot; ON DELETE &quot;);</span>
<span class="nc" id="L807">			sql.append(onDeleteAction);</span>
		}

<span class="nc bnc" id="L810" title="All 4 branches missed.">		if (deferrable != null &amp;&amp; deferrable)</span>
		{
<span class="nc" id="L812">			sql.append(&quot; DEFERRABLE&quot;);</span>
		}
<span class="nc bnc" id="L814" title="All 4 branches missed.">		if (initiallyDeferred != null &amp;&amp; initiallyDeferred)</span>
		{
<span class="nc" id="L816">			sql.append(&quot; INITIALLY DEFERRED&quot;);</span>
		}

<span class="nc" id="L819">		result.add(sql.toString());</span>

		// Additional Index Creation
<span class="nc bnc" id="L822" title="All 4 branches missed.">		if (autoFKIndex &amp;&amp; !fkIndexName.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L824">			result.add(getAddIndexSQL(dialect, fkIndexName, localTableName, null,</span>
<span class="nc" id="L825">				localColumns.toArray(new String[localColumns.size()]), false, null, null, qualifier, prefs));</span>
		}

<span class="nc" id="L828">		return result.toArray(new String[result.size()]);</span>
	}

	/**
	 * Gets the SQL command to add a unique constraint to a table.
	 * 
	 * @param tableName
	 *           name of the table where the unique constraint should be added to.
	 * @param constraintName
	 *           name of the constraint.
	 * @param columns
	 *           the unique columns.
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return the sql command to add a unique constraint.
	 */
	public static String getAddUniqueConstraintSQL(String tableName, String constraintName,
		TableColumnInfo[] columns, DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs,
		HibernateDialect dialect)
	{
		// ALTER TABLE tableName
		// ADD CONSTRAINT constraintName UNIQUE (column1, column2);
<span class="nc" id="L852">		final StringBuilder sql = new StringBuilder();</span>

<span class="nc" id="L854">		sql.append(DialectUtils.ALTER_TABLE_CLAUSE);</span>
<span class="nc" id="L855">		sql.append(&quot; &quot;);</span>
<span class="nc" id="L856">		sql.append(DialectUtils.shapeQualifiableIdentifier(tableName, qualifier, prefs, dialect));</span>
<span class="nc" id="L857">		sql.append(&quot;\n&quot;);</span>

<span class="nc" id="L859">		sql.append(&quot; &quot;);</span>
<span class="nc" id="L860">		sql.append(DialectUtils.ADD_CONSTRAINT_CLAUSE);</span>
<span class="nc" id="L861">		sql.append(&quot; &quot;);</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">		if (prefs.isQuoteConstraintNames())</span>
		{
<span class="nc" id="L864">			sql.append(DialectUtils.shapeIdentifier(constraintName, prefs, dialect));</span>
		}
		else
		{
<span class="nc" id="L868">			sql.append(constraintName);</span>
		}

<span class="nc" id="L871">		sql.append(&quot; &quot;);</span>
<span class="nc" id="L872">		sql.append(DialectUtils.UNIQUE_CLAUSE);</span>
<span class="nc" id="L873">		sql.append(&quot; (&quot;);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">		for (final TableColumnInfo column : columns)</span>
		{
<span class="nc bnc" id="L876" title="All 2 branches missed.">			if (prefs.isQuoteColumnNames())</span>
			{
<span class="nc" id="L878">				sql.append(DialectUtils.shapeIdentifier(column.getColumnName(), prefs, dialect));</span>
			}
			else
			{
<span class="nc" id="L882">				sql.append(column.getColumnName());</span>
			}
<span class="nc" id="L884">			sql.append(&quot;, &quot;);</span>
		}
<span class="nc" id="L886">		sql.delete(sql.length() - 2, sql.length()); // deletes the last &quot;, &quot;</span>
<span class="nc" id="L887">		sql.append(&quot;)&quot;);</span>

<span class="nc" id="L889">		return sql.toString();</span>
	}

	/**
	 * @param st
	 * @param valuesMap
	 * @param columns
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return
	 */
	public static String getAddUniqueConstraintSQL(StringTemplate st, HashMap&lt;String, String&gt; valuesMap,
		TableColumnInfo[] columns, DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs,
		HibernateDialect dialect)
	{
<span class="nc" id="L906">		bindAttributes(dialect, st, valuesMap, qualifier, prefs);</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">		for (final TableColumnInfo column : columns)</span>
		{
<span class="nc" id="L909">			bindAttribute(dialect, st, ST_COLUMN_NAME_KEY, column.getColumnName(), qualifier, prefs);</span>
		}
<span class="nc" id="L911">		return st.toString();</span>
	}

	/**
	 * Returns: (column1, column2, ...)
	 * 
	 * @param colInfos
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect representing the target database.
	 * @return
	 */
	private static String getColumnList(TableColumnInfo[] colInfos, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc" id="L929">		final StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L930">		result.append(&quot;(&quot;);</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">		for (int i = 0; i &lt; colInfos.length; i++)</span>
		{
<span class="nc" id="L933">			String shapedColumnName = colInfos[i].getColumnName();</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">			if (prefs.isQuoteColumnNames())</span>
			{
<span class="nc" id="L936">				shapedColumnName = shapeIdentifier(colInfos[i].getColumnName(), prefs, dialect);</span>
			}
<span class="nc" id="L938">			result.append(shapedColumnName);</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">			if (i + 1 &lt; colInfos.length)</span>
			{
<span class="nc" id="L941">				result.append(&quot;, &quot;);</span>
			}
		}
<span class="nc" id="L944">		result.append(&quot;)&quot;);</span>
<span class="nc" id="L945">		return result.toString();</span>
	}

	/**
	 * Returns the SQL that is used to change the column name. &lt;code&gt;
	 * For example:
	 * 
	 * ALTER TABLE table_name [alterClause] column_name [renameToClause] column_name
	 * &lt;/code&gt;
	 * 
	 * @param from
	 *           the TableColumnInfo as it is
	 * @param to
	 *           the TableColumnInfo as it wants to be
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect representing the target database.
	 * @return the SQL to make the change
	 */
	public static String getColumnNameAlterSQL(TableColumnInfo from, TableColumnInfo to, String alterClause,
		String renameToClause, DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs,
		HibernateDialect dialect)
	{
<span class="nc" id="L971">		final String shapedTable = shapeQualifiableIdentifier(from.getTableName(), qualifier, prefs, dialect);</span>
<span class="nc" id="L972">		String shapedFromColumn = from.getColumnName();</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">		if (prefs.isQuoteColumnNames())</span>
		{
<span class="nc" id="L975">			shapedFromColumn = shapeIdentifier(from.getColumnName(), prefs, dialect);</span>
		}
<span class="nc" id="L977">		String shapedToColumn = to.getColumnName();</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">		if (prefs.isQuoteColumnNames())</span>
		{
<span class="nc" id="L980">			shapedToColumn = shapeIdentifier(to.getColumnName(), prefs, dialect);</span>
		}

<span class="nc" id="L983">		final StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L984">		result.append(&quot;ALTER TABLE &quot;);</span>
<span class="nc" id="L985">		result.append(shapedTable);</span>
<span class="nc" id="L986">		result.append(&quot; &quot;);</span>
<span class="nc" id="L987">		result.append(alterClause);</span>
<span class="nc" id="L988">		result.append(&quot; &quot;);</span>
<span class="nc" id="L989">		result.append(shapedFromColumn);</span>
<span class="nc" id="L990">		result.append(&quot; &quot;);</span>
<span class="nc" id="L991">		result.append(renameToClause);</span>
<span class="nc" id="L992">		result.append(&quot; &quot;);</span>
<span class="nc" id="L993">		result.append(shapedToColumn);</span>
<span class="nc" id="L994">		return result.toString();</span>
	}

	/**
	 * Returns the SQL command to change the specified column's default value. &lt;code&gt;
	 * For example: 
	 * 
	 * ALTER TABLE table_name ALTER COLUMN column_name [defaultClause] 'defaultVal'
	 *  
	 * or
	 *  
	 * ALTER TABLE table_name ALTER COLUMN column_name [defaultClause] 1234
	 * &lt;/code&gt;
	 * 
	 * @param dialect
	 *           the HibernateDialect representing the target database.
	 * @param info
	 *           the column to modify and it's default value.
	 * @param alterClause
	 *           alter phrase that precedes the column name (e.g. ALTER COLUMN)
	 * @param specifyType
	 *           whether or not to specify the column type
	 * @param defaultClause
	 *           alter phrase that precedes the default value (e.g. SET DEFAULT)
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return SQL to make the change
	 */
	public static String getColumnDefaultAlterSQL(HibernateDialect dialect, TableColumnInfo info,
		String alterClause, boolean specifyType, String defaultClause, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs)
	{

<span class="nc" id="L1029">		final StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L1030">		result.append(&quot;ALTER TABLE &quot;);</span>
<span class="nc" id="L1031">		result.append(shapeQualifiableIdentifier(info.getTableName(), qualifier, prefs, dialect));</span>
<span class="nc" id="L1032">		result.append(&quot; &quot;);</span>
<span class="nc" id="L1033">		result.append(alterClause);</span>
<span class="nc" id="L1034">		result.append(&quot; &quot;);</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">		if (prefs.isQuoteColumnNames())</span>
		{
<span class="nc" id="L1037">			result.append(shapeIdentifier(info.getColumnName(), prefs, dialect));</span>
		}
		else
		{
<span class="nc" id="L1041">			result.append(info.getColumnName());</span>
		}
<span class="nc" id="L1043">		result.append(&quot; &quot;);</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">		if (specifyType)</span>
		{
<span class="nc" id="L1046">			result.append(getTypeName(info, dialect));</span>
		}
<span class="nc" id="L1048">		result.append(&quot; &quot;);</span>
<span class="nc" id="L1049">		result.append(defaultClause);</span>
<span class="nc" id="L1050">		result.append(&quot; &quot;);</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">		if (JDBCTypeMapper.isNumberType(info.getDataType()))</span>
		{
<span class="nc" id="L1053">			result.append(info.getDefaultValue());</span>
		}
		else
		{
<span class="nc" id="L1057">			result.append(&quot;'&quot;);</span>
<span class="nc" id="L1058">			result.append(info.getDefaultValue());</span>
<span class="nc" id="L1059">			result.append(&quot;'&quot;);</span>
		}
<span class="nc" id="L1061">		return result.toString();</span>
	}

	/**
	 * Returns the SQL that is used to change the column type. For example: &lt;code&gt;
	 * ALTER TABLE table_name alter_clause column_name [setClause] data_type 
	 * &lt;/code&gt; or &lt;code&gt;
	 * ALTER TABLE table_name alter_clause column_name column_name [setClause] data_type
	 * &lt;/code&gt;
	 * 
	 * @param from
	 *           the TableColumnInfo as it is
	 * @param to
	 *           the TableColumnInfo as it wants to be
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return the SQL to make the change
	 * @throw UnsupportedOperationException if the database doesn't support modifying column types.
	 */
	public static List&lt;String&gt; getColumnTypeAlterSQL(HibernateDialect dialect, String alterClause,
		String setClause, boolean repeatColumn, TableColumnInfo from, TableColumnInfo to,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs) throws UnsupportedOperationException
	{
<span class="nc" id="L1086">		final String shapedTable = shapeQualifiableIdentifier(to.getTableName(), qualifier, prefs, dialect);</span>

<span class="nc" id="L1088">		String shapedToColumn = to.getColumnName();</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">		if (prefs.isQuoteColumnNames())</span>
		{
<span class="nc" id="L1091">			shapedToColumn = shapeIdentifier(to.getColumnName(), prefs, dialect);</span>
		}

<span class="nc" id="L1094">		final ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1095">		final StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L1096">		result.append(&quot;ALTER TABLE &quot;);</span>
<span class="nc" id="L1097">		result.append(shapedTable);</span>
<span class="nc" id="L1098">		result.append(&quot; &quot;);</span>
<span class="nc" id="L1099">		result.append(alterClause);</span>
<span class="nc" id="L1100">		result.append(&quot; &quot;);</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">		if (repeatColumn)</span>
		{
<span class="nc" id="L1103">			result.append(shapedToColumn);</span>
<span class="nc" id="L1104">			result.append(&quot; &quot;);</span>
		}
<span class="nc" id="L1106">		result.append(shapedToColumn);</span>
<span class="nc" id="L1107">		result.append(&quot; &quot;);</span>
<span class="nc bnc" id="L1108" title="All 4 branches missed.">		if (setClause != null &amp;&amp; !&quot;&quot;.equals(setClause))</span>
		{
<span class="nc" id="L1110">			result.append(setClause);</span>
<span class="nc" id="L1111">			result.append(&quot; &quot;);</span>
		}
<span class="nc" id="L1113">		result.append(getTypeName(to, dialect));</span>
<span class="nc" id="L1114">		list.add(result.toString());</span>
<span class="nc" id="L1115">		return list;</span>
	}

	/**
	 * Returns the SQL that is used to change the column name. For example: &lt;code&gt;
	 * RENAME COLUMN table_name.column_name TO new_column_name
	 * &lt;/code&gt;
	 * 
	 * @param from
	 *           the TableColumnInfo as it is
	 * @param to
	 *           the TableColumnInfo as it wants to be
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect representing the target database.
	 * @return the SQL to make the change
	 */
	public static String getColumnRenameSQL(TableColumnInfo from, TableColumnInfo to,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc" id="L1138">		final StringBuilder result = new StringBuilder();</span>

<span class="nc" id="L1140">		final String shapedTable = shapeQualifiableIdentifier(from.getTableName(), qualifier, prefs, dialect);</span>
<span class="nc" id="L1141">		String shapedFromColumn = from.getColumnName();</span>
<span class="nc bnc" id="L1142" title="All 2 branches missed.">		if (prefs.isQuoteColumnNames())</span>
		{
<span class="nc" id="L1144">			shapedFromColumn = shapeIdentifier(from.getColumnName(), prefs, dialect);</span>
		}
<span class="nc" id="L1146">		String shapedToColumn = to.getColumnName();</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">		if (prefs.isQuoteColumnNames())</span>
		{
<span class="nc" id="L1149">			shapedToColumn = shapeIdentifier(to.getColumnName(), prefs, dialect);</span>
		}

<span class="nc" id="L1152">		result.append(&quot;RENAME COLUMN &quot;);</span>
<span class="nc" id="L1153">		result.append(shapedTable);</span>
<span class="nc" id="L1154">		result.append(&quot;.&quot;);</span>
<span class="nc" id="L1155">		result.append(shapedFromColumn);</span>
<span class="nc" id="L1156">		result.append(&quot; TO &quot;);</span>
<span class="nc" id="L1157">		result.append(shapedToColumn);</span>
<span class="nc" id="L1158">		return result.toString();</span>
	}

	/**
	 * @param dialect
	 *           the HibernateDialect representing the target database.
	 * @param featureId
	 * @return
	 * @throws UnsupportedOperationException
	 */
	public static String getUnsupportedMessage(HibernateDialect dialect, int featureId)
		throws UnsupportedOperationException
	{
<span class="nc" id="L1171">		String msg = null;</span>
<span class="nc bnc" id="L1172" title="All 28 branches missed.">		switch (featureId)</span>
		{
		case COLUMN_COMMENT_ALTER_TYPE:
			// i18n[DialectUtils.columnCommentUnsupported={0} doesn''t support
			// column comments]
<span class="nc" id="L1177">			msg = s_stringMgr.getString(&quot;DialectUtils.columnCommentUnsupported&quot;, dialect.getDisplayName());</span>
<span class="nc" id="L1178">			break;</span>
		case COLUMN_DEFAULT_ALTER_TYPE:
			// i18n[DialectUtils.columnDefaultUnsupported={0} doesn''t support
			// altering a column''s default
			// value]
<span class="nc" id="L1183">			msg = s_stringMgr.getString(&quot;DialectUtils.columnDefaultUnsupported&quot;, dialect.getDisplayName());</span>
<span class="nc" id="L1184">			break;</span>

		case COLUMN_DROP_TYPE:
			// i18n[DialectUtils.columnDropUnsupported={0} doesn''t support
			// dropping a column]
<span class="nc" id="L1189">			msg = s_stringMgr.getString(&quot;DialectUtils.columnDropUnsupported&quot;, dialect.getDisplayName());</span>
<span class="nc" id="L1190">			break;</span>
		case COLUMN_NAME_ALTER_TYPE:
			// i18n[DialectUtils.columnNameUnsupported={0} doesn''t support
			// altering a column''s name]
<span class="nc" id="L1194">			msg = s_stringMgr.getString(&quot;DialectUtils.columnNameUnsupported&quot;, dialect.getDisplayName());</span>
<span class="nc" id="L1195">			break;</span>
		case COLUMN_NULL_ALTER_TYPE:
			// i18n[DialectUtils.columnNullUnsupported={0} doesn''t support
			// altering a column's nullable
			// attribute]
<span class="nc" id="L1200">			msg = s_stringMgr.getString(&quot;DialectUtils.columnNullUnsupported&quot;, dialect.getDisplayName());</span>
<span class="nc" id="L1201">			break;</span>
		case COLUMN_TYPE_ALTER_TYPE:
			// i18n[DialectUtils.columnTypeUnsupported={0} doesn''t support
			// altering a column's type attribute]
<span class="nc" id="L1205">			msg = s_stringMgr.getString(&quot;DialectUtils.columnTypeUnsupported&quot;, dialect.getDisplayName());</span>
<span class="nc" id="L1206">			break;</span>
		case ADD_PRIMARY_KEY_TYPE:
			// i18n[DialectUtils.addPrimaryKeyUnsupported={0} doesn''t support
			// adding primary keys]
<span class="nc" id="L1210">			msg = s_stringMgr.getString(&quot;DialectUtils.addPrimaryKeyUnsupported&quot;, dialect.getDisplayName());</span>
<span class="nc" id="L1211">			break;</span>
		case DROP_PRIMARY_KEY_TYPE:
			// i18n[DialectUtils.dropPrimaryKeyUnsupported={0} doesn''t support
			// dropping primary keys]
<span class="nc" id="L1215">			msg = s_stringMgr.getString(&quot;DialectUtils.dropPrimaryKeyUnsupported&quot;, dialect.getDisplayName());</span>
<span class="nc" id="L1216">			break;</span>
		case CREATE_TABLE_TYPE:
<span class="nc" id="L1218">			return s_stringMgr.getString(&quot;DialectUtils.createTableUnsupported&quot;, dialect.getDisplayName());</span>
		case RENAME_TABLE_TYPE:
<span class="nc" id="L1220">			return s_stringMgr.getString(&quot;DialectUtils.renameTableUnsupported&quot;, dialect.getDisplayName());</span>
		case CREATE_VIEW_TYPE:
<span class="nc" id="L1222">			return s_stringMgr.getString(&quot;DialectUtils.createViewUnsupported&quot;, dialect.getDisplayName());</span>
		case RENAME_VIEW_TYPE:
<span class="nc" id="L1224">			return s_stringMgr.getString(&quot;DialectUtils.renameViewUnsupported&quot;, dialect.getDisplayName());</span>
		case DROP_VIEW_TYPE:
<span class="nc" id="L1226">			return s_stringMgr.getString(&quot;DialectUtils.dropViewUnsupported&quot;, dialect.getDisplayName());</span>
		case CREATE_INDEX_TYPE:
<span class="nc" id="L1228">			return s_stringMgr.getString(&quot;DialectUtils.createIndexUnsupported&quot;, dialect.getDisplayName());</span>
		case DROP_INDEX_TYPE:
<span class="nc" id="L1230">			return s_stringMgr.getString(&quot;DialectUtils.dropIndexUnsupported&quot;, dialect.getDisplayName());</span>
		case CREATE_SEQUENCE_TYPE:
<span class="nc" id="L1232">			return s_stringMgr.getString(&quot;DialectUtils.createSequenceUnsupported&quot;, dialect.getDisplayName());</span>
		case ALTER_SEQUENCE_TYPE:
<span class="nc" id="L1234">			return s_stringMgr.getString(&quot;DialectUtils.alterSequenceUnsupported&quot;, dialect.getDisplayName());</span>
		case SEQUENCE_INFORMATION_TYPE:
<span class="nc" id="L1236">			return s_stringMgr.getString(&quot;DialectUtils.sequenceInformationUnsupported&quot;, dialect.getDisplayName());</span>
		case DROP_SEQUENCE_TYPE:
<span class="nc" id="L1238">			return s_stringMgr.getString(&quot;DialectUtils.dropSequenceUnsupported&quot;, dialect.getDisplayName());</span>
		case ADD_FOREIGN_KEY_TYPE:
<span class="nc" id="L1240">			return s_stringMgr.getString(&quot;DialectUtils.addForeignKeyUnsupported&quot;, dialect.getDisplayName());</span>
		case ADD_UNIQUE_TYPE:
<span class="nc" id="L1242">			return s_stringMgr.getString(&quot;DialectUtils.addUniqueUnsupported&quot;, dialect.getDisplayName());</span>
		case ADD_AUTO_INCREMENT_TYPE:
<span class="nc" id="L1244">			return s_stringMgr.getString(&quot;DialectUtils.addAutoIncrementUnsupported&quot;, dialect.getDisplayName());</span>
		case DROP_CONSTRAINT_TYPE:
<span class="nc" id="L1246">			return s_stringMgr.getString(&quot;DialectUtils.dropConstraintUnsupported&quot;, dialect.getDisplayName());</span>
		case INSERT_INTO_TYPE:
<span class="nc" id="L1248">			return s_stringMgr.getString(&quot;DialectUtils.insertIntoUnsupported&quot;, dialect.getDisplayName());</span>
		case UPDATE_TYPE:
<span class="nc" id="L1250">			return s_stringMgr.getString(&quot;DialectUtils.updateUnsupported&quot;, dialect.getDisplayName());</span>
		case VIEW_DEFINITION_TYPE:
<span class="nc" id="L1252">			return s_stringMgr.getString(&quot;DialectUtils.viewDefinitionUnsupported&quot;, dialect.getDisplayName());</span>
		case ADD_COLUMN_TYPE:
<span class="nc" id="L1254">			return s_stringMgr.getString(&quot;DialectUtils.addColumnUnsupported&quot;, dialect.getDisplayName());</span>

		default:
<span class="nc" id="L1257">			throw new IllegalArgumentException(&quot;Unknown featureId: &quot; + featureId);</span>
		}
<span class="nc" id="L1259">		return msg;</span>
	}

	/**
	 * Returns the SQL command to drop the specified table's primary key. For example: &lt;code&gt;
	 * alter table table_name drop primary key 
	 * &lt;/code&gt; or &lt;code&gt;
	 * alter table table_name drop constraint [pkName]
	 * &lt;/code&gt;
	 * 
	 * @param pkName
	 *           the name of the primary key that should be dropped
	 * @param tableName
	 *           the name of the table whose primary key should be dropped
	 * @param useConstraintName
	 *           if true, the constraint name is used - like 'DROP CONSTRAINT pkName'; otherwise a generic
	 *           'DROP PRIMARY KEY' is used instead.
	 * @param cascadeConstraints
	 *           whether or not to append 'CASCADE' to the end.
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect representing the target database.
	 * @return
	 */
	public static String getDropPrimaryKeySQL(String pkName, String tableName, boolean useConstraintName,
		boolean cascadeConstraints, DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs,
		HibernateDialect dialect)
	{
<span class="nc" id="L1290">		final StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L1291">		result.append(&quot;ALTER TABLE &quot;);</span>
<span class="nc" id="L1292">		result.append(shapeQualifiableIdentifier(tableName, qualifier, prefs, dialect));</span>
<span class="nc bnc" id="L1293" title="All 2 branches missed.">		if (useConstraintName)</span>
		{
<span class="nc" id="L1295">			result.append(&quot; DROP CONSTRAINT &quot;);</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">			if (prefs.isQuoteConstraintNames())</span>
			{
<span class="nc" id="L1298">				result.append(shapeIdentifier(pkName, prefs, dialect));</span>
			}
			else
			{
<span class="nc" id="L1302">				result.append(pkName);</span>
			}
		}
		else
		{
<span class="nc" id="L1307">			result.append(&quot; DROP PRIMARY KEY&quot;);</span>
		}
<span class="nc bnc" id="L1309" title="All 2 branches missed.">		if (cascadeConstraints)</span>
		{
<span class="nc" id="L1311">			result.append(&quot; CASCADE&quot;);</span>
		}
<span class="nc" id="L1313">		return result.toString();</span>
	}

	/**
	 * Gets the SQL command to drop an index. As follows: DROP INDEX indexName [ CASCADE ];
	 * 
	 * @param indexName
	 *           name of the index
	 * @param cascade
	 *           true if automatically drop object that depend on the view (such as other views).
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect to use for identifier quoting behavior
	 * @return the sql command to drop an index.
	 */
	public static String getDropIndexSQL(String indexName, Boolean cascade, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
		// DROP INDEX indexName [ CASCADE ];
<span class="nc" id="L1335">		return getDropIndexSQL(null, indexName, cascade, qualifier, prefs, dialect);</span>
	}

	/**
	 * Gets the SQL command to drop an index. As follows: DROP INDEX indexName [ CASCADE ] [ ON &lt;tableName&gt; ];
	 * 
	 * @param indexName
	 *           name of the index
	 * @param cascade
	 *           true if automatically drop object that depend on the view (such as other views).
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect to use for identifier quoting behavior
	 * @return the sql command to drop an index.
	 */
	public static String getDropIndexSQL(String tableName, String indexName, Boolean cascade,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
		// DROP INDEX indexName [ CASCADE ] [ ON &lt;tableName&gt; ];
<span class="nc" id="L1357">		final StringBuilder sql = new StringBuilder();</span>

<span class="nc" id="L1359">		sql.append(DialectUtils.DROP_INDEX_CLAUSE);</span>
<span class="nc" id="L1360">		sql.append(&quot; &quot;);</span>
<span class="nc" id="L1361">		sql.append(shapeQualifiableIdentifier(indexName, qualifier, prefs, dialect)).append(&quot; &quot;);</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">		if (cascade != null)</span>
		{
<span class="nc bnc" id="L1364" title="All 2 branches missed.">			sql.append(cascade ? DialectUtils.CASCADE_CLAUSE : DialectUtils.RESTRICT_CLAUSE);</span>
		}
<span class="nc bnc" id="L1366" title="All 2 branches missed.">		if (tableName != null)</span>
		{
<span class="nc" id="L1368">			sql.append(&quot; ON &quot;);</span>
<span class="nc" id="L1369">			sql.append(shapeQualifiableIdentifier(tableName, qualifier, prefs, dialect));</span>
		}
<span class="nc" id="L1371">		return sql.toString();</span>
	}

	/**
	 * Gets the SQL command to drop a sequence.
	 * 
	 * @param sequenceName
	 *           name of the sequence
	 * @param cascade
	 *           true if automatically drop object that depend on the view (such as other views).
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect to generate the SQL for.
	 * @return the sql command to drop a sequence.
	 */
	public static String getDropSequenceSQL(String sequenceName, Boolean cascade,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
		// DROP SEQUENCE sequenceName CASCADE;
<span class="nc" id="L1393">		final StringBuilder sql = new StringBuilder();</span>

<span class="nc" id="L1395">		sql.append(&quot;DROP SEQUENCE &quot;);</span>
<span class="nc" id="L1396">		sql.append(shapeQualifiableIdentifier(sequenceName, qualifier, prefs, dialect));</span>
<span class="nc bnc" id="L1397" title="All 2 branches missed.">		if (cascade != null)</span>
		{
<span class="nc" id="L1399">			sql.append(&quot; &quot;);</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">			sql.append(cascade ? &quot;CASCADE&quot; : &quot;RESTRICT&quot;);</span>
		}

<span class="nc" id="L1403">		return sql.toString();</span>

	}

	public static String getDropConstraintSQL(String tableName, String constraintName,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
		// ALTER TABLE tableName
		// DROP CONSTRAINT constraintName
<span class="nc" id="L1412">		final StringBuilder sql = new StringBuilder();</span>

<span class="nc" id="L1414">		sql.append(DialectUtils.ALTER_TABLE_CLAUSE + &quot; &quot;);</span>
<span class="nc" id="L1415">		sql.append(shapeQualifiableIdentifier(tableName, qualifier, prefs, dialect)).append(&quot;\n&quot;);</span>

<span class="nc" id="L1417">		sql.append(&quot; &quot; + DialectUtils.DROP_CONSTRAINT_CLAUSE + &quot; &quot;);</span>
<span class="nc bnc" id="L1418" title="All 2 branches missed.">		if (prefs.isQuoteConstraintNames())</span>
		{
<span class="nc" id="L1420">			sql.append(shapeIdentifier(constraintName, prefs, dialect));</span>
		}
		else
		{
<span class="nc" id="L1424">			sql.append(constraintName);</span>
		}
<span class="nc" id="L1426">		return sql.toString();</span>
	}

	/**
	 * Gets the SQL command to drop a view.
	 * 
	 * @param viewName
	 *           name of the view
	 * @param cascade
	 *           cascade true if automatically drop object that depend on the view (such as other views).
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect to generate the SQL for.
	 * @return the SQL command to drop a view.
	 */
	public static String getDropViewSQL(String viewName, Boolean cascade, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
		// DROP VIEW viewName CASCADE;
<span class="nc" id="L1448">		final StringBuffer sql = new StringBuffer();</span>

<span class="nc" id="L1450">		sql.append(DialectUtils.DROP_VIEW_CLAUSE + &quot; &quot;);</span>
<span class="nc" id="L1451">		sql.append(shapeQualifiableIdentifier(viewName, qualifier, prefs, dialect));</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">		if (cascade != null)</span>
		{
<span class="nc" id="L1454">			sql.append(&quot; &quot;);</span>
<span class="nc bnc" id="L1455" title="All 2 branches missed.">			sql.append(cascade ? DialectUtils.CASCADE_CLAUSE : DialectUtils.RESTRICT_CLAUSE);</span>
		}
<span class="nc" id="L1457">		return sql.toString();</span>
	}

	/**
	 * Returns SQL that can be executed to create the specified index. Like: CREATE UNIQUE INDEX indexName ON
	 * tableName (columns);
	 * 
	 * @param indexName
	 *           the name of the index
	 * @param columns
	 *           the columns that are indexed
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect to generate the SQL for.
	 * @return
	 */
	public static String getAddIndexSQL(String indexName, boolean unique, TableColumnInfo[] columns,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc" id="L1479">		final StringBuilder result = new StringBuilder();</span>

<span class="nc" id="L1481">		final String shapedTable =</span>
<span class="nc" id="L1482">			shapeQualifiableIdentifier(columns[0].getTableName(), qualifier, prefs, dialect);</span>
<span class="nc" id="L1483">		String shapedIndexName = indexName;</span>
<span class="nc bnc" id="L1484" title="All 2 branches missed.">		if (prefs.isQuoteConstraintNames())</span>
		{
<span class="nc" id="L1486">			shapedIndexName = shapeIdentifier(indexName, prefs, dialect);</span>
		}

<span class="nc bnc" id="L1489" title="All 2 branches missed.">		if (unique)</span>
		{
<span class="nc" id="L1491">			result.append(&quot;CREATE UNIQUE INDEX &quot;);</span>
		}
		else
		{
<span class="nc" id="L1495">			result.append(&quot;CREATE INDEX &quot;);</span>
		}
<span class="nc" id="L1497">		result.append(shapedIndexName);</span>
<span class="nc" id="L1498">		result.append(&quot; ON &quot;);</span>
<span class="nc" id="L1499">		result.append(shapedTable);</span>
<span class="nc" id="L1500">		result.append(&quot; &quot;);</span>
<span class="nc" id="L1501">		result.append(getColumnList(columns, qualifier, prefs, dialect));</span>
<span class="nc" id="L1502">		return result.toString();</span>
	}

	/**
	 * Constructs the SQL for adding an index, as follows: CREATE UNIQUE INDEX indexName ON tableName USING
	 * btree (column1, column2) TABLESPACE &lt;tableSpace&gt; WHERE constraints;
	 * 
	 * @param indexName
	 *           name of the index to be created
	 * @param tableName
	 *           name of the table
	 * @param columns
	 *           columns where the index should be stored for
	 * @param unique
	 *           true if the index should be unique
	 * @param accessMethod
	 *           the index access method to use (for example, b-tree, r-tree, hash, etc.)
	 * @param tablespace
	 *           tablespace for the index (leave empty for no tablespace)
	 * @param constraints
	 *           constraints for the index (leave empty for no constraints)
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return the sql command to create an index.
	 */
	public static String getAddIndexSQL(HibernateDialect dialect, String indexName, String tableName,
		String accessMethod, String[] columns, boolean unique, String tablespace, String constraints,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs)
	{
		// CREATE UNIQUE INDEX indexName ON tableName USING btree (column1,
		// column2) TABLESPACE
		// WHERE constraints;
<span class="nc" id="L1536">		final StringBuilder sql = new StringBuilder();</span>

<span class="nc" id="L1538">		sql.append(DialectUtils.CREATE_CLAUSE + &quot; &quot;);</span>
<span class="nc bnc" id="L1539" title="All 2 branches missed.">		if (unique)</span>
		{
<span class="nc" id="L1541">			sql.append(DialectUtils.UNIQUE_CLAUSE + &quot; &quot;);</span>
		}
<span class="nc" id="L1543">		sql.append(DialectUtils.INDEX_CLAUSE + &quot; &quot;);</span>
<span class="nc" id="L1544">		sql.append(shapeIdentifier(indexName, prefs, dialect));</span>
<span class="nc" id="L1545">		sql.append(&quot; ON &quot;).append(shapeQualifiableIdentifier(tableName, qualifier, prefs, dialect)).append(&quot; &quot;);</span>
<span class="nc bnc" id="L1546" title="All 4 branches missed.">		if (accessMethod != null &amp;&amp; !&quot;&quot;.equals(accessMethod))</span>
		{
<span class="nc" id="L1548">			sql.append(&quot; USING &quot;);</span>
<span class="nc" id="L1549">			sql.append(accessMethod);</span>
<span class="nc" id="L1550">			sql.append(&quot; &quot;);</span>
		}
<span class="nc" id="L1552">		sql.append(&quot;(&quot;);</span>
<span class="nc bnc" id="L1553" title="All 2 branches missed.">		for (final String column : columns)</span>
		{
<span class="nc" id="L1555">			sql.append(shapeIdentifier(column, prefs, dialect)).append(&quot;, &quot;);</span>
		}
<span class="nc" id="L1557">		sql.delete(sql.length() - 2, sql.length()); // deletes the last &quot;, &quot;</span>
<span class="nc" id="L1558">		sql.append(&quot;)&quot;);</span>

<span class="nc bnc" id="L1560" title="All 4 branches missed.">		if (tablespace != null &amp;&amp; !tablespace.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L1562">			sql.append(&quot; \n TABLESPACE &quot;).append(tablespace);</span>
		}

<span class="nc bnc" id="L1565" title="All 4 branches missed.">		if (constraints != null &amp;&amp; !constraints.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L1567">			sql.append(&quot; \n &quot; + DialectUtils.WHERE_CLAUSE + &quot; &quot;).append(constraints);</span>
		}

<span class="nc" id="L1570">		return sql.toString();</span>
	}

	/**
	 * @param dialect
	 * @param st
	 * @param valuesMap
	 * @param columns
	 * @param qualifier
	 * @param prefs
	 * @return
	 */
	public static String getAddIndexSQL(HibernateDialect dialect, StringTemplate st,
		HashMap&lt;String, String&gt; valuesMap, String[] columns, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs)
	{
<span class="nc" id="L1586">		bindAttributes(dialect, st, valuesMap, qualifier, prefs);</span>
<span class="nc bnc" id="L1587" title="All 2 branches missed.">		for (final String columnName : columns)</span>
		{
<span class="nc" id="L1589">			bindAttribute(dialect, st, ST_COLUMN_NAME_KEY, columnName, qualifier, prefs);</span>
		}
<span class="nc" id="L1591">		return st.toString();</span>
	}

	public static TableColumnInfo getRenamedColumn(TableColumnInfo info, String newColumnName)
	{
<span class="nc" id="L1596">		final TableColumnInfo result =</span>
<span class="nc" id="L1597">			new TableColumnInfo(info.getCatalogName(), info.getSchemaName(), info.getTableName(), newColumnName,</span>
<span class="nc" id="L1598">				info.getDataType(), info.getTypeName(), info.getColumnSize(), info.getDecimalDigits(),</span>
<span class="nc" id="L1599">				info.getRadix(), info.isNullAllowed(), info.getRemarks(), info.getDefaultValue(),</span>
<span class="nc" id="L1600">				info.getOctetLength(), info.getOrdinalPosition(), info.isNullable());</span>
<span class="nc" id="L1601">		return result;</span>
	}

	/**
	 * Gets the SQL command to rename a table.
	 * 
	 * @param oldTableName
	 *           old name of the table
	 * @param newTableName
	 *           new name of the table
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect to generate the SQL for.
	 * @return the sql command to rename a table.
	 */
	public static String getRenameTableSQL(String oldTableName, String newTableName,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
		// ALTER TABLE oldTableName RENAME TO newTableName;
<span class="nc" id="L1623">		final StringBuilder sql = new StringBuilder();</span>

<span class="nc" id="L1625">		sql.append(DialectUtils.ALTER_TABLE_CLAUSE);</span>
<span class="nc" id="L1626">		sql.append(&quot; &quot;);</span>
<span class="nc" id="L1627">		sql.append(shapeQualifiableIdentifier(oldTableName, qualifier, prefs, dialect));</span>
<span class="nc" id="L1628">		sql.append(&quot; RENAME TO &quot;);</span>
<span class="nc" id="L1629">		sql.append(shapeQualifiableIdentifier(newTableName, qualifier, prefs, dialect));</span>

<span class="nc" id="L1631">		return sql.toString();</span>
	}

	/**
	 * Gets the SQL command to rename a view. Looks like &lt;commandPrefix&gt; &lt;oldViewName&gt; &lt;renameClause&gt;
	 * &lt;newViewName&gt;
	 * 
	 * @param commandPrefix
	 *           the beginning of the command (ALTER VIEW / RENAME )
	 * @param renameClause
	 *           the part between the old and new names.
	 * @param oldViewName
	 *           old name of the view
	 * @param newViewName
	 *           new name of the view
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect to generate the SQL for.
	 * @return the sql command
	 */
	public static String getRenameViewSQL(String commandPrefix, String renameClause, String oldViewName,
		String newViewName, DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs,
		HibernateDialect dialect)
	{
		// ALTER VIEW oldTableName RENAME TO newTableName;
		// RENAME oldTableName TO newTableName;

<span class="nc" id="L1661">		final StringBuilder sql = new StringBuilder();</span>

<span class="nc" id="L1663">		sql.append(commandPrefix);</span>
<span class="nc" id="L1664">		sql.append(&quot; &quot;);</span>
<span class="nc" id="L1665">		sql.append(shapeQualifiableIdentifier(oldViewName, qualifier, prefs, dialect)).append(&quot; &quot;);</span>
<span class="nc" id="L1666">		sql.append(renameClause);</span>
<span class="nc" id="L1667">		sql.append(&quot; &quot;);</span>
<span class="nc" id="L1668">		sql.append(shapeIdentifier(newViewName, prefs, dialect));</span>

<span class="nc" id="L1670">		return sql.toString();</span>
	}

	public static String getRenameViewSql(StringTemplate st, HashMap&lt;String, String&gt; valuesMap,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc" id="L1676">		bindAttributes(dialect, st, valuesMap, qualifier, prefs);</span>
<span class="nc" id="L1677">		return st.toString();</span>
	}

	/**
	 * Returns the SQL command to drop the specified table's foreign key constraint.
	 * 
	 * @param fkName
	 *           the name of the foreign key that should be dropped
	 * @param tableName
	 *           the name of the table whose foreign key should be dropped
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect to generate the SQL for.
	 * @return
	 */
	public static String getDropForeignKeySQL(String fkName, String tableName,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc" id="L1698">		final StringBuilder tmp = new StringBuilder();</span>
<span class="nc" id="L1699">		tmp.append(&quot;ALTER TABLE &quot;);</span>
<span class="nc" id="L1700">		tmp.append(shapeQualifiableIdentifier(tableName, qualifier, prefs, dialect));</span>
<span class="nc" id="L1701">		tmp.append(&quot; DROP CONSTRAINT &quot;);</span>
<span class="nc" id="L1702">		tmp.append(shapeIdentifier(fkName, prefs, dialect));</span>
<span class="nc" id="L1703">		return tmp.toString();</span>
	}

	/**
	 * Gets the SQL command to create a new table.
	 * 
	 * @param tableName
	 *           simple name of the table
	 * @param columns
	 *           columns of the table
	 * @param primaryKeys
	 *           primary keys of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param qualifier
	 *           qualifier of the table
	 * @return the sql command to create a table.
	 */
	public static String getCreateTableSQL(String simpleName, List&lt;TableColumnInfo&gt; columns,
		List&lt;TableColumnInfo&gt; primaryKeys, SqlGenerationPreferences prefs, DatabaseObjectQualifier qualifier,
		HibernateDialect dialect)
	{
<span class="nc bnc" id="L1725" title="All 4 branches missed.">		if (columns.isEmpty() &amp;&amp; !dialect.supportsEmptyTables()) { throw new IllegalArgumentException(</span>
<span class="nc" id="L1726">			dialect.getDisplayName()</span>
				+ &quot; does not support empty tables. (parameter 'columns' has to contain at least one column)&quot;); }

		// CREATE TABLE tableName (
		// column1 int,
		// column2 varchar(20) NOT NULL DEFAULT 'Hello World'
		// CONSTRAINT tableName_pkey PRIMARY KEY(column1,column2)
		// );
<span class="nc" id="L1734">		final StringBuilder sql = new StringBuilder();</span>

<span class="nc" id="L1736">		sql.append(DialectUtils.CREATE_TABLE_CLAUSE + &quot; &quot;);</span>
<span class="nc" id="L1737">		sql.append(shapeQualifiableIdentifier(simpleName, qualifier, prefs, dialect)).append(&quot; (\n&quot;);</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">		for (final TableColumnInfo column : columns)</span>
		{
<span class="nc" id="L1740">			sql.append(&quot; &quot;);</span>
<span class="nc bnc" id="L1741" title="All 2 branches missed.">			if (prefs.isQuoteColumnNames())</span>
			{
<span class="nc" id="L1743">				sql.append(shapeIdentifier(column.getColumnName(), prefs, dialect));</span>
			}
			else
			{
<span class="nc" id="L1747">				sql.append(column.getColumnName());</span>
			}
<span class="nc" id="L1749">			sql.append(&quot; &quot;);</span>
<span class="nc" id="L1750">			sql.append(dialect.getTypeName(column.getDataType(), column.getColumnSize(), column.getColumnSize(),</span>
<span class="nc" id="L1751">				column.getDecimalDigits()));</span>

<span class="nc bnc" id="L1753" title="All 4 branches missed.">			if (primaryKeys != null &amp;&amp; primaryKeys.size() == 1</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">				&amp;&amp; primaryKeys.get(0).getColumnName().equals(column.getColumnName()))</span>
			{
<span class="nc" id="L1756">				sql.append(&quot; &quot; + DialectUtils.PRIMARY_KEY_CLAUSE);</span>
			}
<span class="nc bnc" id="L1758" title="All 2 branches missed.">			else if (column.isNullAllowed() == 0)</span>
			{
<span class="nc" id="L1760">				sql.append(&quot; &quot; + DialectUtils.NOT_NULL_CLAUSE);</span>
			}
<span class="nc bnc" id="L1762" title="All 2 branches missed.">			if (column.getDefaultValue() != null)</span>
			{
<span class="nc" id="L1764">				sql.append(&quot; &quot; + DialectUtils.DEFAULT_CLAUSE + &quot; &quot;).append(column.getDefaultValue());</span>
			}

<span class="nc" id="L1767">			sql.append(&quot;,\n&quot;);</span>
<span class="nc" id="L1768">		}</span>

<span class="nc bnc" id="L1770" title="All 4 branches missed.">		if (primaryKeys != null &amp;&amp; primaryKeys.size() &gt; 1)</span>
		{
<span class="nc" id="L1772">			sql.append(&quot; &quot; + DialectUtils.CONSTRAINT_CLAUSE + &quot; &quot;)</span>
<span class="nc" id="L1773">				.append(shapeIdentifier(simpleName + &quot;_pkey&quot;, prefs, dialect))</span>
<span class="nc" id="L1774">				.append(&quot; &quot; + DialectUtils.PRIMARY_KEY_CLAUSE + &quot;(&quot;);</span>
<span class="nc bnc" id="L1775" title="All 2 branches missed.">			for (final TableColumnInfo pkPart : primaryKeys)</span>
			{
<span class="nc" id="L1777">				sql.append(shapeIdentifier(pkPart.getColumnName(), prefs, dialect)).append(&quot;,&quot;);</span>
<span class="nc" id="L1778">			}</span>
<span class="nc" id="L1779">			sql.setLength(sql.length() - 1);</span>
<span class="nc" id="L1780">			sql.append(&quot;)&quot;);</span>
		}
		else
		{
<span class="nc" id="L1784">			sql.setLength(sql.length() - 2);</span>
		}

<span class="nc" id="L1787">		sql.append(&quot;)&quot;);</span>
<span class="nc" id="L1788">		return sql.toString();</span>

	}

	public static List&lt;String&gt; getCreateTableSQL(List&lt;ITableInfo&gt; tables, ISQLDatabaseMetaData md,
		HibernateDialect dialect, CreateScriptPreferences prefs, boolean isJdbcOdbc) throws SQLException
	{
<span class="nc" id="L1795">		return getCreateTableSQL(tables, md, dialect, prefs, isJdbcOdbc, false);</span>
	}

	public static List&lt;String&gt; getCreateTableSQL(List&lt;ITableInfo&gt; tables, ISQLDatabaseMetaData md,
		HibernateDialect dialect, CreateScriptPreferences prefs, boolean isJdbcOdbc, boolean sortColumns)
		throws SQLException
	{
<span class="nc" id="L1802">		final List&lt;String&gt; sqls = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1803">		final List&lt;String&gt; allconstraints = new ArrayList&lt;String&gt;();</span>

<span class="nc bnc" id="L1805" title="All 2 branches missed.">		for (final ITableInfo ti : tables)</span>
		{
<span class="nc" id="L1807">			final StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L1808">			result.append(&quot;CREATE TABLE &quot;);</span>
<span class="nc" id="L1809">			result.append(formatQualifIntern(ti.getSimpleName(), ti.getSchemaName(), prefs));</span>
<span class="nc" id="L1810">			result.append(&quot;\n(&quot;);</span>

<span class="nc" id="L1812">			final List&lt;PrimaryKeyInfo&gt; pkInfos = getPrimaryKeyInfo(md, ti, isJdbcOdbc);</span>
<span class="nc" id="L1813">			final List&lt;String&gt; pks = getPKSequenceList(pkInfos);</span>
<span class="nc" id="L1814">			final TableColumnInfo[] infos = md.getColumnInfo(ti);</span>
<span class="nc bnc" id="L1815" title="All 2 branches missed.">			if (sortColumns)</span>
			{
<span class="nc" id="L1817">				Arrays.sort(infos);</span>
			}
<span class="nc bnc" id="L1819" title="All 2 branches missed.">			for (final TableColumnInfo tcInfo : infos)</span>
			{
<span class="nc" id="L1821">				final String columnName = tcInfo.getColumnName();</span>
<span class="nc" id="L1822">				final String defaultVal = tcInfo.getDefaultValue();</span>
<span class="nc" id="L1823">				final String columnType = dialect.getTypeName(tcInfo);</span>

<span class="nc" id="L1825">				result.append(&quot;\n   &quot;);</span>
<span class="nc" id="L1826">				result.append(columnName);</span>
<span class="nc" id="L1827">				result.append(&quot; &quot;);</span>
<span class="nc" id="L1828">				result.append(columnType);</span>
<span class="nc" id="L1829">				final String isNullable = tcInfo.isNullable();</span>
<span class="nc bnc" id="L1830" title="All 4 branches missed.">				if (pks.size() == 1 &amp;&amp; pks.get(0).equals(columnName))</span>
				{
<span class="nc" id="L1832">					result.append(&quot; PRIMARY KEY&quot;);</span>
				}
				else
				{
					// in Sybase, DEFAULT keyword must appear prior to NULL/NOT
					// NULL
<span class="nc bnc" id="L1838" title="All 4 branches missed.">					if (defaultVal != null &amp;&amp; !&quot;&quot;.equals(defaultVal))</span>
					{
<span class="nc" id="L1840">						result.append(&quot; DEFAULT &quot;);</span>
<span class="nc" id="L1841">						result.append(defaultVal);</span>
					}
				}

<span class="nc bnc" id="L1845" title="All 2 branches missed.">				if (&quot;NO&quot;.equalsIgnoreCase(isNullable))</span>
				{
<span class="nc" id="L1847">					result.append(&quot; NOT NULL&quot;);</span>
				}
<span class="nc" id="L1849">				result.append(&quot;,&quot;);</span>
			}

<span class="nc bnc" id="L1852" title="All 2 branches missed.">			if (pks.size() &gt; 1)</span>
			{
<span class="nc" id="L1854">				result.append(&quot;\n   CONSTRAINT &quot;);</span>
<span class="nc" id="L1855">				result.append(pkInfos.get(0).getSimpleName());</span>
<span class="nc" id="L1856">				result.append(&quot; PRIMARY KEY (&quot;);</span>
<span class="nc bnc" id="L1857" title="All 2 branches missed.">				for (int i = 0; i &lt; pks.size(); i++)</span>
				{
<span class="nc" id="L1859">					result.append(pks.get(i));</span>
<span class="nc" id="L1860">					result.append(&quot;,&quot;);</span>
				}
<span class="nc" id="L1862">				result.setLength(result.length() - 1);</span>
<span class="nc" id="L1863">				result.append(&quot;),&quot;);</span>
			}
<span class="nc" id="L1865">			result.setLength(result.length() - 1);</span>

<span class="nc" id="L1867">			result.append(&quot;\n)&quot;);</span>
<span class="nc" id="L1868">			sqls.add(result.toString());</span>

<span class="nc bnc" id="L1870" title="All 2 branches missed.">			if (isJdbcOdbc)</span>
			{
<span class="nc" id="L1872">				continue;</span>
			}

<span class="nc" id="L1875">			final List&lt;String&gt; constraints = createConstraints(ti, tables, prefs, md);</span>
<span class="nc" id="L1876">			addConstraintsSQLs(sqls, allconstraints, constraints, prefs);</span>

<span class="nc" id="L1878">			final List&lt;String&gt; indexes = createIndexes(ti, ti.getSimpleName(), ti.getSchemaName(), md, pkInfos, prefs);</span>
<span class="nc" id="L1879">			addConstraintsSQLs(sqls, allconstraints, indexes, prefs);</span>
<span class="nc" id="L1880">		}</span>

<span class="nc bnc" id="L1882" title="All 2 branches missed.">		if (prefs.isConstraintsAtEnd())</span>
		{
<span class="nc" id="L1884">			sqls.addAll(allconstraints);</span>
		}
<span class="nc" id="L1886">		return sqls;</span>
	}

	/**
	 * Gets the SQL command to create an index.
	 * 
	 * @param indexName
	 *           name of the index to be created
	 * @param tableName
	 *           name of the table
	 * @param accessMethod
	 *           the index access method to use (for example, b-tree, r-tree, hash, etc.)
	 * @param columns
	 *           columns where the index should be stored for
	 * @param unique
	 *           true if the index should be unique
	 * @param tablespace
	 *           tablespace for the index (leave empty for no tablespace)
	 * @param constraints
	 *           constraints for the index (leave empty for no constraints)
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the hibernate dialect to use.
	 * @return the sql command to create an index.
	 */
	public static String getCreateIndexSQL(String indexName, String tableName, String accessMethod,
		String[] columns, boolean unique, String tablespace, String constraints,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc" id="L1918">		final StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L1919">		result.append(&quot;CREATE &quot;);</span>

<span class="nc bnc" id="L1921" title="All 2 branches missed.">		if (unique)</span>
		{
<span class="nc" id="L1923">			result.append(&quot;UNIQUE &quot;);</span>
		}
<span class="nc" id="L1925">		result.append(&quot; INDEX &quot;);</span>
<span class="nc" id="L1926">		result.append(DialectUtils.shapeQualifiableIdentifier(indexName, qualifier, prefs, dialect));</span>
<span class="nc" id="L1927">		result.append(&quot; ON &quot;);</span>
<span class="nc" id="L1928">		result.append(DialectUtils.shapeQualifiableIdentifier(tableName, qualifier, prefs, dialect));</span>
<span class="nc" id="L1929">		result.append(&quot;(&quot;);</span>
<span class="nc bnc" id="L1930" title="All 2 branches missed.">		for (final String column : columns)</span>
		{
<span class="nc" id="L1932">			result.append(column);</span>
<span class="nc" id="L1933">			result.append(&quot;,&quot;);</span>
		}
<span class="nc" id="L1935">		result.setLength(result.length() - 1);</span>
<span class="nc" id="L1936">		result.append(&quot;)&quot;);</span>
<span class="nc" id="L1937">		return result.toString();</span>
	}

	/**
	 * Gets the SQL command to create a view.
	 * 
	 * @param viewName
	 *           name of the view
	 * @param definition
	 *           old definition of the view.
	 * @param checkOption
	 *           CHECK OPTION. CASCADE, LOCAL or null for no check option.
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the HibernateDialect to use for identifier quoting behavior
	 * @return the sql command to create a view.
	 */
	public static String getCreateViewSQL(String viewName, String definition, String checkOption,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
		// CREATE VIEW viewName
		// AS definition;
<span class="nc" id="L1962">		final StringBuilder sql = new StringBuilder();</span>

<span class="nc" id="L1964">		sql.append(DialectUtils.CREATE_VIEW_CLAUSE + &quot; &quot;)</span>
<span class="nc" id="L1965">			.append(shapeQualifiableIdentifier(viewName, qualifier, prefs, dialect))</span>
<span class="nc" id="L1966">			.append(&quot;\n&quot;);</span>
<span class="nc" id="L1967">		sql.append(&quot; AS &quot;).append(definition);</span>
<span class="nc bnc" id="L1968" title="All 6 branches missed.">		if (dialect.supportsCheckOptionsForViews() &amp;&amp; checkOption != null &amp;&amp; !checkOption.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L1970">			sql.append(&quot;\n WITH &quot;).append(checkOption).append(&quot; CHECK OPTION&quot;);</span>
		}

<span class="nc" id="L1973">		return sql.toString();</span>
	}

	/**
	 * Gets the SQL command to create a sequence.
	 * 
	 * @param sequenceName
	 *           name of the sequence
	 * @param increment
	 *           increment value
	 * @param minimumClause
	 *           MINVALUE, NO MINVALUE, NOMINVALUE
	 * @param minimum
	 *           minimum value
	 * @param maximumClause
	 *           MAXVALUE, NO MAXVALUE, NOMAXVALUE
	 * @param maximum
	 *           maximum value
	 * @param start
	 *           start value (leave empty for default)
	 * @param cache
	 *           cache value, how many sequences should be preallocated (leave empty for default)
	 * @param cycleClause
	 *           the cycle clause to use
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return the sql command to create a sequence.
	 */
	public static String getCreateSequenceSQL(String sequenceName, String increment, String minimumClause,
		String minimum, String maximumClause, String maximum, String start, String cache, String cycleClause,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc" id="L2007">		final StringBuilder sql = new StringBuilder();</span>

<span class="nc" id="L2009">		sql.append(DialectUtils.CREATE_SEQUENCE_CLAUSE).append(&quot; &quot;);</span>
<span class="nc" id="L2010">		sql.append(shapeQualifiableIdentifier(sequenceName, qualifier, prefs, dialect)).append(&quot;\n&quot;);</span>

<span class="nc bnc" id="L2012" title="All 4 branches missed.">		if (increment != null &amp;&amp; !increment.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L2014">			sql.append(&quot;INCREMENT BY &quot;);</span>
<span class="nc" id="L2015">			sql.append(increment);</span>
<span class="nc" id="L2016">			sql.append(&quot; &quot;);</span>
		}

<span class="nc bnc" id="L2019" title="All 4 branches missed.">		if (minimum != null &amp;&amp; !minimum.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L2021">			sql.append(minimumClause);</span>
<span class="nc" id="L2022">			sql.append(&quot; &quot;);</span>
<span class="nc" id="L2023">			sql.append(minimum);</span>
<span class="nc" id="L2024">			sql.append(&quot; &quot;);</span>
		}
		else
		{
<span class="nc" id="L2028">			sql.append(minimumClause);</span>
<span class="nc" id="L2029">			sql.append(&quot; &quot;);</span>
		}

<span class="nc bnc" id="L2032" title="All 4 branches missed.">		if (maximum != null &amp;&amp; !maximum.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L2034">			sql.append(maximumClause);</span>
<span class="nc" id="L2035">			sql.append(&quot; &quot;);</span>
<span class="nc" id="L2036">			sql.append(maximum);</span>
<span class="nc" id="L2037">			sql.append(&quot; &quot;);</span>
		}
		else
		{
<span class="nc" id="L2041">			sql.append(maximumClause);</span>
		}
<span class="nc" id="L2043">		sql.append(&quot;\n&quot;);</span>

<span class="nc bnc" id="L2045" title="All 4 branches missed.">		if (start != null &amp;&amp; !start.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L2047">			sql.append(&quot;START WITH &quot;);</span>
<span class="nc" id="L2048">			sql.append(start).append(&quot; &quot;);</span>
		}

<span class="nc bnc" id="L2051" title="All 4 branches missed.">		if (cache != null &amp;&amp; !cache.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L2053">			sql.append(&quot;CACHE &quot;);</span>
<span class="nc" id="L2054">			sql.append(cache).append(&quot; &quot;);</span>
		}

<span class="nc bnc" id="L2057" title="All 2 branches missed.">		if (cycleClause != null)</span>
		{
<span class="nc" id="L2059">			sql.append(cycleClause);</span>
		}

<span class="nc" id="L2062">		return sql.toString();</span>

	}

	/**
	 * @param st
	 * @param sequenceName
	 * @param increment
	 * @param minimum
	 * @param maximum
	 * @param start
	 * @param cache
	 * @param qualifier
	 * @param prefs
	 * @param dialect
	 * @return
	 */
	public static String getCreateSequenceSQL(StringTemplate st, HashMap&lt;String, String&gt; valuesMap,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc" id="L2082">		return bindTemplateAttributes(dialect, st, valuesMap, qualifier, prefs);</span>
	}

	/**
	 * Gets the SQL command to create a sequence.
	 * 
	 * @param sequenceName
	 *           name of the sequence
	 * @param increment
	 *           increment value
	 * @param minimum
	 *           minimum value (leave empty for NO MINVALUE)
	 * @param maximum
	 *           maximum value (leave empty for NO MINVALUE)
	 * @param start
	 *           start value (leave empty for default)
	 * @param cache
	 *           cache value, how many sequences should be preallocated (leave empty for default)
	 * @param cycleClause
	 *           the cycle clause to use
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return the sql command to create a sequence.
	 */
	public static String getCreateSequenceSQL(String sequenceName, String increment, String minimum,
		String maximum, String start, String cache, String cycleClause, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
		// CREATE SEQUENCE sequenceName
		// INCREMENT BY increment MINVALUE minimum MAXVALUE maxvalue
		// RESTART WITH restart CACHE cache CYCLE;

<span class="nc" id="L2116">		String minimumClause = &quot;&quot;;</span>
<span class="nc bnc" id="L2117" title="All 4 branches missed.">		if (minimum != null &amp;&amp; !minimum.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L2119">			minimumClause = DialectUtils.MINVALUE_CLAUSE;</span>
		}
		else
		{

<span class="nc" id="L2124">			minimumClause = DialectUtils.NO_MINVALUE_CLAUSE;</span>
		}

<span class="nc" id="L2127">		String maximumClause = &quot;&quot;;</span>
<span class="nc bnc" id="L2128" title="All 4 branches missed.">		if (maximum != null &amp;&amp; !maximum.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L2130">			maximumClause = DialectUtils.MAXVALUE_CLAUSE;</span>
		}
		else
		{
<span class="nc" id="L2134">			maximumClause = DialectUtils.NO_MAXVALUE_CLAUSE;</span>
		}

<span class="nc" id="L2137">		return getCreateSequenceSQL(sequenceName, increment, minimumClause, minimum, maximumClause, maximum,</span>
			start, cache, cycleClause, qualifier, prefs, dialect);

	}

	/**
	 * Gets the SQL command to alter a sequence.
	 * 
	 * @param sequenceName
	 *           name of the sequence.
	 * @param increment
	 *           increment value.
	 * @param minimum
	 *           minimum value.
	 * @param maximum
	 *           maximum value.
	 * @param restart
	 *           start value.
	 * @param cache
	 *           cache value, how many sequences should be preallocated.
	 * @param cycleClause
	 *           true if the sequence should wrap around when the max-/minvalue has been reached.
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return the sql command
	 */
	public static String getAlterSequenceSQL(String sequenceName, String increment, String minimum,
		String maximum, String restart, String cache, String cycleClause, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
		// ALTER SEQUENCE sequenceName
		// INCREMENT BY increment MINVALUE minimum MAXVALUE maxvalue
		// RESTART WITH restart CACHE cache CYCLE;
<span class="nc" id="L2172">		final StringBuilder sql = new StringBuilder();</span>

<span class="nc" id="L2174">		sql.append(DialectUtils.ALTER_SEQUENCE_CLAUSE + &quot; &quot;);</span>
<span class="nc" id="L2175">		sql.append(shapeQualifiableIdentifier(sequenceName, qualifier, prefs, dialect)).append(&quot;\n&quot;);</span>

<span class="nc bnc" id="L2177" title="All 4 branches missed.">		if (increment != null &amp;&amp; !increment.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L2179">			sql.append(&quot;INCREMENT BY &quot;);</span>
<span class="nc" id="L2180">			sql.append(increment).append(&quot; &quot;);</span>
		}

<span class="nc bnc" id="L2183" title="All 4 branches missed.">		if (minimum != null &amp;&amp; !minimum.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L2185">			sql.append(&quot;MINVALUE &quot;);</span>
<span class="nc" id="L2186">			sql.append(minimum).append(&quot; &quot;);</span>
		}
		else
		{
<span class="nc" id="L2190">			sql.append(&quot;NO MINVALUE &quot;);</span>
		}

<span class="nc bnc" id="L2193" title="All 4 branches missed.">		if (maximum != null &amp;&amp; !maximum.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L2195">			sql.append(&quot;MAXVALUE &quot;);</span>
<span class="nc" id="L2196">			sql.append(maximum).append(&quot;\n&quot;);</span>
		}
		else
		{
<span class="nc" id="L2200">			sql.append(&quot;NO MAXVALUE\n&quot;);</span>
		}

<span class="nc bnc" id="L2203" title="All 4 branches missed.">		if (restart != null &amp;&amp; !restart.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L2205">			sql.append(&quot;RESTART WITH &quot;);</span>
<span class="nc" id="L2206">			sql.append(restart).append(&quot; &quot;);</span>
		}

<span class="nc bnc" id="L2209" title="All 4 branches missed.">		if (cache != null &amp;&amp; !cache.equals(&quot;&quot;))</span>
		{
<span class="nc" id="L2211">			sql.append(&quot;CACHE &quot;);</span>
<span class="nc" id="L2212">			sql.append(cache).append(&quot; &quot;);</span>
		}

<span class="nc bnc" id="L2215" title="All 2 branches missed.">		if (cycleClause != null)</span>
		{
<span class="nc" id="L2217">			sql.append(cycleClause);</span>
		}

<span class="nc" id="L2220">		return sql.toString();</span>
	}

	/**
	 * Simulates alter statement for sequence for those dialects that have no &quot;ALTER SEQUENCE ...&quot; support.
	 * This will return a drop followed by a create.
	 * 
	 * @param sequenceName
	 *           name of the sequence.
	 * @param increment
	 *           increment value.
	 * @param minimum
	 *           minimum value.
	 * @param maximum
	 *           maximum value.
	 * @param restart
	 *           start value.
	 * @param cache
	 *           cache value, how many sequences should be preallocated.
	 * @param cycleClause
	 *           true if the sequence should wrap around when the max-/minvalue has been reached.
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @return the sql command
	 */
	public static String[] getSimulatedAlterSequenceSQL(String sequenceName, String increment, String minimum,
		String maximum, String restart, String cache, boolean cycle, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc" id="L2251">		final ArrayList&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>

		// Since dialect doesn't support altering sequences, drop then
		// re-create.
<span class="nc" id="L2255">		result.add(dialect.getDropSequenceSQL(sequenceName, false, qualifier, prefs));</span>
<span class="nc" id="L2256">		result.add(dialect.getCreateSequenceSQL(sequenceName, increment, minimum, maximum, minimum, cache,</span>
			cycle, qualifier, prefs));

<span class="nc" id="L2259">		return result.toArray(new String[result.size()]);</span>
	}

	/**
	 * Gets the SQL command to insert data into a table.
	 * &lt;p/&gt;
	 * If the list of columns is empty or null the SQL will look like: INSERT INTO tablename query;
	 * &lt;p/&gt;
	 * instead of: INSERT INTO tablename ( column1, column2, ... ) query;
	 * 
	 * @param tableName
	 *           simple name of the table
	 * @param columns
	 *           columns of the table
	 * @param query
	 *           the query that retrieves the values to insert
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 * @return
	 */
	public static String getInsertIntoSQL(String tableName, List&lt;String&gt; columns, String query,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc bnc" id="L2285" title="All 4 branches missed.">		if (query == null || query.length() == 0) { return &quot;&quot;; }</span>

		// INSERT INTO tableName (column1, column2)
		// query;
<span class="nc" id="L2289">		final StringBuilder sql = new StringBuilder();</span>

<span class="nc" id="L2291">		sql.append(DialectUtils.INSERT_INTO_CLAUSE + &quot; &quot;);</span>
<span class="nc" id="L2292">		sql.append(shapeQualifiableIdentifier(tableName, qualifier, prefs, dialect));</span>
<span class="nc bnc" id="L2293" title="All 4 branches missed.">		if (columns != null &amp;&amp; !columns.isEmpty())</span>
		{
<span class="nc" id="L2295">			sql.append(&quot; (&quot;);</span>
<span class="nc bnc" id="L2296" title="All 2 branches missed.">			for (final String column : columns)</span>
			{
<span class="nc" id="L2298">				sql.append(shapeIdentifier(column, prefs, dialect)).append(&quot;, &quot;);</span>
<span class="nc" id="L2299">			}</span>
<span class="nc" id="L2300">			sql.setLength(sql.length() - 2);</span>
<span class="nc" id="L2301">			sql.append(&quot;)&quot;);</span>
		}
<span class="nc" id="L2303">		sql.append(&quot;\n&quot;);</span>

<span class="nc" id="L2305">		sql.append(&quot; &quot;).append(query);</span>

<span class="nc" id="L2307">		return sql.toString();</span>
	}

	/**
	 * Returns the update SQL for the specified table and values, using either a correlated sub-query (if
	 * fromTables != null) in one statement, or setValues (if fromTables == null) and returning an update SQL
	 * using each setValue.
	 * 
	 * @param st
	 *           The StringTemplate that provides the form for the SQL (some dbs allow table name aliases, some
	 *           don't, etc.)
	 * @param tableName
	 *           simple name of the table
	 * @param setColumns
	 *           columns to be set
	 * @param setValues
	 *           values the columns should be set with
	 * @param fromTables
	 *           simple names of the tables in the FROM clause
	 * @param whereColumns
	 *           columns in the WHERE clause
	 * @param whereValues
	 *           values of the columns in the WHERE clause
	 * @param qualifier
	 *           qualifier of the table
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           the dialect to use
	 * @return a String array of one or more SQL statements
	 */
	public static String[] getUpdateSQL(StringTemplate st, String destTableName, String[] setColumns,
		String[] setValues, String[] fromTables, String[] whereColumns, String[] whereValues,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc bnc" id="L2342" title="All 12 branches missed.">		if ((setColumns == null &amp;&amp; setValues == null)</span>
<span class="nc" id="L2343">			|| (setColumns != null &amp;&amp; setValues != null &amp;&amp; setColumns.length == 0 &amp;&amp; setValues.length == 0)) { return new String[] {}; }</span>
<span class="nc bnc" id="L2344" title="All 12 branches missed.">		if (fromTables == null</span>
			&amp;&amp; ((setColumns != null &amp;&amp; setValues != null &amp;&amp; setColumns.length != setValues.length)
<span class="nc" id="L2346">				|| setColumns == null || setValues == null)) { throw new IllegalArgumentException(</span>
			&quot;The amount of SET columns and values must be the same!&quot;); }
<span class="nc bnc" id="L2348" title="All 14 branches missed.">		if ((whereColumns != null &amp;&amp; whereValues != null &amp;&amp; whereColumns.length != whereValues.length)</span>
<span class="nc" id="L2349">			|| (whereColumns == null &amp;&amp; whereValues != null) || (whereColumns != null &amp;&amp; whereValues == null)) { throw new IllegalArgumentException(</span>
			&quot;The amount of WHERE columns and values must be the same!&quot;); }
<span class="nc bnc" id="L2351" title="All 4 branches missed.">		if (fromTables == null &amp;&amp; setValues == null) { throw new IllegalArgumentException(</span>
			&quot;One of fromTables or setValues args must be non-null&quot;); }

		// Since we can use a correlated sub-query to update all rows in one
		// statement, we don't care about the
		// set values, unless fromTables is null, in which case we go with a
		// normal update. Using the set
		// values would require an update statement for each row in the merged
		// table for each column that was
		// merged in, which is incredibly inefficient. However, the API is
		// intended to support database
		// dialects that can't handle correlated sub-queries.

<span class="nc" id="L2364">		final ArrayList&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
		// String templateStr = null;
<span class="nc" id="L2366">		String columnName = null;</span>
<span class="nc" id="L2367">		String whereColumnName = null;</span>
<span class="nc" id="L2368">		String whereValueName = null;</span>

		// if (fromTables != null) {
		// // update &lt;destTableName&gt; dest
		// // set &lt;setColumnName&gt; = (
		// // select s.&lt;setColumnName&gt;
		// // from &lt;sourceTableName&gt; f where f.&lt;whereColumn&gt; = s.&lt;whereValue&gt;)
		//
		// templateStr =
		// &quot;UPDATE $destTableName$ dest SET $columnName$ = &quot; +
		// &quot;(SELECT src.$columnName$ &quot; +
		// &quot;FROM $sourceTableName$ src &quot; +
		// &quot;where src.$whereColumnName$ = dest.$whereValue$)&quot;;
		// } else {
		// // update &lt;destTableName&gt; dest
		// // set &lt;setColumnName&gt; = &lt;setValue&gt;
		// // where f.&lt;whereColumn&gt; = s.&lt;whereValue&gt;)
		//
		// templateStr =
		// &quot;UPDATE $destTableName$ &quot; +
		// &quot;SET $columnName$ = $columnValue$ &quot; +
		// &quot;where $whereColumnName$ = $whereValue$&quot;;
		// }

<span class="nc bnc" id="L2392" title="All 2 branches missed.">		for (int idx = 0; idx &lt; setColumns.length; idx++)</span>
		{
<span class="nc" id="L2394">			columnName = setColumns[idx]; // desc_t1</span>

<span class="nc" id="L2396">			whereColumnName = whereColumns[idx]; // myid</span>
<span class="nc" id="L2397">			whereValueName = whereValues[idx]; // myid</span>
			// StringTemplate st = new StringTemplate(templateStr);

<span class="nc" id="L2400">			st.setAttribute(ST_DEST_TABLE_NAME_KEY, destTableName);</span>
<span class="nc" id="L2401">			st.setAttribute(ST_COLUMN_NAME_KEY, columnName);</span>
<span class="nc bnc" id="L2402" title="All 2 branches missed.">			if (fromTables != null)</span>
			{
<span class="nc" id="L2404">				st.setAttribute(ST_SOURCE_TABLE_NAME_KEY, fromTables[idx]);</span>
			}
			else
			{
<span class="nc" id="L2408">				st.setAttribute(ST_COLUMN_VALUE_KEY, setValues[idx]);</span>
			}
<span class="nc" id="L2410">			st.setAttribute(ST_WHERE_COLUMN_NAME_KEY, whereColumnName);</span>
<span class="nc" id="L2411">			st.setAttribute(ST_WHERE_VALUE_KEY, whereValueName);</span>
<span class="nc" id="L2412">			result.add(st.toString());</span>
		}

<span class="nc" id="L2415">		return result.toArray(new String[result.size()]);</span>
	}

	private static void addConstraintsSQLs(List&lt;String&gt; sqls, List&lt;String&gt; allconstraints,
		List&lt;String&gt; sqlsToAdd, CreateScriptPreferences prefs)
	{
<span class="nc bnc" id="L2421" title="All 2 branches missed.">		if (sqlsToAdd.size() &gt; 0)</span>
		{
<span class="nc bnc" id="L2423" title="All 2 branches missed.">			if (prefs.isConstraintsAtEnd())</span>
			{
<span class="nc" id="L2425">				allconstraints.addAll(sqlsToAdd);</span>
			}
			else
			{
<span class="nc" id="L2429">				sqls.addAll(sqlsToAdd);</span>
			}
		}
<span class="nc" id="L2432">	}</span>

	/**
	 * Get a list of statements needed to create indexes for the specified table
	 * 
	 * @param ti
	 * @param md
	 * @param primaryKeys
	 *           can be null
	 * @param prefs
	 * @return
	 */
	public static List&lt;String&gt; createIndexes(ITableInfo ti, String destSimpleTableName, String destSchema, ISQLDatabaseMetaData md,
                                            List&lt;PrimaryKeyInfo&gt; primaryKeys, CreateScriptPreferences prefs)
	{
<span class="nc bnc" id="L2447" title="All 2 branches missed.">		if (ti == null) { throw new IllegalArgumentException(&quot;ti cannot be null&quot;); }</span>
<span class="nc bnc" id="L2448" title="All 2 branches missed.">		if (md == null) { throw new IllegalArgumentException(&quot;md cannot be null&quot;); }</span>
<span class="nc" id="L2449">		final List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L2450" title="All 2 branches missed.">		if (ti.getDatabaseObjectType() == DatabaseObjectType.VIEW) { return result; }</span>

<span class="nc" id="L2452">		final List&lt;IndexColInfo&gt; pkCols = new ArrayList&lt;IndexColInfo&gt;();</span>
<span class="nc bnc" id="L2453" title="All 2 branches missed.">		if (primaryKeys != null)</span>
		{
<span class="nc bnc" id="L2455" title="All 2 branches missed.">			for (final PrimaryKeyInfo pkInfo : primaryKeys)</span>
			{
<span class="nc" id="L2457">				pkCols.add(new IndexColInfo(pkInfo.getColumnName()));</span>
<span class="nc" id="L2458">			}</span>
<span class="nc" id="L2459">			Collections.sort(pkCols, IndexColInfo.NAME_COMPARATOR);</span>
		}

<span class="nc" id="L2462">		List&lt;IndexInfo&gt; indexInfos = null;</span>
		try
		{
<span class="nc" id="L2465">			indexInfos = md.getIndexInfo(ti);</span>
		}
<span class="nc" id="L2467">		catch (final SQLException e)</span>
		{
			// i18n[DialectUtils.error.getprimarykey=Unable to get primary key
			// info for table {0}]
<span class="nc" id="L2471">			final String msg = s_stringMgr.getString(&quot;DialectUtils.error.getprimarykey&quot;, ti.getSimpleName());</span>
<span class="nc" id="L2472">			log.error(msg, e);</span>
<span class="nc" id="L2473">			return result;</span>
<span class="nc" id="L2474">		}</span>

		// Group all columns by index
<span class="nc" id="L2477">		final Hashtable&lt;String, TableIndexInfo&gt; buf = new Hashtable&lt;String, TableIndexInfo&gt;();</span>
<span class="nc bnc" id="L2478" title="All 2 branches missed.">		for (final IndexInfo indexInfo : indexInfos)</span>
		{
<span class="nc" id="L2480">			final String indexName = indexInfo.getSimpleName();</span>
<span class="nc bnc" id="L2481" title="All 2 branches missed.">			if (StringUtils.isEmpty(indexName))</span>
			{
<span class="nc" id="L2483">				continue;</span>
			}
<span class="nc" id="L2485">			final String columnName = indexInfo.getColumnName();</span>
<span class="nc bnc" id="L2486" title="All 2 branches missed.">			if (StringUtils.isEmpty(columnName))</span>
			{
<span class="nc" id="L2488">				continue;</span>
			}
<span class="nc" id="L2490">			final TableIndexInfo ixi = buf.get(indexName);</span>
<span class="nc bnc" id="L2491" title="All 2 branches missed.">			if (null == ixi)</span>
			{
<span class="nc" id="L2493">				final List&lt;IndexColInfo&gt; ixCols = new ArrayList&lt;IndexColInfo&gt;();</span>

<span class="nc" id="L2495">				ixCols.add(new IndexColInfo(columnName, indexInfo.getOrdinalPosition()));</span>
<span class="nc" id="L2496">				buf.put(indexName, new TableIndexInfo(indexInfo.getTableName(), indexInfo.getSchemaName(),</span>
<span class="nc bnc" id="L2497" title="All 2 branches missed.">					indexName, ixCols, !indexInfo.isNonUnique()));</span>
<span class="nc" id="L2498">			}</span>
			else
			{
<span class="nc" id="L2501">				ixi.cols.add(new IndexColInfo(indexInfo.getColumnName(), indexInfo.getOrdinalPosition()));</span>
			}
<span class="nc" id="L2503">		}</span>

<span class="nc" id="L2505">		final TableIndexInfo[] ixs = buf.values().toArray(new TableIndexInfo[buf.size()]);</span>
<span class="nc bnc" id="L2506" title="All 2 branches missed.">		for (final TableIndexInfo ix : ixs)</span>
		{
<span class="nc" id="L2508">			Collections.sort(ix.cols, IndexColInfo.NAME_COMPARATOR);</span>

<span class="nc bnc" id="L2510" title="All 2 branches missed.">			if (pkCols.equals(ix.cols))</span>
			{
				// Serveral DBs automatically create an index for primary key
				// fields
				// and return this index in getIndexInfo(). We remove this index
				// from the script
				// because it would break the script with an index already
				// exists error.
<span class="nc" id="L2518">				continue;</span>
			}

<span class="nc" id="L2521">			Collections.sort(ix.cols, IndexColInfo.ORDINAL_POSITION_COMPARATOR);</span>

<span class="nc" id="L2523">			final StringBuilder indexSQL = new StringBuilder();</span>
<span class="nc" id="L2524">			indexSQL.append(&quot;CREATE&quot;);</span>
<span class="nc bnc" id="L2525" title="All 2 branches missed.">			indexSQL.append(ix.unique ? &quot; UNIQUE &quot; : &quot; &quot;);</span>
<span class="nc" id="L2526">			indexSQL.append(&quot;INDEX &quot;);</span>
<span class="nc" id="L2527">			indexSQL.append(ix.ixName);</span>
<span class="nc" id="L2528">			indexSQL.append(&quot; ON &quot;);</span>

<span class="nc" id="L2530">			indexSQL.append(formatQualifIntern(destSimpleTableName, destSchema, prefs));</span>

<span class="nc bnc" id="L2532" title="All 2 branches missed.">			if (ix.cols.size() == 1)</span>
			{
<span class="nc" id="L2534">				indexSQL.append(&quot;(&quot;).append(ix.cols.get(0));</span>

<span class="nc bnc" id="L2536" title="All 2 branches missed.">				for (int j = 1; j &lt; ix.cols.size(); j++)</span>
				{
<span class="nc" id="L2538">					indexSQL.append(&quot;,&quot;).append(ix.cols.get(j));</span>
				}
			}
			else
			{
<span class="nc" id="L2543">				indexSQL.append(&quot;\n(\n&quot;);</span>
<span class="nc bnc" id="L2544" title="All 2 branches missed.">				for (int j = 0; j &lt; ix.cols.size(); j++)</span>
				{
<span class="nc" id="L2546">					indexSQL.append(&quot;  &quot;);</span>
<span class="nc" id="L2547">					indexSQL.append(ix.cols.get(j));</span>
<span class="nc bnc" id="L2548" title="All 2 branches missed.">					if (j &lt; ix.cols.size() - 1)</span>
					{
<span class="nc" id="L2550">						indexSQL.append(&quot;,\n&quot;);</span>
					}
					else
					{
<span class="nc" id="L2554">						indexSQL.append(&quot;\n&quot;);</span>
					}
				}
			}
<span class="nc" id="L2558">			indexSQL.append(&quot;)&quot;);</span>
<span class="nc" id="L2559">			result.add(indexSQL.toString());</span>
		}
<span class="nc" id="L2561">		return result;</span>
	}

	private static List&lt;String&gt; createConstraints(ITableInfo ti, List&lt;ITableInfo&gt; tables,
		CreateScriptPreferences prefs, ISQLDatabaseMetaData md) throws SQLException
	{

<span class="nc" id="L2568">		final List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L2569">		final StringBuffer sbToAppend = new StringBuffer();</span>

<span class="nc" id="L2571">		final ConstraintInfo[] cis = getConstraintInfos(ti, md);</span>

<span class="nc bnc" id="L2573" title="All 2 branches missed.">		for (final ConstraintInfo ci : cis)</span>
		{
<span class="nc bnc" id="L2575" title="All 2 branches missed.">			if (!prefs.isIncludeExternalReferences())</span>
			{
<span class="nc" id="L2577">				boolean found = false;</span>
<span class="nc bnc" id="L2578" title="All 2 branches missed.">				for (final ITableInfo table : tables)</span>
				{
<span class="nc bnc" id="L2580" title="All 2 branches missed.">					if (table.getSimpleName().equalsIgnoreCase(ci.pkTable))</span>
					{
<span class="nc" id="L2582">						found = true;</span>
<span class="nc" id="L2583">						break;</span>
					}
<span class="nc" id="L2585">				}</span>
<span class="nc bnc" id="L2586" title="All 2 branches missed.">				if (false == found)</span>
				{
<span class="nc" id="L2588">					continue;</span>
				}
			}

<span class="nc" id="L2592">			sbToAppend.append(&quot;ALTER TABLE &quot; + formatQualifIntern(ci.fkTable, ci.fkTableSchema, prefs) + &quot;\n&quot;);</span>
<span class="nc" id="L2593">			sbToAppend.append(&quot;ADD CONSTRAINT &quot; + ci.fkName + &quot;\n&quot;);</span>

<span class="nc bnc" id="L2595" title="All 2 branches missed.">			if (ci.fkCols.size() == 1)</span>
			{
<span class="nc" id="L2597">				sbToAppend.append(&quot;FOREIGN KEY (&quot;).append(ci.fkCols.get(0));</span>

<span class="nc bnc" id="L2599" title="All 2 branches missed.">				for (int j = 1; j &lt; ci.fkCols.size(); j++)</span>
				{
<span class="nc" id="L2601">					sbToAppend.append(&quot;,&quot;).append(ci.fkCols.get(j));</span>
				}
<span class="nc" id="L2603">				sbToAppend.append(&quot;)\n&quot;);</span>

<span class="nc" id="L2605">				sbToAppend.append(&quot;REFERENCES &quot; + formatQualifIntern(ci.pkTable, ci.pkTableSchema, prefs) + &quot;(&quot;);</span>
<span class="nc" id="L2606">				sbToAppend.append(ci.pkCols.get(0));</span>
<span class="nc bnc" id="L2607" title="All 2 branches missed.">				for (int j = 1; j &lt; ci.pkCols.size(); j++)</span>
				{
<span class="nc" id="L2609">					sbToAppend.append(&quot;,&quot;).append(ci.pkCols.get(j));</span>
				}
			}
			else
			{
<span class="nc" id="L2614">				sbToAppend.append(&quot;FOREIGN KEY\n&quot;);</span>
<span class="nc" id="L2615">				sbToAppend.append(&quot;(\n&quot;);</span>
<span class="nc bnc" id="L2616" title="All 2 branches missed.">				for (int j = 0; j &lt; ci.fkCols.size(); j++)</span>
				{
<span class="nc" id="L2618">					sbToAppend.append(&quot;  &quot;);</span>
<span class="nc" id="L2619">					sbToAppend.append(ci.fkCols.get(j));</span>
<span class="nc bnc" id="L2620" title="All 2 branches missed.">					if (j &lt; ci.fkCols.size() - 1)</span>
					{
<span class="nc" id="L2622">						sbToAppend.append(&quot;,&quot;);</span>
					}
<span class="nc" id="L2624">					sbToAppend.append(&quot;\n&quot;);</span>

				}
<span class="nc" id="L2627">				sbToAppend.append(&quot;)\n&quot;);</span>

<span class="nc" id="L2629">				sbToAppend.append(&quot;REFERENCES &quot;);</span>
<span class="nc" id="L2630">				sbToAppend.append(formatQualifIntern(ci.pkTable, ci.pkTableSchema, prefs));</span>
<span class="nc" id="L2631">				sbToAppend.append(&quot;\n&quot;);</span>
<span class="nc" id="L2632">				sbToAppend.append(&quot;(\n&quot;);</span>
<span class="nc bnc" id="L2633" title="All 2 branches missed.">				for (int j = 0; j &lt; ci.pkCols.size(); j++)</span>
				{
<span class="nc" id="L2635">					sbToAppend.append(&quot;  &quot;);</span>
<span class="nc" id="L2636">					sbToAppend.append(ci.pkCols.get(j));</span>
<span class="nc bnc" id="L2637" title="All 2 branches missed.">					if (j &lt; ci.pkCols.size() - 1)</span>
					{
<span class="nc" id="L2639">						sbToAppend.append(&quot;,&quot;);</span>
					}
<span class="nc" id="L2641">					sbToAppend.append(&quot;\n&quot;);</span>
				}
			}

<span class="nc" id="L2645">			sbToAppend.append(&quot;)&quot;);</span>

<span class="nc" id="L2647">			boolean overrideUpdate = prefs.isDeleteRefAction();</span>
<span class="nc" id="L2648">			String conditionClause = &quot; ON DELETE &quot;;</span>
<span class="nc" id="L2649">			String overrideAction = prefs.getRefActionByType(prefs.getDeleteAction());</span>
<span class="nc" id="L2650">			int rule = ci.deleteRule;</span>

<span class="nc" id="L2652">			final String onDeleteClause =</span>
<span class="nc" id="L2653">				constructFKContraintActionClause(overrideUpdate, conditionClause, overrideAction, rule);</span>

<span class="nc" id="L2655">			sbToAppend.append(onDeleteClause);</span>

<span class="nc" id="L2657">			overrideUpdate = prefs.isUpdateRefAction();</span>
<span class="nc" id="L2658">			conditionClause = &quot; ON UPDATE &quot;;</span>
<span class="nc" id="L2659">			overrideAction = prefs.getRefActionByType(prefs.getUpdateAction());</span>
<span class="nc" id="L2660">			rule = ci.updateRule;</span>

<span class="nc" id="L2662">			final String onUpdateClause =</span>
<span class="nc" id="L2663">				constructFKContraintActionClause(overrideUpdate, conditionClause, overrideAction, rule);</span>

<span class="nc" id="L2665">			sbToAppend.append(onUpdateClause);</span>
			// sbToAppend.append(&quot;\n&quot;);
<span class="nc" id="L2667">			result.add(sbToAppend.toString());</span>
<span class="nc" id="L2668">			sbToAppend.setLength(0);</span>
		}

<span class="nc" id="L2671">		return result;</span>
	}

	private static String formatQualifIntern(String table, String schema, CreateScriptPreferences prefs)
	{
<span class="nc" id="L2676">		return formatQualified(table, schema, prefs.isQualifyTableNames(), prefs.isUseDoubleQuotes());</span>
	}

	public static String formatQualified(String table, String schema, boolean qualifyTableNames,
		boolean useDoubleQuotes)
	{
<span class="nc bnc" id="L2682" title="All 6 branches missed.">		if (qualifyTableNames &amp;&amp; null != schema &amp;&amp; 0 &lt; schema.trim().length())</span>
		{
<span class="nc bnc" id="L2684" title="All 2 branches missed.">			if (useDoubleQuotes)</span>
			{
<span class="nc" id="L2686">				return &quot;\&quot;&quot; + schema + &quot;\&quot;.\&quot;&quot; + table + &quot;\&quot;&quot;;</span>
			}
			else
			{
<span class="nc" id="L2690">				return schema + &quot;.&quot; + table;</span>
			}
		}
		else
		{
<span class="nc" id="L2695">			return table;</span>
		}
	}

	private static String constructFKContraintActionClause(boolean override, String conditionClause,
		String overrideAction, int rule)
	{
		// Bug 2531193: Oracle create table script the &quot;ON UPDATE&quot; is wrong
<span class="nc" id="L2703">		final StringBuilder tmp = new StringBuilder();</span>
<span class="nc bnc" id="L2704" title="All 2 branches missed.">		if (override)</span>
		{
<span class="nc bnc" id="L2706" title="All 2 branches missed.">			if (&quot;NO ACTION&quot;.equals(overrideAction))</span>
			{
<span class="nc" id="L2708">				return &quot;&quot;;</span>
			}
			else
			{
<span class="nc" id="L2712">				tmp.append(conditionClause);</span>
<span class="nc" id="L2713">				tmp.append(overrideAction);</span>
<span class="nc" id="L2714">				return tmp.toString();</span>
			}
		}

<span class="nc bnc" id="L2718" title="All 4 branches missed.">		switch (rule)</span>
		{
		case DatabaseMetaData.importedKeyCascade:
<span class="nc" id="L2721">			tmp.append(conditionClause);</span>
<span class="nc bnc" id="L2722" title="All 2 branches missed.">			if (override)</span>
			{
<span class="nc" id="L2724">				tmp.append(overrideAction);</span>
			}
			else
			{
<span class="nc" id="L2728">				tmp.append(&quot;CASCADE&quot;);</span>
			}
<span class="nc" id="L2730">			break;</span>
		case DatabaseMetaData.importedKeySetNull:
<span class="nc bnc" id="L2732" title="All 2 branches missed.">			if (override)</span>
			{
<span class="nc" id="L2734">				tmp.append(overrideAction);</span>
			}
			else
			{
<span class="nc" id="L2738">				tmp.append(&quot;SET NULL&quot;);</span>
			}
<span class="nc" id="L2740">			break;</span>
		case DatabaseMetaData.importedKeySetDefault:
<span class="nc bnc" id="L2742" title="All 2 branches missed.">			if (override)</span>
			{
<span class="nc" id="L2744">				tmp.append(overrideAction);</span>
			}
			else
			{
<span class="nc" id="L2748">				tmp.append(&quot;SET DEFAULT&quot;);</span>
			}
<span class="nc" id="L2750">			break;</span>
		case DatabaseMetaData.importedKeyRestrict:
		case DatabaseMetaData.importedKeyNoAction:
		default:
			// Append nothing - standard says this is equivalent to NO ACTION
			// and some DBs
			// (e.g. Oracle don't accept ... NO ACTION)
		}
<span class="nc" id="L2758">		return tmp.toString();</span>
	}

	private static ConstraintInfo[] getConstraintInfos(ITableInfo ti, ISQLDatabaseMetaData md)
		throws SQLException
	{
<span class="nc" id="L2764">		final ArrayList&lt;ConstraintInfo&gt; ret = new ArrayList&lt;ConstraintInfo&gt;();</span>
<span class="nc" id="L2765">		final ForeignKeyInfo[] fkinfos = md.getImportedKeysInfo(ti);</span>
<span class="nc bnc" id="L2766" title="All 2 branches missed.">		for (final ForeignKeyInfo fkinfo : fkinfos)</span>
		{
<span class="nc" id="L2768">			final Vector&lt;String&gt; fkCols = new Vector&lt;String&gt;();</span>
<span class="nc" id="L2769">			final Vector&lt;String&gt; pkCols = new Vector&lt;String&gt;();</span>

<span class="nc bnc" id="L2771" title="All 2 branches missed.">			for (final ForeignKeyColumnInfo fkCol : fkinfo.getForeignKeyColumnInfo())</span>
			{
<span class="nc" id="L2773">				fkCols.add(fkCol.getForeignKeyColumnName());</span>
<span class="nc" id="L2774">				pkCols.add(fkCol.getPrimaryKeyColumnName());</span>
			}

<span class="nc" id="L2777">			final ConstraintInfo ci =</span>
<span class="nc" id="L2778">				new ConstraintInfo(fkinfo.getForeignKeyTableName(), fkinfo.getForeignKeySchemaName(),</span>
<span class="nc" id="L2779">					fkinfo.getPrimaryKeyTableName(), fkinfo.getPrimaryKeySchemaName(), fkinfo.getSimpleName(),</span>
<span class="nc" id="L2780">					fkCols, pkCols, (short) fkinfo.getDeleteRule(), (short) fkinfo.getUpdateRule());</span>

<span class="nc" id="L2782">			ret.add(ci);</span>

		}
<span class="nc" id="L2785">		return ret.toArray(new ConstraintInfo[ret.size()]);</span>
	}

	private static List&lt;PrimaryKeyInfo&gt; getPrimaryKeyInfo(ISQLDatabaseMetaData md, ITableInfo ti,
		boolean isJdbcOdbc)
	{
<span class="nc" id="L2791">		List&lt;PrimaryKeyInfo&gt; result = new ArrayList&lt;PrimaryKeyInfo&gt;();</span>
<span class="nc bnc" id="L2792" title="All 2 branches missed.">		if (isJdbcOdbc) { return result; }</span>
		try
		{
<span class="nc" id="L2795">			result = Arrays.asList(md.getPrimaryKey(ti));</span>
		}
<span class="nc" id="L2797">		catch (final SQLException e)</span>
		{
			// i18n[CreateTableScriptCommand.error.getprimarykey=Unable to get
			// primary key info for table {0}]
<span class="nc" id="L2801">			final String msg = s_stringMgr.getString(&quot;DialectUtils.error.getprimarykey&quot;, ti.getSimpleName());</span>
<span class="nc" id="L2802">			log.error(msg, e);</span>
<span class="nc" id="L2803">		}</span>
<span class="nc" id="L2804">		return result;</span>
	}

	private static List&lt;String&gt; getPKSequenceList(List&lt;PrimaryKeyInfo&gt; infos)
	{
<span class="nc" id="L2809">		final String[] result = new String[infos.size()];</span>
<span class="nc bnc" id="L2810" title="All 2 branches missed.">		for (final PrimaryKeyInfo info : infos)</span>
		{
<span class="nc" id="L2812">			final int iKeySeq = info.getKeySequence() - 1;</span>
<span class="nc" id="L2813">			result[iKeySeq] = info.getColumnName();</span>
<span class="nc" id="L2814">		}</span>
<span class="nc" id="L2815">		return Arrays.asList(result);</span>
	}

	/**
	 * Shapes the table name depending on the prefereneces. If isQualifyTableNames is true, the qualified name
	 * of the table is returned.
	 * 
	 * @param identifier
	 *           identifier to be shaped
	 * @param qualifier
	 *           qualifier of the identifier
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           hibernate dialect
	 * @return the shaped table name
	 */
	public static String shapeQualifiableIdentifier(String identifier, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc bnc" id="L2835" title="All 2 branches missed.">		if (prefs.isQualifyTableNames())</span>
		{
<span class="nc" id="L2837">			return dialect.getQualifiedIdentifier(identifier, qualifier, prefs);</span>
		}
		else
		{
<span class="nc" id="L2841">			return shapeIdentifier(identifier, prefs, dialect);</span>
		}
	}

	/**
	 * Shapes the identifier depending on the preferences. If isQuoteIdentifiers is true, the identifier is
	 * quoted with dialect-specific delimiters.
	 * 
	 * @param identifier
	 *           identifier to be shaped
	 * @param prefs
	 *           preferences for generated sql scripts
	 * @param dialect
	 *           hibernate dialect for the dialect specific quotes
	 * @return the shaped identifier
	 */
	public static String shapeIdentifier(String identifier, SqlGenerationPreferences prefs,
		HibernateDialect dialect)
	{
<span class="nc bnc" id="L2860" title="All 2 branches missed.">		if (prefs.isQuoteIdentifiers())</span>
		{
<span class="nc" id="L2862">			return dialect.openQuote() + identifier + dialect.closeQuote();</span>
		}
		else
		{
<span class="nc" id="L2866">			return identifier;</span>
		}
	}

	/**
	 * @param column
	 * @param qualifier
	 * @param prefs
	 * @param dialect
	 * @return
	 */
	public static String[] getAddSimulatedAutoIncrementColumn(TableColumnInfo column,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs, HibernateDialect dialect)
	{
<span class="nc" id="L2880">		final ArrayList&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L2881">		final String tableName = shapeQualifiableIdentifier(column.getTableName(), qualifier, prefs, dialect);</span>
<span class="nc" id="L2882">		final String columnName = shapeIdentifier(column.getColumnName(), prefs, dialect);</span>
<span class="nc" id="L2883">		final String sequenceName = shapeIdentifier(tableName + &quot;_&quot; + columnName + &quot;_&quot; + &quot;seq&quot;, prefs, dialect);</span>

		// TODO Probably want to allow the user to set these sequence properties
		// ??
		// Sequence settings.
<span class="nc" id="L2888">		final String sequenceIncrement = &quot;1&quot;;</span>
<span class="nc" id="L2889">		final String minimum = &quot;1&quot;;</span>
<span class="nc" id="L2890">		final String maximum = null;</span>
<span class="nc" id="L2891">		final String start = &quot;1&quot;;</span>
<span class="nc" id="L2892">		final String cacheClause = null;</span>
<span class="nc" id="L2893">		final boolean cycle = false;</span>

<span class="nc" id="L2895">		result.add(dialect.getCreateSequenceSQL(sequenceName, sequenceIncrement, minimum, maximum, start,</span>
			cacheClause, cycle, qualifier, prefs));

<span class="nc" id="L2898">		final StringBuilder triggerSql = new StringBuilder();</span>
<span class="nc" id="L2899">		triggerSql.append(&quot;CREATE TRIGGER &quot;);</span>
<span class="nc" id="L2900">		triggerSql.append(columnName);</span>
<span class="nc" id="L2901">		triggerSql.append(&quot;_trigger \n&quot;);</span>
<span class="nc" id="L2902">		triggerSql.append(&quot;NO CASCADE BEFORE INSERT ON &quot;);</span>
<span class="nc" id="L2903">		triggerSql.append(tableName);</span>
<span class="nc" id="L2904">		triggerSql.append(&quot; REFERENCING NEW AS n \n&quot;);</span>
<span class="nc" id="L2905">		triggerSql.append(&quot;FOR EACH ROW \n&quot;);</span>
<span class="nc" id="L2906">		triggerSql.append(&quot;SET n.&quot;);</span>
<span class="nc" id="L2907">		triggerSql.append(columnName);</span>
<span class="nc" id="L2908">		triggerSql.append(&quot; = NEXTVAL FOR &quot;);</span>
<span class="nc" id="L2909">		triggerSql.append(sequenceName);</span>

<span class="nc" id="L2911">		result.add(triggerSql.toString());</span>

<span class="nc" id="L2913">		return result.toArray(new String[result.size()]);</span>

	}

	/**
	 * Returns the SQL statement to use to add a column to the specified table using the information about the
	 * new column specified by info.
	 * 
	 * @param info
	 *           information about the new column such as type, name, etc.
	 * @param dialect
	 *           the HibernateDialect to use to resolve the type
	 * @param addDefaultClause
	 *           whether or not the dialect's SQL supports a DEFAULT clause for columns.
	 * @param addNullClause
	 *           whether or not to add the NULL / NOT NULL clause
	 * @return
	 * @throws UnsupportedOperationException
	 *            if the database doesn't support adding columns after a table has already been created.
	 */
	public static String getAddColumSQL(TableColumnInfo info, HibernateDialect dialect,
		boolean addDefaultClause, boolean supportsNullQualifier, boolean addNullClause,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs)
		throws UnsupportedOperationException, HibernateException
	{
<span class="nc" id="L2938">		final StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L2939">		result.append(DialectUtils.ALTER_TABLE_CLAUSE + &quot; &quot;);</span>
<span class="nc" id="L2940">		result.append(shapeQualifiableIdentifier(info.getTableName(), qualifier, prefs, dialect));</span>
<span class="nc" id="L2941">		result.append(&quot; &quot;);</span>
<span class="nc" id="L2942">		result.append(dialect.getAddColumnString().toUpperCase());</span>

<span class="nc" id="L2944">		result.append(&quot; &quot;);</span>
<span class="nc bnc" id="L2945" title="All 2 branches missed.">		if (prefs.isQuoteColumnNames())</span>
		{
<span class="nc" id="L2947">			result.append(shapeIdentifier(info.getColumnName(), prefs, dialect));</span>
		}
		else
		{
<span class="nc" id="L2951">			result.append(info.getColumnName());</span>
		}
<span class="nc" id="L2953">		result.append(&quot; &quot;);</span>
<span class="nc" id="L2954">		result.append(dialect.getTypeName(info.getDataType(), info.getColumnSize(), info.getColumnSize(),</span>
<span class="nc" id="L2955">			info.getDecimalDigits()));</span>

<span class="nc bnc" id="L2957" title="All 2 branches missed.">		if (addDefaultClause)</span>
		{
<span class="nc" id="L2959">			appendDefaultClause(info, result);</span>
		}
<span class="nc bnc" id="L2961" title="All 2 branches missed.">		if (addNullClause)</span>
		{
<span class="nc bnc" id="L2963" title="All 2 branches missed.">			if (info.isNullable().equals(&quot;NO&quot;))</span>
			{
<span class="nc" id="L2965">				result.append(&quot; NOT NULL &quot;);</span>
			}
			else
			{
<span class="nc bnc" id="L2969" title="All 2 branches missed.">				if (supportsNullQualifier)</span>
				{
<span class="nc" id="L2971">					result.append(&quot; NULL &quot;);</span>
				}
			}
		}
<span class="nc" id="L2975">		return result.toString();</span>
	}

	private static void bindAttribute(HibernateDialect dialect, StringTemplate st, String key, String value,
		DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs)
	{
<span class="nc bnc" id="L2981" title="All 4 branches missed.">		if (value == null || &quot;&quot;.equals(value)) { return; }</span>
<span class="nc bnc" id="L2982" title="All 2 branches missed.">		if (ST_TABLE_NAME_KEY.equals(key))</span>
		{
<span class="nc" id="L2984">			value = DialectUtils.shapeQualifiableIdentifier(value, qualifier, prefs, dialect);</span>
		}
<span class="nc bnc" id="L2986" title="All 2 branches missed.">		if (ST_VIEW_NAME_KEY.equals(key))</span>
		{
<span class="nc" id="L2988">			value = DialectUtils.shapeQualifiableIdentifier(value, qualifier, prefs, dialect);</span>
		}
<span class="nc bnc" id="L2990" title="All 2 branches missed.">		if (ST_OLD_OBJECT_NAME_KEY.equals(key))</span>
		{
<span class="nc" id="L2992">			value = DialectUtils.shapeQualifiableIdentifier(value, qualifier, prefs, dialect);</span>
		}
<span class="nc bnc" id="L2994" title="All 2 branches missed.">		if (ST_NEW_OBJECT_NAME_KEY.equals(key))</span>
		{
<span class="nc" id="L2996">			value = DialectUtils.shapeQualifiableIdentifier(value, qualifier, prefs, dialect);</span>
		}
<span class="nc bnc" id="L2998" title="All 4 branches missed.">		if (ST_COLUMN_NAME_KEY.equals(key) &amp;&amp; prefs.isQuoteColumnNames())</span>
		{
<span class="nc" id="L3000">			value = DialectUtils.shapeIdentifier(value, prefs, dialect);</span>
		}
<span class="nc" id="L3002">		st.setAttribute(key, value);</span>
<span class="nc" id="L3003">	}</span>

	public static String bindAttributes(HibernateDialect dialect, StringTemplate st,
		HashMap&lt;String, String&gt; valuesMap, DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs)
	{
<span class="nc bnc" id="L3008" title="All 2 branches missed.">		for (final Entry&lt;String, String&gt; entry : valuesMap.entrySet())</span>
		{
<span class="nc" id="L3010">			final String key = entry.getKey();</span>
<span class="nc" id="L3011">			final String value = entry.getValue();</span>
<span class="nc" id="L3012">			bindAttribute(dialect, st, key, value, qualifier, prefs);</span>
<span class="nc" id="L3013">		}</span>

<span class="nc" id="L3015">		return st.toString();</span>
	}

	/**
	 * @param dialect
	 * @param st
	 * @param valuesMap
	 * @param qualifier
	 * @param prefs
	 * @return
	 */
	public static String bindTemplateAttributes(HibernateDialect dialect, StringTemplate st,
		HashMap&lt;String, String&gt; valuesMap, DatabaseObjectQualifier qualifier, SqlGenerationPreferences prefs)
	{
<span class="nc" id="L3029">		bindAttributes(dialect, st, valuesMap, qualifier, prefs);</span>
<span class="nc" id="L3030">		return st.toString();</span>
	}

	/**
	 * @param dialect
	 *           the dialect that this attribute binding is meant for
	 * @param st
	 *           the String template
	 * @param valuesMap
	 *           a map of key/value pairs to bind into the template
	 * @param columns
	 *           the TableColumnInfos to use for column names in the column list
	 * @param qualifier
	 *           the specifics regarding schema / catalog
	 * @param prefs
	 *           user's preferences regarding qualifying identifiers
	 * @return the SQL result of binding key/values and column list into the specified template
	 */
	public static String bindTemplateAttributes(HibernateDialect dialect, StringTemplate st,
		HashMap&lt;String, String&gt; valuesMap, TableColumnInfo[] columns, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs)
	{
<span class="nc" id="L3052">		bindAttributes(dialect, st, valuesMap, qualifier, prefs);</span>
<span class="nc bnc" id="L3053" title="All 2 branches missed.">		for (final TableColumnInfo column : columns)</span>
		{
<span class="nc" id="L3055">			bindAttribute(dialect, st, ST_COLUMN_NAME_KEY, column.getColumnName(), qualifier, prefs);</span>
		}
<span class="nc" id="L3057">		return st.toString();</span>
	}

	public static String bindTemplateAttributes(HibernateDialect dialect, StringTemplate st,
		HashMap&lt;String, String&gt; valuesMap, String[] columns, DatabaseObjectQualifier qualifier,
		SqlGenerationPreferences prefs)
	{
<span class="nc" id="L3064">		bindAttributes(dialect, st, valuesMap, qualifier, prefs);</span>
<span class="nc bnc" id="L3065" title="All 2 branches missed.">		for (final String column : columns)</span>
		{
<span class="nc" id="L3067">			bindAttribute(dialect, st, ST_COLUMN_NAME_KEY, column, qualifier, prefs);</span>
		}
<span class="nc" id="L3069">		return st.toString();</span>
	}

	public static HashMap&lt;String, String&gt; getValuesMap(Object... elts)
	{
<span class="nc" id="L3074">		final HashMap&lt;String, String&gt; valuesMap = new HashMap&lt;String, String&gt;();</span>
<span class="nc bnc" id="L3075" title="All 2 branches missed.">		for (int i = 0; i &lt; elts.length - 1; i++)</span>
		{
<span class="nc" id="L3077">			valuesMap.put(elts[i].toString(), elts[i + 1].toString());</span>
		}
<span class="nc" id="L3079">		return valuesMap;</span>
	}

	public static boolean isNotEmptyString(String value)
	{
<span class="nc bnc" id="L3084" title="All 4 branches missed.">		return (value != null) &amp;&amp; (!&quot;&quot;.equals(value));</span>
	}

	/**
	 * This allows to counteract the effects of quoting identifiers in odd cases where the dialect may not
	 * allow it.
	 * 
	 * @param dialect
	 *           the dialect to use to determine the open and close quotes
	 * @param identifier
	 *           the identifier to look for to remove quotes from
	 * @param strWithQuotes
	 *           the string which contains the identifier and may or may not have quotes.
	 * @return the string with quotes stripped from any occurrences of the specified identifier.
	 */
	public static String stripQuotesFromIdentifier(HibernateDialect dialect, String identifier,
		String strWithQuotes)
	{
		// Strip quotes from the column name
<span class="nc" id="L3103">		final StringBuilder tmp = new StringBuilder(&quot;\\&quot; + dialect.openQuote());</span>
<span class="nc" id="L3104">		tmp.append(identifier);</span>
<span class="nc" id="L3105">		tmp.append(&quot;\\&quot; + dialect.closeQuote());</span>
<span class="nc" id="L3106">		return strWithQuotes.replaceAll(tmp.toString(), identifier);</span>
	}

	/**
	 * Converts the specified byte array into a String containing hex characters that represent the nibbles
	 * that form the butes in the array.
	 * 
	 * @param bytes
	 *           the byte array to convert
	 * @return a hex string representing the bytes in the specified byte array.
	 */
	public static String toHexString(byte[] bytes)
	{
<span class="nc" id="L3119">		final char[] hexArray =</span>
			{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
<span class="nc" id="L3121">		final char[] hexChars = new char[bytes.length * 2];</span>
		int v;
<span class="nc bnc" id="L3123" title="All 2 branches missed.">		for (int j = 0; j &lt; bytes.length; j++)</span>
		{
<span class="nc" id="L3125">			v = bytes[j] &amp; 0xFF;</span>
<span class="nc" id="L3126">			hexChars[j * 2] = hexArray[v / 16];</span>
<span class="nc" id="L3127">			hexChars[j * 2 + 1] = hexArray[v % 16];</span>
		}
<span class="nc" id="L3129">		return new String(hexChars);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>