<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RowDataInputFrame.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">102_squirrel-sql</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.squirrel_sql.fw.datasetviewer</a> &gt; <span class="el_source">RowDataInputFrame.java</span></div><h1>RowDataInputFrame.java</h1><pre class="source lang-java linenums">package net.sourceforge.squirrel_sql.fw.datasetviewer;
/*
 * Copyright (C) 2001-2002 Colin Bell
 * colbell@users.sourceforge.net
 * Modifications copyright (C) 2001-2002 Johan Compagner
 * jcompagner@j-com.nl
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.Component;
import java.awt.Color;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.Point;
import java.awt.Dimension;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumnModel;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;

import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.CellComponentFactory;
import net.sourceforge.squirrel_sql.fw.sql.JDBCTypeMapper;
import net.sourceforge.squirrel_sql.fw.util.StringManager;
import net.sourceforge.squirrel_sql.fw.util.StringManagerFactory;

/**
 * @author gwg
 *
 * This is the frame that gets data from the user for creating
 * a new row in a table.
 */
public class RowDataInputFrame extends JDialog
	implements ActionListener {


<span class="nc" id="L56">	private static final StringManager s_stringMgr =</span>
<span class="nc" id="L57">		StringManagerFactory.getStringManager(RowDataInputFrame.class);</span>

	// object that called us and that we want to return data to when done
	DataSetViewerEditableTablePanel _caller;

	// the table containing the user's input
	RowDataJTable table;

	/**
	 * ctor.
	 */
	public RowDataInputFrame(Component comp, ColumnDisplayDefinition[] colDefs,
									 Object[] initialValues,
									 DataSetViewerEditableTablePanel caller) {

		// i18n[rowDataInputFrame.propName=Input New Row Data]
<span class="nc" id="L73">		super(SwingUtilities.windowForComponent(comp), s_stringMgr.getString(&quot;rowDataInputFrame.propName&quot;));</span>

		// get the ConentPane into a variable for convenience
<span class="nc" id="L76">		Container pane = getContentPane();</span>

		// save data passed in to us	
<span class="nc" id="L79">		_caller = caller;</span>

		// set layout
<span class="nc" id="L82">		pane.setLayout(new BorderLayout());</span>

		// create the JTable for input and put in the top of window
<span class="nc" id="L85">		table = new RowDataJTable(colDefs, initialValues);</span>
		// tell scrollpane to use table size with the height adjusted to leave
		// room for the scrollbar at the bottom if needed
<span class="nc" id="L88">		Dimension tableDim = table.getPreferredSize();</span>
<span class="nc" id="L89">		tableDim.setSize(tableDim.getWidth(), tableDim.getHeight() + 15);</span>
<span class="nc" id="L90">		table.setPreferredScrollableViewportSize(tableDim);</span>
<span class="nc" id="L91">		JScrollPane scrollPane = new JScrollPane(table);</span>

		// add row headers to help user understand what the second row is
<span class="nc" id="L94">		JPanel rowHeaderPanel = new JPanel();</span>
<span class="nc" id="L95">		rowHeaderPanel.setLayout(new BorderLayout());</span>
		// i18n[rowDataInputFrame.data=Data]
<span class="nc" id="L97">		JTextArea r1 = new JTextArea(s_stringMgr.getString(&quot;rowDataInputFrame.data&quot;), 1, 10);</span>
<span class="nc" id="L98">		r1.setBackground(Color.lightGray);</span>
<span class="nc" id="L99">		r1.setBorder(BorderFactory.createLineBorder(Color.black));</span>
<span class="nc" id="L100">		r1.setEditable(false);</span>
<span class="nc" id="L101">		rowHeaderPanel.add(r1, BorderLayout.NORTH);</span>
		// i18n[rowDataInputFrame.colDescription=\nColumn\nDescription\n]
<span class="nc" id="L103">		JTextArea r2 = new JTextArea(s_stringMgr.getString(&quot;rowDataInputFrame.colDescription&quot;), 4, 10);</span>
<span class="nc" id="L104">		r2.setBackground(Color.lightGray);</span>
<span class="nc" id="L105">		r2.setBorder(BorderFactory.createLineBorder(Color.black));</span>
<span class="nc" id="L106">		r2.setEditable(false);</span>
<span class="nc" id="L107">		rowHeaderPanel.add(r2, BorderLayout.CENTER);</span>
<span class="nc" id="L108">		scrollPane.setRowHeaderView(rowHeaderPanel);</span>

<span class="nc" id="L110">		pane.add(scrollPane, BorderLayout.NORTH);</span>

		// create the buttons for input done and cancel
<span class="nc" id="L113">		JPanel buttonPanel = new JPanel();</span>


		// i18n[rowDataInputFrame.insert=Insert]
<span class="nc" id="L117">		JButton insertButton = new JButton(s_stringMgr.getString(&quot;rowDataInputFrame.insert&quot;));</span>
<span class="nc" id="L118">		buttonPanel.add(insertButton);</span>
<span class="nc" id="L119">		insertButton.setActionCommand(&quot;insert&quot;);</span>
<span class="nc" id="L120">		insertButton.addActionListener(this);</span>

		// i18n[rowDataInputFrame.cancel=Cancel]
<span class="nc" id="L123">		JButton cancelButton = new JButton(s_stringMgr.getString(&quot;rowDataInputFrame.cancel&quot;));</span>
<span class="nc" id="L124">		buttonPanel.add(cancelButton);</span>
<span class="nc" id="L125">		cancelButton.setActionCommand(&quot;cancel&quot;);</span>
<span class="nc" id="L126">		cancelButton.addActionListener(this);</span>

<span class="nc" id="L128">		pane.add(buttonPanel, BorderLayout.SOUTH);</span>

		// this frame should really go away when done
<span class="nc" id="L131">		setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);</span>

		// display the frame
<span class="nc" id="L134">		pack();</span>
<span class="nc" id="L135">		setVisible(true);</span>

<span class="nc" id="L137">	}</span>

	/**
	 * Handle actions on the buttons 
	 */
	public void actionPerformed(ActionEvent e) {

<span class="nc bnc" id="L144" title="All 2 branches missed.">		if (e.getActionCommand().equals(&quot;cancel&quot;)) {</span>
<span class="nc" id="L145">			setVisible(false);</span>
<span class="nc" id="L146">			dispose();</span>
<span class="nc" id="L147">			return;</span>
		}
<span class="nc bnc" id="L149" title="All 2 branches missed.">		else if ( ! e.getActionCommand().equals(&quot;insert&quot;)) {</span>
<span class="nc" id="L150">			return;	// do not recognize this button request</span>
		}

		// user said to insert, so collect all the data from the
		// JTable and send it to the DataSetViewer for insertion
		// into DB and on-screen tables

		// first make sure that user's last input has been included
		// (It is too easy for user to enter data and forget to click
		// on another field to force it to be set.)
<span class="nc bnc" id="L160" title="All 2 branches missed.">		if (table.isEditing()) {</span>
<span class="nc" id="L161">			int col = table.getEditingColumn();</span>
<span class="nc" id="L162">			table.getCellEditor(0, col).stopCellEditing();</span>
		}

<span class="nc" id="L165">		Object[] rowData = new Object[table.getModel().getColumnCount()];</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">		for (int i=0; i&lt; table.getModel().getColumnCount(); i++) {</span>
<span class="nc" id="L167">			rowData[i] = table.getValueAt(0, i);</span>
		}

		// put the data into the DB and the on-screen JTable.
		// If there was a failure, do not make this form
		// go away since the user may be able to fix the problem
		// by changing the data.
<span class="nc bnc" id="L174" title="All 2 branches missed.">		if (_caller.insertRow(rowData) == null) {</span>
			// the insert worked, so make this input form go away
<span class="nc" id="L176">			setVisible(false);</span>
<span class="nc" id="L177">			dispose();</span>
		}
<span class="nc" id="L179">	}</span>

	/**
	 * JTable for use in creating data for insertion.
	 */
	class RowDataJTable extends JTable {
<span class="nc" id="L185">		private ColumnDisplayDefinition[] _colDefs = null;</span>

		/**
		 * constructor
		 */
<span class="nc" id="L190">		protected  RowDataJTable(ColumnDisplayDefinition[] colDefs, Object[] initalValues) {</span>

<span class="nc" id="L192">			super();</span>
<span class="nc" id="L193">			setModel(new RowDataModel(colDefs, initalValues));</span>

			// create column model

<span class="nc" id="L197">			final String data = &quot;THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG&quot;;</span>
<span class="nc" id="L198">			final int _multiplier =</span>
<span class="nc" id="L199">				getFontMetrics(getFont()).stringWidth(data) / data.length();</span>

<span class="nc" id="L201">			TableColumnModel cm = new DefaultTableColumnModel();</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">			for (int i = 0; i &lt; colDefs.length; ++i)</span>
			{
<span class="nc" id="L204">				ColumnDisplayDefinition colDef = colDefs[i];</span>
<span class="nc" id="L205">				int colWidth = colDef.getDisplayWidth() * _multiplier;</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">				if (colWidth &gt; IDataSetViewer.MAX_COLUMN_WIDTH * _multiplier)</span>
				{
<span class="nc" id="L208">					colWidth = IDataSetViewer.MAX_COLUMN_WIDTH * _multiplier;</span>
				}

<span class="nc" id="L211">				TableColumn col = new TableColumn(i, colWidth,</span>
<span class="nc" id="L212">					CellComponentFactory.getTableCellRenderer(colDefs[i]), null);</span>
<span class="nc" id="L213">				col.setHeaderValue(colDef.getColumnName());</span>
<span class="nc" id="L214">				cm.addColumn(col);</span>
			}

<span class="nc" id="L217">			setColumnModel(cm);</span>

<span class="nc" id="L219">			_colDefs = colDefs;</span>

			// set up cell editors on first row
<span class="nc bnc" id="L222" title="All 2 branches missed.">			for (int i=0; i&lt; colDefs.length; i++) {</span>
<span class="nc" id="L223">				cm.getColumn(i).setCellEditor(</span>
<span class="nc" id="L224">					CellComponentFactory.getInCellEditor(this, _colDefs[i]));</span>
			}


			// the second row contains a multi-line description,
			// so make that row high enough to display it
<span class="nc" id="L230">			setRowHeight(1, 80);</span>

<span class="nc" id="L232">			setRowSelectionAllowed(false);</span>
<span class="nc" id="L233">			setColumnSelectionAllowed(false);</span>
<span class="nc" id="L234">			setCellSelectionEnabled(true);</span>
<span class="nc" id="L235">			getTableHeader().setResizingAllowed(true);</span>
<span class="nc" id="L236">			getTableHeader().setReorderingAllowed(true);</span>
<span class="nc" id="L237">			setAutoCreateColumnsFromModel(false);</span>
<span class="nc" id="L238">			setAutoResizeMode(JTable.AUTO_RESIZE_OFF);</span>

//?? Future: may want to create TablePopupMenu to allow cut/copy/paste operations

			// add mouse listener for Popup
<span class="nc" id="L243">			MouseAdapter m = new MouseAdapter()</span>
<span class="nc" id="L244">			{</span>
				public void mousePressed(MouseEvent evt)
				{
<span class="nc bnc" id="L247" title="All 2 branches missed.">					if (evt.isPopupTrigger())</span>
					{
						// for now, ignore popup request
						//RowDataJTable.this.displayPopupMenu(evt);
					}
<span class="nc bnc" id="L252" title="All 2 branches missed.">					else if (evt.getClickCount() == 2)</span>
					{
						// figure out which column the user clicked on
						// so we can pass in the right column description

<span class="nc" id="L257">						Point pt = evt.getPoint();</span>
<span class="nc" id="L258">						int col = RowDataJTable.this.columnAtPoint(pt);</span>
<span class="nc" id="L259">						CellDataPopup.showDialog(RowDataJTable.this, _colDefs[col], evt, true);</span>
					}
<span class="nc" id="L261">				}</span>
				public void mouseReleased(MouseEvent evt)
				{
<span class="nc bnc" id="L264" title="All 2 branches missed.">					if (evt.isPopupTrigger())</span>
					{
						// for now, ignore popup request
						//RowDataJTable.this.displayPopupMenu(evt);
					}
<span class="nc" id="L269">				}</span>
			};
<span class="nc" id="L271">			addMouseListener(m);</span>
<span class="nc" id="L272">		}</span>

		public boolean isCellEditable(int row, int col) {
<span class="nc bnc" id="L275" title="All 2 branches missed.">			if (row &gt; 0)</span>
<span class="nc" id="L276">				return false;	// only the first row (containing data) is editable</span>
<span class="nc" id="L277">			return CellComponentFactory.isEditableInCell(_colDefs[col], getValueAt(row,col));</span>
		}

		public TableCellRenderer getCellRenderer(int row, int column) {
<span class="nc bnc" id="L281" title="All 2 branches missed.">			if (row == 0)</span>
<span class="nc" id="L282">				return CellComponentFactory.getTableCellRenderer(_colDefs[column]);</span>
			// for entries past the first one, use the default renderer
<span class="nc" id="L284">			return new RowDataDescriptionRenderer();</span>
		}

		/*
		 * When user leaves a cell after editing it, the contents of
		 * that cell need to be converted from a string into an
		 * object of the appropriate type before updating the table.
		 * However, when the call comes from the Popup window, the data
		 * has already been converted and validated.
		 * We assume that a String being passed in here is a value from
		 * a text field that needs to be converted to an object, and
		 * a non-string object has already been validated and converted.
		 */
		public void setValueAt(Object newValueString, int row, int col)
		{
<span class="nc bnc" id="L299" title="All 2 branches missed.">			if (! (newValueString instanceof java.lang.String))</span>
			{
				// data is an object - assume already validated
<span class="nc" id="L302">				super.setValueAt(newValueString, row, col);</span>
<span class="nc" id="L303">				return;</span>
			}

			// data is a String, so we need to convert to real object
<span class="nc" id="L307">			StringBuffer messageBuffer = new StringBuffer();</span>
<span class="nc" id="L308">			ColumnDisplayDefinition colDef = _colDefs[col];</span>
<span class="nc" id="L309">			Object newValueObject = CellComponentFactory.validateAndConvert(</span>
<span class="nc" id="L310">				colDef, getValueAt(row, col), (String) newValueString, messageBuffer);</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">			if (messageBuffer.length() &gt; 0)</span>
			{
				// display error message and do not update the table

				// i18n[rowInputDataFrame.conversionToInternErr=The given text cannot be converted into the internal object.\nThe database has not been changed.\nThe conversion error was:\n{0}]
<span class="nc" id="L316">				String msg = s_stringMgr.getString(&quot;rowInputDataFrame.conversionToInternErr&quot;, messageBuffer);</span>
<span class="nc" id="L317">				JOptionPane.showMessageDialog(this,</span>
					msg,
					// i18n[rowInputDataFrame.conversionErr=Conversion Error]
<span class="nc" id="L320">					s_stringMgr.getString(&quot;rowInputDataFrame.conversionErr&quot;),</span>
					JOptionPane.ERROR_MESSAGE);
<span class="nc" id="L322">			}</span>
			else
			{
				// data converted ok, so update the table
<span class="nc" id="L326">				super.setValueAt(newValueObject, row, col);</span>
			}
<span class="nc" id="L328">		}</span>


	}

	/**
	 * Model for use by JTable in creating data for insertion.
	 */
	class RowDataModel extends DefaultTableModel {


		/**
		 * ctor
		 */
<span class="nc" id="L342">		protected RowDataModel(ColumnDisplayDefinition[] colDefs, Object[] initalValues) {</span>
<span class="nc" id="L343">			super();</span>

			// set up the list of column names and the data for the rows
<span class="nc" id="L346">			String[] colNames = new String[colDefs.length];</span>
<span class="nc" id="L347">			Object[][] rowData = new Object[2][colDefs.length];</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">			for (int i=0; i&lt;colDefs.length; i++) {</span>
<span class="nc" id="L349">				colNames[i] = colDefs[i].getColumnName();	// set column heading</span>
<span class="nc" id="L350">				rowData[0][i] = initalValues[i];	// set data in first row</span>

				// put a description of the field in the following rows
<span class="nc" id="L353">				rowData[1][i] = getColumnDescription(colDefs[i]);</span>
                    
//                    colDefs[i].getSqlTypeName() + &quot;\n&quot; +
//					((colDefs[i].isNullable()) ? &quot;nullable&quot; : &quot;not nullable&quot;) + &quot;\n&quot; +
//					&quot;precision=&quot;+ colDefs[i].getPrecision() + &quot;\n&quot; +
//					&quot;scale=&quot; + colDefs[i].getScale();
			}

			// put the data and header names into the model
<span class="nc" id="L362">			setDataVector(rowData, colNames);</span>
<span class="nc" id="L363">		}</span>
        
        /**
         * Provides values for several column attributes (nullable, prec, scale)
         * and in the event the column is auto-increment it displays that as a 
         * visual cue to the user that the field cannot be edited.
         * 
         * @param def the ColumnDisplayDefinition that describes the column
         * @return a string of column attributes separated by eol chars.
         */
        private String getColumnDescription(ColumnDisplayDefinition def) {
<span class="nc" id="L374">            StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L375">            result.append(def.getSqlTypeName());</span>
<span class="nc" id="L376">            result.append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">            if (def.isNullable()) {</span>
<span class="nc" id="L378">                result.append(&quot;nullable&quot;);</span>
            } else {
<span class="nc" id="L380">                result.append(&quot;not nullable&quot;);</span>
            }
<span class="nc" id="L382">            result.append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">            if (JDBCTypeMapper.isNumberType(def.getSqlType())) {</span>
<span class="nc" id="L384">                result.append(&quot;prec=&quot;);</span>
<span class="nc" id="L385">                result.append(def.getPrecision());</span>
<span class="nc" id="L386">                result.append(&quot;\n&quot;);</span>
<span class="nc" id="L387">                result.append(&quot;scale=&quot;);</span>
<span class="nc" id="L388">                result.append(def.getScale());</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                if (def.isAutoIncrement()) {</span>
<span class="nc" id="L390">                    result.append(&quot;\n&quot;);</span>
<span class="nc" id="L391">                    result.append(&quot;(auto-incr)&quot;);</span>
                }
            } else {
<span class="nc" id="L394">                result.append(&quot;length=&quot;);</span>
<span class="nc" id="L395">                result.append(def.getColumnSize());</span>
            }
<span class="nc" id="L397">            return result.toString();</span>
        }
	}

	/**
	 * renderer to display multiple lines in one table cell
	 */
<span class="nc" id="L404">	class RowDataDescriptionRenderer implements TableCellRenderer {</span>

		public Component getTableCellRendererComponent(JTable table, 
                                                       Object value, 
                                                       boolean isSelected, 
                                                       boolean hasFocus, 
                                                       int row, 
                                                       int column) {

<span class="nc" id="L413">				JTextArea ta = new JTextArea((String)value, 8, 20);</span>
<span class="nc" id="L414">				ta.setBackground(Color.lightGray);</span>
<span class="nc" id="L415">				return ta;</span>
			}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>