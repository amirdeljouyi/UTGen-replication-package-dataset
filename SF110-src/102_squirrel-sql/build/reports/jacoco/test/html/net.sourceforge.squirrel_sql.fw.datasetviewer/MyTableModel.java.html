<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MyTableModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">102_squirrel-sql</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.squirrel_sql.fw.datasetviewer</a> &gt; <span class="el_source">MyTableModel.java</span></div><h1>MyTableModel.java</h1><pre class="source lang-java linenums">package net.sourceforge.squirrel_sql.fw.datasetviewer;
/*
 * Copyright (C) 2001-2002 Colin Bell
 * colbell@users.sourceforge.net
 * Modifications copyright (C) 2001-2002 Johan Compagner
 * jcompagner@j-com.nl
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */


import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;

import javax.swing.table.AbstractTableModel;


public final class MyTableModel extends AbstractTableModel
{
    private static final long serialVersionUID = 5511368149198548935L;

<span class="nc" id="L35">    private List&lt;Object[]&gt; _data = new ArrayList&lt;Object[]&gt;();</span>
<span class="nc" id="L36">	private ColumnDisplayDefinition[] _colDefs = new ColumnDisplayDefinition[0];</span>
<span class="nc" id="L37">	private IDataSetTableControls _creator = null;</span>


	MyTableModel(IDataSetTableControls creator)
	{
<span class="nc" id="L42">		super();</span>
<span class="nc" id="L43">		_creator = creator;</span>
<span class="nc" id="L44">	}</span>

	/**
	 * Determine whether the cell is editable by asking the creator whether
	 * the table is editable or not
	 */
	public boolean isCellEditable(int row, int col)
	{
		// DataTypes may limit the initial data read from the DB, e.g. to minimize the
		// time needed for the initial load of the table.
		// To edit the contents of a cell, we require that the entire contents of the data
		// element be present in the cell before editing.
		// Therefore we ask the DataType if we need to re-read the data contents
		// without limiting it, and do that read if needed.  If there is a problem during the
		// read (e.g. we cannot identify exactly one row in the DB matching the
		// current row in the table), then the cell is not editable.
		// The reverse is not true - if we succeed in reading the data, there may still
		// be other reasons why we cannot edit it, so we need to check for it being editable
		// after the read

<span class="nc bnc" id="L64" title="All 2 branches missed.">		if(col == RowNumberTableColumn.ROW_NUMBER_MODEL_INDEX)</span>
		{
<span class="nc" id="L66">			return false;</span>
		}

<span class="nc bnc" id="L69" title="All 2 branches missed.">		if (_creator.needToReRead(col, getValueAt(row, col)))</span>
		{
<span class="nc" id="L71">			StringBuffer message = new StringBuffer();</span>
<span class="nc" id="L72">			Object newValue = _creator.reReadDatum(_data.get(row), col, message);</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">			if (message.length() &gt; 0)</span>
			{
				// there was a problem with the read
				// It would be nice to report this to the user, but if we try we get in trouble
				// in some cases where the data is continually re-read after the dialog
				// goes away (because the cell is being re-painted).
<span class="nc" id="L79">				return false;	// cell is not editable</span>
			}
<span class="nc" id="L81">			(_data.get(row))[col] = newValue;</span>
		}

<span class="nc" id="L84">		return _creator.isColumnEditable(col, getValueAt(row, col));</span>
	}

	public Object getValueAt(int row, int col)
	{
<span class="nc bnc" id="L89" title="All 2 branches missed.">		if(RowNumberTableColumn.ROW_NUMBER_MODEL_INDEX == col)</span>
		{
<span class="nc" id="L91">			return Integer.valueOf(row + 1);</span>
		}
		else
		{
<span class="nc" id="L95">			return _data.get(row)[col];</span>
		}
	}

	public int getRowCount()
	{
<span class="nc" id="L101">		return _data.size();</span>
	}

	public int getColumnCount()
	{
<span class="nc bnc" id="L106" title="All 2 branches missed.">		return _colDefs != null ? _colDefs.length : 0;</span>
	}

	public String getColumnName(int col)
	{
<span class="nc bnc" id="L111" title="All 2 branches missed.">		if(col == RowNumberTableColumn.ROW_NUMBER_MODEL_INDEX)</span>
		{
<span class="nc" id="L113">			return RowNumberTableColumn.ROW_NUMBER_HEADER;</span>
		}
		else
		{
<span class="nc bnc" id="L117" title="All 2 branches missed.">			return _colDefs != null ? _colDefs[col].getColumnHeading() : super.getColumnName(col);</span>
		}
	}

	public Class&lt;?&gt; getColumnClass(int col)
	{
		try
		{
			// if no columns defined, return a generic class
			// to avoid anything throwing an exception.
<span class="nc bnc" id="L127" title="All 2 branches missed.">			if (_colDefs == null)</span>
			{
<span class="nc" id="L129">				return Object.class;</span>
			}
		
<span class="nc" id="L132">			return Class.forName(_colDefs[col].getClassName());</span>
		}
<span class="nc" id="L134">		catch (Exception e)</span>
		{
<span class="nc" id="L136">			return null;</span>
		}
	}

	void setHeadings(ColumnDisplayDefinition[] hdgs)
	{
<span class="nc" id="L142">		_colDefs = hdgs;</span>
<span class="nc" id="L143">	}</span>

	public void addRow(Object[] row)
	{
<span class="nc" id="L147">		_data.add(row);</span>
<span class="nc" id="L148">	}</span>

	void clear()
	{
<span class="nc" id="L152">		_data.clear();</span>
<span class="nc" id="L153">	}</span>

	public void allRowsAdded()
	{
<span class="nc" id="L157">		fireTableStructureChanged();</span>
<span class="nc" id="L158">	}</span>

	/**
	 * Let creator handle saving the data, if anything is to be done with it.
	 * If the creator succeeds in changing the underlying data,
	 * then update the JTable as well.
	 */
	public void setValueAt(Object newValue, int row, int col) {
<span class="nc" id="L166">      int[] colsToUpdate = _creator.changeUnderlyingValueAt(row, col, newValue, getValueAt(row, col));</span>

<span class="nc bnc" id="L168" title="All 2 branches missed.">      for (int i = 0; i &lt; colsToUpdate.length; i++)</span>
      {
<span class="nc" id="L170">         _data.get(row)[ colsToUpdate[i] ] = newValue;</span>
      }
<span class="nc" id="L172">	}</span>
	
	/**
	 * Delete a set of selected rows.
	 */
	public void deleteRows(int[] rows) {
		// The list of rows may be empty, in which case we just return.
<span class="nc bnc" id="L179" title="All 2 branches missed.">		if (rows.length == 0)</span>
<span class="nc" id="L180">			return;</span>
		
		
		
		// We want to delete rows from the end of the table towards the beginning
		// of the table.  If we delete from the front to the back, that throws off
		// the indexes of the rows after each delete and we would have to compensate
		// for that.
		// Example: if we want to delete rows 2 and 4 and do it in that
		// order, then after deleteing row 2 the row that used to be row 4 is now
		// actually row 3, so we would have to subtract 1 from the index to get the
		// row to delete.
		// On the other hand, if we delete row 4 first, then the indexes of all
		// rows prior to that one have not been affected, so we can then delete
		// row 2 without any complications.
		
		// sort the indexes into ascending order (because that is the
		// only function easilly available from the Arrays class)
<span class="nc" id="L198">		Arrays.sort(rows);</span>
		
		// The indexes are in ascending order, but we want to delete in
		// descending order (see previous comment), so run through the
		// list backwards.
<span class="nc bnc" id="L203" title="All 2 branches missed.">		for (int i=rows.length - 1; i&gt;=0; i--) {</span>
			// delete the row from the table
<span class="nc bnc" id="L205" title="All 2 branches missed.">            if (rows[i] &lt; _data.size()) {</span>
<span class="nc" id="L206">                _data.remove(rows[i]);</span>
            }
		}

		// notify table that rows have changed
		// The deleted rows may not be contiguous in the actual data model
		// because the gui may be showing a version of the data sorted in
		// some other order, so we cannot use fireRowsDeleted.
<span class="nc" id="L214">		fireTableDataChanged();</span>
		
<span class="nc" id="L216">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>