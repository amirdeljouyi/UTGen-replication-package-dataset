<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataSetViewerTablePanel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">102_squirrel-sql</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.squirrel_sql.fw.datasetviewer</a> &gt; <span class="el_source">DataSetViewerTablePanel.java</span></div><h1>DataSetViewerTablePanel.java</h1><pre class="source lang-java linenums">package net.sourceforge.squirrel_sql.fw.datasetviewer;
/*
 * Copyright (C) 2001-2002 Colin Bell
 * colbell@users.sourceforge.net
 * Modifications copyright (C) 2001-2002 Johan Compagner
 * jcompagner@j-com.nl
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.print.PageFormat;
import java.awt.print.Printable;
import java.awt.print.PrinterException;

import javax.swing.DefaultCellEditor;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableColumnModel;

import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.CellComponentFactory;
import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.RestorableJTextField;
import net.sourceforge.squirrel_sql.fw.gui.ButtonTableHeader;
import net.sourceforge.squirrel_sql.fw.gui.RectangleSelectionHandler;
import net.sourceforge.squirrel_sql.fw.gui.SortableTableModel;
import net.sourceforge.squirrel_sql.fw.gui.TablePopupMenu;
import net.sourceforge.squirrel_sql.fw.util.StringManager;
import net.sourceforge.squirrel_sql.fw.util.StringManagerFactory;
import net.sourceforge.squirrel_sql.fw.util.log.ILogger;
import net.sourceforge.squirrel_sql.fw.util.log.LoggerController;

public class DataSetViewerTablePanel extends BaseDataSetViewerDestination
				implements IDataSetTableControls, Printable
{

<span class="nc" id="L59">	private static final StringManager s_stringMgr =</span>
<span class="nc" id="L60">		StringManagerFactory.getStringManager(DataSetViewerTablePanel.class);</span>

<span class="nc" id="L62">	private ILogger s_log = LoggerController.createLogger(DataSetViewerTablePanel.class);</span>

<span class="nc" id="L64">	private MyJTable _table = null;</span>
	private MyTableModel _typedModel;
	private IDataSetUpdateableModel _updateableModel;
   private DataSetViewerTableListSelectionHandler _selectionHandler;

<span class="nc" id="L69">   private IDataModelImplementationDetails _dataModelImplementationDetails =</span>
         new IDataModelImplementationDetails()
<span class="nc" id="L71">         {</span>
            @Override
            public String getStatementSeparator()
            {
<span class="nc" id="L75">               return &quot;;&quot;;</span>
            }
         };

   public DataSetViewerTablePanel()
	{
<span class="nc" id="L81">		super();</span>
<span class="nc" id="L82">	}</span>

   public void init(IDataSetUpdateableModel updateableModel)
   {
<span class="nc" id="L86">      init(updateableModel, ListSelectionModel.SINGLE_INTERVAL_SELECTION);</span>
<span class="nc" id="L87">   }</span>


	public void init(IDataSetUpdateableModel updateableModel, int listSelectionMode)
	{
<span class="nc" id="L92">      init(updateableModel, listSelectionMode, null);</span>
<span class="nc" id="L93">	}</span>

   public void init(IDataSetUpdateableModel updateableModel, IDataModelImplementationDetails dataModelImplementationDetails)
   {
<span class="nc" id="L97">      init(updateableModel, ListSelectionModel.SINGLE_INTERVAL_SELECTION, dataModelImplementationDetails);</span>
<span class="nc" id="L98">   }</span>

   public void init(IDataSetUpdateableModel updateableModel, int listSelectionMode, IDataModelImplementationDetails dataModelImplementationDetails)
   {
<span class="nc bnc" id="L102" title="All 2 branches missed.">      if (null != dataModelImplementationDetails)</span>
      {
<span class="nc" id="L104">         _dataModelImplementationDetails = dataModelImplementationDetails;</span>
      }

<span class="nc" id="L107">      _table = new MyJTable(this, updateableModel, listSelectionMode);</span>
<span class="nc" id="L108">      _selectionHandler = new DataSetViewerTableListSelectionHandler(_table);</span>
<span class="nc" id="L109">      _updateableModel = updateableModel;</span>


<span class="nc" id="L112">   }</span>

	
	public IDataSetUpdateableModel getUpdateableModel()
	{
<span class="nc" id="L117">		return _updateableModel;</span>
	}

   public IDataModelImplementationDetails getDataModelImplementationDetails()
   {
<span class="nc" id="L122">      return _dataModelImplementationDetails;</span>
   }

   public void clear()
	{
<span class="nc" id="L127">		_typedModel.clear();</span>
<span class="nc" id="L128">		_typedModel.fireTableDataChanged();</span>
<span class="nc" id="L129">	}</span>
	

	public void setColumnDefinitions(ColumnDisplayDefinition[] colDefs)
	{
<span class="nc" id="L134">		super.setColumnDefinitions(colDefs);</span>
<span class="nc" id="L135">		_table.setColumnDefinitions(colDefs);</span>
<span class="nc" id="L136">	}</span>

	public void moveToTop()
	{
<span class="nc bnc" id="L140" title="All 2 branches missed.">		if (_table.getRowCount() &gt; 0)</span>
		{
<span class="nc" id="L142">			_table.setRowSelectionInterval(0, 0);</span>
		}
<span class="nc" id="L144">	}</span>

	/**
	 * Get the component for this viewer.
	 *
	 * @return	The component for this viewer.
	 */
	public Component getComponent()
	{
<span class="nc" id="L153">		return _table;</span>
	}

	/*
	 * @see BaseDataSetViewerDestination#addRow(Object[])
	 */
	protected void addRow(Object[] row)
	{
<span class="nc" id="L161">		_typedModel.addRow(row);</span>
<span class="nc" id="L162">	}</span>
	
	/*
	 * @see BaseDataSetViewerDestination#getRow(row)
	 */
	protected Object[] getRow(int row)
	{
<span class="nc" id="L169">		Object values[] = new Object[_typedModel.getColumnCount()];</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">		for (int i=0; i &lt; values.length; i++)</span>
<span class="nc" id="L171">			values[i] = _typedModel.getValueAt(row, i);</span>
<span class="nc" id="L172">		return values;</span>
	}

	/*
	 * @see BaseDataSetViewerDestination#allRowsAdded()
	 */
	protected void allRowsAdded()
	{
<span class="nc" id="L180">		_typedModel.fireTableStructureChanged();</span>
<span class="nc" id="L181">      _table.initColWidths();</span>
<span class="nc" id="L182">   }</span>

	/*
	 * @see IDataSetViewer#getRowCount()
	 */
	public int getRowCount()
	{
<span class="nc" id="L189">		return _typedModel.getRowCount();</span>
	}

	public void setShowRowNumbers(boolean showRowNumbers)
	{
<span class="nc" id="L194">		_table.setShowRowNumbers(showRowNumbers);</span>
<span class="nc" id="L195">	}</span>

   public void addRowSelectionListener(RowSelectionListener rowSelectionListener)
   {
<span class="nc" id="L199">      _selectionHandler.addRowSelectionListener(rowSelectionListener);</span>
<span class="nc" id="L200">   }</span>

   public void removeRowSelectionListener(RowSelectionListener rowSelectionListener)
   {
<span class="nc" id="L204">      _selectionHandler.removeRowSelectionListener(rowSelectionListener);</span>
<span class="nc" id="L205">   }</span>

   public int[] getSeletedRows()
   {
<span class="nc" id="L209">      return _table.getSelectedRows();</span>
   }

   public int[] getSeletedModelRows()
   {
<span class="nc" id="L214">      int[] selectedViewRows = _table.getSelectedRows();</span>

<span class="nc" id="L216">      int[] ret = new int[selectedViewRows.length];</span>

<span class="nc bnc" id="L218" title="All 2 branches missed.">      for (int i = 0; i &lt; selectedViewRows.length; i++)</span>
      {
<span class="nc" id="L220">         ret[i] = (((SortableTableModel)_table.getModel()).transfromToModelRow(selectedViewRows[i]));</span>
      }

<span class="nc" id="L223">      return ret;</span>
   }

   
   public int getColumnWidthForHeader(String header)
   {
<span class="nc" id="L229">      TableColumnModel columnModel = _table.getColumnModel();</span>

<span class="nc bnc" id="L231" title="All 2 branches missed.">      for (int i = 0; i &lt; columnModel.getColumnCount(); i++)</span>
      {
<span class="nc bnc" id="L233" title="All 2 branches missed.">         if(columnModel.getColumn(i).getHeaderValue().equals(header))</span>
         {
<span class="nc" id="L235">            return columnModel.getColumn(i).getWidth();</span>
         }
      }

<span class="nc" id="L239">      throw new IllegalStateException(&quot;No col with header: &quot; + header);</span>
   }


   /*
     * The JTable used for displaying all DB ResultSet info.
     */
	protected final class MyJTable extends JTable
	{
		private static final long serialVersionUID = 1L;
		private final int _multiplier;
		private static final String data = &quot;THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG&quot;;

		private TablePopupMenu _tablePopupMenu;
		private IDataSetTableControls _creator;

<span class="nc" id="L255">      private RectangleSelectionHandler _rectangleSelectionHandler = new RectangleSelectionHandler(this);</span>
		private RowNumberTableColumn _rntc;
<span class="nc" id="L257">		private ButtonTableHeader _tableHeader = new ButtonTableHeader();</span>

		MyJTable(IDataSetTableControls creator,
               IDataSetUpdateableModel updateableObject, int listSelectionMode)
<span class="nc" id="L261">		{</span>
<span class="nc" id="L262">			super(new SortableTableModel(new MyTableModel(creator)));</span>
<span class="nc" id="L263">			_creator = creator;</span>
<span class="nc" id="L264">			_typedModel = (MyTableModel) ((SortableTableModel) getModel()).getActualModel();</span>
<span class="nc" id="L265">			_multiplier =</span>
<span class="nc" id="L266">				getFontMetrics(getFont()).stringWidth(data) / data.length();</span>
<span class="nc" id="L267">			setRowHeight(getFontMetrics(getFont()).getHeight());</span>
<span class="nc" id="L268">			boolean allowUpdate = false;</span>
			// we want to allow editing of read-only tables on-demand, but
			// it would be confusing to include the &quot;Make Editable&quot; option
			// when we are already in edit mode, so only allow that option when
			// the background model is updateable AND we are not already editing
<span class="nc bnc" id="L273" title="All 4 branches missed.">			if (updateableObject != null &amp;&amp; ! creator.isTableEditable())</span>
<span class="nc" id="L274">				allowUpdate = true;</span>
<span class="nc" id="L275">			createGUI(allowUpdate, updateableObject, listSelectionMode);</span>

			// just in case table is editable, call creator to set up cell editors
<span class="nc" id="L278">			_creator.setCellEditors(this);</span>

			/*
			 * TODO: When 1.4 is the earliest version supported, add the following line:
			*		setSurrendersFocusOnKeystroke(true);
			* This should help handle some problems with navigation using tab &amp; return
			* to move through cells.
			*/


<span class="nc" id="L288">		}</span>


		public void paint(Graphics g)
		{
<span class="nc" id="L293">			super.paint(g);</span>
<span class="nc" id="L294">         _rectangleSelectionHandler.paintRectWhenNeeded(g);</span>
<span class="nc" id="L295">		}</span>

		public IDataSetTableControls getCreator() {
<span class="nc" id="L298">			return _creator;</span>
		}

		/*
		 * override the JTable method so that whenever something asks for
		 * the cellEditor, we save a reference to that cell editor.
		 * Our ASSUMPTION is that the cell editor is only requested
		 * when it is about to be activated.
		 */
		public TableCellEditor getCellEditor(int row, int col)
		{
<span class="nc" id="L309">			TableCellEditor cellEditor = super.getCellEditor(row, col);</span>
<span class="nc" id="L310">			currentCellEditor = (DefaultCellEditor)cellEditor;</span>
<span class="nc" id="L311">			return cellEditor;</span>
		}


		/**
		 * There are two special cases where we need to override the default behavior
		 * when we begin cell editing.  For some reason, when you use the keyboard to
		 * enter a cell (tab, enter, arrow keys, etc), the first character that you type
		 * after entering the field is NOT passed through the KeyListener mechanism
		 * where we have the special handling in the DataTypes.  Instead, it is passed
		 * through the KeyMap and Action mechanism, and the default Action on the
		 * JTextField is to add the character to the end of the existing text, or if it is delete
		 * to delete the last character of the existing text.  In most cases, this is ok, but
		 * there are three special cases of which we only handle two here:
		 * 	- If the data field currently contains &quot;&lt;null&gt;&quot; and the user types a character,
		 * 	  we want that character to replace the string &quot;&lt;null&gt;&quot;, which represents the
		 * 	  null value.  In this case we process the event normally, which usually adds
		 * 	  the char to the end of the string, then remove the char afterwards.
		 * 	  We take this approach rather than just immediately replacing the &quot;&lt;null&gt;&quot;
		 * 	  with the char because there are some chars that should not be put into
		 * 	  the editable text, such as control-characters.
		 * 	- If the data field contains &quot;&lt;null&gt;&quot; and the user types a delete, we do not
		 * 	  want to delete the last character from the string &quot;&lt;null&gt;&quot; since that string
		 * 	  represents the null value.  In this case we simply ignore the user input.
		 * 	- Whether or not the field initially contains null, we do not run the input validation
		 * 	  function for the DataType on the input character.  This means that the user
		 * 	  can type an illegal character into the field.  For example, after entering an
		 * 	  Integer field by typing a tab, the user can enter a letter (e.g. &quot;a&quot;) into that
		 * 	  field.  The normal keyListener processing prevents that, but we cannot
		 * 	  call it from this point.  (More accurately, I cannot figure out how to do it
		 * 	  easilly.)  Thus the user may enter one character of invalid data into the field.
		 * 	  This is not too serious a problem, however, because the normal validation
		 * 	  is still done when the user leaves the field and it SQuirreL tries to convert
		 * 	  the text into an object of the correct type, so errors of this nature will still
		 * 	  be caught.  They just won't be prevented.
		 */
		public void processKeyEvent(KeyEvent e) {

				// handle special case of delete with &lt;null&gt; contents
<span class="nc bnc" id="L350" title="All 4 branches missed.">				if (e.getKeyChar() == '\b' &amp;&amp; getEditorComponent() != null &amp;&amp;</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">						((RestorableJTextField)getEditorComponent()).getText().equals(&quot;&lt;null&gt;&quot;) ) {</span>
						//ignore the user input
<span class="nc" id="L353">						return;</span>
				}

				// generally for KEY_TYPED this means add the typed char to the end of the text,
				// but there are some things (e.g. control chars) that are ignored, so let the
				// normal processing do its thing
<span class="nc" id="L359">				super.processKeyEvent(e);</span>

				// now check to see if the original contents were &lt;null&gt;
				// and we have actually added the input char to the end of it                                                              
<span class="nc bnc" id="L363" title="All 2 branches missed.">				if (getEditorComponent() != null) {</span>
<span class="nc bnc" id="L364" title="All 4 branches missed.">						if (e.getID() == KeyEvent.KEY_TYPED &amp;&amp; ((RestorableJTextField)getEditorComponent()).getText().length() == 7) {</span>
								// check that we did not just add a char to a &lt;null&gt;
<span class="nc bnc" id="L366" title="All 2 branches missed.">								if (((RestorableJTextField)getEditorComponent()).getText().equals(&quot;&lt;null&gt;&quot;+e.getKeyChar())) {</span>
										// replace the null with just the char
<span class="nc" id="L368">										((RestorableJTextField)getEditorComponent()).updateText(&quot;&quot;+e.getKeyChar());</span>
								}
						}
				}

<span class="nc" id="L373">		}</span>


		/*
		 * When user leaves a cell after editing it, the contents of
		 * that cell need to be converted from a string into an
		 * object of the appropriate type before updating the table.
		 * However, when the call comes from the Popup window, the data
		 * has already been converted and validated.
		 * We assume that a String being passed in here is a value from
		 * a text field that needs to be converted to an object, and
		 * a non-string object has already been validated and converted.
		 */
		public void setValueAt(Object newValueString, int row, int col)
		{
<span class="nc bnc" id="L388" title="All 2 branches missed.">			if (! (newValueString instanceof java.lang.String))</span>
			{
				// data is an object - assume already validated
<span class="nc" id="L391">				super.setValueAt(newValueString, row, col);</span>
<span class="nc" id="L392">				return;</span>
			}

			// data is a String, so we need to convert to real object
<span class="nc" id="L396">			StringBuffer messageBuffer = new StringBuffer();</span>

<span class="nc" id="L398">			int modelIndex = getColumnModel().getColumn(col).getModelIndex();</span>
<span class="nc" id="L399">			ColumnDisplayDefinition colDef = getColumnDefinitions()[modelIndex];</span>
<span class="nc" id="L400">			Object newValueObject = CellComponentFactory.validateAndConvert(</span>
<span class="nc" id="L401">				colDef, getValueAt(row, col), (String) newValueString, messageBuffer);</span>

<span class="nc bnc" id="L403" title="All 2 branches missed.">			if (messageBuffer.length() &gt; 0)</span>
			{

				// i18n[dataSetViewerTablePanel.textCantBeConverted=The given text cannot be converted into the internal object.\nThe database has not been changed.\nThe conversion error was:\n{0}]
<span class="nc" id="L407">				String msg = s_stringMgr.getString(&quot;dataSetViewerTablePanel.textCantBeConverted&quot;, messageBuffer);</span>

<span class="nc bnc" id="L409" title="All 2 branches missed.">				if (s_log.isDebugEnabled()) {</span>
<span class="nc" id="L410">					s_log.debug(&quot;setValueAt: msg from DataTypeComponent was: &quot;+msg);</span>
				}
				
				// display error message and do not update the table
<span class="nc" id="L414">				JOptionPane.showMessageDialog(this,</span>
					msg,
					// i18n[dataSetViewerTablePanel.conversionError=Conversion Error]
<span class="nc" id="L417">					s_stringMgr.getString(&quot;dataSetViewerTablePanel.conversionError&quot;),</span>
					JOptionPane.ERROR_MESSAGE);
				
<span class="nc" id="L420">			}</span>
			else
			{
				// data converted ok, so update the table
<span class="nc" id="L424">				super.setValueAt(newValueObject, row, col);</span>
			}
<span class="nc" id="L426">		}</span>


		public void setColumnDefinitions(ColumnDisplayDefinition[] colDefs)
		{
<span class="nc" id="L431">			TableColumnModel tcm = createColumnModel(colDefs);</span>
<span class="nc" id="L432">			setColumnModel(tcm);</span>
<span class="nc" id="L433">			_typedModel.setHeadings(colDefs);</span>

			// just in case table is editable, call creator to set up cell editors
<span class="nc" id="L436">			_creator.setCellEditors(this);</span>
<span class="nc" id="L437">			_tablePopupMenu.reset();</span>
<span class="nc" id="L438">		}</span>

		MyTableModel getTypedModel()
		{
<span class="nc" id="L442">			return _typedModel;</span>
		}

		/**
		 * Display the popup menu for this component.
		 */
		private void displayPopupMenu(MouseEvent evt)
		{
<span class="nc" id="L450">			_tablePopupMenu.show(evt.getComponent(), evt.getX(), evt.getY());</span>
<span class="nc" id="L451">		}</span>


		private TableColumnModel createColumnModel(ColumnDisplayDefinition[] colDefs)
		{
			//_colDefs = hdgs;
<span class="nc" id="L457">			TableColumnModel cm = new DefaultTableColumnModel();</span>

<span class="nc" id="L459">			_rntc = new RowNumberTableColumn();</span>

<span class="nc bnc" id="L461" title="All 2 branches missed.">			for (int i = 0; i &lt; colDefs.length; ++i)</span>
			{
<span class="nc" id="L463">				ColumnDisplayDefinition colDef = colDefs[i];</span>

				int colWidth;

<span class="nc bnc" id="L467" title="All 2 branches missed.">            if (null == colDef.getAbsoluteWidth())</span>
            {
<span class="nc" id="L469">               colWidth = colDef.getDisplayWidth() * _multiplier;</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">               if (colWidth &gt; MAX_COLUMN_WIDTH * _multiplier)</span>
               {
<span class="nc" id="L472">                  colWidth = MAX_COLUMN_WIDTH * _multiplier;</span>
               }
<span class="nc bnc" id="L474" title="All 2 branches missed.">               else if (colWidth &lt; MIN_COLUMN_WIDTH * _multiplier)</span>
               {
<span class="nc" id="L476">                    colWidth = MIN_COLUMN_WIDTH * _multiplier;</span>
               }
            }
            else
            {
<span class="nc" id="L481">               colWidth = colDef.getAbsoluteWidth();</span>
            }

<span class="nc" id="L484">            ExtTableColumn col = new ExtTableColumn(i, colWidth,</span>
<span class="nc" id="L485">					CellComponentFactory.getTableCellRenderer(colDefs[i]), null);</span>

<span class="nc" id="L487">            String headerValue = colDef.getColumnHeading();</span>
<span class="nc" id="L488">            col.setHeaderValue(headerValue);</span>
<span class="nc" id="L489">				col.setColumnDisplayDefinition(colDef);</span>
<span class="nc" id="L490">				cm.addColumn(col);</span>
			}

<span class="nc" id="L493">			return cm;</span>
		}

		void setShowRowNumbers(boolean show)
		{
			try
			{
<span class="nc" id="L500">				int rowNumColIx = getColumnModel().getColumnIndex(RowNumberTableColumn.ROW_NUMBER_COL_IDENTIFIER);</span>
<span class="nc" id="L501">				_tableHeader.columnIndexWillBeRemoved(rowNumColIx);</span>
			}
<span class="nc" id="L503">			catch(IllegalArgumentException e)</span>
			{
				// Column not in model
<span class="nc" id="L506">			}</span>

<span class="nc" id="L508">			getColumnModel().removeColumn(_rntc);</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">			if(show)</span>
			{
<span class="nc" id="L511">				_tableHeader.columnIndexWillBeAdded(0);</span>
<span class="nc" id="L512">				getColumnModel().addColumn(_rntc);</span>
<span class="nc" id="L513">				getColumnModel().moveColumn(getColumnModel().getColumnCount()-1, 0);</span>
			}
<span class="nc" id="L515">		}</span>

		private void createGUI(boolean allowUpdate,
                             IDataSetUpdateableModel updateableObject, int selectionMode)
		{
<span class="nc" id="L520">			setSelectionMode(selectionMode);</span>
<span class="nc" id="L521">			setRowSelectionAllowed(false);</span>
<span class="nc" id="L522">			setColumnSelectionAllowed(false);</span>
<span class="nc" id="L523">			setCellSelectionEnabled(true);</span>
<span class="nc" id="L524">			getTableHeader().setResizingAllowed(true);</span>
<span class="nc" id="L525">			getTableHeader().setReorderingAllowed(true);</span>
<span class="nc" id="L526">			setAutoCreateColumnsFromModel(false);</span>
<span class="nc" id="L527">			setAutoResizeMode(JTable.AUTO_RESIZE_OFF);</span>
<span class="nc" id="L528">			setTableHeader(_tableHeader);</span>
<span class="nc" id="L529">			_tableHeader.setTable(this);</span>

<span class="nc" id="L531">			_tablePopupMenu = new TablePopupMenu(allowUpdate, updateableObject, DataSetViewerTablePanel.this, getDataModelImplementationDetails());</span>
<span class="nc" id="L532">			_tablePopupMenu.setTable(this);</span>

<span class="nc" id="L534">         addMouseListener(new MouseAdapter()</span>
<span class="nc" id="L535">         {</span>
            public void mousePressed(MouseEvent evt)
            {
<span class="nc" id="L538">               onMousePressed(evt, false);</span>
<span class="nc" id="L539">            }</span>

            public void mouseReleased(MouseEvent evt)
            {
<span class="nc" id="L543">               onMouseReleased(evt);</span>
<span class="nc" id="L544">            }</span>
         });

<span class="nc" id="L547">         getTableHeader().addMouseListener(new MouseAdapter()</span>
<span class="nc" id="L548">         {</span>
            public void mousePressed(MouseEvent evt)
            {
<span class="nc" id="L551">               onMousePressed(evt, true);</span>
<span class="nc" id="L552">            }</span>

            public void mouseReleased(MouseEvent evt)
            {
<span class="nc" id="L556">               onMouseReleased(evt);</span>
<span class="nc" id="L557">            }</span>
         });

<span class="nc" id="L560">      }</span>

      private void onMouseReleased(MouseEvent evt)
      {
<span class="nc bnc" id="L564" title="All 2 branches missed.">         if (evt.isPopupTrigger())</span>
         {
<span class="nc" id="L566">            this.displayPopupMenu(evt);</span>
         }
<span class="nc" id="L568">      }</span>

      private void onMousePressed(MouseEvent evt, boolean clickedOnTableHeader)
      {
<span class="nc bnc" id="L572" title="All 2 branches missed.">         if (evt.isPopupTrigger())</span>
         {
<span class="nc" id="L574">            this.displayPopupMenu(evt);</span>
         }
<span class="nc bnc" id="L576" title="All 4 branches missed.">         else if (evt.getClickCount() == 2 &amp;&amp; false == clickedOnTableHeader)</span>
         {
            // If this was done when the header was clicked
            // it prevents MS Excel like adopition of column
            // sizes by double click. See class ButtonTableHeader.

            // figure out which column the user clicked on
            // so we can pass in the right column description
<span class="nc" id="L584">            Point pt = evt.getPoint();</span>
<span class="nc" id="L585">            TableColumnModel cm = this.getColumnModel();</span>
<span class="nc" id="L586">            int columnIndexAtX = cm.getColumnIndexAtX(pt.x);</span>

<span class="nc" id="L588">            int modelIndex = cm.getColumn(columnIndexAtX).getModelIndex();</span>


<span class="nc bnc" id="L591" title="All 2 branches missed.">            if (RowNumberTableColumn.ROW_NUMBER_MODEL_INDEX != modelIndex)</span>
            {
<span class="nc" id="L593">               ColumnDisplayDefinition colDefs[] = getColumnDefinitions();</span>
<span class="nc" id="L594">               CellDataPopup.showDialog(this, colDefs[modelIndex], evt, this._creator.isTableEditable());</span>

            }
         }
<span class="nc" id="L598">      }</span>

      public void initColWidths()
      {
<span class="nc" id="L602">         _tableHeader.initColWidths();</span>
<span class="nc" id="L603">      }</span>
   }


	
	
	
	
	/////////////////////////////////////////////////////////////////////////
	//
	// Implement the IDataSetTableControls interface,
	// functions needed to support table operations
	//
	// These functions are called from within MyJTable and MyTable to tell
	// those classes how to operate.  The code in these functions will be
	// different depending on whether the table is read-only or editable.
	//
	// The definitions below are for read-only operation.  The editable
	// table panel overrides these functions with the versions that tell the
	// tables how to set up for editing operations.
	//
	//
	/////////////////////////////////////////////////////////////////////////
	
	/**
	 * Tell the table that it is editable.  This is called from within
	 * MyTable.isCellEditable().  We do not bother to distinguish between
	 * editable and non-editable cells within the same table.
	 */
	public boolean isTableEditable() {
<span class="nc" id="L633">		return false;</span>
	}
	
	/**
	 * Tell the table whether particular columns are editable.
	 */
	public boolean isColumnEditable(int col, Object originalValue) {
<span class="nc" id="L640">		return false;</span>
	}

	/**
	 * See if a value in a column has been limited in some way and
	 * needs to be re-read before being used for editing.
	 * For read-only tables this may actually return true since we want
	 * to be able to view the entire contents of the cell even if it was not
	 * completely loaded during the initial table setup.
	 */
	public boolean needToReRead(int col, Object originalValue) {
		// call the DataType object for this column and have it check the current value
<span class="nc" id="L652">		return CellComponentFactory.needToReRead(_colDefs[col], originalValue);</span>
	}
	
	/**
	 * Re-read the contents of this cell from the database.
	 * If there is a problem, the message will have a non-zero length after return.
	 */
	public Object reReadDatum(Object[] values, int col, StringBuffer message) {
		// call the underlying model to get the whole data, if possible
<span class="nc" id="L661">		return ((IDataSetUpdateableTableModel)_updateableModel).</span>
<span class="nc" id="L662">			reReadDatum(values, _colDefs, col, message);</span>
	}
	
	/**
	 * Function to set up CellEditors.  Null for read-only tables.
	 */
<span class="nc" id="L668">	public void setCellEditors(JTable table) {}</span>
	
	/**
	 * Change the data in the permanent store that is represented by the JTable.
	 * Does nothing in read-only table.
	 */
	public int[] changeUnderlyingValueAt(
		int row,
		int col,
		Object newValue,
		Object oldValue)
	{
<span class="nc" id="L680">		return new int[0];	// underlaying data cannot be changed</span>
	}
	
	/**
	 * Delete a set of rows from the table.
	 * The indexes are the row indexes in the SortableModel.
	 */
<span class="nc" id="L687">	public void deleteRows(int[] rows) {}	// cannot delete rows in read-only table</span>
	
	/**
	 * Initiate operations to insert a new row into the table.
	 */
<span class="nc" id="L692">	public void insertRow() {}	// cannot insert row into read-only table</span>
	
	

	//
	// Begin code related to printing
	//

                                                                                
	//
	// variables used in printing
	//
	JTableHeader tableHeader;
<span class="nc" id="L705">	int [] subTableSplit = null;</span>
<span class="nc" id="L706">	boolean pageinfoCalculated=false;</span>
<span class="nc" id="L707">	int totalNumPages=0;</span>
<span class="nc" id="L708">	int prevPageIndex = 0;</span>
<span class="nc" id="L709">	int subPageIndex = 0;</span>
<span class="nc" id="L710">	int subTableSplitSize = 0;</span>
	double tableHeightOnFullPage, headerHeight;
	double pageWidth, pageHeight;
	int fontHeight, fontDesent;
	double tableHeight, rowHeight;
<span class="nc" id="L715">	double scale = 8.0/12.0;        // default is 12 point, so define font relative to that</span>


	/**
	 * Print the table contents.
	 * This was copied from a tutorial paper on the Sun Java site:
	 * paper: http://developer.java.sun.com/developer/onlineTraining/Programming/JDCBook/advprint.html
	 * code: http://developer.java.sun.com/developer/onlineTraining/Programming/JDCBook/Code/SalesReport.java
	 */
	public int print(Graphics g, PageFormat pageFormat, int pageIndex)
			throws PrinterException {

<span class="nc" id="L727">		Graphics2D g2=(Graphics2D)g;</span>
		
		// reset each time we start a new print
<span class="nc bnc" id="L730" title="All 2 branches missed.">		if (pageIndex==0)</span>
<span class="nc" id="L731">			pageinfoCalculated = false;</span>
		
<span class="nc bnc" id="L733" title="All 2 branches missed.">		if(!pageinfoCalculated) {</span>
<span class="nc" id="L734">			getPageInfo(g, pageFormat);</span>
		}
 
<span class="nc" id="L737">		g2.setColor(Color.black);</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">		if(pageIndex&gt;=totalNumPages) {</span>
<span class="nc" id="L739">			return NO_SUCH_PAGE;</span>
		}
<span class="nc bnc" id="L741" title="All 2 branches missed.">		if (prevPageIndex != pageIndex) {</span>
<span class="nc" id="L742">			subPageIndex++;</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">			if( subPageIndex == subTableSplitSize -1) {</span>
<span class="nc" id="L744">					subPageIndex=0;</span>
			}
		}
 
<span class="nc" id="L748">		g2.translate(pageFormat.getImageableX(), pageFormat.getImageableY());</span>
 
<span class="nc" id="L750">		int rowIndex = pageIndex/ (subTableSplitSize -1);</span>
         
<span class="nc" id="L752">		printTablePart(g2, pageFormat, rowIndex, subPageIndex);</span>
<span class="nc" id="L753">		prevPageIndex= pageIndex;</span>
 
<span class="nc" id="L755">		return Printable.PAGE_EXISTS;</span>
	}
 
 
	/**
	 * Part of print code coped from Sun
	 */
	public void getPageInfo(Graphics g, PageFormat pageFormat) {
 
<span class="nc" id="L764">		subTableSplit = null;</span>
<span class="nc" id="L765">		subTableSplitSize = 0;</span>
<span class="nc" id="L766">		subPageIndex = 0;</span>
<span class="nc" id="L767">		prevPageIndex = 0;</span>
 
<span class="nc" id="L769">		fontHeight=(int)(g.getFontMetrics().getHeight() * scale);</span>
<span class="nc" id="L770">		fontDesent=(int)(g.getFontMetrics().getDescent() * scale);</span>
 
<span class="nc" id="L772">		tableHeader = _table.getTableHeader();</span>
//		double headerWidth = tableHeader.getWidth() * scale;
<span class="nc" id="L774">		headerHeight = tableHeader.getHeight() +_table.getRowMargin() * scale;</span>
 
<span class="nc" id="L776">		pageHeight = pageFormat.getImageableHeight();</span>
<span class="nc" id="L777">		pageWidth =  pageFormat.getImageableWidth();</span>
 
//		double tableWidth =_table.getColumnModel().getTotalColumnWidth() * scale;
<span class="nc" id="L780">		tableHeight = _table.getHeight() * scale;</span>
<span class="nc" id="L781">		rowHeight = _table.getRowHeight() + _table.getRowMargin() * scale;</span>
 
<span class="nc" id="L783">		tableHeightOnFullPage = (int)(pageHeight - headerHeight - fontHeight*2);</span>
<span class="nc" id="L784">		tableHeightOnFullPage = tableHeightOnFullPage/rowHeight * rowHeight;</span>
 
<span class="nc" id="L786">		TableColumnModel tableColumnModel = tableHeader.getColumnModel();</span>
<span class="nc" id="L787">		int columns = tableColumnModel.getColumnCount();</span>
<span class="nc" id="L788">		int columnMargin = (int)(tableColumnModel.getColumnMargin() * scale);</span>
 
<span class="nc" id="L790">		int [] temp = new int[columns];</span>
<span class="nc" id="L791">		int columnIndex = 0;</span>
<span class="nc" id="L792">		temp[0] = 0;</span>
		int columnWidth;
<span class="nc" id="L794">		int length = 0;</span>
<span class="nc" id="L795">		subTableSplitSize = 0;</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">		while ( columnIndex &lt; columns ) {</span>
 
<span class="nc" id="L798">			columnWidth = (int)(tableColumnModel.getColumn(columnIndex).getWidth() * scale);</span>
 
<span class="nc bnc" id="L800" title="All 2 branches missed.">			if ( length + columnWidth + columnMargin &gt; pageWidth ) {</span>
<span class="nc" id="L801">				temp[subTableSplitSize+1] = temp[subTableSplitSize] + length;</span>
<span class="nc" id="L802">				length = columnWidth;</span>
<span class="nc" id="L803">				subTableSplitSize++;</span>
			}
			else {
<span class="nc" id="L806">				length += columnWidth + columnMargin;</span>
			}
<span class="nc" id="L808">			columnIndex++;</span>
		} //while
 
<span class="nc bnc" id="L811" title="All 2 branches missed.">		if ( length &gt; 0 )  {  // if are more columns left, part page</span>
<span class="nc" id="L812">		   temp[subTableSplitSize+1] = temp[subTableSplitSize] + length;</span>
<span class="nc" id="L813">		   subTableSplitSize++;</span>
		}
 
<span class="nc" id="L816">		subTableSplitSize++;</span>
<span class="nc" id="L817">		subTableSplit = new int[subTableSplitSize];</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">		for ( int i=0; i &lt; subTableSplitSize; i++ ) {</span>
<span class="nc" id="L819">			subTableSplit[i]= temp[i];</span>
		}
<span class="nc" id="L821">		totalNumPages = (int)(tableHeight/tableHeightOnFullPage);</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">		if ( tableHeight%tableHeightOnFullPage &gt;= rowHeight ) { // at least 1 more row left</span>
<span class="nc" id="L823">			totalNumPages++;</span>
		}
 
<span class="nc" id="L826">		totalNumPages *= (subTableSplitSize-1);</span>
<span class="nc" id="L827">		pageinfoCalculated = true;</span>
<span class="nc" id="L828">	}</span>
 
	/**
	 * Part of print code coped from Sun
	 */
	public void printTablePart(Graphics2D g2, PageFormat pageFormat, int rowIndex, int columnIndex) {
 
<span class="nc" id="L835">		String pageNumber = &quot;Page: &quot;+(rowIndex+1);</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">		if ( subTableSplitSize &gt; 1 ) {</span>
<span class="nc" id="L837">			pageNumber += &quot;-&quot; + (columnIndex+1);</span>
		}
 
<span class="nc" id="L840">		int pageLeft = subTableSplit[columnIndex];</span>
<span class="nc" id="L841">		int pageRight = subTableSplit[columnIndex + 1];</span>
 
<span class="nc" id="L843">		int pageWidth =  pageRight-pageLeft;</span>
 
 
		// page number message (in smaller type)
<span class="nc" id="L847">		g2.setFont(new Font(g2.getFont().getName(), g2.getFont().getStyle(), 8));</span>
<span class="nc" id="L848">		g2.drawString(pageNumber,  pageWidth/2-35, (int)(pageHeight - fontHeight));</span>
 
<span class="nc" id="L850">		double clipHeight = Math.min(tableHeightOnFullPage, tableHeight - rowIndex*tableHeightOnFullPage);</span>
 
<span class="nc" id="L852">		g2.translate(-subTableSplit[columnIndex], 0);</span>
<span class="nc" id="L853">		g2.setClip(pageLeft ,0, pageWidth, (int)headerHeight);</span>
 
<span class="nc" id="L855">		g2.scale(scale, scale);</span>
<span class="nc" id="L856">		tableHeader.paint(g2);   // draw the header on every page</span>
<span class="nc" id="L857">		g2.scale(1/scale, 1/scale);</span>
<span class="nc" id="L858">		g2.translate(0, headerHeight);</span>
<span class="nc" id="L859">		g2.translate(0,  -tableHeightOnFullPage*rowIndex);</span>
 
		// cut table image and draw on the page
 
<span class="nc" id="L863">		g2.setClip(pageLeft, (int)tableHeightOnFullPage*rowIndex, pageWidth, (int)clipHeight);</span>
<span class="nc" id="L864">		g2.scale(scale, scale);</span>
<span class="nc" id="L865">		_table.paint(g2);</span>
<span class="nc" id="L866">		g2.scale(1/scale, 1/scale);</span>
 
<span class="nc" id="L868">		double pageTop =  tableHeightOnFullPage*rowIndex - headerHeight;</span>
//		double pageBottom = pageTop +  clipHeight + headerHeight;
<span class="nc" id="L870">		g2.drawRect(pageLeft, (int)pageTop, pageWidth, (int)(clipHeight+ headerHeight));</span>
<span class="nc" id="L871">	}</span>
	
	//
	// End of code related to printing
	//


   @Override
   public TableState getResultSortableTableState()
   {
<span class="nc" id="L881">      return new TableState(_table);</span>
   }

   @Override
   public void applyResultSortableTableState(TableState sortableTableState)
   {
<span class="nc" id="L887">      sortableTableState.apply(_table);</span>
<span class="nc" id="L888">   }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>