<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataSetViewerEditableTablePanel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">102_squirrel-sql</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.squirrel_sql.fw.datasetviewer</a> &gt; <span class="el_source">DataSetViewerEditableTablePanel.java</span></div><h1>DataSetViewerEditableTablePanel.java</h1><pre class="source lang-java linenums">package net.sourceforge.squirrel_sql.fw.datasetviewer;
/*
 * Copyright (C) 2001-2003 Colin Bell
 * colbell@users.sourceforge.net
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

import net.sourceforge.squirrel_sql.fw.datasetviewer.cellcomponent.CellComponentFactory;
import net.sourceforge.squirrel_sql.fw.gui.SortableTableModel;
import net.sourceforge.squirrel_sql.fw.gui.TablePopupMenu;
import net.sourceforge.squirrel_sql.fw.util.StringManagerFactory;
import net.sourceforge.squirrel_sql.fw.util.StringManager;

import javax.swing.*;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableColumn;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;

/**
 * @author gwg
 *
 * Table view that allows editing of the data.
 */
<span class="nc" id="L40">public class DataSetViewerEditableTablePanel extends DataSetViewerTablePanel</span>
{

<span class="nc" id="L43">	private static final StringManager s_stringMgr =</span>
<span class="nc" id="L44">		StringManagerFactory.getStringManager(DataSetViewerEditableTablePanel.class);</span>


	/* Menu for right-mouse-click when in cell editors */
<span class="nc" id="L48">	TablePopupMenu cellPopupMenu = null;</span>
	
	/**
	 * Internal definitions
	 */
	public void init(IDataSetUpdateableModel updateableModel, IDataModelImplementationDetails dataModelImplementationDetails)
	{
<span class="nc" id="L55">		super.init(updateableModel, dataModelImplementationDetails);</span>
<span class="nc" id="L56">		setUpdateableModelReference(updateableModel);</span>
<span class="nc" id="L57">	}</span>
	
	///////////////////////////////////////////////////////////////////////////
	//
	// Override the functions that need to be changed to tell the table
	// mechanisms how to do editing.
	//
	//////////////////////////////////////////////////////////////////////////
	
	/**
	 * Tell the table that it is editable.  This is called from within
	 * MyTable.isCellEditable().  Certain column data types may not be editable.
	 */
	public  boolean isTableEditable()
	{
<span class="nc" id="L72">		return true;</span>
	}
	
	/**
	 * Tell the table whether a particular column may be edited or not
	 * based on whether the class associated with that column is known
	 * or not known, where &quot;not known&quot; is signaled by Object.class.
	 */
	public boolean isColumnEditable(int col, Object originalValue)
	{
<span class="nc bnc" id="L82" title="All 2 branches missed.">		if (_colDefs == null)</span>
<span class="nc" id="L83">			return false;	// cannot edit something that we do not know anything about</span>

<span class="nc bnc" id="L85" title="All 2 branches missed.">		if(RowNumberTableColumn.ROW_NUMBER_MODEL_INDEX == col)</span>
<span class="nc" id="L86">			return false;</span>

		// Cannot edit the rowID column, if present
<span class="nc bnc" id="L89" title="All 2 branches missed.">		if ( ((IDataSetUpdateableTableModel)getUpdateableModel()).getRowidCol() == col)</span>
<span class="nc" id="L90">			return false;</span>

<span class="nc" id="L92">		return CellComponentFactory.isEditableInCell(_colDefs[col], originalValue);</span>
	}
	
	/**
	 * Function to set up CellEditors for each of the data types
	 * to be handled in this table. Since different columns have different
	 * parameters (e.g. nullable or not nullable) we set the cell editors on the columns
	 * rather than on the table as a whole.
	 */
	public void setCellEditors(JTable table)
	{
		// we need to table column model to be able to add CellEditors to the
		// individual columns
<span class="nc" id="L105">		cellPopupMenu = new TablePopupMenu(getUpdateableModel(), this, table, getDataModelImplementationDetails());</span>
		
<span class="nc bnc" id="L107" title="All 2 branches missed.">		for (int i=0; i &lt; _colDefs.length; i++) {</span>
			// use factory to get the appropriate editor
<span class="nc" id="L109">			DefaultCellEditor editor =</span>
<span class="nc" id="L110">				CellComponentFactory.getInCellEditor(table, _colDefs[i]);</span>
			
			// add right-click menu to cell editor
<span class="nc" id="L113">			editor.getComponent().addMouseListener(</span>
				new MouseAdapter()
<span class="nc" id="L115">				{</span>
					public void mousePressed(MouseEvent evt)
					{
<span class="nc bnc" id="L118" title="All 2 branches missed.">						if (evt.isPopupTrigger())</span>
						{
<span class="nc" id="L120">							DataSetViewerEditableTablePanel.this.cellPopupMenu.show(</span>
<span class="nc" id="L121">								evt.getComponent(), evt.getX(), evt.getY());</span>
						}
<span class="nc" id="L123">					}</span>
					public void mouseReleased(MouseEvent evt)
					{
<span class="nc bnc" id="L126" title="All 2 branches missed.">						if (evt.isPopupTrigger())</span>
						{
<span class="nc" id="L128">							DataSetViewerEditableTablePanel.this.cellPopupMenu.show(</span>
<span class="nc" id="L129">								evt.getComponent(), evt.getX(), evt.getY());</span>
						}
<span class="nc" id="L131">					}</span>
				});

			// We have to look for the modelindex because of the Row Number column
<span class="nc" id="L135">			getColumnForModelIndex(i, table.getColumnModel()).setCellEditor(editor);</span>
		}
<span class="nc" id="L137">	}</span>

	private TableColumn getColumnForModelIndex(int modelIndex, TableColumnModel columnModel)
	{
<span class="nc bnc" id="L141" title="All 2 branches missed.">		for (int i = 0; i &lt; columnModel.getColumnCount(); i++)</span>
		{
<span class="nc bnc" id="L143" title="All 2 branches missed.">			if(columnModel.getColumn(i).getModelIndex() == modelIndex)</span>
			{
<span class="nc" id="L145">				return columnModel.getColumn(i);</span>
			}
		}

<span class="nc" id="L149">		throw new IllegalArgumentException(&quot;No column for model index &quot; + modelIndex);</span>
	}

	/**
	 * Call the underlaying object to update the data represented by the JTable.
	 * Both the old and the new value are objects of the appropriate
	 * Data Type for the column.  The newValue has been validated as part of
	 * the conversion from the external user representation (a String) into the
	 * internal object.
	 */
	public int[] changeUnderlyingValueAt(
		int row,
		int col,
		Object newValue,
		Object oldValue)
	{
<span class="nc" id="L165">		String message = null;</span>

		// At this point the user input has been validated and both the
		// new and old values are objects of the appropriate data type.
		// Either or both of newValue and oldValue may be null.

		// if there is no updateable model, then we cannot update anything
		// (should never happen - just being safe here)
<span class="nc bnc" id="L173" title="All 2 branches missed.">		if (getUpdateableModelReference() == null)</span>
<span class="nc" id="L174">			return new int[0];	// no underlying data, so cannot be changed</span>


		// check to see if new data is same as old data, in which case we
		// do not update the underlying data.
		//
		// This is NOT an optimization (though it does
		// speed things up).  We need to do this to avoid an error when we check for
		// rows being changed in the DB.  If the new value and old value are the same,
		// when we look to see if any rows already exist with the new value, it will find
		// the existing row and claim that the update will make one row identical to the
		// changed row (i.e. that there will be two identical rows in the DB) which is
		// not true.  So we avoid the problem by not updating the DB if the data has not
		// been changed.  This can happen if user changes the cell contents, then changes
		// them back before exiting the cell.

		// first look to see if they are identical objects, e.g. both null
<span class="nc bnc" id="L191" title="All 2 branches missed.">		if (newValue == oldValue)</span>
<span class="nc" id="L192">			return new int[0];	// the caller does not need to know that nothing happened</span>

		// if either of the values is null and the other is not, then the data has
		// changed and we fall-through to the change process.  Otherwise, check
		// the object contents.
<span class="nc bnc" id="L197" title="All 4 branches missed.">		if (oldValue != null &amp;&amp; newValue != null) {</span>
			// ask the DataType object if the two values are the same
<span class="nc bnc" id="L199" title="All 2 branches missed.">			if (CellComponentFactory.areEqual( _colDefs[col], oldValue, newValue))</span>
<span class="nc" id="L200">				return new int[0];	// the caller does not need to know that nothing happened</span>

			// if we reach this point, the value has been changed,
			// so fall through to next section
		}

		// call the function in the app code that checks for unexpected
		// conditions in the current DB
<span class="nc bnc" id="L208" title="All 2 branches missed.">		if (getUpdateableModelReference() != null)</span>
<span class="nc" id="L209">			message = ((IDataSetUpdateableTableModel)getUpdateableModelReference()).</span>
<span class="nc" id="L210">				getWarningOnCurrentData(getRow(row), _colDefs, col, oldValue);</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">		if (message != null) {</span>
			// set up dialog to ask user if it is ok to proceed
			// IMPORTANT: this dialog is SYNCHRONOUS (ie. we do not proceed until
			// user gives a response).  This is critical since this function provides
			// a return value to its caller that depends on the user input.
			// i18n[baseDataSetViewerDestination.warning=Warning]
<span class="nc" id="L218">			int option = JOptionPane.showConfirmDialog(null, message, s_stringMgr.getString(&quot;baseDataSetViewerDestination.warning&quot;),</span>
				JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
<span class="nc bnc" id="L220" title="All 2 branches missed.">			if ( option != JOptionPane.YES_OPTION)</span>
			{
<span class="nc" id="L222">				return new int[0];	// no update done to underlying data</span>
			}
		}

		// call the function in the app code that checks for unexpected
		// conditions in the DB as it will be after doing the update
<span class="nc bnc" id="L228" title="All 2 branches missed.">		if (getUpdateableModelReference() != null)</span>
<span class="nc" id="L229">			message = ((IDataSetUpdateableTableModel)getUpdateableModelReference()).</span>
<span class="nc" id="L230">				getWarningOnProjectedUpdate(getRow(row), _colDefs, col, newValue);</span>

<span class="nc bnc" id="L232" title="All 2 branches missed.">		if (message != null) {</span>
			// set up dialog to ask user if it is ok to proceed
			// IMPORTANT: this dialog is SYNCHRONOUS (ie. we do not proceed until
			// user gives a response).  This is critical since this function provides
			// a return value to its caller that depends on the user input.
			// i18n[baseDataSetViewerDestination.warning2=Warning]
<span class="nc" id="L238">			int option = JOptionPane.showConfirmDialog(null, message, s_stringMgr.getString(&quot;baseDataSetViewerDestination.warning2&quot;),</span>
				JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
<span class="nc bnc" id="L240" title="All 2 branches missed.">			if ( option != JOptionPane.YES_OPTION)</span>
			{
<span class="nc" id="L242">				return new int[0];	// no update done to underlying data</span>
			}
		}

		// call the function in the app code that saves the data in the
		// persistant storage (e.g. a database).
		// The success or failure of that function (as indicated by the absance or
		// presence of a result errpor/warning message) determines the result of this call.
		// (Since the table is supposed to be editable, we should have an
		// IDataSetUpdateableTableModel object set in our super class.)

<span class="nc" id="L253">		message = ((IDataSetUpdateableTableModel)getUpdateableModelReference()).</span>
<span class="nc" id="L254">			updateTableComponent(getRow(row), _colDefs, col, oldValue, newValue);</span>

<span class="nc bnc" id="L256" title="All 2 branches missed.">		if (message != null) {</span>
			// tell user that there was a problem
			// i18n[baseDataSetViewerDestination.error=Error]
<span class="nc" id="L259">			JOptionPane.showMessageDialog(null, message, s_stringMgr.getString(&quot;baseDataSetViewerDestination.error&quot;),</span>
				JOptionPane.ERROR_MESSAGE);

			// tell caller that the underlying data was not updated
			//?? is this always true, or could the data be updated with a warning?
<span class="nc" id="L264">			return new int[0];</span>
		}


		// No problems, so indicate a successful update of the underlying data.
		// In case we are editing an SQL result that contains the edited colum
		// more than once, we need to tell the caller to update all columns.
		// Otherwise generation of where clauses for further editing will fail.
<span class="nc" id="L272">		ArrayList&lt;Integer&gt; buf = new ArrayList&lt;Integer&gt;();</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">		for (int i = 0; i &lt; _colDefs.length; i++)</span>
		{
<span class="nc bnc" id="L275" title="All 2 branches missed.">			if(_colDefs[i].getFullTableColumnName().equalsIgnoreCase(_colDefs[col].getFullTableColumnName()))</span>
			{
<span class="nc" id="L277">				buf.add(Integer.valueOf(i));</span>
			}
		}

<span class="nc" id="L281">		int[] ret = new int[buf.size()];</span>

<span class="nc bnc" id="L283" title="All 2 branches missed.">		for (int i = 0; i &lt; ret.length; i++)</span>
		{
<span class="nc" id="L285">			ret[i] = buf.get(i);</span>
		}

<span class="nc" id="L288">		return ret;</span>
	}
	
	/**
	 * Delete a set of rows from the table.
	 * The indexes are the row indexes in the SortableModel.
	 */
	public void deleteRows(int[] rows)
	{
		// The list of rows may be empty, in which case
		// we tell user they should select something first
<span class="nc bnc" id="L299" title="All 2 branches missed.">		if (rows.length == 0) {</span>
<span class="nc" id="L300">			JOptionPane.showMessageDialog(null,</span>
			   // i18n[dataSetViewerEditableTablePanel.selectionNeeded=You must select something in the table to delete.]
<span class="nc" id="L302">				s_stringMgr.getString(&quot;dataSetViewerEditableTablePanel.selectionNeeded&quot;));</span>
<span class="nc" id="L303">			return;</span>
		}


		// i18n[dataSetViewerEditableTablePanel.deleteRosQuestion=Do you wish to delete {0} rows from this table?]
<span class="nc" id="L308">		String msg = s_stringMgr.getString(&quot;dataSetViewerEditableTablePanel.deleteRosQuestion&quot;, rows.length);</span>

		// Non-empty set of rows to delete.  Make sure user wants to delete
<span class="nc" id="L311">		int option = JOptionPane.showConfirmDialog(</span>
			null,
			msg,
			// i18n[dataSetViewerEditableTablePanel.warning=Warning]
<span class="nc" id="L315">			s_stringMgr.getString(&quot;dataSetViewerEditableTablePanel.warning&quot;),</span>
			JOptionPane.YES_NO_OPTION,
			JOptionPane.WARNING_MESSAGE);


<span class="nc bnc" id="L320" title="All 2 branches missed.">		if ( option != JOptionPane.YES_OPTION)</span>
		{
<span class="nc" id="L322">			return;	// no update done to underlying data</span>
		}
		
		//cancel any current cell editing operations
<span class="nc bnc" id="L326" title="All 2 branches missed.">		if (currentCellEditor != null) {</span>
<span class="nc" id="L327">			currentCellEditor.cancelCellEditing();</span>
<span class="nc" id="L328">			currentCellEditor = null;</span>
		}
		
		// create data structure containing contents of rows to be deleted
		// We cannot use the getRow() method because that uses MyJTable whereas
		// the indexes that we have are indexes in the SortableTableModel.
<span class="nc" id="L334">		SortableTableModel tableModel = (SortableTableModel)((JTable)getComponent()).getModel();</span>

<span class="nc" id="L336">		Object[][] rowData = new Object[rows.length][_colDefs.length];</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">		for (int i=0; i&lt;rows.length; i++) {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">			for (int j=0; j&lt;_colDefs.length; j++)</span>
<span class="nc" id="L339">				rowData[i][j] = tableModel.getValueAt(rows[i],j);</span>
		}
		
		// tell creator to delete from DB
<span class="nc" id="L343">		String message = </span>
<span class="nc" id="L344">			((IDataSetUpdateableTableModel)getUpdateableModel()).deleteRows(rowData, _colDefs);</span>

<span class="nc bnc" id="L346" title="All 2 branches missed.">		if (message != null)</span>
		{
			// tell user that there was a problem
<span class="nc" id="L349">			JOptionPane.showMessageDialog(null,</span>
				// i18n[dataSetViewerEditableTablePanel.noRowsDeleted={0}\nNo rows deleted from database.]
<span class="nc" id="L351">				s_stringMgr.getString(&quot;dataSetViewerEditableTablePanel.noRowsDeleted&quot;, message),</span>
				// i18n[dataSetViewerEditableTablePanel.error=Error]
<span class="nc" id="L353">				s_stringMgr.getString(&quot;dataSetViewerEditableTablePanel.error&quot;),</span>
				JOptionPane.ERROR_MESSAGE);

<span class="nc" id="L356">			return;</span>
		}

		// DB delete worked correctly, so now delete from table
		//IMPORTANT: The user and the creator both work through the
		// SortableTableModel, not the Actual model.  Thus the row
		// indexes to delete are given in the SortableTableModel row numbers,
		// so we must work through that model model to actually do the delete.
<span class="nc" id="L364">		((SortableTableModel)((MyJTable)getComponent()).getModel()).deleteRows(rows);</span>
<span class="nc" id="L365">        ((MyJTable)getComponent()).clearSelection();</span>
<span class="nc" id="L366">	}</span>

	/**
	 * Initiate operations to insert a new row into the table.
	 * This method just creates the panel to get the row input from the user.
	 */
	public void insertRow() {
<span class="nc" id="L373">		JTable table = (JTable)getComponent();</span>
		
		// Setting the starting position is ugly.  I just picked a point.
<span class="nc" id="L376">		Point pt = new Point(10, 200);</span>

<span class="nc" id="L378">		Component comp = SwingUtilities.getRoot(table);</span>

		// get the default values from the DB for the table columns
<span class="nc" id="L381">		String[] dbDefaultValues = </span>
<span class="nc" id="L382">			((IDataSetUpdateableTableModel)getUpdateableModelReference()).</span>
<span class="nc" id="L383">				getDefaultValues(_colDefs);</span>
		
		// based on defaults from DB, get the default object instance
		// for each column
<span class="nc" id="L387">		Object[] initialValues = new Object[dbDefaultValues.length];</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">		for (int i=0; i&lt; initialValues.length; i++) {</span>
<span class="nc" id="L389">			initialValues[i] = CellComponentFactory.getDefaultValue(</span>
				_colDefs[i], dbDefaultValues[i]);
		}

		// The following only works if SwingUtilities.getRoot(table) returns
		// and instanceof BaseMDIParentFrame.
		// If SwingTUilities.getRoot(table) returns and instance of Dialog or
		// Frame, then other code must be used.
<span class="nc" id="L397">		RowDataInputFrame rdif = new RowDataInputFrame( table, _colDefs, initialValues, this);</span>
//		((IMainFrame)comp).addInternalFrame(rdif, false);
//		rdif.setLayer(JLayeredPane.POPUP_LAYER);
<span class="nc" id="L400">		rdif.pack();</span>

<span class="nc" id="L402">		Dimension dim = rdif.getSize();</span>
<span class="nc" id="L403">		boolean dimChanged = false;</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">		if (dim.width &lt; 300)</span>
		{
<span class="nc" id="L406">			dim.width = 300;</span>
<span class="nc" id="L407">			dimChanged = true;</span>
		}

<span class="nc bnc" id="L410" title="All 2 branches missed.">		if (dimChanged)</span>
		{
<span class="nc" id="L412">			rdif.setSize(dim);</span>
		}

			
		// Determine the position to place the new internal frame. Ensure that the right end
		// of the internal frame doesn't exend past the right end the parent frame.	Use a
		// fudge factor as the dim.width doesn't appear to get the final width of the internal
		// frame (e.g. where pt.x + dim.width == parentBounds.width, the new internal frame
		// still extends past the right end of the parent frame).
<span class="nc" id="L421">		int fudgeFactor = 100;</span>
<span class="nc" id="L422">		Rectangle parentBounds = comp.getBounds();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">		if (parentBounds.width &lt;= (dim.width + fudgeFactor))</span>
		{
<span class="nc" id="L425">			dim.width = parentBounds.width - fudgeFactor;</span>
<span class="nc" id="L426">			pt.x = fudgeFactor / 2;</span>
<span class="nc" id="L427">			rdif.setSize(dim);</span>
		}
		else 
		{
<span class="nc bnc" id="L431" title="All 2 branches missed.">			if ((pt.x + dim.width + fudgeFactor) &gt; (parentBounds.width))</span>
			{
<span class="nc" id="L433">				pt.x -= (pt.x + dim.width + fudgeFactor) - parentBounds.width;</span>
			}
		}

<span class="nc" id="L437">		rdif.setLocation(pt);</span>
<span class="nc" id="L438">		rdif.setVisible(true);</span>
<span class="nc" id="L439">	}</span>
	
	/**
	 * Insert a new row into the table after the user has entered the row's data.
	 */
	protected String insertRow(Object[] values) {

<span class="nc" id="L446">		String message = </span>
<span class="nc" id="L447">			((IDataSetUpdateableTableModel)getUpdateableModelReference()).</span>
<span class="nc" id="L448">				insertRow(values, _colDefs);</span>
		
<span class="nc bnc" id="L450" title="All 2 branches missed.">		if (message != null) {</span>
			// there was a problem inserting into the DB
<span class="nc" id="L452">			JOptionPane.showMessageDialog(null,</span>
				// i18n[dataSetViewereditableTablePanel.error2=Error]
<span class="nc" id="L454">				message, s_stringMgr.getString(&quot;dataSetViewereditableTablePanel.error2&quot;),</span>
				JOptionPane.ERROR_MESSAGE);
				
<span class="nc" id="L457">			return &quot;Error&quot;;	// non-null return tells caller there was a problem</span>
		}

		// add the data to the existing tables
		
		// Do not try to be fancy and insert the data where the user is looking,
		// just stuff it into the actual model and re-paint the table
		// when the 'table changed' event is fired.
		
<span class="nc" id="L466">		SortableTableModel sortedModel =</span>
<span class="nc" id="L467">			(SortableTableModel)((JTable)getComponent()).getModel();</span>
			
<span class="nc" id="L469">		sortedModel.insertRow(values);</span>
		
		// everything is ok
<span class="nc" id="L472">		return null;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>