<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GroupLayoutEngineer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">40_glengineer</a> &gt; <a href="index.source.html" class="el_package">glengineer</a> &gt; <span class="el_source">GroupLayoutEngineer.java</span></div><h1>GroupLayoutEngineer.java</h1><pre class="source lang-java linenums">package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;

import java.util.*;
import java.awt.Component;
import java.awt.Container;

import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;


/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * &lt;p&gt;
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 * 
 * 
 * &lt;h3&gt;How to use the {@code GroupLayoutEngineer}&lt;/h3&gt;
 * 
 * &lt;ol&gt;
 * &lt;li&gt; Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * &lt;pre&gt;
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	&quot;FINDLABEL  TEXTFIELD      FINDBUTTON  &quot;,
 * 	&quot;          --------------+             &quot;,
 * 	&quot;           CB11   CB12  | CANSELBUTTON&quot;,
 * 	&quot;                        |             &quot;,
 * 	&quot;           CB21   CB22  |             &quot;);
 * &lt;/pre&gt;
 * 
 * &lt;li&gt; Associate the names on the scheme with concrete components, for example:
 * &lt;pre&gt;
 * gle.associate(&quot;FINDLABEL&quot;, new JLabel(&quot;Find What:&quot;));
 * gle.associate(&quot;TEXTFIELD&quot;, new JTextField());
 * gle.associate(&quot;FINDBUTTON&quot;, new JButton(&quot;Find&quot;));
 * gle.associate(&quot;CB11&quot;, new JCheckBox(&quot;Match Case&quot;));
 * gle.associate(&quot;CB12&quot;, new JCheckBox(&quot;Wrap Around&quot;));
 * gle.associate(&quot;CB21&quot;, new JCheckBox(&quot;Whole Words&quot;));
 * gle.associate(&quot;CB22&quot;, new JCheckBox(&quot;Search Backwards&quot;));
 * gle.associate(&quot;CANSELBUTTON&quot;, new JButton(&quot;Cancel&quot;));
 * &lt;/pre&gt;
 * 
 * &lt;li&gt; Apply optional preferences (such as special alignment), for example:
 * &lt;pre&gt;
 * gle.linkSize(&quot;FINDBUTTON&quot;, &quot;CANSELBUTTON&quot;);
 * 
 * gle.getParallelGroup(Axis.VERTICAL, &quot;FINDLABEL&quot;,&quot;FINDBUTTON&quot;)
 * 	.setContentAlignment(Alignment.BASELINE);
 * 
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * &lt;/pre&gt;
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * &lt;p&gt;&lt;br&gt;
 * 
 * &lt;li&gt; Invoke the method
 * &lt;pre&gt;
 * gle.engineer();
 * &lt;/pre&gt;
 * &lt;/ol&gt;
 * 
 * 
 * &lt;h3&gt;How to control gaps&lt;/h3&gt;
 * 
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * &lt;p&gt;
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * &lt;pre&gt;
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	&quot;FINDLABEL .. TEXTFIELD      . FINDBUTTON  &quot;,
 * 	&quot;            --------------+       .       &quot;,
 * 	&quot;             CB11 .g CB12 |   CANSELBUTTON&quot;,
 * 	&quot;               .          |               &quot;,
 * 	&quot;             CB21    CB22 |               &quot;);
 * 
 * gle.associateGap(&quot;.&quot;, ComponentPlacement.RELATED);
 * gle.associateGap(&quot;..&quot;, ComponentPlacement.UNRELATED);
 * gle.associateGap(&quot;.g1&quot;, 20);
 * &lt;/pre&gt;
 * 
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * &lt;p&gt;
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * &lt;p&gt;
 * Note that you may skip the associations of the denotations &quot;.&quot; and &quot;..&quot;
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 * 
 * &lt;p&gt;&lt;br&gt;
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * &lt;pre&gt;
 * gle.getSequentialGroup(Axis.HORIZONTAL, &quot;CB11&quot;, &quot;CB22&quot;)
 *   .getGroup(&quot;CB12&quot;,&quot;CB22&quot;)
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * &lt;/pre&gt;
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 * 
 * 
 * &lt;h3&gt;How to draw schemes&lt;/h3&gt;
 * 
 * In order to avoid formal introduction to this topic, 
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * &lt;p&gt;
 * Here we mention specific yet essential details only.
 * 
 * &lt;ol&gt;
 * &lt;li&gt; The names of components (and gaps) on the scheme may consist of 
 * letters of any case, numbers, and underscores '_'.
 * &lt;li&gt; For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * &lt;li&gt; One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * &lt;li&gt; If a block on the scheme is intersected by 
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * &lt;li&gt; The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * &lt;li&gt; If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * &lt;li&gt; Gaps on the scheme affect sequential groups only.
 * &lt;li&gt; If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * &lt;li&gt; Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * &lt;li&gt; A line may be intersected only by one gap.
 * &lt;li&gt; If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * &lt;/ol&gt; 
 * 
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer
{
	private Scheme scheme;
	/**
	 * The mapping of the names on the scheme to the associated components.
	 */
	private NamesToComponents namesToComponents;
	
	private NamesToGapAgents namesToGapAgents;
	
	/**
	 * The layout manager {@code GroupLayout} under control.
	 */
	private GroupLayout gl;
	
	/**
	 * The object which can create sequential and parallel
	 * {@code GroupLayout} groups and add components to groups
	 * using the components' names.
	 * &lt;p&gt;
	 * A reference to this object is given to the agents of elements.
	 * 
	 * @see glengineer.agents
	 */
	private GroupCreatorAndElementAdderClass creatorAndAdder;
	
	/**
	 * The agent of the top level horizontal group.
	 */
	private TopSequentialGroupAgent horizontalLayoutAgent;
	/**
	 * The agent of the top level vertical group.
	 */
	private TopSequentialGroupAgent verticalLayoutAgent;
	
	/**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
<span class="nc" id="L207">	private boolean autoBaselineAlignment = false;</span>
	
	/**
	 * @param container	the container that needs to be laid out
	 * @param lines		a sequence of lines representing the scheme
	 */
	public GroupLayoutEngineer(Container container, String... lines)
<span class="nc" id="L214">	{</span>
<span class="nc" id="L215">		scheme = new Scheme(lines);</span>
		
<span class="nc" id="L217">		namesToComponents = new NamesToComponents();</span>
<span class="nc" id="L218">		namesToGapAgents = new NamesToGapAgents();</span>
		
<span class="nc" id="L220">		horizontalLayoutAgent =</span>
<span class="nc" id="L221">			compouseTopSequentialGroup( Axis.HORIZONTAL );</span>
<span class="nc" id="L222">		verticalLayoutAgent =</span>
<span class="nc" id="L223">			compouseTopSequentialGroup( Axis.VERTICAL );</span>
		
<span class="nc" id="L225">		horizontalLayoutAgent.removeGapsFromParallelGroups();</span>
<span class="nc" id="L226">		verticalLayoutAgent.removeGapsFromParallelGroups();</span>
		
<span class="nc" id="L228">		gl = new GroupLayout(container);</span>
<span class="nc" id="L229">		container.setLayout(gl);</span>
		
//		setAutoCreateGaps(true);
//		setAutoCreateContainerGaps(true);
<span class="nc" id="L233">	}</span>
	
	/**
	 * Returns a top sequential group agent for the specified layout direction.
	 * &lt;p&gt;
	 * A group will be created even if it would contain a single element.
	 * 
	 * @param axis	the layout direction
	 * 
	 * @return		the agent of the new sequential group
	 */
	protected TopSequentialGroupAgent compouseTopSequentialGroup( Axis axis )
	{
		Block topBlock;
<span class="nc bnc" id="L247" title="All 2 branches missed.">		if( axis == Axis.HORIZONTAL )</span>
<span class="nc" id="L248">			topBlock = new HorizontalBlock(scheme);</span>
		else //VERTICAL
<span class="nc" id="L250">			topBlock = new VerticalBlock(scheme);</span>
		
<span class="nc" id="L252">		topBlock.optimize();</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">		if( topBlock.isTrivial() )</span>
<span class="nc" id="L254">			throw new IllegalArgumentException(</span>
					&quot;the scheme does not possess components' names&quot;);
		
<span class="nc" id="L257">		TopSequentialGroupAgent result = new TopSequentialGroupAgent();</span>
		
<span class="nc" id="L259">		List&lt;Block&gt; blocksList = topBlock.extractSequentialSubblocks();</span>
		
<span class="nc bnc" id="L261" title="All 2 branches missed.">		for (Block subBlock : blocksList)</span>
<span class="nc" id="L262">			result.addAgent( processSubblockOfSequentialGroup(subBlock) );</span>
		
<span class="nc" id="L264">		return result;</span>
	}

	/**
	 * Returns a new sequential group agent filled with
	 * the agents of the specified block content.
	 * 
	 * @param block	the block which content should be placed
	 * 				into a sequential group.
	 * 
	 * @return		the agent of the new sequential group.
	 */
	protected Agent compouseSequentialGroupFromBlock( Block block )
	{
<span class="nc" id="L278">		block.optimize();</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">		if( block.isTrivial() )  return null;</span>
		
<span class="nc" id="L281">		List&lt;Block&gt; blocksList = block.extractSequentialSubblocks();</span>
		
<span class="nc bnc" id="L283" title="All 2 branches missed.">		if( blocksList.size() == 1 )</span>
<span class="nc" id="L284">			return processSubblockOfSequentialGroup( block );</span>
		
<span class="nc" id="L286">		SequentialGroupAgent result = new SequentialGroupAgent();</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">		for (Block subBlock : blocksList)</span>
<span class="nc" id="L288">			result.addAgent( processSubblockOfSequentialGroup(subBlock) );</span>
<span class="nc" id="L289">		return result;</span>
	}
	
	/**
	 * Verifies whether the specified subblock contains a single element
	 * or a set of elements
	 * and either returns the agent of the corresponding element,
	 * or divides the set of elements into a new parallel subgroup
	 * and returns the corresponding agent.
	 * 
	 * @param subblock	a block in a sequential group.
	 * 
	 * @return			the agent of the specified subblock content.
	 */
	private Agent processSubblockOfSequentialGroup( Block subblock )
	{
<span class="nc bnc" id="L305" title="All 2 branches missed.">		if( subblock.containsOnlyOneWord() )</span>
<span class="nc" id="L306">			return getElementFromBlockWithOnlyWord( subblock );</span>
		else
<span class="nc" id="L308">			return composeParallelGroupFromBlock( subblock );</span>
	}
	
	/**
	 * Returns the agent of the unique element (a component or a gap)
	 * in the specified block which is added into a sequential group.
	 * 
	 * @param block	a block with an only element in a parallel group.
	 * 
	 * @return		the agent of the unique element in the specified block.
	 */
	private Agent getElementFromBlockWithOnlyWord( Block block )
	{
<span class="nc" id="L321">		String word = block.textAt( block.firstWord_Horizontally() );</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">		if( word.charAt(0) == '.' )</span>
<span class="nc" id="L323">			return new TemporaryGapAgent(word);</span>
<span class="nc" id="L324">		return new ComponentAgent( word );</span>
	}
	
	/**
	 * Returns a new parallel group agent filled with
	 * the agents of the specified block content.
	 * 
	 * @param block	the block which content should be placed
	 * 				into a sequential group.
	 * 
	 * @return		the agent of the new parallel group.
	 */
	protected Agent composeParallelGroupFromBlock( Block block )
	{
<span class="nc" id="L338">		block.optimize();</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">		if( block.isTrivial() )  return null;</span>
		
<span class="nc" id="L341">		List&lt;Block&gt; blocksList = block.extractParallelSubblocks();</span>
		
<span class="nc bnc" id="L343" title="All 2 branches missed.">		if( blocksList.size() == 1 )</span>
<span class="nc" id="L344">			return processSubblockOfParallelGroup( block );</span>
		
<span class="nc" id="L346">		ParallelGroupAgent result = new ParallelGroupAgent();</span>
		Agent agent;
<span class="nc bnc" id="L348" title="All 2 branches missed.">		for (Block subBlock : blocksList) {</span>
<span class="nc" id="L349">			agent = processSubblockOfParallelGroup(subBlock);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">			if( agent != null ) result.addAgent( agent );</span>
<span class="nc" id="L351">		}</span>
<span class="nc" id="L352">		return result;</span>
	}
	
	/**
	 * Verifies whether the specified subblock contains a single element
	 * or a set of elements
	 * and then either returns the agent of the corresponding element,
	 * or divides the set of elements into a new sequential subgroup
	 * and returns the corresponding agent.
	 * &lt;p&gt;
	 * If there is a unique element and it is a gap,  
	 * 
	 * @param subblock	a block in a parallel group.
	 * 
	 * @return	the agent of the specified subblock content.
	 */
	private Agent processSubblockOfParallelGroup( Block subblock )
	{
<span class="nc bnc" id="L370" title="All 2 branches missed.">		if( subblock.containsOnlyOneWord() )</span>
<span class="nc" id="L371">			return getElementFromBlockWithOnlyWord( subblock );</span>
		else
<span class="nc" id="L373">			return compouseSequentialGroupFromBlock( subblock );</span>
	}
	
	/**
	 * Associates the specified {@code name} on the scheme
	 * with the specified {@code component}.
	 * 
	 * @param name		the component name present on the scheme.
	 * @param component	the component to be associated with the name.
	 */
	public void associate( String name, Component component )
	{
<span class="nc" id="L385">		namesToComponents.put(name,component);</span>
<span class="nc" id="L386">	}</span>
	
	/**
	 * Associates the specified {@code denotation} on the scheme
	 * with gaps of the specified {@code size}.
	 */
	public void associateGap( String denotation, int size )
	{
<span class="nc" id="L394">		namesToGapAgents.put(</span>
				denotation,
				new GapAgent(size) );
<span class="nc" id="L397">	}</span>
	
	/**
	 * Associates the specified {@code denotation} on the scheme with gaps
	 * of the specified {@code min}, {@code pref}, and {@code max} sizes.
	 */
	public void associateGap(
			String denotation, int min, int pref, int max )
	{
<span class="nc" id="L406">		namesToGapAgents.put(</span>
				denotation,
				new GapAgent(min,pref,max) );
<span class="nc" id="L409">	}</span>
	
	/**
	 * Associates the specified {@code denotation} on the scheme
	 * with preferred gaps
	 * of the specified component placement type (related or unrelated).
	 */
	public void associateGap( String denotation, ComponentPlacement type )
	{
<span class="nc" id="L418">		namesToGapAgents.put(</span>
				denotation,
				new PreferredGapAgent(type) );
<span class="nc" id="L421">	}</span>
	
	/**
	 * Associates the specified {@code denotation} on the scheme
	 * with preferred gaps
	 * of the specified component placement type (related or unrelated)
	 * and of the specified preferred and maximum sizes.
	 */
	public void associateGap(
			String denotation, ComponentPlacement type, int pref, int max )
	{
<span class="nc" id="L432">		namesToGapAgents.put(</span>
				denotation,
				new PreferredGapAgent(type, pref, max) );
<span class="nc" id="L435">	}</span>
	
	
	/**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding)
    {
<span class="nc" id="L449">    	gl.setAutoCreateGaps(autoCreatePadding);</span>
<span class="nc" id="L450">    }</span>
    
    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps)
    {
<span class="nc" id="L463">    	gl.setAutoCreateContainerGaps(autoCreateContainerGaps);</span>
<span class="nc" id="L464">    }</span>
    
    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment)
    {
<span class="nc" id="L473">    	this.autoBaselineAlignment = autoBaselineAlignment;</span>
<span class="nc" id="L474">    }</span>
	
	/**
	 * Forces the specified components to have the same size
	 * regardless of their preferred, minimum or maximum sizes.
	 * Components that are linked are given the maximum
	 * of the preferred size of each of the linked components.
     * 
	 * @param names	the names of the components	that are
	 * 				to have the same size.
	 */
	public void linkSize(String... names)
	{
<span class="nc" id="L487">		Component[] components = namesToComponents.getComponents(names);</span>
<span class="nc" id="L488">		gl.linkSize(components);</span>
<span class="nc" id="L489">	}</span>
	
	/**
	 * Forces the specified components to have the same size
	 * along the specified axis regardless of their
	 * preferred, minimum or maximum sizes.
	 * Components that are linked are given the maximum
	 * of the preferred size of each of the linked components.
     * 
	 * @param axis	the axis to link the size along.
	 * @param names	the names of the components	that are
	 * 				to have the same size.
	 */
	public void linkSize(Axis axis, String... names)
	{
<span class="nc" id="L504">		Component[] components = namesToComponents.getComponents(names);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">		if( axis==Axis.HORIZONTAL )</span>
<span class="nc" id="L506">			gl.linkSize(SwingConstants.HORIZONTAL, components);</span>
		else //axis==Axis.VERTICAL
<span class="nc" id="L508">			gl.linkSize(SwingConstants.VERTICAL, components);</span>
<span class="nc" id="L509">	}</span>
	
	/**
	 * Disables the components under the specified names.
	 * &lt;p&gt;
	 * Each component must be associated with its name
	 * before this method is applied.
	 */
	public void disable(String...componentsNames)
	{
<span class="nc bnc" id="L519" title="All 2 branches missed.">		for( Component c : namesToComponents.getComponents(componentsNames) )</span>
<span class="nc" id="L520">			c.setEnabled(false);</span>
<span class="nc" id="L521">	}</span>
	
	/**
	 * Finds the agent of the component with the specified name
	 * and returns an interface for adjusting that component.
	 * 
	 * @param axis			layout direction
	 * @param componentName	the name of the component to be found 
	 * @return				an interface {@code FunctionsOnComponent}
	 * 						for adjusting the component
	 */
	public FunctionsOnComponent getComponent(Axis axis, String componentName)
	{
<span class="nc" id="L534">		Agent agent = getAgent(axis,componentName);</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">		if( agent == null )</span>
<span class="nc" id="L536">			throw new IllegalArgumentException(</span>
					&quot;no such component found: &quot; + componentName );
<span class="nc" id="L538">		return ((ComponentAgent)agent).getFunctionsOnComponentImplementation();</span>
	}
	
	/**
	 * Finds the agent of the group which first and last components
	 * have the specified names;
	 * returns an interface for adjusting that group and adding gaps into it.
	 * 
	 * @param axis		layout direction
	 * @param firstName	the name of the first component in the group
	 * @param lastName	the name of the last component in the group
	 * @return			an interface {@code FunctionsOnGroup}
	 * 					for adjusting that group and adding gaps into it
	 */
	public FunctionsOnGroup getGroup(
			Axis axis, String firstName, String lastName)
	{
<span class="nc" id="L555">		Agent agent = getGroupAgent(axis, firstName,lastName);</span>
<span class="nc bnc" id="L556" title="All 4 branches missed.">		if( agent==null || !(agent instanceof GroupAgent) )</span>
<span class="nc" id="L557">			throw new IllegalArgumentException(</span>
					&quot;no such group found: &lt;&quot; +
					firstName + &quot;,&quot; + lastName + &quot;&gt;&quot; );
<span class="nc" id="L560">		return ((GroupAgent)agent).getFunctionsOnGroupImplemenation();</span>
	}
	
	/**
	 * Finds the agent of the parallel group which first and last components
	 * have the specified names;
	 * returns an interface for adjusting that group and adding gaps into it.
	 * 
	 * @param axis		layout direction
	 * @param firstName	the name of the first component in the group
	 * @param lastName	the name of the last component in the group
	 * @return			an interface {@code FunctionsOnParallelGroup}
	 * 					for adjusting that group and adding gaps into it
	 */
	public FunctionsOnParallelGroup getParallelGroup(
			Axis axis, String firstName, String lastName )
	{
<span class="nc" id="L577">		Agent agent = getParallelGroupAgent(axis, firstName,lastName);</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">		if( agent == null )</span>
<span class="nc" id="L579">			throw new IllegalArgumentException(</span>
					&quot;no such parallel group found: &lt;&quot; +
					firstName + &quot;,&quot; + lastName + &quot;&gt;&quot; );
<span class="nc" id="L582">		return ((ParallelGroupAgent)agent)</span>
<span class="nc" id="L583">					.getFunctionsOnParallelGroupImplemenation();</span>
	}
	
	/**
	 * Finds the agent of the sequential group which first and last components
	 * have the specified names;
	 * returns an interface for adjusting that group and adding gaps into it.
	 * 
	 * @param axis		layout direction
	 * @param firstName	the name of the first component in the group
	 * @param lastName	the name of the last component in the group
	 * @return			an interface {@code FunctionsOnSequentialGroup}
	 * 					for adjusting that group and adding gaps into it
	 */
	public FunctionsOnSequentialGroup getSequentialGroup(
			Axis axis, String firstName, String lastName )
	{
<span class="nc" id="L600">		Agent agent = getSequentialGroupAgent(axis, firstName,lastName);</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">		if( agent==null )</span>
<span class="nc" id="L602">			throw new IllegalArgumentException(</span>
					&quot;No such sequential group found: &lt;&quot; +
					firstName + &quot;,&quot; + lastName + &quot;&gt;.&quot; );
<span class="nc" id="L605">		return ((SequentialGroupAgent)agent)</span>
<span class="nc" id="L606">					.getFunctionsOnSequentialGroupImplemenation();</span>
	}
	
	/**
	 * Returns the agent of the top level sequential group
	 * under the specified layout direction.
	 * 
	 * @param axis	layout direction
	 * @return		the agent of the top level sequential group
	 * 				under the specified layout direction
	 */
	public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis)
	{
<span class="nc" id="L619">		return getTopAgent(axis)</span>
<span class="nc" id="L620">				.getFunctionsOnTopSequentialGroupImplemenation();</span>
	}

	/**
	 * Returns the agent of the component with the specified name
	 * under the specified layout direction.
	 * 
	 * @param axis	layout direction
	 * @param name	the name of the component to be found
	 * @return		the corresponding agent
	 */
	private Agent getAgent( Axis axis, String name )
	{
<span class="nc" id="L633">		return getTopAgent(axis).findDependingComponentByName(name);</span>
	}
	
	/**
	 * Returns the agent of the group with the specified first and last names
	 * under the specified layout direction.
	 * 
	 * @param axis		layout direction
	 * @param firstName	the name of the first component in the group
	 * @param lastName	the name of the last component in the group
	 * @return			the agent of the corresponding group
	 */
	private GroupAgent getGroupAgent(
			Axis axis, String firstName, String lastName )
	{
<span class="nc" id="L648">		return getTopAgent(axis)</span>
<span class="nc" id="L649">				.findDependingGroupByNames(firstName,lastName);</span>
	}
	private SequentialGroupAgent getSequentialGroupAgent(
			Axis axis, String firstName, String lastName )
	{
<span class="nc" id="L654">		return getTopAgent(axis)</span>
<span class="nc" id="L655">			.findDependingSequentialGroupByNames(firstName,lastName);</span>
	}
	private ParallelGroupAgent getParallelGroupAgent(
			Axis axis, String firstName, String lastName )
	{
<span class="nc" id="L660">		return getTopAgent(axis)</span>
<span class="nc" id="L661">			.findDependingParallelGroupByNames(firstName,lastName);</span>
	}
	
	/**
	 * Returns (a reference to) the top agent
	 * for the specified layout direction. 
	 * 
	 * @param axis	layout direction
	 * @return		the corresponding top agent
	 */
	private TopSequentialGroupAgent getTopAgent(Axis axis)
	{
<span class="nc bnc" id="L673" title="All 2 branches missed.">		return axis == Axis.HORIZONTAL ?</span>
				horizontalLayoutAgent :	verticalLayoutAgent;
	}
	
	/**
	 * Places the components into the container
	 * according to the scheme and to all additional preferences.
	 */
	public void engineer()
	{
<span class="nc" id="L683">		horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);</span>
<span class="nc" id="L684">		verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);</span>
		
<span class="nc bnc" id="L686" title="All 2 branches missed.">		if( autoBaselineAlignment )</span>
<span class="nc" id="L687">			makeTextFieldsBaselineIn( verticalLayoutAgent );</span>
		
<span class="nc" id="L689">		creatorAndAdder = new GroupCreatorAndElementAdderClass();</span>
		
<span class="nc" id="L691">		gl.setHorizontalGroup(</span>
<span class="nc" id="L692">				horizontalLayoutAgent.groupContent(creatorAndAdder) );</span>
		
<span class="nc" id="L694">		gl.setVerticalGroup(</span>
<span class="nc" id="L695">			verticalLayoutAgent.groupContent(creatorAndAdder) );</span>
<span class="nc" id="L696">	}</span>
	
	/**
	 * If the specified group is parallel,
	 * contains directly a component of type {@code JTextField},
	 * and does not contain other groups with components,
	 * then this method makes the alignment of the group {@code Baseline}.
	 * &lt;p&gt;
	 * In the case of a group having subgroups with components
	 * this method passes the call to that subgroups.
	 * &lt;p&gt;
	 * As a result of applying this method,
	 * all parallel groups having TextFields (but having no subgroups)
	 * will be aligned along baselines.
	 */
	private void makeTextFieldsBaselineIn(GroupAgent group)
	{
<span class="nc" id="L713">		boolean containsGroups = false;</span>
<span class="nc" id="L714">		boolean containsTextfields = false;//the group must be baseline aligned</span>
<span class="nc" id="L715">		boolean isParallel = group instanceof ParallelGroupAgent;</span>
		
<span class="nc bnc" id="L717" title="All 2 branches missed.">		for( Agent child : group.getChildren() ) {</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">			if( child instanceof GroupAgent &amp;&amp; </span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">					((GroupAgent)child).getFirstName() != null ) {</span>
				//child is a group with components.
<span class="nc" id="L721">				makeTextFieldsBaselineIn( (GroupAgent)child );</span>
<span class="nc" id="L722">				containsGroups = true;</span>
			} else
<span class="nc bnc" id="L724" title="All 6 branches missed.">				if( child instanceof ComponentAgent &amp;&amp;</span>
						isParallel &amp;&amp; ! containsGroups ) {
<span class="nc" id="L726">					ComponentAgent agent = (ComponentAgent) child;</span>
<span class="nc" id="L727">					Component comp =</span>
<span class="nc" id="L728">						namesToComponents.compMap.get( agent.getFirstName() );</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">					if( comp instanceof JTextField )</span>
<span class="nc" id="L730">						containsTextfields = true;</span>
				}
<span class="nc" id="L732">		}</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">		if( containsTextfields ) {</span>
<span class="nc" id="L734">			ParallelGroupSettings settings =</span>
<span class="nc" id="L735">				((ParallelGroupAgent)group).getSettings();</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">			if( settings.contentAlignment == null )</span>
<span class="nc" id="L737">				settings.contentAlignment = Alignment.BASELINE;</span>
		}
<span class="nc" id="L739">	}</span>
	
	
	/**
	 * Outputs the groups hierarchy.
	 */
	public void printGroupStructure()
	{
<span class="nc" id="L747">		new GroupPrinter().printTopGroupsStructure();</span>
<span class="nc" id="L748">	}</span>
	
	
	
	/**
	 * Encapsulates the &quot;names of components - to - components&quot; mapping
	 * and the corresponding methods of access and modification.
	 */
	private class NamesToComponents
	{
		/**
		 * Holds the association between the names of the components on
		 * the scheme and the corresponding components.
		 */
<span class="nc" id="L762">		private HashMap&lt;String,Component&gt; compMap =</span>
				new HashMap&lt;String,Component&gt;();

		public NamesToComponents()
<span class="nc" id="L766">		{</span>
<span class="nc" id="L767">		}</span>
		
		@SuppressWarnings(&quot;unused&quot;)
		public boolean contains(String name)
		{
<span class="nc" id="L772">			return compMap.containsKey(name);</span>
		}
		
		@SuppressWarnings(&quot;unused&quot;)
		public boolean contains(Component component)
		{
<span class="nc" id="L778">			return compMap.containsValue(component);</span>
		}
		
		public void put(String name, Component component)
		{
<span class="nc bnc" id="L783" title="All 4 branches missed.">			if( name == null || component == null ||</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">					!scheme.containsComponentName(name) ||</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">					compMap.put(name,component) != null )</span>
<span class="nc" id="L786">				throw new IllegalArgumentException(</span>
						&quot;Cannot associate a component&quot;
						+ &quot; with the name \&quot;&quot; + name + &quot;\&quot;&quot; );
<span class="nc" id="L789">		}</span>
		
		/**
		 * Returns the component associated with the specified name.
		 * 
		 * @param name	the name of the component to return
		 * 
		 * @return		the component associated with the specified name
		 */
		public Component getComponent(String name)
		{
<span class="nc bnc" id="L800" title="All 2 branches missed.">			if( name == null )</span>
<span class="nc" id="L801">				throw new IllegalArgumentException(&quot;No name specified&quot;);</span>
			
<span class="nc" id="L803">			Component result = compMap.get(name);</span>
			
<span class="nc bnc" id="L805" title="All 2 branches missed.">			if( result == null ) </span>
<span class="nc" id="L806">				throw new IllegalArgumentException(</span>
						&quot;cannot find a component&quot; + 
						&quot; with the specified name \&quot;&quot; + name + &quot;\&quot;&quot; );
<span class="nc" id="L809">			return result;</span>
		}
		
		/**
		 * Returns the components associated with the specified names.
		 * 
		 * @param names	the names of the components to return
		 * 
		 * @return		the components associated with the specified names
		 */
		public Component[] getComponents(String... names)
		{
<span class="nc" id="L821">			int l = names.length;</span>
<span class="nc" id="L822">			Component[] components = new Component[l];</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">			for (int i=0; i&lt;l; i++)</span>
<span class="nc" id="L824">				components[i] = getComponent(names[i]);</span>
<span class="nc" id="L825">			return components;</span>
		}
		
	}
	
	
	/**
	 * Declares the method of possessing the gap agent
	 * by a temporary gap agent.
	 */
	public interface TemporaryGapsToGaps
	{
		/**
		 * Returns the gap agent associated with the specified
		 * temporary gap agent.
		 */
		public Agent gap(TemporaryGapAgent temp);
	}
	
	/**
	 * Encapsulates the &quot;names of the gaps - to - agents of these gaps&quot; mapping
	 * and the corresponding methods of access and modification.
	 */
	private class NamesToGapAgents implements TemporaryGapsToGaps
	{
		/**
		 * Holds the association between the gaps denotations
		 * on the scheme and the corresponding gap types.
		 * &lt;p&gt;
		 * The gaps (which can be preferred or simple) are represented
		 * by instances of {@code Agent}, which is a superclass
		 * for both {@code PreferredGapAgent} and {@code GapAgent}.
		 */
<span class="nc" id="L858">		private HashMap&lt;String,Agent&gt; gapMap = new HashMap&lt;String,Agent&gt;();</span>

		public NamesToGapAgents()
<span class="nc" id="L861">		{</span>
<span class="nc" id="L862">			safePut( &quot;.&quot;, new PreferredGapAgent(</span>
							LayoutStyle.ComponentPlacement.RELATED) );
<span class="nc" id="L864">			safePut( &quot;..&quot;, new PreferredGapAgent(</span>
					LayoutStyle.ComponentPlacement.UNRELATED) );
<span class="nc" id="L866">		}</span>
		
		public void put(String name, GapAgent agent)
		{
<span class="nc bnc" id="L870" title="All 2 branches missed.">			if( name == null ) </span>
<span class="nc" id="L871">				throw new IllegalArgumentException(</span>
						&quot;Cannot associate a gap with a null name.&quot;);
<span class="nc bnc" id="L873" title="All 2 branches missed.">			if( agent == null )</span>
<span class="nc" id="L874">				throw new IllegalArgumentException(</span>
						&quot;Cannot associate null agents.&quot;);
<span class="nc bnc" id="L876" title="All 2 branches missed.">			if( !scheme.containsGapName(name) )</span>
<span class="nc" id="L877">				return;</span>
				/*throw new IllegalArgumentException(
					&quot;The gap name &quot; + name + &quot; not found on the scheme.&quot;);*/
<span class="nc" id="L880">			safePut(name,agent);</span>
			
<span class="nc" id="L882">		}</span>
		protected void safePut(String name, GapAgent agent)
		{
<span class="nc" id="L885">			gapMap.put(name,agent);</span>
<span class="nc" id="L886">		}</span>
		
		public void put(String name, PreferredGapAgent agent)
		{
<span class="nc bnc" id="L890" title="All 2 branches missed.">			if( name == null ) </span>
<span class="nc" id="L891">				throw new IllegalArgumentException(</span>
						&quot;Cannot associate a gap with a null name.&quot;);
<span class="nc bnc" id="L893" title="All 2 branches missed.">			if( agent == null )</span>
<span class="nc" id="L894">				throw new IllegalArgumentException(</span>
						&quot;Cannot associate null agents.&quot;);
<span class="nc bnc" id="L896" title="All 2 branches missed.">			if( !scheme.containsGapName(name) )</span>
<span class="nc" id="L897">				return;</span>
				/*throw new IllegalArgumentException(
					&quot;The gap name &quot; + name + &quot; not found on the scheme.&quot;);*/
<span class="nc" id="L900">			safePut(name,agent);</span>
			
<span class="nc" id="L902">		}</span>
		protected void safePut(String name, PreferredGapAgent agent)
		{
<span class="nc" id="L905">			gapMap.put(name,agent);</span>
<span class="nc" id="L906">		}</span>
		
		/**
		 * Returns the gap agent associated with the specified name.
		 */
		public Agent gap(String name)
		{
<span class="nc bnc" id="L913" title="All 2 branches missed.">			if( name == null )</span>
<span class="nc" id="L914">				throw new IllegalArgumentException(&quot;No name specified&quot;);</span>
			
<span class="nc" id="L916">			Agent result = gapMap.get(name);</span>
			
<span class="nc bnc" id="L918" title="All 2 branches missed.">			if( result == null ) </span>
<span class="nc" id="L919">				throw new IllegalArgumentException(</span>
						&quot;cannot find a gap denoted by \&quot;&quot; + name + &quot;\&quot;&quot; );
<span class="nc" id="L921">			return result;</span>
		}
		
		/**
		 * Returns the gap agent associated with the specified
		 * temporary gap agent.
		 */
		public Agent gap(TemporaryGapAgent temp)
		{
<span class="nc" id="L930">			return gap( temp.getDenotation() );</span>
		}
	}
	
	
	/**
	 * An adapter for such functions of the {@code GroupLayout}
	 * as creating new groups and adding groups and components to groups.
	 */
<span class="nc" id="L939">	private class GroupCreatorAndElementAdderClass</span>
			implements GroupCreatorAndElementAdder
	{
		/**
		 * Creates and returns a new {@code SequentialGroup}.
		 */
		public SequentialGroup createSequentialGroup()
		{
<span class="nc" id="L947">			return gl.createSequentialGroup();</span>
		}
	
		/**
		 * Creates and returns a new {@code ParallelGroup}
		 * with the specified settings.
		 */
		public ParallelGroup createParallelGroup(
				ParallelGroupSettings settings )
		{
<span class="nc bnc" id="L957" title="All 2 branches missed.">			if( settings.contentAlignment != null )</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">				if( settings.resizable != null )</span>
<span class="nc" id="L959">					return gl.createParallelGroup(</span>
<span class="nc" id="L960">							settings.contentAlignment, settings.resizable);</span>
				else //(resizable == null)
<span class="nc" id="L962">					return gl.createParallelGroup( settings.contentAlignment );</span>
			else //(settings.contentAlignment == null)
<span class="nc bnc" id="L964" title="All 2 branches missed.">				if( settings.resizable != null )</span>
<span class="nc" id="L965">					return gl.createParallelGroup(</span>
<span class="nc" id="L966">							Alignment.LEADING, settings.resizable );</span>
				else
<span class="nc" id="L968">					return gl.createParallelGroup();</span>
		}
	
		/**
		 * Adds the component having the specified {@code compName}
		 * to the specified {@code group},
		 * applies to it the specified {@code settings}.
		 */
		public void addComponentToGroup(
				String compName, Group group, ComponentSettings settings )
		{
<span class="nc bnc" id="L979" title="All 2 branches missed.">			if( settings.alignmentWithRespectToParent != null )</span>
			//It seems that we must add to a parallel group.
<span class="nc bnc" id="L981" title="All 2 branches missed.">				if( group instanceof ParallelGroup )</span>
				//Really, to a parallel.
<span class="nc bnc" id="L983" title="All 2 branches missed.">					if( settings.sizes != null ) {</span>
<span class="nc" id="L984">						Sizes sizes = settings.sizes;</span>
<span class="nc" id="L985">						((ParallelGroup)group).addComponent(</span>
<span class="nc" id="L986">								namesToComponents.getComponent(compName),</span>
								settings.alignmentWithRespectToParent,
								sizes.min,sizes.pref,sizes.max );
<span class="nc" id="L989">					} else</span>
<span class="nc" id="L990">						((ParallelGroup)group).addComponent(</span>
<span class="nc" id="L991">								namesToComponents.getComponent(compName),</span>
								settings.alignmentWithRespectToParent );
				else //Parallel group not found.
<span class="nc" id="L994">					throw new IllegalArgumentException(</span>
						&quot;components can be aligned in parallel groups only&quot; );
			else //Alignment not specified.
<span class="nc bnc" id="L997" title="All 2 branches missed.">				if( settings.sizes != null ) {</span>
<span class="nc" id="L998">					Sizes sizes = settings.sizes;</span>
<span class="nc" id="L999">					group.addComponent(</span>
<span class="nc" id="L1000">							namesToComponents.getComponent(compName),</span>
							sizes.min, sizes.pref, sizes.max );
<span class="nc" id="L1002">				} else //Even sizes aren't specified.</span>
<span class="nc" id="L1003">					group.addComponent(</span>
<span class="nc" id="L1004">							namesToComponents.getComponent(compName) );</span>
<span class="nc" id="L1005">		}</span>
		
		/**
		 * Adds the specified {@code group} with the specified {@code settings}
		 * to another group {@code parentGroup}.
		 */
		public void addGroupToGroup(
				Group group, Settings settings, Group parentGroup )
		{
<span class="nc bnc" id="L1014" title="All 2 branches missed.">			if( settings.alignmentWithRespectToParent != null )</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">				if( parentGroup instanceof ParallelGroup )</span>
<span class="nc" id="L1016">					((ParallelGroup)parentGroup)</span>
<span class="nc" id="L1017">						.addGroup(</span>
							settings.alignmentWithRespectToParent,
							group );
				else
<span class="nc" id="L1021">					throw new IllegalArgumentException(</span>
							&quot;content can be aligned in parallel groups only&quot; );
<span class="nc" id="L1023">			parentGroup.addGroup( group );</span>
<span class="nc" id="L1024">		}</span>
	}
	
	
	/**
	 * Provides output of the created groups' structure.
	 * &lt;p&gt;
	 * Is maintained for debugging purposes.
	 */
<span class="nc" id="L1033">	public class GroupPrinter</span>
	{
		/**
		 * Outputs the both directions top groups structures.
		 */
		public void printTopGroupsStructure()
		{
			Axis axis;
<span class="nc" id="L1041">			axis = Axis.HORIZONTAL;</span>
<span class="nc" id="L1042">			System.out.println(&quot;\nTop &quot; + axis.toString().toUpperCase()</span>
					+ &quot; group structure.&quot;);
<span class="nc" id="L1044">			printTopGroupStructure(axis);</span>
			
<span class="nc" id="L1046">			System.out.println(&quot;\n-----------------------------\n&quot;);</span>
<span class="nc" id="L1047">			axis = Axis.VERTICAL;</span>
<span class="nc" id="L1048">			System.out.println(&quot;Top &quot; + axis.toString().toUpperCase()</span>
					+ &quot; group structure.&quot;);
<span class="nc" id="L1050">			printTopGroupStructure(axis);</span>
<span class="nc" id="L1051">		}</span>
		
		/**
		 * Outputs the specified direction top group structure.
		 */
		public void printTopGroupStructure(Axis axis)
		{
<span class="nc" id="L1058">			printGroupStructure( getTopAgent(axis) );</span>
<span class="nc" id="L1059">		}</span>
		
		/**
		 * Outputs the specified group structure.
		 */
		public void printGroupStructure(GroupAgent group)
		{
<span class="nc" id="L1066">			System.out.println();</span>
<span class="nc" id="L1067">			System.out.println(&quot;Elements of &quot; + group.toString() + &quot;:&quot;);</span>
<span class="nc" id="L1068">			List&lt;Agent&gt; childrenAgents = group.getChildren();</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">			for (Agent child : childrenAgents)</span>
<span class="nc" id="L1070">				System.out.println( child.toString() );</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">			for (Agent child : childrenAgents)</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">				if( child instanceof GroupAgent )</span>
<span class="nc" id="L1073">					printGroupStructure( (GroupAgent)child );</span>
<span class="nc" id="L1074">		}</span>
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>