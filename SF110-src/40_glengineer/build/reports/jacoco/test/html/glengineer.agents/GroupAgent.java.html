<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GroupAgent.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">40_glengineer</a> &gt; <a href="index.source.html" class="el_package">glengineer.agents</a> &gt; <span class="el_source">GroupAgent.java</span></div><h1>GroupAgent.java</h1><pre class="source lang-java linenums">package glengineer.agents;

import glengineer.GroupLayoutEngineer.TemporaryGapsToGaps;
import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnGroupAndElement;
import glengineer.agents.settings.Settings;

import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

import javax.swing.GroupLayout.Group;


/**
 * The agent representing a group.
 */
public abstract class GroupAgent
		extends Agent
{
<span class="nc" id="L23">	protected LinkedList&lt;Agent&gt; childrenAgents = new LinkedList&lt;Agent&gt;();</span>
	
	
	public GroupAgent()
<span class="nc" id="L27">	{</span>
<span class="nc" id="L28">		settings = new Settings();</span>
<span class="nc" id="L29">	}</span>
	
	public String getFirstName()
	{
<span class="nc bnc" id="L33" title="All 2 branches missed.">		if( childrenAgents.isEmpty() )  return null;</span>
		String result;
<span class="nc" id="L35">		Iterator&lt;Agent&gt; i = childrenAgents.iterator();</span>
<span class="nc bnc" id="L36" title="All 2 branches missed.">		while( i.hasNext() ) {</span>
<span class="nc" id="L37">			result = i.next().getFirstName();</span>
<span class="nc bnc" id="L38" title="All 2 branches missed.">			if( result != null )</span>
<span class="nc" id="L39">				return result;</span>
		}
<span class="nc" id="L41">		return null;</span>
	}
	public String getLastName()
	{
<span class="nc bnc" id="L45" title="All 2 branches missed.">		if( childrenAgents.isEmpty() )  return null;</span>
		String result;
<span class="nc" id="L47">		Iterator&lt;Agent&gt; i = childrenAgents.descendingIterator();</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">		while( i.hasNext() ) {</span>
<span class="nc" id="L49">			result = i.next().getLastName();</span>
<span class="nc bnc" id="L50" title="All 2 branches missed.">			if( result != null )</span>
<span class="nc" id="L51">				return result;</span>
		}
<span class="nc" id="L53">		return null;</span>
	}
	
	public boolean isComponent(String componentName)
	{
<span class="nc" id="L58">		return false;</span>
	}
	public boolean isGroup(String firstName, String lastName)
	{
<span class="nc bnc" id="L62" title="All 2 branches missed.">		return getFirstName().equals(firstName) &amp;&amp;</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">					getLastName().equals(lastName);</span>
	}
	public boolean isGap()
	{
<span class="nc" id="L67">		return false;</span>
	}
	
	public boolean equals(Agent agent)
	{
<span class="nc" id="L72">		return  agent.isGroup( getFirstName(), getLastName() );</span>
	}
	
	public void addAgent(Agent agent)
	{
<span class="nc bnc" id="L77" title="All 2 branches missed.">		if( agent == null )</span>
<span class="nc" id="L78">			throw new IllegalArgumentException(&quot;Cannot add null agents.&quot;);</span>
<span class="nc" id="L79">		childrenAgents.add( agent );</span>
<span class="nc" id="L80">	}</span>
	
	public List&lt;Agent&gt; getChildren()
	{
<span class="nc" id="L84">		return Collections.unmodifiableList( childrenAgents );</span>
	}
	
	public int getNumberOfChildren()
	{
<span class="nc" id="L89">		return childrenAgents.size();</span>
	}
	
	/**
	 * Finds and returns the child of this group
	 * which is the component with the specified name.
	 * 
	 * @throws	IllegalArgumentException if not found.
	 */
	public ComponentAgent getComponent(String name)
	{
<span class="nc bnc" id="L100" title="All 2 branches missed.">		for (Agent child : childrenAgents)</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">			if( child.isComponent(name) )</span>
<span class="nc" id="L102">				return (ComponentAgent)child;</span>
<span class="nc" id="L103">		throw new IllegalArgumentException(</span>
				&quot;component &quot; + name +
				&quot; in the &quot; + this + &quot; not found&quot;);
	}
	
	/**
	 * Finds and returns the child of this group
	 * which is the group with the specified first and last names.
	 * 
	 * @throws	IllegalArgumentException if not found.
	 */
	public GroupAgent getGroup(String firstName, String lastName)
	{
<span class="nc bnc" id="L116" title="All 2 branches missed.">		for (Agent child : childrenAgents)</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">			if( child.isGroup(firstName,lastName) )</span>
<span class="nc" id="L118">				return (GroupAgent)child;</span>
<span class="nc" id="L119">		throw new IllegalArgumentException(</span>
				&quot;the group &lt;&quot; + firstName + &quot;,&quot; + lastName +
				&quot;&gt; in the &quot; + this + &quot; not found&quot;);
	}
	
	/**
	 * Searches for the group agent with the specified first and last names
	 * among this agent and all agents of lower level (if this is a group).
	 * 
	 * @return	the agent found or null if not found.
	 */
	public ComponentAgent findDependingComponentByName(String componentName)
	{
<span class="nc" id="L132">		ComponentAgent result = null;</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">		for (Agent child : childrenAgents) {</span>
<span class="nc" id="L134">			result = child.findDependingComponentByName(componentName);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">			if( result != null )</span>
<span class="nc" id="L136">				return result;</span>
<span class="nc" id="L137">		}</span>
<span class="nc" id="L138">		return null;</span>
	}

	/**
	 * Searches for the group agent with the specified name
	 * among all agents of lower level.
	 * 
	 * @return	the agent found or null if not found.
	 */
	public GroupAgent findDependingGroupByNames(
			String firstName, String lastName )
	{
<span class="nc bnc" id="L150" title="All 2 branches missed.">		if( isGroup(firstName,lastName) )</span>
<span class="nc" id="L151">			return this;</span>
<span class="nc" id="L152">		GroupAgent result = null;</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">		for (Agent child : childrenAgents) {</span>
<span class="nc" id="L154">			result = child.findDependingGroupByNames(firstName,lastName);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">			if( result != null )</span>
<span class="nc" id="L156">				return result;</span>
<span class="nc" id="L157">		}</span>
<span class="nc" id="L158">		return null;</span>
	}
	
	public ParallelGroupAgent findDependingParallelGroupByNames(
			String firstName, String lastName )
	{
<span class="nc bnc" id="L164" title="All 4 branches missed.">		if( isGroup(firstName,lastName) &amp;&amp;</span>
				this instanceof ParallelGroupAgent )
<span class="nc" id="L166">			return (ParallelGroupAgent)this;</span>
<span class="nc" id="L167">		GroupAgent result = null;</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">		for (Agent child : childrenAgents) {</span>
<span class="nc" id="L169">			result = child.findDependingParallelGroupByNames(</span>
					firstName,lastName);
<span class="nc bnc" id="L171" title="All 2 branches missed.">			if( result != null )</span>
<span class="nc" id="L172">				return (ParallelGroupAgent)result;</span>
<span class="nc" id="L173">		}</span>
<span class="nc" id="L174">		return null;</span>
	}
	
	public SequentialGroupAgent findDependingSequentialGroupByNames(
			String firstName, String lastName )
	{
<span class="nc bnc" id="L180" title="All 4 branches missed.">		if( isGroup(firstName,lastName) &amp;&amp;</span>
				this instanceof SequentialGroupAgent )
<span class="nc" id="L182">			return (SequentialGroupAgent)this;</span>
<span class="nc" id="L183">		GroupAgent result = null;</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">		for (Agent child : childrenAgents) {</span>
<span class="nc" id="L185">			result = child.findDependingSequentialGroupByNames(</span>
					firstName,lastName);
<span class="nc bnc" id="L187" title="All 2 branches missed.">			if( result != null )</span>
<span class="nc" id="L188">				return (SequentialGroupAgent)result;</span>
<span class="nc" id="L189">		}</span>
<span class="nc" id="L190">		return null;</span>
	}
	
	/**
	 * Gaps must affect sequential groups only.
	 * This method does all the job related to removing gaps from
	 * parallel groups in this group.
	 * In particular, it finds parallel groups which consist of gaps only
	 * and replaces these parallel groups by gaps of corresponding types.
	 * &lt;p&gt;
	 * More precisely:
	 * &lt;ol&gt;
	 * &lt;li&gt; Passes the invocation of this method to all subgroups.
	 * &lt;li&gt; Removes all gaps from every deeper parallel group
	 * containing not only gaps.
	 * &lt;li&gt; Replaces every deeper parallel group containing only gaps
	 * by the gap of that type.
	 * If such parallel group contains gaps of different type,
	 * throws a runtime exception.
	 * &lt;li&gt; Replaces every continuous sequence of gaps
	 * by a gap of that type.
	 * If such sequence contains gaps of different type,
	 * throws a runtime exception.
	 * &lt;li&gt; After all, if some subgroups have begun
	 * to consist of single elements,
	 * this method replaces them by those elements.
	 * &lt;/ol&gt;
	 * 
	 * &lt;p&gt; Note that this method
	 * is called from the constructor of the {@code GroupLayoutEngineer},
	 * and hence the gaps added into the hierarchy manually
	 * will not be removed by this method.
	 */
	public void removeGapsFromParallelGroups()
	{
<span class="nc" id="L225">		passTheCallToSubgroups();</span>
		
<span class="nc" id="L227">		removeGapsFromParallelSubgroupsWithOtherContent();</span>
		
<span class="nc" id="L229">		replaceParallelSubgroupsWithGapsByTheirSingleGaps();</span>
		
<span class="nc" id="L231">		replaceContinuousSequencesOfGapsBySingleGaps();</span>
		
<span class="nc" id="L233">		replaceGroupsWithSingleElementsByThatElements();</span>
<span class="nc" id="L234">	}</span>
	
	private void passTheCallToSubgroups()
	{
<span class="nc" id="L238">		Iterator&lt;Agent&gt; i = childrenAgents.iterator();</span>
		Agent child;
<span class="nc bnc" id="L240" title="All 2 branches missed.">		while( i.hasNext() ) {</span>
<span class="nc" id="L241">			child = i.next();</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">			if( child instanceof GroupAgent )</span>
<span class="nc" id="L243">				((GroupAgent)child).removeGapsFromParallelGroups();</span>
		}
<span class="nc" id="L245">	}</span>
	
	/*
	 * Removes gaps from parallel subgroups containing not only gaps.
	 */
	private void removeGapsFromParallelSubgroupsWithOtherContent()
	{
<span class="nc" id="L252">		Iterator&lt;Agent&gt; i = childrenAgents.iterator();</span>
		Agent child;
		ParallelGroupAgent parallel;
<span class="nc bnc" id="L255" title="All 2 branches missed.">		while( i.hasNext() ) {</span>
<span class="nc" id="L256">			child = i.next();</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">			if( child instanceof ParallelGroupAgent ) {</span>
<span class="nc" id="L258">				parallel = (ParallelGroupAgent)child;</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">				if( ! parallel.containsGapsOnly() )</span>
<span class="nc" id="L260">					parallel.removeAllGaps();</span>
			}
		}
<span class="nc" id="L263">	}</span>
	
	private void replaceParallelSubgroupsWithGapsByTheirSingleGaps()
	{
<span class="nc" id="L267">		ListIterator&lt;Agent&gt; li = childrenAgents.listIterator();</span>
		Agent child;
		ParallelGroupAgent parallel;
		Agent gap;
<span class="nc bnc" id="L271" title="All 2 branches missed.">		while( li.hasNext() ) {</span>
<span class="nc" id="L272">			child = li.next();</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">			if( child instanceof ParallelGroupAgent ) {</span>
<span class="nc" id="L274">				parallel = (ParallelGroupAgent)child;</span>
<span class="nc" id="L275">				gap = parallel.getGapsType();</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">				if( gap != null ) //gaps found!</span>
<span class="nc" id="L277">					li.set( gap ); //replace the group by its single gap.</span>
			}
		}
<span class="nc" id="L280">	}</span>
	
	private void replaceContinuousSequencesOfGapsBySingleGaps()
	{
<span class="nc" id="L284">		ListIterator&lt;Agent&gt; li = childrenAgents.listIterator();</span>
		Agent child;
		Agent currentGap;
		Agent nextGap;
<span class="nc bnc" id="L288" title="All 2 branches missed.">		while( li.hasNext() ) {</span>
<span class="nc" id="L289">			child = li.next();</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">			if( ! child.isGap() )  continue;</span>
<span class="nc" id="L291">			currentGap = child; //begins a sequence of gaps.</span>
			//remove elements of the sequence one by one:
<span class="nc bnc" id="L293" title="All 2 branches missed.">			while( li.hasNext() ) {</span>
<span class="nc" id="L294">				nextGap = li.next();</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">				if( ! nextGap.isGap() )</span>
<span class="nc" id="L296">					break; //the sequence of gaps is finished.</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">				if( nextGap.equals(currentGap) )</span>
<span class="nc" id="L298">					li.remove();</span>
				else
<span class="nc" id="L300">					throw new IllegalArgumentException(</span>
							&quot;A sequence of gaps possessing different types&quot;
							+ &quot; was found in a group.&quot; );
			}
		}
<span class="nc" id="L305">	}</span>
	
	private void replaceGroupsWithSingleElementsByThatElements()
	{
<span class="nc" id="L309">		ListIterator&lt;Agent&gt; li = childrenAgents.listIterator();</span>
		Agent child;
		GroupAgent nextSubgroup;
<span class="nc bnc" id="L312" title="All 2 branches missed.">		while( li.hasNext() ) {</span>
<span class="nc" id="L313">			child = li.next();</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">			if( child instanceof GroupAgent ) {</span>
<span class="nc" id="L315">				nextSubgroup = (GroupAgent)child;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">				if( nextSubgroup.getNumberOfChildren() == 1 )</span>
<span class="nc" id="L317">					li.set( nextSubgroup.getChildren().get(0) );</span>
			}
		}
<span class="nc" id="L320">	}</span>
	
	
	/**
	 * Replaces all temporary gaps in this group and in all lower groups
	 * by the corresponding gaps.
	 * The correspondence is defined by the specified parameter {@code map}.
	 * &lt;p&gt;
	 * This method is (typically) called by the engineer object
	 * at the beginning of its {@code engineer()} method
	 * because at that point all user denotations for the gaps on the scheme
	 * are already associated with concrete gaps types by the user.
	 */
	public void replaceTemporaryGapsByRealGaps(TemporaryGapsToGaps map)
	{
<span class="nc" id="L335">		ListIterator&lt;Agent&gt; li = childrenAgents.listIterator();</span>
		Agent child;
<span class="nc bnc" id="L337" title="All 2 branches missed.">		while( li.hasNext() ) {</span>
<span class="nc" id="L338">			child = li.next();</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">			if( child instanceof GroupAgent )</span>
<span class="nc" id="L340">				((GroupAgent)child).replaceTemporaryGapsByRealGaps(map);</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">			if( child instanceof TemporaryGapAgent )</span>
<span class="nc" id="L342">				li.set( map.gap( (TemporaryGapAgent)child ) );</span>
		}
<span class="nc" id="L344">	}</span>
	
	/**
	 * ��������� �� �������������� ���������� � ������,
	 * ��������� ��� ��������� ����������� �� �� ��������� ���������
	 * ����� ���������� {@code ComponentAdder}, � ��� ��������
	 * ����� �������� - ������ ���������� {@code GroupCreator}.
	 * &lt;p&gt;
	 * ���������� �������-���������.
	 * 
	 * @param parentGroup		������, ���� �����������
	 * 							�������������� ����������
	 * @param creatorAndAdder	��������� ��� �������� �����
	 * 							� ���������� � ��� �����������
	 */
	public void addContentToGroup(
			Group parentGroup, GroupCreatorAndElementAdder creatorAndAdder )
	{
<span class="nc" id="L362">		creatorAndAdder.addGroupToGroup(</span>
<span class="nc" id="L363">				groupContent(creatorAndAdder),</span>
				settings,
				parentGroup );
<span class="nc" id="L366">	}</span>

	/**
	 * ���������� ����� ������, ������������ �� ��������������� �����������.
	 * 
	 * @param creatorAndAdder	��������� ��� �������� �����
	 * 							� ���������� � ��� �����������
	 * @return					������, ������������ �� ���������������
	 * 							�����������.
	 */
	public abstract Group groupContent(
			GroupCreatorAndElementAdder creatorAndAdder );
	
	/**
	 * Returns a class implementing the interface
	 * {@code FunctionsOnGroup} (more precisely, its extensions)
	 * which allows the end user to possess access
	 * to the settings of elements of this group.
	 */
	public abstract FunctionsOnGroup getFunctionsOnGroupImplemenation();
	
	/**
	 * This is a base class for two classes
	 * which provide the end user by methods
	 * of controlling settings of elements of groups
	 * and methods of inserting gaps beside elements of groups.
	 * &lt;p&gt;
	 * For this purpose, this class declares the fields
	 * {@code parentGroupAgent} and {@code elementAgent}
	 * which specify the group and its element.
	 * These fields are then used in methods of this class' extensions.
	 * &lt;p&gt;
	 * This class also implements methods of inserting non-preferred gaps
	 * beside the element {@code parentGroupAgent}
	 * of the group {@code elementAgent}.
	 * 
	 * @see
	 * ParallelGroupAgent.FunctionsOnParallelGroupAndElementImplementation
	 * @see
	 * SequentialGroupAgent.FunctionsOnSequentialGroupAndElementImplementation
	 */
	protected static class FunctionsOnGroupAndElementImplementation
		implements FunctionsOnGroupAndElement
	{
		/**
		 * A parent group containing some element
		 * which settings with respect to the parent group will be changed.
		 */
		protected GroupAgent parentGroupAgent;
		
		/**
		 * An element in the parent group
		 * which settings with respect to the parent group will be changed.
		 */
		protected Agent elementAgent;
		
		public FunctionsOnGroupAndElementImplementation(
				GroupAgent parent, Agent element )
<span class="nc" id="L424">		{</span>
<span class="nc" id="L425">			this.parentGroupAgent = parent;</span>
<span class="nc" id="L426">			this.elementAgent = element;</span>
<span class="nc" id="L427">		}</span>
		
		/**
         * Adds a rigid gap of the specified size
         * to the {@code parentGroupAgent} before its {@code elementAgent}.
         */
		public void addPrecedingGap(int size)
		{
<span class="nc" id="L435">			parentGroupAgent.addGapBefore( new GapAgent(size), elementAgent );</span>
<span class="nc" id="L436">		}</span>
		
		/**
         * Adds a gap of the specified sizes
         * to the {@code parentGroupAgent} before its {@code elementAgent}.
         */
		public void addPrecedingGap(int min, int pref, int max)
		{
<span class="nc" id="L444">			parentGroupAgent.addGapBefore(</span>
					new GapAgent(min,pref,max), elementAgent );
<span class="nc" id="L446">		}</span>
		
		/**
         * Adds a rigid gap of the specified size
         * to the {@code parentGroupAgent} after its {@code elementAgent}.
         */
		public void addFollowingGap(int size)
		{
<span class="nc" id="L454">			parentGroupAgent.addGapAfter( new GapAgent(size), elementAgent );</span>
<span class="nc" id="L455">		}</span>
		
		/**
         * Adds a gap of the specified sizes
         * to the {@code parentGroupAgent} after its {@code elementAgent}.
         */
		public void addFollowingGap(int min, int pref, int max)
		{
<span class="nc" id="L463">			parentGroupAgent.addGapAfter(</span>
					new GapAgent(min,pref,max), elementAgent );
<span class="nc" id="L465">		}</span>
		
	}
	
	
	/**
	 * Finds the specified element in the list of this group's children
	 * and inserts the specified gap into that list before that element.
	 */
	public void addGapBefore(GapAgent gap, Agent element)
	{
<span class="nc bnc" id="L476" title="All 2 branches missed.">		if( childrenAgents.isEmpty() ) {</span>
<span class="nc" id="L477">			childrenAgents.add(gap);</span>
<span class="nc" id="L478">			return;</span>
		}
<span class="nc" id="L480">		ListIterator&lt;Agent&gt; iter = childrenAgents.listIterator();</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">		while( iter.hasNext() )</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">			if( iter.next().equals(element)) {</span>
<span class="nc" id="L483">				iter.previous();</span>
<span class="nc" id="L484">				iter.add(gap);</span>
<span class="nc" id="L485">				return;</span>
			}
<span class="nc" id="L487">		throw new IllegalArgumentException(</span>
<span class="nc" id="L488">				&quot;the &quot; + element.toString() +</span>
<span class="nc" id="L489">				&quot; in the &quot; + toString() + &quot; not found&quot; );</span>
	}
	
	/**
	 * Finds the specified element in the list of this group's children
	 * and inserts the specified gap into that list after that element.
	 */
	public void addGapAfter(GapAgent gap, Agent element)
	{
<span class="nc bnc" id="L498" title="All 2 branches missed.">		if( childrenAgents.isEmpty() ) {</span>
<span class="nc" id="L499">			childrenAgents.add(gap);</span>
<span class="nc" id="L500">			return;</span>
		}
<span class="nc" id="L502">		ListIterator&lt;Agent&gt; iter = childrenAgents.listIterator();</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">		while( iter.hasNext() )</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">			if( iter.next().equals(element)) {</span>
<span class="nc" id="L505">				iter.add(gap);</span>
<span class="nc" id="L506">				return;</span>
			}
<span class="nc" id="L508">		throw new IllegalArgumentException(</span>
<span class="nc" id="L509">				&quot;the &quot; + element.toString() +</span>
<span class="nc" id="L510">				&quot; in the &quot; + toString() + &quot; not found&quot; );</span>
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>