<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VerticalBlock.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">40_glengineer</a> &gt; <a href="index.source.html" class="el_package">glengineer.blocks</a> &gt; <span class="el_source">VerticalBlock.java</span></div><h1>VerticalBlock.java</h1><pre class="source lang-java linenums">package glengineer.blocks;

import glengineer.positions.*;

import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block
{
	public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
<span class="nc" id="L14">		super(scheme, x1, y1, x2, y2);</span>
<span class="nc" id="L15">	}</span>
	public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
<span class="nc" id="L17">		super(scheme, p1, p2);</span>
<span class="nc" id="L18">	}</span>
	public VerticalBlock(Scheme scheme) {
<span class="nc" id="L20">		super(scheme);</span>
<span class="nc" id="L21">	}</span>
	public VerticalBlock(Block b) {
<span class="nc" id="L23">		super(b.scheme, b.getPos1(), b.getPos2());</span>
<span class="nc" id="L24">	}</span>
	public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {
<span class="nc" id="L26">		super(block.scheme, x1, y1, x2, y2);</span>
<span class="nc" id="L27">	}</span>
	
	public VerticalBlock subblock(int x1, int y1, int x2, int y2) {
<span class="nc" id="L30">		return new VerticalBlock(scheme, x1,y1, x2,y2);</span>
	}
	
	public VerticalBlock cloneWith(CharPosition1 p1) {
<span class="nc" id="L34">		return new VerticalBlock(scheme, p1, getPos2());</span>
	}
	
	/**
	 * Divides the current block into a set of sequential subblocks,
	 * optimizes these subblocks and returns them as a linked list.
	 * 
	 * @return	a list of optimized sequential subblocks.
	 */
	public List&lt;Block&gt; extractSequentialSubblocks()
	{
<span class="nc" id="L45">		this.optimize();</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">		if(isTrivial())  return new LinkedList&lt;Block&gt;();</span>
		
<span class="nc" id="L48">		List&lt;Block&gt; result = new LinkedList&lt;Block&gt;();</span>
		
		VerticalBlock firstBlock;
<span class="nc" id="L51">		VerticalBlock theRest = this;</span>
		do {
<span class="nc" id="L53">			firstBlock = theRest.extractFirstSequentialSubblock();</span>
<span class="nc" id="L54">			theRest =</span>
<span class="nc" id="L55">				theRest.cloneWith( new CharPosition1(this.x1,firstBlock.y2) );</span>
<span class="nc" id="L56">			firstBlock.optimize();</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">			if( ! firstBlock.isTrivial() )</span>
<span class="nc" id="L58">				result.add( firstBlock );</span>
<span class="nc" id="L59">			theRest.optimize();</span>
		}
<span class="nc bnc" id="L61" title="All 2 branches missed.">		while ( ! theRest.isTrivial() );</span>
<span class="nc" id="L62">		return result;</span>
	}
	
	/**
	 * Extracts the upper subblock of this block.
	 * &lt;p&gt;
	 * The required block is chosen so that its last exclusive horizontal line
	 * does not contain elements of vertical lines
	 * starting above the line.
	 * &lt;p&gt;
	 * The algorithm finds the upper entity
	 * (an element of a component, gap, or vertical line)
	 * using simple search along the scheme,
	 * and retains it as the top of the required block.
	 * Then, starting from the height of that point,
	 * it sequentially finds vertical lines
	 * end below but begin not below
	 * and moves to lower end of such lines.
	 * The lower end of the last such vertical line defines
	 * the bottom of the required block.
	 */
	private VerticalBlock extractFirstSequentialSubblock()
	{
<span class="nc" id="L85">		Set&lt;VWordPosition&gt; vLines = getIntersectingVLines();</span>
		
<span class="nc" id="L87">		CharPosition blockStart = getBlockStart();</span>
		
<span class="nc" id="L89">		int y2 = getUpperSubblockEnd( blockStart, vLines );</span>
		
<span class="nc" id="L91">		return subblock( this.x1, blockStart.y, this.x2, y2 );</span>
	}
	
	/**
	 * Returns the set of all vertical lines intersecting this block.
	 */
	private Set&lt;VWordPosition&gt; getIntersectingVLines()
	{
<span class="nc" id="L99">		Set&lt;VWordPosition&gt; source = scheme.getVLinesPositions();</span>
<span class="nc" id="L100">		Set&lt;VWordPosition&gt; result = new HashSet&lt;VWordPosition&gt;();</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">		for (VWordPosition line : source)</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">			if( line.intersects(this) )</span>
<span class="nc" id="L103">				result.add( line );</span>
<span class="nc" id="L104">		return result;</span>
	}
	
	/**
	 * Finds the upper entity (an element of a word or vertical line)
	 * of this block.
	 * Returns its position on the scheme.
	 * @throws	IllegalArgumentException if this block happens to be empty.
	 */
	private CharPosition getBlockStart()
	{
<span class="nc" id="L115">		int x = x1;</span>
<span class="nc" id="L116">		int y = y1;</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">		for (; y &lt; y2; y++)</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">			for (x = x1; x &lt; x2; x++)</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">				if( entityAt(x,y) )  return new CharPosition(x,y);</span>
<span class="nc" id="L120">		throw new IllegalArgumentException(</span>
				&quot;Can not extract elements from an empty block:\n&quot; + this);
	}
	
	/**
	 * Verifies whether the character under the cell
	 * determined by the specified coordinates
	 * is a word character or a vertical line character.
	 */
	private boolean entityAt(int x, int y)
	{
<span class="nc" id="L131">		char c = charAt(x,y);</span>
		/* 
		 * Since all symbols on the scheme are correct
		 * (which has been verified in its constructor),
		 * there is no need to use the slower method isWordChar().
		 */
<span class="nc bnc" id="L137" title="All 4 branches missed.">		return  c != ' ' &amp;&amp; c != '-';</span>
	}
	/**
	 * Finds the last line of the subblock
	 * containing the specified position {@code blockStart}.
	 * Returns the coordinate {@code y2} of such block.
	 */
	private int getUpperSubblockEnd( CharPosition blockStart,
								Set&lt;VWordPosition&gt; vLines )
	{
<span class="nc" id="L147">		int nextY = blockStart.y;</span>
		int currentY;
		do {
<span class="nc" id="L150">			currentY = nextY;</span>
<span class="nc" id="L151">			nextY = y2OfAVLineCovering(currentY, vLines);</span>
<span class="nc bnc" id="L152" title="All 4 branches missed.">		} while( nextY &gt; currentY &amp;&amp; nextY &lt; y2 - 1 );</span>
<span class="nc" id="L153">		return Math.min( y2, nextY + 1 );</span>
	}
	
	/**
	 * Finds a vertical line which vertical range covers
	 * the specified value {@code y}
	 * and which lower point is lower than {@code y}.
	 * Returns the position of the last element of such line (inclusive)
	 * or {@code y} if such line does not exist.
	 */
	private int y2OfAVLineCovering( int y, Set&lt;VWordPosition&gt; vLines )
	{
<span class="nc bnc" id="L165" title="All 2 branches missed.">		for (VWordPosition line : vLines)</span>
<span class="nc bnc" id="L166" title="All 4 branches missed.">			if( line.y1 &lt;= y &amp;&amp; y + 1 &lt; line.y2 )</span>
<span class="nc" id="L167">				return line.y2 - 1;</span>
<span class="nc" id="L168">		return y;</span>
	}
	
	/**
	 * Divides the current block into a set of parallel subblocks,
	 * optimizes these subblocks and returns them as a linked list.
	 * &lt;p&gt;
	 * If the block has vertical lines,
	 * this method divides the block by the maximal vertical lines only.
	 * &lt;p&gt;
	 * If there are no vertical lines, the block is divided into
	 * usual parallel subblocks.
	 */
	public List&lt;Block&gt; extractParallelSubblocks()
	{
<span class="nc" id="L183">		this.optimize();</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">		if( isTrivial() )  return new LinkedList&lt;Block&gt;();</span>
		
<span class="nc" id="L186">		Set&lt;VWordPosition&gt; vLines = getIntersectingVLines();</span>
		
<span class="nc bnc" id="L188" title="All 2 branches missed.">		if( vLines.size() &gt; 0 )</span>
<span class="nc" id="L189">			return extractParallelSubblocksSeparatedByLines( vLines );</span>
		else
<span class="nc" id="L191">			return extractParallelSubblocksWithoutLines();</span>
	}
	
	/**
	 * Divides the current block into a set of parallel subblocks
	 * by its most long vertical lines,
	 * optimizes these subblocks, and returns them as a linked list.
	 */
	protected List&lt;Block&gt; extractParallelSubblocksSeparatedByLines(
			Set&lt;VWordPosition&gt; vLines )
	{
<span class="nc" id="L202">		removeSmallVLinesFrom(vLines);</span>
<span class="nc" id="L203">		return extractParallelSubblocksSeparatedBy( vLines );</span>
	}
	
	/**
	 * Finds the longest lines in the specified set of vertical lines
	 * and then removes from it all other elements.
	 * &lt;p&gt;
	 * Note that, more formally, this method considers the lengths
	 * of &lt;i&gt;intersections&lt;/i&gt; of the lines with this block.
	 */
	private void removeSmallVLinesFrom( Set&lt;VWordPosition&gt; vLines )
	{
		//determine the maximum length:
<span class="nc" id="L216">		int maxLength = 0;</span>
		int length;
<span class="nc bnc" id="L218" title="All 2 branches missed.">		for (VWordPosition line : vLines) {</span>
<span class="nc" id="L219">			length = line.getLengthInsideOf(this);</span>
<span class="nc" id="L220">			maxLength = Math.max(length,maxLength);</span>
<span class="nc" id="L221">		}</span>
		//remove the short lines:
		VWordPosition line;
<span class="nc" id="L224">		Iterator&lt;VWordPosition&gt; i = vLines.iterator();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">		for(; i.hasNext(); ) {</span>
<span class="nc" id="L226">			line = i.next();</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">			if( line.getLengthInsideOf(this) &lt; maxLength )</span>
<span class="nc" id="L228">				i.remove();</span>
		}
<span class="nc" id="L230">	}</span>
	
	private List&lt;Block&gt; extractParallelSubblocksSeparatedBy(
			Set&lt;VWordPosition&gt; separators )
	{
<span class="nc" id="L235">		List&lt;Block&gt; result = new LinkedList&lt;Block&gt;();</span>
		Block subBlock;
<span class="nc" id="L237">		int leftX = x1; //the left bound of a subblock</span>
		int rightX; //the exclusive right bound of a subblock
<span class="nc" id="L239">		HWordPosition gapAtSeparator = null; //(may exist; widens the separator)</span>
		
<span class="nc bnc" id="L241" title="All 2 branches missed.">		for( VWordPosition rightSeparator : sortedVLines(separators) ) {</span>
<span class="nc" id="L242">			rightX = rightSeparator.x;</span>
			//if the separator has a gap, the latter must be skipped:
<span class="nc" id="L244">			gapAtSeparator = scheme.gapAtLine(rightSeparator); </span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">			if( gapAtSeparator != null )</span>
<span class="nc" id="L246">				rightX = gapAtSeparator.x1;</span>
			//adding the subblock between leftX and rightX:
<span class="nc bnc" id="L248" title="All 2 branches missed.">			if( rightX &gt; leftX + 1 ) {</span>
<span class="nc" id="L249">				subBlock = subblock(leftX,y1,rightX,y2);</span>
<span class="nc" id="L250">				subBlock.optimize();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">				if( !subBlock.isTrivial() )</span>
<span class="nc" id="L252">					result.add( subBlock );</span>
			}
			//iterating leftX:
<span class="nc bnc" id="L255" title="All 2 branches missed.">			if( gapAtSeparator == null )</span>
<span class="nc" id="L256">				leftX = rightX + 1;</span>
			else
<span class="nc" id="L258">				leftX = gapAtSeparator.x2;</span>
<span class="nc" id="L259">		}</span>
		//on the right of the last line:
<span class="nc bnc" id="L261" title="All 2 branches missed.">		if( leftX &lt; x2 ) {</span>
<span class="nc" id="L262">			subBlock = subblock(leftX,y1,x2,y2);</span>
<span class="nc" id="L263">			subBlock.optimize();</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">			if( !subBlock.isTrivial() )</span>
<span class="nc" id="L265">				result.add( subBlock );</span>
		}
<span class="nc" id="L267">		return result;</span>
	}
	
	/*
	 * Returns a list of the specified vertical lines
	 * sorted according to the horizontal coordinates.
	 */
	private List&lt;VWordPosition&gt; sortedVLines( Set&lt;VWordPosition&gt; vLines )
	{
<span class="nc" id="L276">		LinkedList&lt;VWordPosition&gt; list = new LinkedList&lt;VWordPosition&gt;(vLines);</span>
<span class="nc" id="L277">		Collections.sort( list );</span>
<span class="nc" id="L278">		return list;</span>
	}
	
	/**
	 * Divides the current block without vertical lines
	 * into a set of (optimized) parallel subblocks.
	 * Returns them as a linked list.
	 */
	protected List&lt;Block&gt; extractParallelSubblocksWithoutLines()
	{
<span class="nc" id="L288">		List&lt;Block&gt; result = new LinkedList&lt;Block&gt;();</span>
		
		Block firstBlock;
<span class="nc" id="L291">		VerticalBlock theRest = this;</span>
		do {
<span class="nc" id="L293">			firstBlock = theRest.extractFirstParallelSubblock();</span>
<span class="nc" id="L294">			theRest = theRest.cloneWith(</span>
					new CharPosition1(firstBlock.x2,this.y1) );
<span class="nc" id="L296">			firstBlock.optimize();</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">			if( ! firstBlock.isTrivial() )</span>
<span class="nc" id="L298">				result.add( firstBlock );</span>
<span class="nc" id="L299">			theRest.optimize();</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">		} while ( ! theRest.isTrivial() );</span>
<span class="nc" id="L301">		return result;</span>
	}
	
	/**
	 * Extracts the left subblock of this block.
	 * &lt;p&gt;
	 * The required block is chosen so that its last exclusive vertical line
	 * does not contain elements of components or gaps
	 * starting on the left from the line.
	 * &lt;p&gt;
	 * The algorithm just finds the most left entity
	 * (an element of a component or gap)
	 * using simple search along the scheme,
	 * identifies the horizontal element containing the entity found,
	 * checks whether the last exclusive vertical line of the element
	 * matches the requirement for the boundary of the required block,
	 * and, if does not, takes the detaining horizontal element
	 * and continues the cycle.
	 */
	private Block extractFirstParallelSubblock()
	{
<span class="nc" id="L322">		final HWordPosition firstWord =</span>
<span class="nc" id="L323">			scheme.anyHElementAt( firstWordChar() );</span>
		
<span class="nc" id="L325">		HWordPosition lastWord = firstWord;</span>
		
<span class="nc" id="L327">		HWordPosition nextWord = firstWord;</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">		for(; nextWord != null; ) {</span>
<span class="nc" id="L329">			lastWord = nextWord;</span>
<span class="nc" id="L330">			nextWord = findAWordExtendingSubblockToTheRightFrom( nextWord );</span>
		}
		
<span class="nc" id="L333">		int startX = firstWord.x1;</span>
<span class="nc" id="L334">		int endX = lastWord.x2;</span>
		//For the case of words containing cells outside of this block:
<span class="nc" id="L336">		startX = Math.max( startX, x1 );</span>
<span class="nc" id="L337">		endX = Math.min( endX, x2 );</span>
		
<span class="nc" id="L339">		return subblock( startX, y1, endX, y2 );</span>
	}
	
	/**
	 * Searches down and to the right from the beginning of this block
	 * for the first occurrence of a word character.
	 * @return	the position of the word character found.
	 * @throws	IllegalArgumentException if this block
	 * 			does not contain word characters.
	 */
	private CharPosition firstWordChar()
	{
<span class="nc" id="L351">		int y = firstWordCharBelow(x1,y1);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">		if( y != y2 )</span>
<span class="nc" id="L353">			return new CharPosition(x1,y);</span>
		
<span class="nc" id="L355">		int x = x1 + 1;</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">		for (; x &lt; x2; x++) {</span>
<span class="nc" id="L357">			y = firstWordCharBelow(x,y1);</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">			if( y != y2 )  break;</span>
		}
		
<span class="nc bnc" id="L361" title="All 2 branches missed.">		if( x != x2 )</span>
<span class="nc" id="L362">			return new CharPosition(x,y);</span>
		else
<span class="nc" id="L364">			throw new IllegalArgumentException(</span>
					&quot;Can not extract a group from an empty block:\n&quot; + this);
	}
	
	/**
	 * Finds the first entity below the specified position.
	 * @return	the y-coordinate of the entity found or y2 if not found.
	 */
	private int firstWordCharBelow(int x, int y)
	{
<span class="nc bnc" id="L374" title="All 2 branches missed.">		for (; y &lt; y2; y++)</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">			if( wordCharAt(x,y) )  break;</span>
<span class="nc" id="L376">		return y;</span>
	}
	
	/**
	 * Verifies whether the character under the cell
	 * determined by the specified coordinates
	 * is a word character.
	 * &lt;p&gt;
	 * Overrides the less optimal method {@code CharTable.wordCharAt()}.
	 * Since all symbols on the scheme are definitely correct
	 * (which has been verified in its constructor),
	 * there is no need to use slower method.
	 */
	public boolean wordCharAt(int x, int y)
	{
<span class="nc" id="L391">		char c = charAt(x,y);</span>
<span class="nc bnc" id="L392" title="All 8 branches missed.">		return c != ' ' &amp;&amp; c != '-' &amp;&amp; c != '|' &amp;&amp; c != '+';</span>
	}
	
	/**
	 * Returns a word which starts not righter than the right end of the
	 * {@code currentWord} but ends strictly righter
	 * (or null if does not exist).
	 */
	private HWordPosition findAWordExtendingSubblockToTheRightFrom(
				HWordPosition currentWord )
	{
<span class="nc" id="L403">		int x = currentWord.x2 - 1;</span>
<span class="nc" id="L404">		int y = y1;</span>
<span class="nc" id="L405">		int yToSkip = currentWord.y;</span>
		
		HWordPosition result;
		
<span class="nc bnc" id="L409" title="All 2 branches missed.">		for(; y &lt; y2; y++) {</span>
<span class="nc bnc" id="L410" title="All 4 branches missed.">			if( y == yToSkip || ! wordCharAt(x,y) )</span>
<span class="nc" id="L411">				continue;</span>
<span class="nc" id="L412">			result = scheme.anyHElementAt(x,y);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">			if( result == null ) </span>
<span class="nc" id="L414">				continue;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">			if( result.x2 &gt; currentWord.x2 )</span>
<span class="nc" id="L416">				return result;</span>
		}
		
<span class="nc" id="L419">		return null;</span>
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>