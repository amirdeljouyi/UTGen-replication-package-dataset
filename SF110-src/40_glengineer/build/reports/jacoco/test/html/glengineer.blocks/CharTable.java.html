<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CharTable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">40_glengineer</a> &gt; <a href="index.source.html" class="el_package">glengineer.blocks</a> &gt; <span class="el_source">CharTable.java</span></div><h1>CharTable.java</h1><pre class="source lang-java linenums">package glengineer.blocks;

import glengineer.positions.*;


/**
 * An abstract class for the {@code Scheme} and {@code Block} classes.
 * Encapsulates various operations dealing with table boundaries,
 * operations classifying the type of text under specified positions,
 * and operations searching for text of specified type.
 * &lt;p&gt;
 * The basic text possessing operations are leaved abstract.
 */
<span class="fc" id="L14">public abstract class CharTable</span>
{
	/**
	 * The string declares the set of characters
	 * which are allowed in the names of components.
	 */
	public static final String LETTERS =
		&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890&quot;;
	
	/**
	 * The string of elements for drawing horizontal and vertical lines.
	 */
	public static final String SPLITTERS = &quot;-|+&quot;;
	
	/**
	 * This table left boundary coordinate (inclusive).
	 */
	public int x1;
	/**
	 * This table top boundary coordinate (inclusive).
	 */
	public int y1;
	/**
	 * This table right boundary coordinate (exclusive).
	 */
	public int x2;
	/**
	 * This table bottom boundary coordinate (exclusive).
	 */
	public int y2;
	
	
	public CharPosition1 getPos1() {
<span class="nc" id="L47">		return new CharPosition1(x1,y1);</span>
	}
	public CharPosition2 getPos2() {
<span class="nc" id="L50">		return new CharPosition2(x2,y2);</span>
	}
	
	/**
	 * Verifies whether the specified value
	 * is a proper x-coordinate for an element of this char table.
	 */
	public boolean permitsX(int x) {
<span class="nc bnc" id="L58" title="All 4 branches missed.">		if( x1 &lt;= x &amp;&amp; x &lt; x2 )  return true;</span>
<span class="nc" id="L59">		else  return false;</span>
	}
	/**
	 * Verifies whether the specified value
	 * is a proper y-coordinate for an element of this char table.
	 */
	public boolean permitsY(int y) {
<span class="nc bnc" id="L66" title="All 4 branches missed.">		if( y1 &lt;= y &amp;&amp; y &lt; y2 )  return true;</span>
<span class="nc" id="L67">		else  return false;</span>
	}
	/**
	 * Verifies whether the specified character position
	 * lies inside of this char table.
	 */
	public boolean contains(int x, int y) {
<span class="nc bnc" id="L74" title="All 4 branches missed.">		return permitsX(x) &amp;&amp; permitsY(y);</span>
	}
	/**
	 * Verifies whether the specified character position
	 * lies inside of this char table.
	 */
	public boolean contains(CharPosition pos) {
<span class="nc bnc" id="L81" title="All 4 branches missed.">		return permitsX(pos.x) &amp;&amp; permitsY(pos.y);</span>
	}
	
	public boolean isTrivial() {
<span class="nc bnc" id="L85" title="All 4 branches missed.">		return (x1 &gt;= x2) || (y1 &gt;= y2);</span>
	}
	
	/**
	 * ����� ���������� ������ �������, �������������
	 * �� ����������� {@code x} � {@code y}.
	 * 
	 * @param x	���������� �� �����������.
	 * @param y	���������� �� ���������.
	 * @return	��������������� ���� ����������� ������.
	 */
	public abstract char charAt(int x, int y);
	/**
	 * ����� ���������� ������ �������, ������������� � {@code p}.
	 */	
	public char charAt(CharPosition p) {
<span class="nc" id="L101">		return charAt(p.x,p.y);</span>
	}
	/**
	 * Verifies whether the specified character can be a part of a word
	 * (say, is a letter).
	 * 
	 * @param c	character
	 */
	public static boolean isLetter(char c) {
<span class="nc bnc" id="L110" title="All 2 branches missed.">		return LETTERS.indexOf( c ) &gt; -1;</span>
	}
	
	public boolean letterAt(int x, int y) {
<span class="nc" id="L114">		return isLetter( charAt(x,y) );</span>
	}
	
	/**
	 * Verifies whether the specified symbol is a word character,
	 * i.e. is a letter or a dot.
	 * 
	 * @param c	symbol
	 */
	public static boolean isWordChar(char c) {
<span class="nc bnc" id="L124" title="All 4 branches missed.">		return c == '.' || LETTERS.indexOf( c ) &gt; -1;</span>
	}
	/**
	 * Verifies whether the symbol at the specified position {@code (x,y)}
	 * is a word character, i.e. is a letter or a dot.
	 * 
	 * @param x	x-coordinate
	 * @param y	y-coordinate
	 * @return	{@code true} if the symbol under position {@code (x,y)}
	 * 			is a word character
	 */
	public boolean wordCharAt(int x, int y) {
<span class="nc" id="L136">		return  isWordChar( charAt(x,y) );</span>
	}
	
	/**
	 * ���������, �������� �� ������ ������ ������ �������������� �����.
	 * @param c	������.
	 */
	public static boolean isSplitter(char c) {
<span class="nc bnc" id="L144" title="All 2 branches missed.">		return SPLITTERS.indexOf( c ) &gt; -1;</span>
	}
	
	/**
	 * ���������, �������� �� ������ �������, ������������� � �����
	 * {@code (x,y)}, ������ �������������� �����.
	 */
	public boolean splitterAt(int x, int y) {
<span class="nc" id="L152">		return isSplitter( charAt(x,y) ); </span>
	}
			
	/**
	 * Returns the text on the table
	 * specified by the given horizontal word position coordinates.
	 * 
	 * @param x1	the number of the first symbol
	 * 				of the required word on the table.
	 * @param x2	the number of the last symbol
	 * 				of the required word on the table + 1.
	 * @param y		the number of the line with the required word.
	 * 
	 * @return		the text lying at the specified horizontal word position.
	 */
	public abstract String textAt(int x1, int x2, int y);
	
	/**
	 * Returns the text lying at the specified word position on the table.
	 * 
	 * @param wp	the position of the word to be returned.
	 * 
	 * @return		the text lying at the specified word position.
	 */
	public String textAt(WordPosition wp)
	{
<span class="nc bnc" id="L178" title="All 2 branches missed.">		if( wp == null )</span>
<span class="nc" id="L179">			throw new IllegalArgumentException(&quot;Null word position.&quot;);</span>
<span class="nc" id="L180">		return wp.textAt(this);</span>
	}
	/**
	 * Returns the text lying at the specified
	 * horizontal word position on the table.
	 * 
	 * @param hwp	the position of the horizontal word to be returned.
	 * 
	 * @return		the text lying at the specified word position.
	 */
	public String textAt(HWordPosition hwp)
	{
<span class="nc" id="L192">		return textAt(hwp.x1, hwp.x2, hwp.y);</span>
	}
	
	/**
	 * Returns the text lying at the specified
	 * vertical word position on the table.
	 * 
	 * @param vwp	the position of the vertical word to be returned.
	 * 
	 * @return		the text lying at the specified word position.
	 */
	public String textAt(VWordPosition vwp)
	{
<span class="nc" id="L205">		StringBuilder result = new StringBuilder( &quot;(vertical) &quot; );</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">		for (int y = vwp.y1; y &lt; vwp.y2; y++)</span>
<span class="nc" id="L207">			result.append(charAt(vwp.x,y));</span>
<span class="nc" id="L208">		return result.toString();</span>
	}
	
	/**
	 * Optimizes the boundaries by moving them close to the contained
	 * components and gaps.
	 * &lt;p&gt;
	 * If the optimized table remains non-trivial, it definitely contains
	 * some components or gaps.
	 */
	public void optimize() {
<span class="nc" id="L219">		optimizeX1();</span>
<span class="nc" id="L220">		optimizeX2();</span>
<span class="nc" id="L221">		optimizeY1();</span>
<span class="nc" id="L222">		optimizeY2();</span>
<span class="nc" id="L223">	}</span>
	private void optimizeX1() {
<span class="nc bnc" id="L225" title="All 4 branches missed.">		for (; x1 &lt; x2 &amp;&amp; columnContainsNoWordChars(x1); ) x1++;</span>
<span class="nc" id="L226">	}</span>
	private void optimizeX2() {
<span class="nc bnc" id="L228" title="All 4 branches missed.">		for (; x1 &lt; x2 &amp;&amp; columnContainsNoWordChars(x2-1); ) x2--;</span>
<span class="nc" id="L229">	}</span>
	private void optimizeY1() {
<span class="nc bnc" id="L231" title="All 4 branches missed.">		for (; y1 &lt; y2 &amp;&amp; rowContainsNoWordChars(y1); ) y1++;</span>
<span class="nc" id="L232">	}</span>
	private void optimizeY2() {
<span class="nc bnc" id="L234" title="All 4 branches missed.">		for (; y1 &lt; y2 &amp;&amp; rowContainsNoWordChars(y2-1); ) y2--;</span>
<span class="nc" id="L235">	}</span>
	/**
	 * Verifies that the column under the specified number
	 * does not contain word characters.
	 */
	private boolean columnContainsNoWordChars(int x) {
<span class="nc bnc" id="L241" title="All 2 branches missed.">		for (int y=y1; y&lt;y2; y++)</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">			if( wordCharAt(x,y) )  return false;</span>
<span class="nc" id="L243">		return true;</span>
	}
	/**
	 * Verifies that the row under the specified number
	 * does not contain word characters.
	 */
	private boolean rowContainsNoWordChars(int y) {
<span class="nc bnc" id="L250" title="All 2 branches missed.">		for (int x=x1; x&lt;x2; x++)</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">			if( wordCharAt(x,y) )  return false;</span>
<span class="nc" id="L252">		return true;</span>
	}
	
	/**
	 * Returns (position of) the first horizontal word in this char table;
	 * the direction of searching is rightwards-downwards (say, horizontal).
	 */
	public HWordPosition firstWord_Horizontally() {
<span class="nc" id="L260">		return firstWordAfter_Horizontally( getPos1() );</span>
	}
	
	/**
	 * Returns (position of) the first horizontal word after the
	 * specified word {@code wp}; the direction of searching
	 * is rightwards-downwards (say, horizontal).
	 * 
	 * If not found, returns null.
	 */
	public HWordPosition firstWordAfter_Horizontally(HWordPosition wp) {
<span class="nc" id="L271">		return firstWordAfter_Horizontally( wp.getEnd() );</span>
	}
	
	/**
	 * Returns (position of) the first horizontal word after the
	 * specified position {@code p} (inclusive);
	 * the direction of searching is rightwards-downwards (say, horizontal).
	 * 
	 * If not found, returns null.
	 */
	private HWordPosition firstWordAfter_Horizontally(CharPosition p)
	{
<span class="nc" id="L283">		CharPosition wordStart = firstWordCharAfter_Horizontally(p);</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">		if( wordStart == null ) //word characters not found.</span>
<span class="nc" id="L285">			return null;</span>
		//wordStart is the character found.
<span class="nc" id="L287">		return new HWordPosition(</span>
				wordStart,
<span class="nc" id="L289">				firstNonWordCharOnTheRightOf(wordStart) );</span>
	}
	
	/**
	 * Returns the position of the first word character after the
	 * specified position {@code p} (inclusive);
	 * the direction of searching is rightwards-downwards (say, horizontal).
	 * 
	 * If not found, returns null.
	 */
	private CharPosition firstWordCharAfter_Horizontally(CharPosition p)
	{
<span class="nc" id="L301">		int x = p.x;</span>
<span class="nc" id="L302">		int y = p.y;</span>
		//search to the horizontal line end:
<span class="nc bnc" id="L304" title="All 2 branches missed.">		for (x = p.x; x &lt; x2; x++)</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">			if( wordCharAt(x,y) )  return new CharPosition(x,y);</span>
		//since not found, search in other horizontal lines:
<span class="nc bnc" id="L307" title="All 2 branches missed.">		for (y++; y &lt; y2; y++)</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">			for (x = x1; x &lt; x2; x++)</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">				if( wordCharAt(x,y) )</span>
<span class="nc" id="L310">					return new CharPosition(x,y);</span>
<span class="nc" id="L311">		return null;</span>
	}
	
	/**
	 * Returns the x-coordinate of the first symbol which lies on the right
	 * from the specified position {@code p} and is not a word character.
	 * 
	 * If not found, returns {@code x2}.
	 */
	private int firstNonWordCharOnTheRightOf(CharPosition p) {
<span class="nc" id="L321">		int x = p.x + 1;</span>
<span class="nc" id="L322">		int y = p.y;</span>
<span class="nc bnc" id="L323" title="All 4 branches missed.">		for (; x &lt; x2 &amp;&amp; wordCharAt(x,y); x++) ;</span>
<span class="nc" id="L324">		return x;</span>
	}
	
	/**
	 * Returns (position of) the first horizontal word in this char table;
	 * the direction of searching is leftwards-upwards (say, horizontal).
	 * 
	 * If not found, returns null.
	 */
	public HWordPosition lastWord_Horizontally()
	{
<span class="nc" id="L335">		CharPosition wordEnd = lastWordChar_Horizontally();</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">		if( wordEnd == null )</span>
<span class="nc" id="L337">			return null;</span>
<span class="nc" id="L338">		return new HWordPosition(</span>
<span class="nc" id="L339">				lastWordCharOnTheLeftOf(wordEnd), wordEnd );</span>
	}
	
	/**
	 * Returns the position of the first letter + 1
	 * when the search direction is leftwards-upwards (say, horizontal)
	 * or null if not found.
	 */
	private CharPosition lastWordChar_Horizontally() {
<span class="nc" id="L348">		int x = x2 - 1;</span>
<span class="nc" id="L349">		int y = y2 - 1;</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">		for (; y &gt;= y1; y--)</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">			for (x = x2-1; x &gt;= x1; x--)</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">				if( wordCharAt(x,y) )</span>
<span class="nc" id="L353">					return new CharPosition(x+1,y);</span>
<span class="nc" id="L354">		return null;</span>
	}
	
	/**
	 * Returns the x-coordinate of the last word character
	 * of a continuous sequence of word characters
	 * starting at the specified position {@code p} and going leftwards.
	 */
	private int lastWordCharOnTheLeftOf(CharPosition p) {
<span class="nc" id="L363">		int x = p.x - 1;</span>
<span class="nc" id="L364">		int y = p.y;</span>
<span class="nc bnc" id="L365" title="All 4 branches missed.">		for (; x &gt;= x1 &amp;&amp; wordCharAt(x,y); x--) ;</span>
<span class="nc" id="L366">		return x+1;</span>
	}
	
	
	/**
	 * Returns (position of) the first horizontal word in this char table;
	 * the direction of searching is downwards-rightwards (say, vertical).
	 * If not found, returns null.
	 */
	public HWordPosition firstWord_Vertically()
	{
<span class="nc" id="L377">		CharPosition nextWordCharPos = </span>
<span class="nc" id="L378">			firstWordCharVertically();</span>
		
<span class="nc bnc" id="L380" title="All 2 branches missed.">		if( nextWordCharPos != null )</span>
<span class="nc" id="L381">			return new HWordPosition(</span>
					nextWordCharPos,
<span class="nc" id="L383">					firstNonWordCharOnTheRightOf(nextWordCharPos) );</span>
<span class="nc" id="L384">		else return null;</span>
	}
	
	/**
	 * Returns the position of the first word character;
	 * the direction of searching is downwards-rightwards (say, vertical).
	 * 
	 * If not found, returns null.
	 */
	private CharPosition firstWordCharVertically()
	{
<span class="nc bnc" id="L395" title="All 2 branches missed.">		for (int x = x1; x &lt; x2; x++)</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">			for (int y = y1; y &lt; y2; y++)</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">				if( wordCharAt(x,y) )</span>
<span class="nc" id="L398">					return new CharPosition(x,y);</span>
<span class="nc" id="L399">		return null;</span>
	}
	
	/**
	 * Returns (position of) the first horizontal word after the
	 * specified word {@code wp}; the direction of searching
	 * is downwards-rightwards (say, vertical).
	 * If not found, returns null.
	 * 
	 * @throws IllegalArgumentException if the specified word position is null.
	 */
	public HWordPosition firstWordAfter_Vertically(HWordPosition wp)
	{
<span class="nc bnc" id="L412" title="All 2 branches missed.">		if( wp == null )</span>
<span class="nc" id="L413">			throw new IllegalArgumentException(</span>
					&quot;Can not search for the word following the null word.&quot;);
		
<span class="nc" id="L416">		CharPosition nextWordCharPos =</span>
<span class="nc" id="L417">			firstWordCharAfter_Vertically( wp.getStart() );</span>
		
<span class="nc bnc" id="L419" title="All 4 branches missed.">		while ( nextWordCharPos != null &amp;&amp; this.contains(nextWordCharPos) ) {</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">			if( ! wp.contains(nextWordCharPos) ) //this is a new word</span>
<span class="nc" id="L421">				return new HWordPosition(</span>
						nextWordCharPos,
<span class="nc" id="L423">						firstNonWordCharOnTheRightOf(nextWordCharPos) );</span>
<span class="nc" id="L424">			nextWordCharPos =</span>
<span class="nc" id="L425">				firstWordCharAfter_Vertically( nextWordCharPos );</span>
		}
		
<span class="nc" id="L428">		return null;</span>
	}
	
	/**
	 * Returns the position of the first word character after the
	 * specified position {@code p} (inclusive);
	 * the direction of searching is downwards-rightwards (say, vertical).
	 * 
	 * If not found, returns null.
	 */
	private CharPosition firstWordCharAfter_Vertically(CharPosition p)
	{
<span class="nc" id="L440">		int x = p.x;</span>
<span class="nc" id="L441">		int y = p.y;</span>
		//search to the vertical line end:
<span class="nc bnc" id="L443" title="All 2 branches missed.">		for (y++; y &lt; y2; y++)</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">			if( wordCharAt(x,y) )  return new CharPosition(x,y);</span>
		//since not found, search in other vertical lines:
<span class="nc bnc" id="L446" title="All 2 branches missed.">		for (x++; x &lt; x2; x++)</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">			for (y = y1; y &lt; y2; y++)</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">				if( wordCharAt(x,y) )</span>
<span class="nc" id="L449">					return new CharPosition(x,y);</span>
<span class="nc" id="L450">		return null;</span>
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>