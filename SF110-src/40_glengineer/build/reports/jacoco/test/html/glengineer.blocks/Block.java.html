<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Block.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">40_glengineer</a> &gt; <a href="index.source.html" class="el_package">glengineer.blocks</a> &gt; <span class="el_source">Block.java</span></div><h1>Block.java</h1><pre class="source lang-java linenums">package glengineer.blocks;

import glengineer.positions.*;

import java.util.*;


/**
 * Represents a rectangular area on a scheme.
 * This is an abstract class for its two concrete descendants,
 * {@code HorizontalBlock} and {@code VerticalBlock},
 * which are used for dealing with
 * the horizontal and the vertical layouts, respectively.
 */
public abstract class Block  extends CharTable
{
	/**
	 * ����� ����������, �� ������� ���������� {@code Block}.
	 */
	protected Scheme scheme;
	
	/**
	 * ������ ���� ������ ����� � ������� ������������ ���������
	 * � �������� �������.
	 */
	public Block(Scheme scheme, int x1, int y1, int x2, int y2)
<span class="fc" id="L27">	{</span>
<span class="pc bpc" id="L28" title="7 of 12 branches missed.">		if( x1 &lt; 0 || y1 &lt; 0 || x1 &gt; x2 || y1 &gt; y2 ||</span>
				x2 &gt; scheme.x2 || y2 &gt; scheme.y2 )
<span class="fc" id="L30">			throw new IllegalArgumentException( &quot;improper block definition&quot; +</span>
					&quot;: &quot; + x1 + &quot;,&quot; + y1 + &quot;, &quot; + x2 + &quot;,&quot; + y2 + &quot;.&quot; );
<span class="nc" id="L32">		this.x1 = x1;</span>
<span class="nc" id="L33">		this.y1 = y1;</span>
<span class="nc" id="L34">		this.x2 = x2;</span>
<span class="nc" id="L35">		this.y2 = y2;</span>
<span class="nc" id="L36">		this.scheme = scheme;</span>
<span class="nc" id="L37">	}</span>
	public Block(Scheme scheme, CharPosition p1, CharPosition p2) {
<span class="nc" id="L39">		this(scheme, p1.x,p1.y, p2.x,p2.y);</span>
<span class="nc" id="L40">	}</span>
	
	/**
	 * ������ ���� ������ �����, �� ������� ����������� �� ���� ������. 
	 */
<span class="nc" id="L45">	public Block(Scheme scheme) {</span>
<span class="nc" id="L46">		x1 = 0;</span>
<span class="nc" id="L47">		y1 = 0;</span>
<span class="nc" id="L48">		x2 = scheme.x2;</span>
<span class="nc" id="L49">		y2 = scheme.y2;</span>
<span class="nc" id="L50">		this.scheme = scheme;</span>
<span class="nc" id="L51">	}		</span>
	
	/**
	 * ������ � ���������� �������, ������� ��������� ����������.
	 * @param x1	{@code x}-���������� ������ ������ ��������.
	 * @param y1	{@code y}-���������� ������ ������ ��������.
	 * @param x2	{@code x}-���������� ����� ������ ��������.
	 * @param y2	{@code y}-���������� ����� ������ ��������.
	 * @return		����� �������.
	 */
	public abstract Block subblock(int x1, int y1, int x2, int y2) ;
	
	/**
	 * ����� ���������� ������, �������������
	 * �� ����������� {@code x} � {@code y}.
	 * 
	 * @param x	���������� �� �����������.
	 * @param y	���������� �� ���������.
	 * 
	 * @return	��������������� ���� ����������� ������.
	 */
	public char charAt(int x, int y) {
		try {
<span class="nc" id="L74">			return scheme.lines[y].charAt(x);</span>
<span class="nc" id="L75">		} catch (RuntimeException re) {</span>
<span class="nc" id="L76">			throw new IllegalArgumentException(</span>
				&quot;char position &quot; + new CharPosition(x,y) +
				&quot; out of block.\n&quot; + this );
		}
	}
	
	public String textAt(int x1, int x2, int y) {
		try {
<span class="nc" id="L84">			return scheme.lines[y].substring(x1,x2);</span>
<span class="nc" id="L85">		} catch (RuntimeException re) {</span>
<span class="nc" id="L86">			throw new IllegalArgumentException(&quot;Improper subline coodinates.&quot;);</span>
		}
	}
	
	/**
	 * Verifies whether the block contains only one element
	 * (a component or a gap).
	 * 
	 * @return	{@code true} if only one or {@code false} if more than one.
	 * 			If there are no elements or the block is trivial,
	 * 			an exception is thrown.
	 */
	public boolean containsOnlyOneWord()
	{
<span class="nc bnc" id="L100" title="All 2 branches missed.">		if( isTrivial() )</span>
<span class="nc" id="L101">			throw new IllegalArgumentException(</span>
					&quot;cannot search in a trivial block&quot; );
<span class="nc" id="L103">		HWordPosition firstWord = firstWord_Horizontally();</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">		if( firstWord.y == y2 ) //������ ��� �����������.</span>
<span class="nc" id="L105">			throw new IllegalArgumentException(</span>
					&quot;cannot verify unicity of an word in an empty block&quot;);
<span class="nc" id="L107">		WordPosition lastWord = lastWord_Horizontally();</span>
<span class="nc" id="L108">		return firstWord.equals(lastWord);</span>
	}
	
	/**
	 * Divides the current block into a set of sequential subblocks,
	 * optimizes these subblocks and returns them as a linked list.
	 */
	public abstract List&lt;Block&gt; extractSequentialSubblocks();
	
	/**
	 * Divides the current block into a set of parallel subblocks,
	 * optimizes these subblocks and returns them as a linked list.
	 */
	public abstract List&lt;Block&gt; extractParallelSubblocks();
	
	
	public String toString() {
<span class="nc" id="L125">		String result = &quot;Block(&quot;+x1+&quot;,&quot;+y1+&quot;, &quot;+x2+&quot;,&quot;+y2+&quot;):\n&quot;;</span>
		//���������� ������ ��� ����� � ���� �����:
<span class="nc" id="L127">			int frameWidth = x2-x1 + 4;</span>
<span class="nc" id="L128">			char[] line = new char[frameWidth];</span>
<span class="nc" id="L129">			java.util.Arrays.fill(line,'#');</span>
<span class="nc" id="L130">			String lineString = &quot; &quot; + new String(line);</span>
<span class="nc" id="L131">		result = result.concat( lineString + &quot;\n&quot;);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">		for (int y=y1; y&lt;y2; y++)</span>
<span class="nc" id="L133">			result = result.concat(</span>
<span class="nc" id="L134">					&quot; # &quot; + scheme.textAt(x1, x2,y) + &quot; #\n&quot; );</span>
<span class="nc" id="L135">		result = result.concat( lineString );</span>
<span class="nc" id="L136">		return result;</span>
	}
	
	/**
	 * Returns the upper line of this block.
	 * &lt;p&gt;
	 * This method is used when the block represents a position
	 * of a horizontal word on a scheme.
	 */
	public String getUpperLine()
	{
<span class="nc" id="L147">		return textAt(x1,x2, y1);</span>
	}
	
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>