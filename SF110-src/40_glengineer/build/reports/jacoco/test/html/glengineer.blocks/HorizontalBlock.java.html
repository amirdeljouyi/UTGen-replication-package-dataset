<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HorizontalBlock.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">40_glengineer</a> &gt; <a href="index.source.html" class="el_package">glengineer.blocks</a> &gt; <span class="el_source">HorizontalBlock.java</span></div><h1>HorizontalBlock.java</h1><pre class="source lang-java linenums">package glengineer.blocks;

import glengineer.positions.*;

import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block
{
	public HorizontalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
<span class="nc" id="L14">		super(scheme, x1, y1, x2, y2);</span>
<span class="nc" id="L15">	}</span>
	public HorizontalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
<span class="nc" id="L17">		super(scheme, p1, p2);</span>
<span class="nc" id="L18">	}</span>
	public HorizontalBlock(Scheme scheme) {
<span class="nc" id="L20">		super(scheme);</span>
<span class="nc" id="L21">	}</span>
	public HorizontalBlock(Block b) {
<span class="nc" id="L23">		super(b.scheme, b.getPos1(), b.getPos2());</span>
<span class="nc" id="L24">	}</span>
	public HorizontalBlock(Block block, int x1, int y1, int x2, int y2) {
<span class="nc" id="L26">		super(block.scheme, x1, y1, x2, y2);</span>
<span class="nc" id="L27">	}</span>
	
	public Block subblock(int x1, int y1, int x2, int y2) {
<span class="nc" id="L30">		return new HorizontalBlock(scheme, x1,y1, x2,y2);</span>
	}
	
	public HorizontalBlock cloneWith(CharPosition1 p1)
	{
<span class="nc" id="L35">		return new HorizontalBlock(scheme, p1, getPos2());</span>
	}
	
	/**
	 * Divides the current block into a set of sequential subblocks,
	 * optimizes these subblocks and returns them as a linked list.
	 * 
	 * @return	a list of optimized sequential subblocks.
	 */
	public List&lt;Block&gt; extractSequentialSubblocks()
	{
<span class="nc" id="L46">		this.optimize();</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">		if( isTrivial() )  return new LinkedList&lt;Block&gt;();</span>
		
<span class="nc" id="L49">		List&lt;Block&gt; result = new LinkedList&lt;Block&gt;();</span>
		
		Block firstBlock;
<span class="nc" id="L52">		HorizontalBlock theRest = this;</span>
		do {
<span class="nc" id="L54">			firstBlock = theRest.extractFirstSequentialSubblock();</span>
<span class="nc" id="L55">			theRest = theRest.cloneWith(</span>
					new CharPosition1(firstBlock.x2,this.y1) );
<span class="nc" id="L57">			firstBlock.optimize();</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">			if( ! firstBlock.isTrivial() )</span>
<span class="nc" id="L59">				result.add( firstBlock );</span>
<span class="nc" id="L60">			theRest.optimize();</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">		} while ( ! theRest.isTrivial() );</span>
<span class="nc" id="L62">		return result;</span>
	}
	
	/**
	 * Extracts the left subblock of this block.
	 * &lt;p&gt;
	 * The required block is chosen so that its last exclusive vertical line
	 * does not contain elements of components, gaps , or horizontal lines
	 * starting on the left from the line.
	 * &lt;p&gt;
	 * The algorithm just finds the most left entity
	 * (an element of a component, gap, or horizontal line)
	 * using simple search along the scheme,
	 * identifies the horizontal element containing the entity found,
	 * checks whether the last exclusive vertical line of the element
	 * matches the requirement for the boundary of the required block,
	 * and, if does not, takes the detaining horizontal element
	 * and continues the cycle.
	 */
	private Block extractFirstSequentialSubblock()
	{
<span class="nc" id="L83">		final HWordPosition firstWord =</span>
<span class="nc" id="L84">			scheme.anyHElementAt( firstEntity() );</span>
		
<span class="nc" id="L86">		HWordPosition lastWord = firstWord;</span>
		
<span class="nc" id="L88">		HWordPosition nextWord = firstWord;</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">		for(; nextWord != null; ) {</span>
<span class="nc" id="L90">			lastWord = nextWord;</span>
<span class="nc" id="L91">			nextWord = findAWordExtendingSubblockToTheRightFrom( nextWord );</span>
		}
		
<span class="nc" id="L94">		int startX = firstWord.x1;</span>
<span class="nc" id="L95">		int endX = lastWord.x2;</span>
		//For the case of words containing cells outside of this block:
<span class="nc" id="L97">		startX = Math.max( startX, x1 );</span>
<span class="nc" id="L98">		endX = Math.min( endX, x2 );</span>
		
<span class="nc" id="L100">		return subblock( startX, y1, endX, y2 );</span>
	}
	
	/**
	 * Searches down and to the right from the beginning of this block
	 * for the first occurrence of an entity.
	 * @return	the position of the entity found.
	 * @throws	IllegalArgumentException if this block
	 * 			does not contain entities.
	 */
	private CharPosition firstEntity()
	{
<span class="nc" id="L112">		int y = firstEntityBelow(x1,y1);</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">		if( y != y2 )</span>
<span class="nc" id="L114">			return new CharPosition(x1,y);</span>
		
<span class="nc" id="L116">		int x = x1 + 1;</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">		for (; x &lt; x2; x++) {</span>
<span class="nc" id="L118">			y = firstEntityBelow(x,y1);</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">			if( y != y2 )  break;</span>
		}
		
<span class="nc bnc" id="L122" title="All 2 branches missed.">		if( x != x2 )</span>
<span class="nc" id="L123">			return new CharPosition(x,y);</span>
		else
<span class="nc" id="L125">			throw new IllegalArgumentException(</span>
					&quot;Can not extract a group from an empty block:\n&quot; + this);
	}
	
	/**
	 * Finds the first entity below the specified position.
	 * @return	the y-coordinate of the entity found or y2 if not found.
	 */
	private int firstEntityBelow(int x, int y)
	{
<span class="nc bnc" id="L135" title="All 2 branches missed.">		for (; y &lt; y2; y++)</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">			if( entityAt(x,y) )  break;</span>
<span class="nc" id="L137">		return y;</span>
	}
	
	/**
	 * Verifies whether the character under the cell
	 * determined by the specified coordinates
	 * is a word character or a horizontal line character.
	 */
	private boolean entityAt(int x, int y)
	{
<span class="nc" id="L147">		char c = charAt(x,y);</span>
		/* 
		 * Since all symbols on the scheme are correct
		 * (which has been verified in its constructor),
		 * there is no need to use the slower method isWordChar().
		 */
<span class="nc bnc" id="L153" title="All 4 branches missed.">		return c != ' ' &amp;&amp; c != '|';</span>
	}
	
	/**
	 * Returns a word which starts not righter than the right end of the
	 * {@code currentWord} but ends strictly righter
	 * (or null if does not exist).
	 */
	private HWordPosition findAWordExtendingSubblockToTheRightFrom(
				HWordPosition currentWord )
	{
<span class="nc" id="L164">		int x = currentWord.x2 - 1;</span>
<span class="nc" id="L165">		int y = y1;</span>
<span class="nc" id="L166">		int yToSkip = currentWord.y;</span>
		
		HWordPosition result;
		
<span class="nc bnc" id="L170" title="All 2 branches missed.">		for(; y &lt; y2; y++) {</span>
<span class="nc bnc" id="L171" title="All 4 branches missed.">			if( y == yToSkip || ! entityAt(x,y) )</span>
<span class="nc" id="L172">				continue;</span>
<span class="nc" id="L173">			result = scheme.anyHElementAt(x,y);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">			if( result == null ) </span>
<span class="nc" id="L175">				continue;</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">			if( result.x2 &gt; currentWord.x2 )</span>
<span class="nc" id="L177">				return result;</span>
		}
		
<span class="nc" id="L180">		return null;</span>
	}
	
	
	/**
	 * Divides the current block into a set of parallel subblocks,
	 * optimizes these subblocks and returns them as a linked list.
	 * &lt;p&gt;
	 * If the block has horizontal lines,
	 * this method divides the block by the maximal horizontal lines only.
	 * &lt;p&gt;
	 * If there are no horizontal lines, the block is divided into
	 * usual parallel subblocks.
	 */
	public List&lt;Block&gt; extractParallelSubblocks()
	{
<span class="nc" id="L196">		this.optimize();</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">		if( isTrivial() )</span>
<span class="nc" id="L198">			return new LinkedList&lt;Block&gt;();</span>
		
<span class="nc" id="L200">		Set&lt;HWordPosition&gt; hLines = getIntersectingHLines();</span>
		
<span class="nc bnc" id="L202" title="All 2 branches missed.">		if( hLines.size() &gt; 0 )</span>
<span class="nc" id="L203">			return extractParallelSubblocksSeparatedByLines( hLines );</span>
		else
<span class="nc" id="L205">			return extractParallelSubblocksWithoutLines();</span>
	}
	
	/**
	 * Returns the set of all horizontal lines intersecting this block.
	 */
	private Set&lt;HWordPosition&gt; getIntersectingHLines()
	{
<span class="nc" id="L213">		Set&lt;HWordPosition&gt; source = scheme.getHLinesPositions();</span>
<span class="nc" id="L214">		Set&lt;HWordPosition&gt; result = new HashSet&lt;HWordPosition&gt;();</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">		for (HWordPosition line : source)</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">			if( line.intersects(this) )</span>
<span class="nc" id="L217">				result.add( line );</span>
<span class="nc" id="L218">		return result;</span>
	}
	
	/**
	 * Divides the current block into a set of parallel subblocks
	 * by its most long horizontal lines,
	 * optimizes these subblocks, and returns them as a linked list.
	 */
	protected List&lt;Block&gt; extractParallelSubblocksSeparatedByLines(
			Set&lt;HWordPosition&gt; hLines )
	{
<span class="nc" id="L229">		removeSmallHLinesFrom(hLines);</span>
		
<span class="nc" id="L231">		List&lt;Integer&gt; separators = sortedYsOf(hLines);</span>
		
<span class="nc" id="L233">		return extractParallelSubblocksSeparatedBy( separators );</span>
	}
	
	/**
	 * Finds the longest lines in the specified set of horizontal lines
	 * and then removes from it all other elements.
	 * &lt;p&gt;
	 * Note that, more formally, this method considers the lengths
	 * of &lt;i&gt;intersections&lt;/i&gt; of the lines with this block.
	 */
	private void removeSmallHLinesFrom( Set&lt;HWordPosition&gt; hLines )
	{
		//determine the maximum length:
<span class="nc" id="L246">		int maxLength = 0;</span>
		int length;
<span class="nc bnc" id="L248" title="All 2 branches missed.">		for (HWordPosition line : hLines) {</span>
<span class="nc" id="L249">			length = line.getLengthInsideOf(this);</span>
<span class="nc" id="L250">			maxLength = Math.max(length,maxLength);</span>
<span class="nc" id="L251">		}</span>
		//remove the short lines:
		HWordPosition line;
<span class="nc" id="L254">		Iterator&lt;HWordPosition&gt; i = hLines.iterator();</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">		for(; i.hasNext(); ) {</span>
<span class="nc" id="L256">			line = i.next();</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">			if( line.getLengthInsideOf(this) &lt; maxLength )</span>
<span class="nc" id="L258">				i.remove();</span>
		}
<span class="nc" id="L260">	}</span>
	
	/**
	 * Returns a list of the specified horizontal lines' vertical coordinates.
	 */
	private List&lt;Integer&gt; sortedYsOf( Set&lt;HWordPosition&gt; hLines )
	{
<span class="nc" id="L267">		LinkedList&lt;Integer&gt; linesY = new LinkedList&lt;Integer&gt;();</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">		for (HWordPosition line : hLines)</span>
<span class="nc" id="L269">			linesY.add( new Integer(line.y) );</span>
<span class="nc" id="L270">		Collections.sort( linesY );</span>
<span class="nc" id="L271">		return linesY;</span>
	}
	
	private List&lt;Block&gt; extractParallelSubblocksSeparatedBy(
			List&lt;Integer&gt; ySeparators )
	{
<span class="nc" id="L277">		List&lt;Block&gt; blocksList = new LinkedList&lt;Block&gt;();</span>
		Block subBlock;
<span class="nc" id="L279">		int upperY = y1; //upper bound of a subblock</span>
		
<span class="nc bnc" id="L281" title="All 2 branches missed.">		for (int lowerY : ySeparators) {</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">			if( lowerY &gt; upperY ) {</span>
				//there is a (non-trivial?) block between two lines.
<span class="nc" id="L284">				subBlock = new HorizontalBlock(this, x1,upperY, x2,lowerY);</span>
<span class="nc" id="L285">				subBlock.optimize();</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">				if( !subBlock.isTrivial() )</span>
<span class="nc" id="L287">					blocksList.add( subBlock );</span>
			}
<span class="nc" id="L289">			upperY = lowerY + 1;</span>
<span class="nc" id="L290">		}</span>
		//below the last line:
<span class="nc bnc" id="L292" title="All 2 branches missed.">		if( upperY &lt; y2 ) {</span>
<span class="nc" id="L293">			subBlock = new HorizontalBlock(this, x1,upperY, x2,y2);</span>
<span class="nc" id="L294">			subBlock.optimize();</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">			if( !subBlock.isTrivial() )</span>
<span class="nc" id="L296">				blocksList.add( subBlock );</span>
		}
<span class="nc" id="L298">		return blocksList;</span>
	}
	
	/**
	 * Divides the current block without horizontal lines
	 * into a set of parallel subblocks, optimizes these subblocks
	 * and returns them as a linked list.
	 */
	protected List&lt;Block&gt; extractParallelSubblocksWithoutLines()
	{
<span class="nc" id="L308">		List&lt;Block&gt; result = new LinkedList&lt;Block&gt;();</span>
		Block block;
<span class="nc bnc" id="L310" title="All 2 branches missed.">		for (int y = y1; y &lt; y2; y++) {</span>
<span class="nc" id="L311">			block = subblock(x1,y, x2,y+1);</span>
<span class="nc" id="L312">			block.optimize();</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">			if( !block.isTrivial() )</span>
<span class="nc" id="L314">				result.add(block);</span>
		}
<span class="nc" id="L316">		return result;</span>
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>