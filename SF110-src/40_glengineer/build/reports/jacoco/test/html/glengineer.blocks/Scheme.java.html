<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Scheme.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">40_glengineer</a> &gt; <a href="index.source.html" class="el_package">glengineer.blocks</a> &gt; <span class="el_source">Scheme.java</span></div><h1>Scheme.java</h1><pre class="source lang-java linenums">package glengineer.blocks;

import glengineer.positions.*;

import java.util.*;


/**
 * Represents the layout scheme which is specified by the end user
 * as a sequence of strings.
 */
public class Scheme extends CharTable 
{
	protected final String[] lines;
	
	/**
	 * Encapsulates the sets of positions of all components, lines and gaps
	 * present on the scheme.
	 */
<span class="nc" id="L20">	private static class Positions {</span>
<span class="nc" id="L21">		HashSet&lt;HWordPosition&gt; components = new HashSet&lt;HWordPosition&gt;();</span>
<span class="nc" id="L22">		HashSet&lt;HWordPosition&gt; hLines = new HashSet&lt;HWordPosition&gt;();</span>
<span class="nc" id="L23">		HashSet&lt;VWordPosition&gt; vLines = new HashSet&lt;VWordPosition&gt;();</span>
<span class="nc" id="L24">		HashSet&lt;HWordPosition&gt; gaps = new HashSet&lt;HWordPosition&gt;();</span>
	}
	private Positions positions;
	
	/**
	 * Encapsulates the sets of names of all components and of all gaps
	 * present on the scheme.
	 */
<span class="nc" id="L32">	private static class Names {</span>
<span class="nc" id="L33">		HashSet&lt;String&gt; components = new HashSet&lt;String&gt;();</span>
<span class="nc" id="L34">		HashSet&lt;String&gt; gaps = new HashSet&lt;String&gt;();</span>
	}
	private Names names;
	
	/**
	 * Maps components and gaps positions to the corresponding names.
	 */
	private HashMap&lt;HWordPosition,String&gt; positionsToNames;
	
	/**
	 * Maps the y-coordinates on the scheme
	 * to sets of horizontal words having these coordinates.
	 * This map is used in the horizontal words and lines search methods.
	 */
	private Map&lt;Integer, HashSet&lt;HWordPosition&gt;&gt; hWordsAtYs;
	
	/**
	 * Maps the x-coordinates on the scheme
	 * to sets of vertical words having these coordinates.
	 * This map is used in the vertical line search method.
	 */
	private Map&lt;Integer, HashSet&lt;VWordPosition&gt;&gt; vWordsAtXs;
	
	/**
	 * Represents the correspondence between the lines on the scheme
	 * and the gaps which belong to those lines (intersect them).
	 * Both lines and gaps are represented by their positions on the scheme.
	 * &lt;p&gt;
	 * Note that each line may contain (may be intersected by) only one gap.
	 */
	private Map&lt;WordPosition, HWordPosition&gt; gapsAtLines;
	
	public Scheme(String... strings)
<span class="nc" id="L67">	{</span>
<span class="nc" id="L68">		lines = strings;</span>
<span class="nc" id="L69">		calculateAndCheckSize();</span>
<span class="nc" id="L70">		recognizeContent();</span>
<span class="nc" id="L71">		extractNamesFromPositions();</span>
<span class="nc" id="L72">		organizeFastElementsSearch();</span>
<span class="nc" id="L73">		recognizeGapsAtLines();</span>
<span class="nc" id="L74">	}</span>
	
	protected void calculateAndCheckSize()
	{
<span class="nc bnc" id="L78" title="All 2 branches missed.">		if( lines.length == 0 )</span>
<span class="nc" id="L79">			throw new IllegalArgumentException(&quot;The scheme has no lines.&quot;);</span>
<span class="nc" id="L80">		x1 = 0;</span>
<span class="nc" id="L81">		y1 = 0;</span>
<span class="nc" id="L82">		y2 = lines.length;</span>
<span class="nc" id="L83">		x2 = lines[0].length();</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">		for (int i=1; i&lt;y2; i++)</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">			if( lines[i].length() != x2 )</span>
<span class="nc" id="L86">				throw new IllegalArgumentException(</span>
						&quot;The strings are not of equal length.&quot;);
<span class="nc" id="L88">	}</span>
	
	
	/**
	 * Finds each element present on the scheme,
	 * identifies it with certain type,
	 * and places the element to the corresponding set
	 * in the field {@code positions}.
	 * 
	 * @throws 	IllegalArgumentException if the scheme contains improper symbols.
	 * 			&lt;p&gt;
	 * 			Note that after successful scheme initialization
	 * 			there is no need to determine its characters types using
	 * 			comparation with {@code CharTable.LETTERS}. One can just
	 * 			use comparation with dots, lines, and spaces instead.
	 */
	protected void recognizeContent()
	{
<span class="nc" id="L106">		positions = new Positions();</span>
		
		/* Find sequentially the upper-left corner
		 * of each element on the scheme,
		 * find another end of the element,
		 * identify the element,
		 * register it.
		 */
		
		//A non-trivial order of visiting cells of the scheme is possible.
<span class="nc" id="L116">		boolean[][] visited = new boolean[x2][y2];</span>
		
<span class="nc bnc" id="L118" title="All 2 branches missed.">		for (int y = y1; y &lt; y2; y++)</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">			for (int x = x1; x &lt; x2; x++) {</span>
<span class="nc bnc" id="L120" title="All 4 branches missed.">				if( visited[x][y] || charAt(x,y) == ' ' )  continue;</span>
<span class="nc" id="L121">				visited[x][y] = true;</span>
<span class="nc" id="L122">				trackElementStartingAt(x,y, visited);</span>
			}
<span class="nc" id="L124">	}</span>
	
	/**
	 * Recognizes the element containing the specified position
	 * (if such element exists).
	 */
	private void trackElementStartingAt(int x, int y, boolean[][] visited)
	{
<span class="nc" id="L132">		char c = charAt(x,y);</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">		if( c == '-' )</span>
<span class="nc" id="L134">			positions.hLines.add( trackHLineStartingAt(x,y,visited) );</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">		else if( c == '|' )</span>
<span class="nc" id="L136">			positions.vLines.add( trackVLineStartingAt(x,y,visited) );</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">		else if( isLetter(c) )</span>
<span class="nc" id="L138">			positions.components.add( trackComponentStartingAt(x,y,visited) );</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">		else if( c == '.' )</span>
<span class="nc" id="L140">			positions.gaps.add( trackGapStartingAt(x,y,visited) );</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">		else if( c == '+' ) {</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">			boolean startsHline = (firstNonPlusOnTheRightFrom(x,y) == '-');</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">			boolean startsVline = (firstNonPlusDownFrom(x,y) == '|');</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">			if( startsHline )</span>
<span class="nc" id="L145">				positions.hLines.add( trackHLineStartingAt(x,y,visited) );</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">			if( startsVline )</span>
<span class="nc" id="L147">				positions.vLines.add( trackVLineStartingAt(x,y,visited) );</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">			else if( !startsHline )</span>
<span class="nc" id="L149">				throw new IllegalArgumentException(</span>
						&quot;Unrecognizable construction found in the scheme&quot;
						+ &quot; under position (&quot; + x + &quot;,&quot; + y + &quot;)&quot;);
<span class="nc" id="L152">		} else throwWrongSymbolException(x,y,c);</span>
<span class="nc" id="L153">	}</span>
	
	private HWordPosition trackHLineStartingAt(
			int x, int y,
			boolean[][] visited )
	{
		//retain x and move x to the end of the line:
<span class="nc" id="L160">		int startX = x;</span>
		char c;
<span class="nc bnc" id="L162" title="All 2 branches missed.">		for (x = startX+1; x &lt; x2; x++) {</span>
<span class="nc" id="L163">			c = charAt(x,y);</span>
<span class="nc bnc" id="L164" title="All 4 branches missed.">			if( c == '-' || c == '+' )  //the line continues</span>
<span class="nc" id="L165">				visited[x][y] = true;</span>
<span class="nc bnc" id="L166" title="All 8 branches missed.">			else if( c==' ' || c=='|' || c=='.' || isLetter(c) )  //line end</span>
<span class="nc" id="L167">				return new HWordPosition(startX,x, y);</span>
<span class="nc" id="L168">			else throwWrongSymbolException(x,y,c);</span>
		}
<span class="nc" id="L170">		return new HWordPosition(startX,x, y);</span>
	}
	
	private VWordPosition trackVLineStartingAt(
			int x, int y,
			boolean[][] visited )
	{
<span class="nc" id="L177">		int startY = y;</span>
		//just in case check for pluses above:
<span class="nc bnc" id="L179" title="All 4 branches missed.">		for (; startY - 1 &gt;= y1 &amp;&amp; charAt(x, startY - 1) == '+'; startY--) ;</span>
		//retain y as startY and move y to the end of the line:
		char c;
<span class="nc bnc" id="L182" title="All 2 branches missed.">		for (y = startY+1; y &lt; y2; y++) {</span>
<span class="nc" id="L183">			c = charAt(x,y);</span>
<span class="nc bnc" id="L184" title="All 4 branches missed.">			if( c == '|' || c == '+' )  //the line continues</span>
<span class="nc" id="L185">				visited[x][y] = true;</span>
<span class="nc bnc" id="L186" title="All 8 branches missed.">			else if( c==' ' || c=='-' || c=='.' || isLetter(c) )  //line end</span>
<span class="nc" id="L187">				return new VWordPosition(x, startY,y);</span>
<span class="nc" id="L188">			else throwWrongSymbolException(x,y,c);</span>
		}
<span class="nc" id="L190">		return new VWordPosition(x, startY,y);</span>
	}
	
	private HWordPosition trackComponentStartingAt(
			int x, int y,
			boolean[][] visited )
	{
		//retain x as startX and move x to the end of the component:
<span class="nc" id="L198">		int startX = x;</span>
		char c;
<span class="nc bnc" id="L200" title="All 2 branches missed.">		for (x = startX+1; x &lt; x2; x++) {</span>
<span class="nc" id="L201">			c = charAt(x,y);</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">			if( isLetter(c) )  //the component continues</span>
<span class="nc" id="L203">				visited[x][y] = true;</span>
<span class="nc bnc" id="L204" title="All 4 branches missed.">			else if( c == ' ' || isSplitter(c) )  //component finished</span>
<span class="nc" id="L205">				return new HWordPosition(startX,x, y);</span>
<span class="nc" id="L206">			else throwWrongSymbolException(x,y,c);</span>
		}
<span class="nc" id="L208">		return new HWordPosition(startX,x, y);</span>
	}

	private HWordPosition trackGapStartingAt(
			int x, int y,
			boolean[][] visited )
	{
		//retain x as startX and move x to the end of the gap:
<span class="nc" id="L216">		int startX = x;</span>
		char c;
<span class="nc bnc" id="L218" title="All 2 branches missed.">		for (x = startX + 1; x &lt; x2; x++) {</span>
<span class="nc" id="L219">			c = charAt(x,y);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">			if( isWordChar(c) )  //the gap continues</span>
<span class="nc" id="L221">				visited[x][y] = true;</span>
<span class="nc bnc" id="L222" title="All 6 branches missed.">			else if( c == '-' || c == '+' || c == ' ' )  //gap finished</span>
<span class="nc" id="L223">				return new HWordPosition(startX,x, y);</span>
<span class="nc" id="L224">			else throwWrongSymbolException(x,y,c);</span>
		}
<span class="nc" id="L226">		return new HWordPosition(startX,x, y);</span>
	}
	
	private char firstNonPlusOnTheRightFrom(int x, int y)
	{
		char c;
<span class="nc bnc" id="L232" title="All 2 branches missed.">		for (; x &lt; x2; x++) {</span>
<span class="nc" id="L233">			c = charAt(x,y);</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">			if( c != '+' )  return c;</span>
		}
<span class="nc" id="L236">		return ' ';</span>
	}
	
	private char firstNonPlusDownFrom(int x, int y)
	{
		char c;
<span class="nc bnc" id="L242" title="All 2 branches missed.">		for (; y &lt; y2; y++) {</span>
<span class="nc" id="L243">			c = charAt(x,y);</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">			if( c != '+' )  return c;</span>
		}
<span class="nc" id="L246">		return ' ';</span>
	}
	
	private void throwWrongSymbolException(int x, int y, char c)
	{
<span class="nc" id="L251">		throw new IllegalArgumentException(</span>
				&quot;A wrong symbol \'&quot; + c + &quot;\' was found on the scheme&quot;
				+ &quot; under position (&quot; + x + &quot;,&quot; + y + &quot;)&quot;);
	}
	
	/**
	 * Initializes the sets {@code names.components} and {@code names.gaps}
	 * and the mapping {@code positionsToNames}
	 * using the positions of all these elements on the scheme,
	 * which are considered to be initialized earlier.
	 */
	protected void extractNamesFromPositions()
	{
<span class="nc" id="L264">		names = new Names();</span>
<span class="nc" id="L265">		positionsToNames = new HashMap&lt;HWordPosition, String&gt;();</span>
		
		String name;
		
<span class="nc bnc" id="L269" title="All 2 branches missed.">		for (HWordPosition wp: positions.components) {</span>
<span class="nc" id="L270">			name = textAt(wp);</span>
<span class="nc" id="L271">			registerComponentName(name);</span>
<span class="nc" id="L272">			positionsToNames.put(wp,name);</span>
<span class="nc" id="L273">		}</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">		for (HWordPosition wp : positions.gaps) {</span>
<span class="nc" id="L275">			name = textAt(wp);</span>
<span class="nc" id="L276">			registerGapName(name);</span>
<span class="nc" id="L277">			positionsToNames.put(wp,name);</span>
<span class="nc" id="L278">		}</span>
<span class="nc" id="L279">	}</span>
	
	private void registerComponentName(String name)
	{
<span class="nc bnc" id="L283" title="All 2 branches missed.">		if( !names.components.add( name ) )</span>
<span class="nc" id="L284">			throw new IllegalArgumentException(</span>
					&quot;cannot register the component name \&quot;&quot; + name + &quot;\&quot;&quot;);
<span class="nc" id="L286">	}</span>
	private void registerGapName(String name)
	{
<span class="nc" id="L289">		names.gaps.add( name );</span>
<span class="nc" id="L290">	}</span>
	
	/**
	 * Initializes the variables
	 * {@code hWordsAtLines} and {@code vWordsAtLines}
	 * which are used in the searching methods
	 * {@code horizontalElementAt()} and {@code verticalLineAt()}.
	 */
	protected void organizeFastElementsSearch()
	{
<span class="nc" id="L300">		hWordsAtYs =</span>
			new HashMap&lt;Integer, HashSet&lt;HWordPosition&gt;&gt;(lines.length);
<span class="nc bnc" id="L302" title="All 2 branches missed.">		for (int i = 0; i &lt; lines.length; i++)</span>
<span class="nc" id="L303">			hWordsAtYs.put(i, new HashSet&lt;HWordPosition&gt;());</span>
		
<span class="nc" id="L305">		distributeHWordsByLines(positions.components);</span>
<span class="nc" id="L306">		distributeHWordsByLines(positions.gaps);</span>
<span class="nc" id="L307">		distributeHWordsByLines(positions.hLines);</span>
		
<span class="nc" id="L309">		vWordsAtXs = new HashMap&lt;Integer, HashSet&lt;VWordPosition&gt;&gt;();</span>
		
<span class="nc" id="L311">		distributeVWordsByLines(positions.vLines);</span>
<span class="nc" id="L312">	}</span>
	
	/**
	 * Puts the references at each word position in the specified
	 * set {@code from} into the corresponding values of the map
	 * {@code hWordsAtLines}.
	 * 
	 * @param from	the set of positions to be distributed.
	 */
	private void distributeHWordsByLines(Set&lt;HWordPosition&gt; from)
	{
<span class="nc bnc" id="L323" title="All 2 branches missed.">		for (HWordPosition wp : from) {</span>
<span class="nc" id="L324">			hWordsAtYs.get( new Integer(wp.y) ).add(wp);</span>
<span class="nc" id="L325">		}</span>
<span class="nc" id="L326">	}</span>
	/**
	 * Puts the references at each word position in the specified
	 * set {@code from} into the corresponding values of the map
	 * {@code vWordsAtLines}.
	 * 
	 * @param from	the set of positions to be distributed.
	 */
	private void distributeVWordsByLines(Set&lt;VWordPosition&gt; from)
	{
		Integer key;
<span class="nc bnc" id="L337" title="All 2 branches missed.">		for (VWordPosition wp : from) {</span>
<span class="nc" id="L338">			key = new Integer(wp.x);</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">			if( ! vWordsAtXs.containsKey(key) )</span>
<span class="nc" id="L340">				vWordsAtXs.put(key, new HashSet&lt;VWordPosition&gt;());</span>
<span class="nc" id="L341">			vWordsAtXs.get( key ).add(wp);</span>
<span class="nc" id="L342">		}</span>
<span class="nc" id="L343">	}</span>
	
	/**
	 * Investigates, which gaps must be considered as belonging to lines;
	 * then modifies the corresponding lines' positions.
	 * &lt;p&gt;
	 * This method initializes the field {@code gapsAtLines}
	 * and influences the fields
	 * {@code positions.hLines}, {@code positions.vLines}
	 * {@code hWordsAtYs}, and {@code vWordsAtXs}.
	 */
	protected void recognizeGapsAtLines()
	{
<span class="nc" id="L356">		gapsAtLines = new HashMap&lt;WordPosition, HWordPosition&gt;();</span>
		
<span class="nc" id="L358">		recognizeHorizontalGapsAtLines();</span>
<span class="nc" id="L359">		recognizeVerticalGapsAtLines();</span>
<span class="nc" id="L360">	}</span>
	
	protected void recognizeHorizontalGapsAtLines()
	{
<span class="nc" id="L364">		HashSet&lt;HWordPosition&gt; hLinesToRemove = new HashSet&lt;HWordPosition&gt;();</span>
<span class="nc" id="L365">		HashSet&lt;HWordPosition&gt; hLinesToAdd = new HashSet&lt;HWordPosition&gt;();</span>
<span class="nc" id="L366">		HWordPosition gapAtLine = null;</span>
		//Searching:
		
<span class="nc" id="L369">		Iterator&lt;HWordPosition&gt; i = positions.hLines.iterator();</span>
		HWordPosition hLine;
<span class="nc bnc" id="L371" title="All 2 branches missed.">		while( i.hasNext() ) {</span>
<span class="nc" id="L372">			hLine = i.next();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">			if( hLinesToRemove.contains(hLine) ) //already visited.</span>
<span class="nc" id="L374">				continue;</span>
			
<span class="nc" id="L376">			int newX1 = hLine.x1;</span>
<span class="nc" id="L377">			HWordPosition leftGap = gapOnTheLeftFrom(hLine);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">			if( leftGap != null ) {</span>
<span class="nc" id="L379">				newX1 = leftGap.x1;</span>
<span class="nc" id="L380">				gapAtLine = leftGap;</span>
<span class="nc" id="L381">				hLinesToRemove.add(hLine); //the current line will be changed.</span>
				
<span class="nc" id="L383">				HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">				if( leftLine != null &amp;&amp;</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">						positions.hLines.contains(leftLine) &amp;&amp;</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">						! hLinesToRemove.contains(leftLine) ) {</span>
<span class="nc" id="L387">					newX1 = leftLine.x1;</span>
<span class="nc" id="L388">					hLinesToRemove.add(leftLine); //the line will be changed.</span>
					
<span class="nc bnc" id="L390" title="All 2 branches missed.">					if( gapOnTheLeftFrom(leftLine) != null )</span>
<span class="nc" id="L391">						throwMultipleGapsAtYException(hLine.y);</span>
				}
			}
			
<span class="nc" id="L395">			int newX2 = hLine.x2;</span>
<span class="nc" id="L396">			HWordPosition rightGap = gapOnTheRightFrom(hLine);</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">			if( rightGap != null ) {</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">				if( leftGap != null ) //this is not the first gap.</span>
<span class="nc" id="L399">					throwMultipleGapsAtYException(hLine.y);</span>
<span class="nc" id="L400">				newX2 = rightGap.x2;</span>
<span class="nc" id="L401">				gapAtLine = rightGap;</span>
<span class="nc" id="L402">				hLinesToRemove.add(hLine); //the current line will be changed.</span>
				
<span class="nc" id="L404">				HWordPosition rightLine = hLineOnTheRightFrom(rightGap);</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">				if( rightLine != null &amp;&amp;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">						positions.hLines.contains(rightLine) &amp;&amp;</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">						! hLinesToRemove.contains(rightLine) ) {</span>
<span class="nc" id="L408">					newX2 = rightLine.x2;</span>
<span class="nc" id="L409">					hLinesToRemove.add(rightLine); //the line will be changed.</span>
					
<span class="nc bnc" id="L411" title="All 2 branches missed.">					if( gapOnTheRightFrom(rightLine) != null )</span>
<span class="nc" id="L412">						throwMultipleGapsAtYException(hLine.y);</span>
				}
			}
			
<span class="nc bnc" id="L416" title="All 4 branches missed.">			if( newX1 != hLine.x1 || newX2 != hLine.x2 ) {</span>
				HWordPosition
<span class="nc" id="L418">					newLine = new HWordPosition(newX1,newX2,hLine.y);</span>
<span class="nc" id="L419">				hLinesToAdd.add(newLine);</span>
<span class="nc" id="L420">				gapsAtLines.put(newLine,gapAtLine);</span>
			}
<span class="nc" id="L422">		}</span>
		
		//Applying the changes:
		
<span class="nc bnc" id="L426" title="All 2 branches missed.">		for (HWordPosition line : hLinesToRemove) {</span>
<span class="nc" id="L427">			positions.hLines.remove(line);</span>
<span class="nc" id="L428">			hWordsAtYs.get(line.y).remove(line);</span>
<span class="nc" id="L429">		}</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">		for (HWordPosition line : hLinesToAdd) {</span>
<span class="nc" id="L431">			positions.hLines.add(line);</span>
<span class="nc" id="L432">			hWordsAtYs.get(line.y).add(line);</span>
<span class="nc" id="L433">		}</span>
<span class="nc" id="L434">	}</span>
	
	private HWordPosition gapOnTheLeftFrom(HWordPosition hLine)
	{
<span class="nc" id="L438">		CharPosition leftPos = hLine.getStart();</span>
<span class="nc" id="L439">		return gapAt(leftPos.x-1,leftPos.y);</span>
	}
	private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine)
	{
<span class="nc" id="L443">		CharPosition leftPos = hLine.getStart();</span>
<span class="nc" id="L444">		return anyHElementAt(leftPos.x-1,leftPos.y);</span>
	}
	private HWordPosition gapOnTheRightFrom(HWordPosition hLine)
	{
<span class="nc" id="L448">		return  gapAt( hLine.getEnd() );</span>
	}
	private HWordPosition hLineOnTheRightFrom(HWordPosition hLine)
	{
<span class="nc" id="L452">		CharPosition rightPos = hLine.getEnd();</span>
<span class="nc" id="L453">		return anyHElementAt(rightPos.x,rightPos.y);</span>
	}
	
	private void throwMultipleGapsAtYException(int y)
	{
<span class="nc" id="L458">		throw new IllegalArgumentException(</span>
				&quot;Multiple gaps on a horisontal line&quot; +
				&quot; at y=&quot; + y + &quot; found.&quot;);
	}
	
	protected void recognizeVerticalGapsAtLines()
	{
<span class="nc" id="L465">		HashSet&lt;VWordPosition&gt; vLinesToRemove = new HashSet&lt;VWordPosition&gt;();</span>
<span class="nc" id="L466">		HashSet&lt;VWordPosition&gt; vLinesToAdd = new HashSet&lt;VWordPosition&gt;();</span>
<span class="nc" id="L467">		HWordPosition gapAtLine = null;</span>
		//Searching:
		
<span class="nc" id="L470">		Iterator&lt;VWordPosition&gt; i = positions.vLines.iterator();</span>
		VWordPosition vLine;
<span class="nc bnc" id="L472" title="All 2 branches missed.">		while( i.hasNext() ) {</span>
<span class="nc" id="L473">			vLine = i.next();</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">			if( vLinesToRemove.contains(vLine) ) //already visited.</span>
<span class="nc" id="L475">				continue;</span>
			
<span class="nc" id="L477">			int newY1 = vLine.y1;</span>
<span class="nc" id="L478">			HWordPosition topGap = gapAbove(vLine);</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">			if( topGap != null ) {</span>
<span class="nc" id="L480">				newY1 = topGap.y;</span>
<span class="nc" id="L481">				gapAtLine = topGap;</span>
<span class="nc" id="L482">				vLinesToRemove.add(vLine); //the current line will be changed.</span>
				
<span class="nc" id="L484">				VWordPosition topLine = vLineAbove(vLine);</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">				if( topLine != null &amp;&amp;</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">						positions.vLines.contains(topLine) &amp;&amp;</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">						! vLinesToRemove.contains(topLine) ) {</span>
<span class="nc" id="L488">					newY1 = topLine.y1;</span>
<span class="nc" id="L489">					vLinesToRemove.add(topLine); //the line will be changed.</span>
					
<span class="nc bnc" id="L491" title="All 2 branches missed.">					if( gapAbove(topLine) != null )</span>
<span class="nc" id="L492">						throwMultipleGapsAtXException(vLine.x);</span>
				}
			}
			
<span class="nc" id="L496">			int newY2 = vLine.y2;</span>
<span class="nc" id="L497">			HWordPosition bottomGap = gapBelow(vLine);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">			if( bottomGap != null ) {</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">				if( topGap != null ) //this is not the first gap.</span>
<span class="nc" id="L500">					throwMultipleGapsAtXException(vLine.x);</span>
<span class="nc" id="L501">				newY2 = bottomGap.y + 1;</span>
<span class="nc" id="L502">				gapAtLine = bottomGap;</span>
<span class="nc" id="L503">				vLinesToRemove.add(vLine); //the current line will be changed.</span>
				
<span class="nc" id="L505">				VWordPosition bottomLine = vLineBelow(vLine);</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">				if( bottomLine != null &amp;&amp;</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">						positions.vLines.contains(bottomLine) &amp;&amp;</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">						! vLinesToRemove.contains(bottomLine) ) {</span>
<span class="nc" id="L509">					newY2 = bottomLine.y2;</span>
<span class="nc" id="L510">					vLinesToRemove.add(bottomLine); //the line will be changed.</span>
					
<span class="nc bnc" id="L512" title="All 2 branches missed.">					if( gapBelow(bottomLine) != null )</span>
<span class="nc" id="L513">						throwMultipleGapsAtXException(vLine.x);</span>
				}
			}
			
<span class="nc bnc" id="L517" title="All 4 branches missed.">			if( newY1 != vLine.y1 || newY2 != vLine.y2 ) {</span>
				VWordPosition
<span class="nc" id="L519">					newLine = new VWordPosition(vLine.x,newY1,newY2);</span>
<span class="nc" id="L520">				vLinesToAdd.add(newLine);</span>
<span class="nc" id="L521">				gapsAtLines.put(newLine,gapAtLine);</span>
			}
<span class="nc" id="L523">		}</span>
		
		//Applying the changes:
		
		//removing:
<span class="nc bnc" id="L528" title="All 2 branches missed.">		for (VWordPosition line : vLinesToRemove) {</span>
<span class="nc" id="L529">			positions.vLines.remove(line);</span>
<span class="nc" id="L530">			vWordsAtXs.get(line.x).remove(line);</span>
<span class="nc" id="L531">		}</span>
		//adding:
<span class="nc bnc" id="L533" title="All 2 branches missed.">		for (VWordPosition line : vLinesToAdd) {</span>
<span class="nc" id="L534">			positions.vLines.add(line);</span>
<span class="nc" id="L535">			vWordsAtXs.get(line.x).add(line);</span>
<span class="nc" id="L536">		}</span>
<span class="nc" id="L537">	}</span>
	
	private HWordPosition gapAbove(VWordPosition vLine)
	{
<span class="nc" id="L541">		CharPosition topPos = vLine.getStart();</span>
<span class="nc" id="L542">		return gapAt(topPos.x,topPos.y-1);</span>
	}
	/* 
	 * Returns the vertical line lying above the specified line
	 * and the gap lying above it.
	 */
	private VWordPosition vLineAbove(VWordPosition vLine)
	{
<span class="nc" id="L550">		CharPosition topPos = vLine.getStart();</span>
<span class="nc" id="L551">		return verticalLineAt(topPos.x,topPos.y-2);</span>
	}
	private HWordPosition gapBelow(VWordPosition vLine)
	{
<span class="nc" id="L555">		return  gapAt( vLine.getEnd() );</span>
	}
	/* 
	 * Returns the vertical line lying below the specified line
	 * and the gap lying below it.
	 */
	private VWordPosition vLineBelow(VWordPosition vLine)
	{
<span class="nc" id="L563">		CharPosition bottomPos = vLine.getEnd();</span>
<span class="nc" id="L564">		return verticalLineAt(bottomPos.x,bottomPos.y+1);</span>
	}
	
	private void throwMultipleGapsAtXException(int x)
	{
<span class="nc" id="L569">		throw new IllegalArgumentException(</span>
				&quot;Multiple gaps on a vertical line&quot; +
				&quot; at x=&quot; + x + &quot; found.&quot;);
	}
	
	/**
	 * Verifies whether the scheme contains the specified component name.
	 */
	public boolean containsComponentName(String name)
	{
<span class="nc" id="L579">		return names.components.contains(name);</span>
	}
	
	/**
	 * Verifies whether the scheme contains the specified gap denotation.
	 */
	public boolean containsGapName(String name)
	{
<span class="nc" id="L587">		return names.gaps.contains(name);</span>
	}
	
	/**
	 * Returns the symbol lying on the scheme under the specified position.
	 */
	public char charAt(int x, int y)
	{
		try {
<span class="nc" id="L596">			return lines[y].charAt(x);</span>
<span class="nc" id="L597">		} catch (RuntimeException re) {</span>
<span class="nc" id="L598">			throw new IllegalArgumentException(&quot;char position out of table&quot;);</span>
		}
	}
	
	/**
	 * Returns the text lying on the scheme
	 * specified by the given word position coordinates.
	 */
	public String textAt(int x1, int x2, int y)
	{
		try {
<span class="nc" id="L609">			return lines[y].substring(x1, x2);</span>
<span class="nc" id="L610">		} catch (RuntimeException re) {</span>
<span class="nc" id="L611">			throw new IllegalArgumentException(&quot;Improper subline coodinates.&quot;);</span>
		}
	}
	
	/**
	 * Returns an unmodifiable set of all positions
	 * of horizontal lines on the scheme.
	 */
	public Set&lt;HWordPosition&gt; getHLinesPositions()
	{
<span class="nc" id="L621">		return Collections.unmodifiableSet( positions.hLines );</span>
	}
	
	/**
	 * Returns an unmodifiable set of all positions
	 * of vertical lines on the scheme.
	 */
	public Set&lt;VWordPosition&gt; getVLinesPositions()
	{
<span class="nc" id="L630">		return Collections.unmodifiableSet( positions.vLines );</span>
	}
	
	/**
	 * Finds and returns (the position of) a horizontal element
	 * which contains the specified point.
	 * If such element does not exist, returns null.
	 * &lt;p&gt;
	 * Note that some points may lie at horizontal lines
	 * and at gaps belonging to that lines simultaneously.
	 * In such cases the method returns any of the two elements.
	 */
	public HWordPosition anyHElementAt(int x, int y)
	{
<span class="nc bnc" id="L644" title="All 2 branches missed.">		if( ! contains(x,y) )</span>
<span class="nc" id="L645">			return null;</span>
<span class="nc" id="L646">		char c = charAt(x,y);</span>
<span class="nc bnc" id="L647" title="All 4 branches missed.">		if( c == ' '  || c == '|' )</span>
<span class="nc" id="L648">			return null;</span>
		
<span class="nc" id="L650">		Set&lt;HWordPosition&gt; h =  hWordsAtYs.get(new Integer(y));</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">		if( h != null )</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">			for (HWordPosition hwp : h)</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">				if( hwp.contains(x,y) )</span>
<span class="nc" id="L654">					return hwp;</span>
		
<span class="nc" id="L656">		return null;</span>
	}
	public HWordPosition anyHElementAt(CharPosition pos) {
<span class="nc" id="L659">		return anyHElementAt(pos.x,pos.y);</span>
	}
	
	/**
	 * Finds and returns (the position of) the gap
	 * containing the specified point
	 * or null if such gap does not exist on the scheme.
	 */
	public HWordPosition gapAt(int x, int y)
	{
<span class="nc bnc" id="L669" title="All 2 branches missed.">		if( ! contains(x,y) )</span>
<span class="nc" id="L670">			return null;</span>
<span class="nc" id="L671">		char c = charAt(x,y);</span>
<span class="nc bnc" id="L672" title="All 4 branches missed.">		if( c == ' '  || c == '|' )</span>
<span class="nc" id="L673">			return null;</span>
		
<span class="nc" id="L675">		Set&lt;HWordPosition&gt; h =  hWordsAtYs.get(new Integer(y));</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">		if( h != null )</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">			for (HWordPosition hwp : h)</span>
<span class="nc bnc" id="L678" title="All 4 branches missed.">				if( hwp.contains(x,y) &amp;&amp; positions.gaps.contains(hwp) )</span>
<span class="nc" id="L679">					return hwp;</span>
		
<span class="nc" id="L681">		return null;</span>
	}
	public HWordPosition gapAt(CharPosition pos) {
<span class="nc" id="L684">		return gapAt(pos.x,pos.y);</span>
	}
	
	/**
	 * Finds and returns (the position of) the vertical line
	 * which contains the specified point
	 * or null if such line does not exist.
	 */
	public VWordPosition verticalLineAt(int x, int y)
	{
<span class="nc bnc" id="L694" title="All 2 branches missed.">		if( ! contains(x,y) )</span>
<span class="nc" id="L695">			return null;</span>
<span class="nc" id="L696">		char c = charAt(x,y);</span>
<span class="nc bnc" id="L697" title="All 4 branches missed.">		if( c == ' '  || c == '-' )</span>
<span class="nc" id="L698">			return null;</span>
		
<span class="nc" id="L700">		Set&lt;VWordPosition&gt; v =  vWordsAtXs.get(new Integer(x));</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">		if( v != null )</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">			for (VWordPosition vwp : v)</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">				if( vwp.contains(x,y) )</span>
<span class="nc" id="L704">					return vwp;</span>
		
<span class="nc" id="L706">		return null;</span>
	}
	public VWordPosition verticalLineAt(CharPosition pos) {
<span class="nc" id="L709">		return verticalLineAt(pos.x,pos.y);</span>
	}
	
	/**
	 * Returns the gap belonging to the specified horizontal or vertical line
	 * or null if such gap does not exist.
	 */
	public HWordPosition gapAtLine(WordPosition line)
	{
<span class="nc bnc" id="L718" title="All 2 branches missed.">		if( gapsAtLines == null )  return null;</span>
<span class="nc" id="L719">		return gapsAtLines.get(line);</span>
	}
	
	public String toString()
	{
<span class="nc" id="L724">		StringBuilder result =</span>
<span class="nc" id="L725">			new StringBuilder( (lines[0].length() + 1) * lines.length );</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">		for (int i = 0; i &lt; lines.length; i++)</span>
<span class="nc" id="L727">			result.append( lines[i] + '\n' );</span>
<span class="nc" id="L728">		return result.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>