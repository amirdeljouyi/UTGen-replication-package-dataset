<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileFollower.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">41_follow</a> &gt; <a href="index.source.html" class="el_package">ghm.follow</a> &gt; <span class="el_source">FileFollower.java</span></div><h1>FileFollower.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)
 * 
 * This file is part of Follow (http://follow.sf.net).
 * 
 * Follow is free software; you can redistribute it and/or modify it under the
 * terms of version 2 of the GNU General Public License as published by the Free
 * Software Foundation.
 * 
 * Follow is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
 * Suite 330, Boston, MA 02111-1307 USA
 */

package ghm.follow;

import ghm.follow.io.OutputDestination;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Instances of this class 'follow' a particular text file, assmebling that
 * file's characters into Strings and sending them to instances of
 * {@link OutputDestination}. The name and behavior of this class are inspired
 * by the '-f' (follow) flag of the UNIX command 'tail'.
 * 
 * @see OutputDestination
 * @author &lt;a href=&quot;mailto:greghmerrill@yahoo.com&quot;&gt;Greg Merrill&lt;/a&gt;
 */
public class FileFollower
{

	/**
	 * Constructs a new FileFollower; invoking this constructor does
	 * &lt;em&gt;not&lt;/em&gt; cause the new object to begin following the supplied file.
	 * In order to begin following, one must call {@link #start()}.
	 * 
	 * @param file
	 *            file to be followed
	 * @param bufferSize
	 *            number of chars to be read each time the file is accessed
	 * @param latency
	 *            each time a FileFollower's running thread encounters the end
	 *            of the file in its stream, it will rest for this many
	 *            milliseconds before checking to see if there are any more
	 *            bytes in the file
	 * @param initialOutputDestinations
	 *            an initial array of OutputDestinations which will be used when
	 *            printing the contents of the file (this array may be
	 *            &lt;tt&gt;null&lt;/tt&gt;)
	 */
	public FileFollower(File file, int bufferSize, int latency,
	        OutputDestination[] initialOutputDestinations)
<span class="nc" id="L66">	{</span>
<span class="nc" id="L67">		this.file = file;</span>
<span class="nc" id="L68">		this.bufferSize = bufferSize;</span>
<span class="nc" id="L69">		this.latency = latency;</span>

<span class="nc bnc" id="L71" title="All 2 branches missed.">		int initOutputDestsSize = (initialOutputDestinations != null) ? initialOutputDestinations.length</span>
		        : 0;
<span class="nc" id="L73">		outputDestinations = new ArrayList&lt;OutputDestination&gt;(initOutputDestsSize);</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">		for (int i = 0; i &lt; initOutputDestsSize; i++)</span>
		{
<span class="nc" id="L76">			outputDestinations.add(initialOutputDestinations[i]);</span>
		}
<span class="nc" id="L78">	}</span>

	/**
	 * Identical to {@link #FileFollower(File, int, int, OutputDestination[])},
	 * except that a default buffer size (32,768 characters) and latency (1000
	 * milliseconds) are used.
	 * 
	 * @see #FileFollower(File, int, int, OutputDestination[])
	 */
	public FileFollower(File file, OutputDestination[] initialOutputDestinations)
	{
		// Initial buffer size pilfered from org.gjt.sp.jedit.Buffer. I'm not
		// sure whether this is a truly optimal buffer size.
<span class="nc" id="L91">		this(file, 32768, // Don't change without updating docs!</span>
		        1000, // Don't change without updating docs!
		        initialOutputDestinations);
<span class="nc" id="L94">	}</span>

	/**
	 * Cause this FileFollower to spawn a thread which will follow the file
	 * supplied in the constructor and send its contents to all of the
	 * FileFollower's OutputDestinations.&lt;br&gt;
	 * &lt;br&gt;
	 * If this FileFollower is running but paused, this method equates to
	 * calling unpause().
	 */
	public synchronized void start()
	{
<span class="nc bnc" id="L106" title="All 4 branches missed.">		if (continueRunning &amp;&amp; paused)</span>
		{
<span class="nc" id="L108">			unpause();</span>
		}
		else
		{
<span class="nc" id="L112">			continueRunning = true;</span>
<span class="nc" id="L113">			paused = false;</span>
<span class="nc" id="L114">			runnerThread = new Thread(new Runner(), getFollowedFile().getName());</span>
<span class="nc" id="L115">			runnerThread.start();</span>
		}
<span class="nc" id="L117">	}</span>

	public synchronized void pause()
	{
<span class="nc" id="L121">		paused = true;</span>
<span class="nc" id="L122">	}</span>

	public synchronized void unpause()
	{
<span class="nc" id="L126">		paused = false;</span>
<span class="nc" id="L127">	}</span>

	public synchronized void restart()
	{
<span class="nc" id="L131">		needsRestart = true;</span>
<span class="nc" id="L132">		runnerThread.interrupt();</span>
<span class="nc" id="L133">	}</span>

	/**
	 * Cause this FileFollower to stop following the file supplied in the
	 * constructor after it flushes the characters it's currently reading to all
	 * its OutputDestinations.
	 */
	public synchronized void stop()
	{
<span class="nc" id="L142">		continueRunning = false;</span>
<span class="nc" id="L143">		runnerThread.interrupt();</span>
<span class="nc" id="L144">	}</span>

	/**
	 * Like {@link #stop()}, but this method will not exit until the thread
	 * which is following the file has finished executing (i.e., stop
	 * synchronously).
	 */
	public synchronized void stopAndWait() throws InterruptedException
	{
<span class="nc" id="L153">		stop();</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">		while (runnerThread.isAlive())</span>
		{
<span class="nc" id="L156">			Thread.yield();</span>
		}
<span class="nc" id="L158">	}</span>

	/**
	 * Send the supplied string to all OutputDestinations
	 * 
	 * @param s
	 */
	private synchronized void print(String s)
	{
<span class="nc bnc" id="L167" title="All 2 branches missed.">		for (OutputDestination out : outputDestinations)</span>
		{
<span class="nc" id="L169">			out.print(s);</span>
<span class="nc" id="L170">		}</span>
<span class="nc" id="L171">	}</span>

	/**
	 * Clear all OutputDestinations
	 */
	private synchronized void clear()
	{
<span class="nc bnc" id="L178" title="All 2 branches missed.">		for (OutputDestination out : outputDestinations)</span>
		{
<span class="nc" id="L180">			out.clear();</span>
<span class="nc" id="L181">		}</span>
<span class="nc" id="L182">	}</span>

	/**
	 * Add another OutputDestination to which the followed file's contents
	 * should be printed.
	 * 
	 * @param outputDestination
	 *            OutputDestination to be added
	 */
	public boolean addOutputDestination(OutputDestination outputDestination)
	{
<span class="nc" id="L193">		return outputDestinations.add(outputDestination);</span>
	}

	/**
	 * Remove the supplied OutputDestination from the list of OutputDestinations
	 * to which the followed file's contents should be printed.
	 * 
	 * @param outputDestination
	 *            OutputDestination to be removed
	 */
	public boolean removeOutputDestination(OutputDestination outputDestination)
	{
<span class="nc" id="L205">		return outputDestinations.remove(outputDestination);</span>
	}

	/**
	 * Returns the List which maintains all OutputDestinations for this
	 * FileFollower.
	 * 
	 * @return contains all OutputDestinations for this FileFollower
	 */
	public List&lt;OutputDestination&gt; getOutputDestinations()
	{
<span class="nc" id="L216">		return outputDestinations;</span>
	}

	/**
	 * Returns the file which is being followed by this FileFollower
	 * 
	 * @return file being followed
	 */
	public File getFollowedFile()
	{
<span class="nc" id="L226">		return file;</span>
	}

	/**
	 * Returns the following state of a file
	 * 
	 * @return true if being followed, false if not being followed
	 */
	public boolean isBeingFollowed()
	{
<span class="nc" id="L236">		return continueRunning;</span>
	}

	/**
	 * Returns the pause state of the follower.
	 * 
	 * @return true if paused, false otherwise
	 */
	public boolean isPaused()
	{
<span class="nc" id="L246">		return paused;</span>
	}

	/**
	 * Returns the size of the character buffer used to read characters from the
	 * followed file. Each time the file is accessed, this buffer is filled.
	 * 
	 * @return size of the character buffer
	 */
	public int getBufferSize()
	{
<span class="nc" id="L257">		return bufferSize;</span>
	}

	/**
	 * Sets the size of the character buffer used to read characters from the
	 * followed file. Increasing buffer size will improve efficiency but
	 * increase the amount of memory used by the FileFollower.&lt;br&gt;
	 * &lt;em&gt;NOTE:&lt;/em&gt; Setting this value will &lt;em&gt;not&lt;/em&gt; cause a running
	 * FileFollower to immediately begin reading characters into a buffer of the
	 * newly specified size. You must stop &amp; restart the FileFollower in order
	 * for changes to take effect.
	 * 
	 * @param bufferSize
	 *            size of the character buffer
	 */
	public void setBufferSize(int bufferSize)
	{
<span class="nc" id="L274">		this.bufferSize = bufferSize;</span>
<span class="nc" id="L275">	}</span>

	/**
	 * Returns the time (in milliseconds) which a FileFollower spends sleeping
	 * each time it encounters the end of the followed file.
	 * 
	 * @return latency, in milliseconds
	 */
	public int getLatency()
	{
<span class="nc" id="L285">		return latency;</span>
	}

	/**
	 * Sets the time (in milliseconds) which a FileFollower spends sleeping each
	 * time it encounters the end of the followed file. Note that extremely low
	 * latency values may cause thrashing between the FileFollower's running
	 * thread and other threads in an application. A change in this value will
	 * be reflected the next time the FileFollower's running thread sleeps.
	 * 
	 * @param latency
	 *            latency, in milliseconds
	 */
	public void setLatency(int latency)
	{
<span class="nc" id="L300">		this.latency = latency;</span>
<span class="nc" id="L301">	}</span>

	protected int bufferSize;

	protected int latency;

	protected File file;

	protected List&lt;OutputDestination&gt; outputDestinations;

	protected boolean continueRunning;

	protected boolean needsRestart;

	protected Thread runnerThread;

	protected boolean paused;

	/**
	 * Instances of this class are used to run a thread which follows a
	 * FileFollower's file and sends prints its contents to OutputDestinations.
	 * This class should only handle the gathering of data from the followed
	 * file. Actually writing to the output destinations is handled by the outer
	 * class (FileFollower).
	 */
<span class="nc" id="L326">	class Runner implements Runnable</span>
	{
<span class="nc" id="L328">		private Logger log = Logger.getLogger(Runner.class.getName());</span>

		public void run()
		{
<span class="nc" id="L332">			log.finer(&quot;entering FileFollower.run()&quot;);</span>

<span class="nc bnc" id="L334" title="All 2 branches missed.">			while (continueRunning)</span>
			{
<span class="nc" id="L336">				runAction();</span>
			}

<span class="nc" id="L339">			log.finer(&quot;exiting FileFollower.run()&quot;);</span>
<span class="nc" id="L340">		}</span>

		protected void runAction()
		{
			try
			{
<span class="nc" id="L346">				clear();</span>
<span class="nc" id="L347">				long fileSize = file.length();</span>
<span class="nc" id="L348">				byte[] byteArray = new byte[bufferSize];</span>
				int numBytesRead;
<span class="nc" id="L350">				long lastActivityTime = file.lastModified();</span>

				// create some stream readers to handle the file
<span class="nc" id="L353">				FileInputStream fis = new FileInputStream(file);</span>
<span class="nc" id="L354">				BufferedInputStream bis = new BufferedInputStream(fis);</span>

				// start at the beginning of the file
<span class="nc" id="L357">				long startingPoint = 0;</span>

				// if the file size is bigger than the buffer size, skip to the
				// end of the file if not performing a restart
<span class="nc bnc" id="L361" title="All 2 branches missed.">				if (fileSize &gt; bufferSize)</span>
				{
<span class="nc" id="L363">					startingPoint = fileSize - bufferSize;</span>
				}
				// reset the restart flag
<span class="nc" id="L366">				needsRestart = false;</span>

<span class="nc" id="L368">				log.finer(&quot;Starting point: &quot; + startingPoint + &quot;; Last activity: &quot;</span>
				        + lastActivityTime);

<span class="nc" id="L371">				bis.skip(startingPoint);</span>

<span class="nc bnc" id="L373" title="All 4 branches missed.">				while (continueRunning &amp;&amp; !needsRestart)</span>
				{
<span class="nc bnc" id="L375" title="All 2 branches missed.">					if (!paused)</span>
					{
<span class="nc" id="L377">						lastActivityTime = System.currentTimeMillis();</span>

<span class="nc" id="L379">						numBytesRead = bis.read(byteArray, 0, byteArray.length);</span>

<span class="nc bnc" id="L381" title="All 2 branches missed.">						boolean dataWasFound = (numBytesRead &gt; 0);</span>

<span class="nc" id="L383">						log</span>
<span class="nc" id="L384">						        .finer(&quot;Bytes read: &quot; + numBytesRead + &quot;; dataWasFound: &quot;</span>
						                + dataWasFound);

						// if data was found, print it and log activity time
<span class="nc bnc" id="L388" title="All 2 branches missed.">						if (dataWasFound)</span>
						{
<span class="nc" id="L390">							String output = new String(byteArray, 0, numBytesRead);</span>

							// print the output to the listeners
<span class="nc" id="L393">							print(output);</span>
<span class="nc" id="L394">						}</span>
						// no data found so check the file and restart if needed
						else
						{
							// check if the file handle has become stale (file
							// was modified, but no data was read).
<span class="nc" id="L400">							boolean fileExists = file.exists();</span>
							// removed check for 0 length because a file could
							// change by being cleared out
							// &amp;&amp; (file_.length() &gt; 0);
<span class="nc bnc" id="L404" title="All 2 branches missed.">							boolean fileHasChanged = file.lastModified() &gt; lastActivityTime;</span>

<span class="nc bnc" id="L406" title="All 4 branches missed.">							if (fileExists &amp;&amp; fileHasChanged)</span>
							{
<span class="nc" id="L408">								log.finer(&quot;Needs restart [fileExists=&quot; + fileExists</span>
								        + &quot;; fileHasChanged=&quot; + fileHasChanged + &quot;]&quot;);
<span class="nc" id="L410">								needsRestart = true;</span>
							}
						}

<span class="nc bnc" id="L414" title="All 2 branches missed.">						boolean allDataRead = (numBytesRead &lt; byteArray.length);</span>

<span class="nc bnc" id="L416" title="All 4 branches missed.">						if (allDataRead &amp;&amp; !needsRestart)</span>
						{
<span class="nc" id="L418">							log.finer(&quot;Sleeping for &quot; + latency + &quot;ms [allDataRead:&quot; + allDataRead</span>
							        + &quot;; needsRestart:&quot; + needsRestart + &quot;]&quot;);
<span class="nc" id="L420">							sleep();</span>
						}
<span class="nc" id="L422">					}</span>
					else
					{
<span class="nc" id="L425">						log.finer(&quot;Runner paused.&quot;);</span>
<span class="nc" id="L426">						sleep();</span>
					}
				}
<span class="nc" id="L429">				log.finer(&quot;exiting Runner.runAction [continueRunning=&quot; + continueRunning</span>
				        + &quot;; needsRestart=&quot; + needsRestart + &quot;]&quot;);
<span class="nc" id="L431">				bis.close();</span>
<span class="nc" id="L432">				fis.close();</span>
			}
<span class="nc" id="L434">			catch (IOException e)</span>
			{
<span class="nc" id="L436">				log.log(Level.SEVERE, &quot;IOException while following file&quot;, e);</span>
<span class="nc" id="L437">			}</span>
<span class="nc" id="L438">		}</span>

		private void sleep()
		{
			try
			{
<span class="nc" id="L444">				Thread.sleep(latency);</span>
			}
<span class="nc" id="L446">			catch (InterruptedException e)</span>
			{
				// Interrupt may be thrown manually by stop()
<span class="nc" id="L449">				log.finer(&quot;DIED IN MY SLEEP&quot;);</span>
<span class="nc" id="L450">			}</span>
<span class="nc" id="L451">		}</span>
	}

	/** Line separator, retrieved from System properties &amp; stored statically. */
<span class="fc" id="L455">	protected static final String lineSeparator = System.getProperty(&quot;line.separator&quot;);</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>