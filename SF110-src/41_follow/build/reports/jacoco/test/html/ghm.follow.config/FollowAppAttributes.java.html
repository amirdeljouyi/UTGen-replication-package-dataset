<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FollowAppAttributes.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">41_follow</a> &gt; <a href="index.source.html" class="el_package">ghm.follow.config</a> &gt; <span class="el_source">FollowAppAttributes.java</span></div><h1>FollowAppAttributes.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)
 * 
 * This file is part of Follow (http://follow.sf.net).
 * 
 * Follow is free software; you can redistribute it and/or modify it under the
 * terms of version 2 of the GNU General Public License as published by the Free
 * Software Foundation.
 * 
 * Follow is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
 * Suite 330, Boston, MA 02111-1307 USA
 */

package ghm.follow.config;

import ghm.follow.FollowApp;

import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JOptionPane;

import java.util.logging.Logger;

/**
 * @author &lt;a href=&quot;mailto:greghmerrill@yahoo.com&quot;&gt;Greg Merrill&lt;/a&gt;
 */
public class FollowAppAttributes
{
<span class="fc" id="L46">	private static Logger log = Logger.getLogger(FollowAppAttributes.class.getName());</span>
	EnumeratedProperties properties;
	private EnumeratedProperties defaultProperties;
	private FollowAppAttributes defaultAttributes;
<span class="fc" id="L50">	static final String userHome = System.getProperty(&quot;user.home&quot;);</span>
	public static final String PROPERTY_FILE_NAME = &quot;.followApp.properties&quot;;
<span class="fc" id="L52">	static final String defaultPropertyFileName = userHome + FollowApp.FILE_SEPARATOR</span>
			+ PROPERTY_FILE_NAME;
	private File propertyFile;
	public static final String PROPERTY_PROTOTYPE_FILE_NAME = &quot;followApp.properties.prototype&quot;;
	public static final int BUFFER_SIZE = 32768;

	public static final String HEIGHT_KEY = &quot;height&quot;;
	public static final String WIDTH_KEY = &quot;width&quot;;
	public static final String X_KEY = &quot;x&quot;;
	public static final String Y_KEY = &quot;y&quot;;
	public static final String FOLLOWED_FILES_KEY = &quot;followedFiles&quot;;
	public static final String TAB_PLACEMENT_KEY = &quot;tabs.placement&quot;;
	public static final String SELECTED_TAB_INDEX_KEY = &quot;tabs.selectedIndex&quot;;
	public static final String LAST_FILE_CHOOSER_DIR_KEY = &quot;fileChooser.lastDir&quot;;
	public static final String BUFFER_SIZE_KEY = &quot;bufferSize&quot;;
	public static final String LATENCY_KEY = &quot;latency&quot;;
	public static final String ATTRIBUTES_VERSION_KEY = &quot;attributesVersion&quot;;
	public static final String FONT_FAMILY_KEY = &quot;fontFamily&quot;;
	public static final String FONT_STYLE_KEY = &quot;fontStyle&quot;;
	public static final String FONT_SIZE_KEY = &quot;fontSize&quot;;
	public static final String CONFIRM_DELETE_KEY = &quot;confirmDelete&quot;;
	public static final String CONFIRM_DELETE_ALL_KEY = &quot;confirmDeleteAll&quot;;
	public static final String AUTO_SCROLL_KEY = &quot;autoScroll&quot;;
	public static final String EDITOR_KEY = &quot;editor&quot;;
	public static final String TAB_SIZE_KEY = &quot;tabSize&quot;;
	public static final String RECENT_FILES_MAX_KEY = &quot;recentFilesMax&quot;;
	public static final String RECENT_FILES_KEY = &quot;recentFiles&quot;;

	// Versions
	public static final int UNVERSIONED = 0;
	public static final int v1_1 = 1;
	public static final int v1_2 = 2;
	public static final int v1_3 = 3;
	public static final int v1_3_2 = 4;
	public static final int v1_4 = 5;
	public static final int v1_5_0 = 6;
	public static final int v1_6_0 = 7;

<span class="pc" id="L90">	private PropertyChangeSupport pcs = new PropertyChangeSupport(this);</span>

	public FollowAppAttributes() throws IOException
	{
		// have to cast null so that the constructor call isn't ambiguous
<span class="fc" id="L95">		this((File) null);</span>
<span class="fc" id="L96">	}</span>

	public FollowAppAttributes(File exitingPropertyFile) throws IOException
<span class="fc" id="L99">	{</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">		if (exitingPropertyFile != null)</span>
		{
<span class="nc" id="L102">			propertyFile = exitingPropertyFile;</span>
		}
		else
		{
<span class="fc" id="L106">			propertyFile = new File(defaultPropertyFileName);</span>
		}

<span class="pc bpc" id="L109" title="1 of 2 branches missed.">		if (!(propertyFile.exists()))</span>
		{
			// If the property file doesn't exist, we create a default property
			// file using a prototype property file stored somewhere on the
			// classpath
<span class="nc" id="L114">			log.info(&quot;No property file for the Follow application is present; creating &quot;</span>
<span class="nc" id="L115">					+ propertyFile.getAbsolutePath() + &quot; (with default values) ...&quot;);</span>
<span class="nc" id="L116">			properties = (EnumeratedProperties) getDefaultProperties().clone();</span>
<span class="nc" id="L117">			log.info(&quot;... property file created successfully.&quot;);</span>
		}
		else
		{
<span class="fc" id="L121">			properties = new EnumeratedProperties();</span>
<span class="fc" id="L122">			FileInputStream fis = new FileInputStream(propertyFile);</span>
<span class="fc" id="L123">			properties.load(fis);</span>
<span class="pc bpc" id="L124" title="6 of 7 branches missed.">			switch (getAttributesVersion())</span>
			{
				case UNVERSIONED:
					// Migrate unversioned attributes to 1.1 attributes
<span class="nc" id="L128">					log.info(&quot;Migrating pre-v1.1 properties to v1.1.&quot;);</span>
<span class="nc" id="L129">					setAttributesVersion(v1_1);</span>
<span class="nc" id="L130">					setTabPlacement(getDefaultAttributes().getTabPlacement());</span>
				case v1_1:
					// Migrate 1.1 attributes to 1.2 attributes
<span class="nc" id="L133">					log.info(&quot;Migrating v1.1 properties to v1.2.&quot;);</span>
<span class="nc" id="L134">					setAttributesVersion(v1_2);</span>
<span class="nc" id="L135">					setFont(getDefaultAttributes().getFont());</span>
				case v1_2:
					// Migrate 1.2 attributes to 1.3 attributes
<span class="nc" id="L138">					log.info(&quot;Migrating v1.2 properties to v1.3.&quot;);</span>
<span class="nc" id="L139">					setAttributesVersion(v1_3);</span>
<span class="nc" id="L140">					setConfirmDelete(true);</span>
<span class="nc" id="L141">					setConfirmDeleteAll(true);</span>
					// Additionally, it is necessary to warn the user about the
					// changes to
					// Clear and ClearAll and the introduction of Delete and
					// DeleteAll
<span class="nc" id="L146">					JOptionPane.showMessageDialog(null, FollowApp</span>
<span class="nc" id="L147">							.getResourceString(&quot;v1.3.warning.text&quot;), FollowApp</span>
<span class="nc" id="L148">							.getResourceString(&quot;v1.3.warning.title&quot;), JOptionPane.WARNING_MESSAGE);</span>
				case v1_3:
				case v1_3_2:
					// Migrate 1.3 attributes to 1.4 attributes
<span class="nc" id="L152">					log.info(&quot;Migrating v1.3 properties to v1.4.&quot;);</span>
<span class="nc" id="L153">					setAttributesVersion(v1_4);</span>
<span class="nc" id="L154">					setAutoScroll(true);</span>
					// Inform the user of the new AutoScroll feature
<span class="nc" id="L156">					JOptionPane.showMessageDialog(null, FollowApp</span>
<span class="nc" id="L157">							.getResourceString(&quot;v1.4.info.text&quot;), FollowApp</span>
<span class="nc" id="L158">							.getResourceString(&quot;v1.4.info.title&quot;), JOptionPane.INFORMATION_MESSAGE);</span>
				case v1_4:
					// Migrate 1.4 attributes to 1.5 attributes
<span class="nc" id="L161">					log.info(&quot;Migrating v1.4 properties to v.1.5.&quot;);</span>
<span class="nc" id="L162">					setAttributesVersion(v1_5_0);</span>
<span class="nc" id="L163">					setTabSize(4);</span>
				case v1_5_0:
					// Migrate 1.5.0 attributes to 1.6.0 attributes
<span class="fc" id="L166">					log.info(&quot;Migrating v1.5 properties to 1.6.0.&quot;);</span>
<span class="fc" id="L167">					setAttributesVersion(v1_6_0);</span>
<span class="fc" id="L168">					setRecentFilesMax(5);</span>
			}
<span class="fc" id="L170">			fis.close();</span>
		}
<span class="fc" id="L172">	}</span>

	private FollowAppAttributes(EnumeratedProperties props) throws IOException
<span class="nc" id="L175">	{</span>
<span class="nc" id="L176">		properties = props;</span>
<span class="nc" id="L177">	}</span>

	public int getHeight()
	{
<span class="nc" id="L181">		return getInt(HEIGHT_KEY);</span>
	}

	public void setHeight(int height)
	{
<span class="nc" id="L186">		setInt(HEIGHT_KEY, height);</span>
<span class="nc" id="L187">	}</span>

	public int getWidth()
	{
<span class="nc" id="L191">		return getInt(WIDTH_KEY);</span>
	}

	public void setWidth(int width)
	{
<span class="nc" id="L196">		setInt(WIDTH_KEY, width);</span>
<span class="nc" id="L197">	}</span>

	public int getX()
	{
<span class="nc" id="L201">		return getInt(X_KEY);</span>
	}

	public void setX(int x)
	{
<span class="nc" id="L206">		setInt(X_KEY, x);</span>
<span class="nc" id="L207">	}</span>

	public int getY()
	{
<span class="nc" id="L211">		return getInt(Y_KEY);</span>
	}

	public void setY(int y)
	{
<span class="nc" id="L216">		setInt(Y_KEY, y);</span>
<span class="nc" id="L217">	}</span>

	/**
	 * Get an array files being followed
	 * 
	 * @return File[] File array of followed files
	 */
	public List&lt;File&gt; getFollowedFiles()
	{
<span class="nc" id="L226">		return getFiles(getFollowedFilesList());</span>
	}

	/**
	 * Get a list of files being followed
	 * 
	 * @return List file names as Strings
	 */
	private List&lt;String&gt; getFollowedFilesList()
	{
<span class="nc" id="L236">		return getEnumeratedProperty(FOLLOWED_FILES_KEY);</span>
	}

	protected List&lt;File&gt; getFiles(List&lt;String&gt; fileList)
	{
<span class="nc" id="L241">		ArrayList&lt;File&gt; files = new ArrayList&lt;File&gt;(fileList.size());</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">		for (String s : fileList)</span>
		{
<span class="nc" id="L244">			files.add(new File(s));</span>
<span class="nc" id="L245">		}</span>
<span class="nc" id="L246">		return files;</span>
	}

	/**
	 * Checks the existence of a file in the list of followed files
	 * 
	 * @return true iff any File in the List of followed Files (getFollowedFiles()) has the same
	 *         Canonical Path as the supplied File
	 */
	public boolean followedFileListContains(File file)
	{
<span class="nc" id="L257">		return fileListContains(getFollowedFilesList(), file);</span>
	}

	/**
	 * Checks the existence of a file in the list of recent files
	 * 
	 * @return true iff any File in the List of recent Files (getFollowedFiles()) has the same
	 *         Canonical Path as the supplied File
	 */
	public boolean recentFileListContains(File file)
	{
<span class="nc" id="L268">		return fileListContains(getRecentFilesList(), file);</span>
	}

	/**
	 * @return true iff any File in the List of Files (getFollowedFiles()) has the same Canonical
	 *         Path as the supplied File
	 */
	protected boolean fileListContains(List&lt;String&gt; fileList, File file)
	{
<span class="nc" id="L277">		boolean retval = false;</span>
<span class="nc bnc" id="L278" title="All 4 branches missed.">		if (fileList != null &amp;&amp; file != null)</span>
		{
<span class="nc bnc" id="L280" title="All 2 branches missed.">			for (int i = 0; i &lt; fileList.size(); i++)</span>
			{
<span class="nc" id="L282">				String nextFile = (String) fileList.get(i);</span>
				// be sure to check the same thing that is added in
				// addFollowedFile(File)
<span class="nc bnc" id="L285" title="All 2 branches missed.">				if (nextFile.equals(file.getAbsolutePath()))</span>
				{
<span class="nc" id="L287">					retval = true;</span>
<span class="nc" id="L288">					break;</span>
				}
			}
		}
<span class="nc" id="L292">		return retval;</span>
	}

	/**
	 * Adds a file to the list of followed files
	 * 
	 * @param file
	 */
	public void addFollowedFile(File file)
	{
<span class="nc" id="L302">		List&lt;String&gt; fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">		if (!fileListContains(fileNames, file))</span>
		{
<span class="nc" id="L305">			fileNames.add(file.getAbsolutePath());</span>
<span class="nc" id="L306">			setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);</span>
		}
<span class="nc" id="L308">	}</span>

	/**
	 * Removes a file from the list of followed files
	 * 
	 * @param file
	 */
	public void removeFollowedFile(File file)
	{
<span class="nc" id="L317">		List&lt;String&gt; fileNames = getEnumeratedProperty(FOLLOWED_FILES_KEY);</span>
<span class="nc" id="L318">		fileNames.remove(file.getAbsolutePath());</span>
<span class="nc" id="L319">		setEnumeratedProperty(FOLLOWED_FILES_KEY, fileNames);</span>
<span class="nc" id="L320">	}</span>

	public int getTabPlacement()
	{
<span class="fc" id="L324">		return getInt(TAB_PLACEMENT_KEY);</span>
	}

	public void setTabPlacement(int tabPlacement)
	{
<span class="nc" id="L329">		setInt(TAB_PLACEMENT_KEY, tabPlacement);</span>
<span class="nc" id="L330">	}</span>

	public int getTabSize()
	{
<span class="nc" id="L334">		return getInt(TAB_SIZE_KEY);</span>
	}

	public void setTabSize(int tabSize)
	{
<span class="nc" id="L339">		setInt(TAB_SIZE_KEY, tabSize);</span>
<span class="nc" id="L340">	}</span>

	public void setTabSize(String tabSize)
	{
<span class="nc" id="L344">		setTabSize(Integer.parseInt(tabSize));</span>
<span class="nc" id="L345">	}</span>

	public int getSelectedTabIndex()
	{
		try
		{
<span class="nc" id="L351">			return getInt(SELECTED_TAB_INDEX_KEY);</span>
		}
<span class="nc" id="L353">		catch (NumberFormatException e)</span>
		{
<span class="nc" id="L355">			setSelectedTabIndex(0);</span>
<span class="nc" id="L356">			return 0;</span>
		}
	}

	public void setSelectedTabIndex(int selectedTabIndex)
	{
<span class="nc" id="L362">		setInt(SELECTED_TAB_INDEX_KEY, selectedTabIndex);</span>
<span class="nc" id="L363">	}</span>

	public File getLastFileChooserDirectory()
	{
<span class="nc" id="L367">		return new File(properties.getProperty(LAST_FILE_CHOOSER_DIR_KEY, userHome));</span>
	}

	public void setLastFileChooserDirectory(File file)
	{
<span class="nc" id="L372">		setString(LAST_FILE_CHOOSER_DIR_KEY, file.getAbsolutePath());</span>
<span class="nc" id="L373">	}</span>

	public int getBufferSize()
	{
<span class="nc" id="L377">		return getInt(BUFFER_SIZE_KEY);</span>
	}

	public void setBufferSize(int bufferSize)
	{
<span class="nc" id="L382">		setInt(BUFFER_SIZE_KEY, bufferSize);</span>
<span class="nc" id="L383">	}</span>

	public void setBufferSize(String bufferSize)
	{
<span class="nc" id="L387">		setBufferSize(Integer.parseInt(bufferSize));</span>
<span class="nc" id="L388">	}</span>

	public int getLatency()
	{
<span class="nc" id="L392">		return getInt(LATENCY_KEY);</span>
	}

	public void setLatency(int latency)
	{
<span class="nc" id="L397">		setInt(LATENCY_KEY, latency);</span>
<span class="nc" id="L398">	}</span>

	public void setLatency(String latency)
	{
<span class="nc" id="L402">		setLatency(Integer.parseInt(latency));</span>
<span class="nc" id="L403">	}</span>

	public int getAttributesVersion()
	{
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">		if (properties.get(ATTRIBUTES_VERSION_KEY) == null)</span>
		{
			// Supporting v1.0 &amp; v1.0.1, which had no notion of attributes
			// version
<span class="nc" id="L411">			return UNVERSIONED;</span>
		}
		else
		{
<span class="fc" id="L415">			return getInt(ATTRIBUTES_VERSION_KEY);</span>
		}
	}

	public void setAttributesVersion(int attributesVersion)
	{
<span class="fc" id="L421">		setInt(ATTRIBUTES_VERSION_KEY, attributesVersion);</span>
<span class="fc" id="L422">	}</span>

	public Font getFont()
	{
<span class="nc" id="L426">		Font font = new Font(getString(FONT_FAMILY_KEY), getInt(FONT_STYLE_KEY),</span>
<span class="nc" id="L427">				getInt(FONT_SIZE_KEY));</span>
<span class="nc" id="L428">		return font;</span>
	}

	public void setFont(Font font)
	{
<span class="nc" id="L433">		setString(FONT_FAMILY_KEY, font.getFontName());</span>
<span class="nc" id="L434">		setInt(FONT_STYLE_KEY, font.getStyle());</span>
<span class="nc" id="L435">		setInt(FONT_SIZE_KEY, font.getSize());</span>
<span class="nc" id="L436">	}</span>

	public boolean confirmDelete()
	{
<span class="nc" id="L440">		return getBoolean(CONFIRM_DELETE_KEY);</span>
	}

	public void setConfirmDelete(boolean value)
	{
<span class="nc" id="L445">		setBoolean(CONFIRM_DELETE_KEY, value);</span>
<span class="nc" id="L446">	}</span>

	public boolean confirmDeleteAll()
	{
<span class="nc" id="L450">		return getBoolean(CONFIRM_DELETE_ALL_KEY);</span>
	}

	public void setConfirmDeleteAll(boolean value)
	{
<span class="nc" id="L455">		setBoolean(CONFIRM_DELETE_ALL_KEY, value);</span>
<span class="nc" id="L456">	}</span>

	public boolean autoScroll()
	{
<span class="nc" id="L460">		return getBoolean(AUTO_SCROLL_KEY);</span>
	}

	public void setAutoScroll(boolean value)
	{
<span class="nc" id="L465">		setBoolean(AUTO_SCROLL_KEY, value);</span>
<span class="nc" id="L466">	}</span>

	public String getEditor()
	{
<span class="nc" id="L470">		String result = getString(EDITOR_KEY);</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">		if (result == null)</span>
		{
<span class="nc" id="L473">			result = &quot;&quot;;</span>
		}

<span class="nc" id="L476">		return (result);</span>
	}

	public void setEditor(String value)
	{
<span class="nc" id="L481">		setString(EDITOR_KEY, value);</span>
<span class="nc" id="L482">	}</span>

	/**
	 * Adds a file to the list of recent files
	 * 
	 * @param file
	 */
	public void addRecentFile(File file)
	{
<span class="nc bnc" id="L491" title="All 2 branches missed.">		if (!recentFileListContains(file))</span>
		{
<span class="nc" id="L493">			List&lt;String&gt; fileList = getRecentFilesList();</span>
			// check size constraint and add accordingly
<span class="nc bnc" id="L495" title="All 2 branches missed.">			if (fileList.size() == getRecentFilesMax())</span>
			{
<span class="nc bnc" id="L497" title="All 2 branches missed.">				for (int i = 0; i &lt; fileList.size() - 1; i++)</span>
				{
<span class="nc" id="L499">					fileList.set(i, fileList.get(i + 1));</span>
				}
<span class="nc" id="L501">				fileList.set(fileList.size() - 1, file.getAbsolutePath());</span>
			}
			else
			{
<span class="nc" id="L505">				fileList.add(file.getAbsolutePath());</span>
			}
<span class="nc" id="L507">			setEnumeratedProperty(RECENT_FILES_KEY, fileList);</span>
		}
<span class="nc" id="L509">	}</span>

	/**
	 * Get an array of recently opened files
	 * 
	 * @return File[] File array of followed files
	 */
	public List&lt;File&gt; getRecentFiles()
	{
<span class="nc" id="L518">		return getFiles(getRecentFilesList());</span>
	}

	public int getRecentFilesMax()
	{
<span class="nc" id="L523">		return getInt(RECENT_FILES_MAX_KEY);</span>
	}

	public void setRecentFilesMax(String max)
	{
<span class="nc" id="L528">		setRecentFilesMax(Integer.parseInt(max));</span>
<span class="nc" id="L529">	}</span>

	public void setRecentFilesMax(int max)
	{
<span class="fc" id="L533">		List&lt;String&gt; files = getRecentFilesList();</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">		if (files.size() &gt; max)</span>
		{
<span class="nc bnc" id="L536" title="All 2 branches missed.">			for (int i = files.size() - max; i &gt; 0; i--)</span>
			{
<span class="nc" id="L538">				files.remove(0);</span>
			}
<span class="nc" id="L540">			setEnumeratedProperty(RECENT_FILES_KEY, files);</span>
		}
<span class="fc" id="L542">		setInt(RECENT_FILES_MAX_KEY, max);</span>
<span class="fc" id="L543">	}</span>

	public File getPropertyFile()
	{
<span class="nc" id="L547">		return propertyFile;</span>
	}

	public void store() throws IOException
	{
<span class="nc" id="L552">		BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(</span>
				defaultPropertyFileName));
<span class="nc" id="L554">		properties.store(bos, null);</span>
		// close this stream.  no need to flush it since Properties.store(..) does that
<span class="nc" id="L556">		bos.close();</span>
<span class="nc" id="L557">	}</span>

	// The listener list wrapper methods.
	public synchronized void addPropertyChangeListener(PropertyChangeListener listener)
	{
<span class="nc" id="L562">		pcs.addPropertyChangeListener(listener);</span>
<span class="nc" id="L563">	}</span>

	public synchronized void addPropertyChangeListener(String prop, PropertyChangeListener listener)
	{
<span class="nc" id="L567">		pcs.addPropertyChangeListener(prop, listener);</span>
<span class="nc" id="L568">	}</span>

	public synchronized void removePropertyChangeListener(PropertyChangeListener listener)
	{
<span class="nc" id="L572">		pcs.removePropertyChangeListener(listener);</span>
<span class="nc" id="L573">	}</span>

	public synchronized void removePropertyChangeListener(String prop, PropertyChangeListener listener)
	{
<span class="nc" id="L577">		pcs.removePropertyChangeListener(prop, listener);</span>
<span class="nc" id="L578">	}</span>

	public FollowAppAttributes getDefaultAttributes() throws IOException
	{
<span class="nc bnc" id="L582" title="All 2 branches missed.">		if (defaultAttributes == null)</span>
		{
<span class="nc" id="L584">			defaultAttributes = new FollowAppAttributes(getDefaultProperties());</span>
			// Check for the unlikely possibility that the default font is
			// unavailable
<span class="nc" id="L587">			Font defaultFont = defaultAttributes.getFont();</span>
<span class="nc" id="L588">			String[] availableFontFamilyNames = GraphicsEnvironment.getLocalGraphicsEnvironment()</span>
<span class="nc" id="L589">					.getAvailableFontFamilyNames();</span>
<span class="nc" id="L590">			boolean defaultFontIsAvailable = false;</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">			for (int i = 0; i &lt; availableFontFamilyNames.length; i++)</span>
			{
<span class="nc bnc" id="L593" title="All 2 branches missed.">				if (defaultFont.getFamily().equals(availableFontFamilyNames[i]))</span>
				{
<span class="nc" id="L595">					defaultFontIsAvailable = true;</span>
<span class="nc" id="L596">					break;</span>
				}
			}
<span class="nc bnc" id="L599" title="All 2 branches missed.">			if (!defaultFontIsAvailable)</span>
			{
<span class="nc" id="L601">				log.info(&quot;Font family &quot; + defaultFont.getFamily() + &quot; is unavailable; using &quot;</span>
						+ availableFontFamilyNames[0] + &quot; instead.&quot;);
<span class="nc" id="L603">				defaultAttributes.setFont(new Font(availableFontFamilyNames[0], defaultFont</span>
<span class="nc" id="L604">						.getStyle(), defaultFont.getSize()));</span>
			}
		}
<span class="nc" id="L607">		return defaultAttributes;</span>
	}

	/**
	 * Get a list of recently opened files
	 * 
	 * @return List recently opened files as Strings
	 */
	private List&lt;String&gt; getRecentFilesList()
	{
<span class="fc" id="L617">		return getEnumeratedProperty(RECENT_FILES_KEY);</span>
	}

	private int getInt(String key)
	{
<span class="fc" id="L622">		int retval = 0;</span>
<span class="fc" id="L623">		String s = getString(key);</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">		if (s != null)</span>
<span class="fc" id="L625">			retval = Integer.parseInt(getString(key));</span>
<span class="fc" id="L626">		return retval;</span>
	}

	private void setInt(String key, int value)
	{
<span class="fc" id="L631">		int oldValue = getInt(key);</span>
<span class="fc" id="L632">		properties.setProperty(key, String.valueOf(value));</span>
<span class="fc" id="L633">		pcs.firePropertyChange(key, oldValue, value);</span>
<span class="fc" id="L634">	}</span>

	private boolean getBoolean(String key)
	{
<span class="nc" id="L638">		return &quot;true&quot;.equals(getString(key));</span>
	}

	private void setBoolean(String key, boolean value)
	{
<span class="nc" id="L643">		boolean oldValue = getBoolean(key);</span>
<span class="nc" id="L644">		properties.setProperty(key, String.valueOf(value));</span>
<span class="nc" id="L645">		pcs.firePropertyChange(key, oldValue, value);</span>
<span class="nc" id="L646">	}</span>

	private String getString(String key)
	{
<span class="fc" id="L650">		return properties.getProperty(key);</span>
	}

	private void setString(String key, String value)
	{
<span class="nc" id="L655">		String oldValue = getString(key);</span>
<span class="nc" id="L656">		properties.setProperty(key, value);</span>
<span class="nc" id="L657">		pcs.firePropertyChange(key, oldValue, value);</span>
<span class="nc" id="L658">	}</span>

	private List&lt;String&gt; getEnumeratedProperty(String key)
	{
<span class="fc" id="L662">		return properties.getEnumeratedProperty(key);</span>
	}

	private void setEnumeratedProperty(String key, List&lt;String&gt; values)
	{
<span class="nc" id="L667">		List&lt;String&gt; oldValue = getEnumeratedProperty(key);</span>
<span class="nc" id="L668">		properties.setEnumeratedProperty(key, values);</span>
<span class="nc" id="L669">		pcs.firePropertyChange(key, oldValue, values);</span>
<span class="nc" id="L670">	}</span>

	private EnumeratedProperties getDefaultProperties() throws IOException
	{
<span class="nc bnc" id="L674" title="All 2 branches missed.">		if (defaultProperties == null)</span>
		{
<span class="nc" id="L676">			InputStream in = this.getClass().getResourceAsStream(PROPERTY_PROTOTYPE_FILE_NAME);</span>
<span class="nc" id="L677">			BufferedInputStream bis = new BufferedInputStream(in);</span>
<span class="nc" id="L678">			FileOutputStream fos = new FileOutputStream(propertyFile);</span>
<span class="nc" id="L679">			BufferedOutputStream bos = new BufferedOutputStream(fos);</span>
<span class="nc" id="L680">			byte[] byteArray = new byte[BUFFER_SIZE];</span>
			int len;
<span class="nc bnc" id="L682" title="All 2 branches missed.">			while ((len = bis.read(byteArray, 0, BUFFER_SIZE)) &gt; 0)</span>
			{
<span class="nc" id="L684">				bos.write(byteArray, 0, len);</span>
			}
<span class="nc" id="L686">			bos.flush();</span>
<span class="nc" id="L687">			bos.close();</span>
<span class="nc" id="L688">			bis.close();</span>
<span class="nc" id="L689">			defaultProperties = new EnumeratedProperties();</span>
<span class="nc" id="L690">			defaultProperties.load(new BufferedInputStream(new FileInputStream(propertyFile)));</span>
		}
<span class="nc" id="L692">		return defaultProperties;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>