<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SearchableTextPane.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">41_follow</a> &gt; <a href="index.source.html" class="el_package">ghm.follow.search</a> &gt; <span class="el_source">SearchableTextPane.java</span></div><h1>SearchableTextPane.java</h1><pre class="source lang-java linenums">package ghm.follow.search;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.JTextArea;
import javax.swing.plaf.ComponentUI;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Utilities;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;

public class SearchableTextPane extends JTextArea
{
<span class="fc" id="L21">	private Logger log = Logger.getLogger(SearchableTextPane.class.getName());</span>
<span class="fc" id="L22">	private int lastSearchPos = -1;</span>
	private String lastSearchTerm;
<span class="fc" id="L24">	private final DefaultHighlightPainter wordPainter = new DefaultHighlightPainter(Color.YELLOW);</span>

	public SearchableTextPane(Font font, int tabSize)
<span class="fc" id="L27">	{</span>
		// set the display font
<span class="fc" id="L29">		setFont(font);</span>
<span class="fc" id="L30">		setTabSize(tabSize);</span>
<span class="fc" id="L31">	}</span>

	/**
	 * Override this to keep the text from wrapping and to make the viewable area as wide as the
	 * tabbed pane
	 */
	public boolean getScrollableTracksViewportWidth()
	{
<span class="fc" id="L39">		Component parent = getParent();</span>
<span class="fc" id="L40">		ComponentUI ui = getUI();</span>

<span class="pc bpc" id="L42" title="3 of 4 branches missed.">		return parent != null ? (ui.getPreferredSize(this).width &lt;= parent.getSize().width) : true;</span>
	}

	/**
	 * Highlight &lt;code&gt;term&lt;/code&gt; wherever it is found in the view. Also highlights the entire
	 * line on which the term is found.
	 * 
	 * @param term
	 * @param caseSensitive
	 * @param useRegularExpression
	 * @return
	 */
	public List&lt;LineResult&gt; highlight(String term, int flags)
	{
<span class="fc" id="L56">		List&lt;LineResult&gt; lineResults = new ArrayList&lt;LineResult&gt;();</span>
		// Remove all old highlights
<span class="fc" id="L58">		removeHighlights();</span>
		// Search for pattern
<span class="pc bpc" id="L60" title="1 of 4 branches missed.">		if ((term != null) &amp;&amp; (term.length() &gt; 0))</span>
		{
			// look for instances of the term in the text

			try
			{
<span class="fc" id="L66">				Document doc = getDocument();</span>
<span class="fc" id="L67">				String text = doc.getText(0, doc.getLength());</span>
<span class="fc" id="L68">				List&lt;WordResult&gt; searchResults = new SearchEngine(flags).search(term, text);</span>
<span class="fc" id="L69">				lineResults = convertWords2Lines(searchResults);</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">				for (LineResult lineResult : lineResults)</span>
				{
<span class="fc" id="L72">					List&lt;WordResult&gt; wordResults = lineResult.getWordResults();</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">					for (WordResult wordResult : wordResults)</span>
					{
						// highlight the searched term
<span class="fc" id="L76">						int wordStart = wordResult.start;</span>
<span class="fc" id="L77">						int wordEnd = wordResult.end;</span>
<span class="fc" id="L78">						addHighlight(wordStart, wordEnd - wordStart);</span>
<span class="fc" id="L79">						Thread.yield();</span>
<span class="fc" id="L80">					}</span>
<span class="fc" id="L81">				}</span>
			}
<span class="nc" id="L83">			catch (BadLocationException e)</span>
			{
<span class="nc" id="L85">				log.log(Level.SEVERE, &quot;BadLocationException in SearchableTextPane&quot;, e);</span>
<span class="nc" id="L86">				lineResults = new ArrayList&lt;LineResult&gt;();</span>
<span class="fc" id="L87">			}</span>
		}
<span class="fc" id="L89">		return lineResults;</span>
	}

	/**
	 * Highlight a piece of text in the document
	 * 
	 * @param start
	 * @param wordEnd
	 * @param highlighter
	 */
	private void addHighlight(int start, int length) throws BadLocationException
	{
<span class="fc" id="L101">		getHighlighter().addHighlight(start, start + length, wordPainter);</span>
<span class="fc" id="L102">	}</span>

	/**
	 * Removes highlights from text area
	 */
	public void removeHighlights()
	{
<span class="fc" id="L109">		getHighlighter().removeAllHighlights();</span>
<span class="fc" id="L110">	}</span>

	/**
	 * Searches for a term. If the term provided matches the last searched term, the last found
	 * position is used as a starting point.&lt;br&gt;
	 * &lt;br&gt;
	 * Developer note: this method isn't currently used.
	 * 
	 * @param term
	 *            The string for which to search.
	 * @return The position where the term was found.&lt;br&gt;
	 *         If the term is null, empty or not found, -1 is returned.
	 */
	public int search(String term)
	{
<span class="fc bfc" id="L125" title="All 4 branches covered.">		if (term != null &amp;&amp; term.length() &gt; 0)</span>
		{
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">			if (term.equals(lastSearchTerm))</span>
			{
				// assume to start at the beginning
<span class="nc" id="L130">				int pos = 0;</span>
				// if there is a previous search position, start there plus the
				// length
				// of the last term so that last term again isn't found again
<span class="nc bnc" id="L134" title="All 2 branches missed.">				if (lastSearchPos != -1)</span>
				{
<span class="nc" id="L136">					pos = lastSearchPos + lastSearchTerm.length();</span>
				}
<span class="nc" id="L138">				lastSearchPos = search(lastSearchTerm, pos);</span>
<span class="nc" id="L139">			}</span>
			else
			{
<span class="fc" id="L142">				lastSearchPos = search(term, 0);</span>
			}
		}
		// remember the term if it was found
<span class="fc bfc" id="L146" title="All 2 branches covered.">		if (lastSearchPos == -1)</span>
		{
<span class="fc" id="L148">			lastSearchTerm = null;</span>
		}
		else
		{
<span class="fc" id="L152">			lastSearchTerm = term;</span>
		}
<span class="fc" id="L154">		return lastSearchPos;</span>
	}

	/**
	 * Searches for a term at the given starting position.&lt;br&gt;
	 * &lt;br&gt;
	 * Developer note: this method isn't currently used.
	 * 
	 * @param term
	 *            The string for which to search.
	 * @param startPos
	 *            Where to start.
	 * @return The position where the term was found.&lt;br&gt;
	 *         If the term is null, empty or not found, -1 is returned.
	 */
	public int search(String term, int startPos)
	{
<span class="fc" id="L171">		int pos = 0;</span>
		try
		{
<span class="fc" id="L174">			Document doc = getDocument();</span>
<span class="fc" id="L175">			String text = doc.getText(0, doc.getLength());</span>

			// Search for pattern
<span class="fc" id="L178">			pos = text.indexOf(term, startPos);</span>
		}
<span class="nc" id="L180">		catch (BadLocationException e)</span>
		{
			// just return -1;
<span class="nc" id="L183">			log.log(Level.WARNING, &quot;BadLocationException in SearchableTextPane&quot;, e);</span>
<span class="nc" id="L184">			pos = -1;</span>
<span class="fc" id="L185">		}</span>
<span class="fc" id="L186">		return pos;</span>
	}

	/**
	 * Converts word results from search into line results
	 * 
	 * @param words
	 * @return
	 */
	private List&lt;LineResult&gt; convertWords2Lines(List&lt;WordResult&gt; words) throws BadLocationException
	{
<span class="fc" id="L197">		ArrayList&lt;LineResult&gt; lines = new ArrayList&lt;LineResult&gt;();</span>
<span class="fc" id="L198">		LineResult tempLine = null;</span>
<span class="fc" id="L199">		int lastLine = -1;</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">		for (WordResult word : words)</span>
		{
<span class="fc" id="L202">			int line = getLineOfOffset(word.start);</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">			if (line != lastLine)</span>
			{
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">				if (tempLine != null)</span>
				{
<span class="nc" id="L207">					lines.add(tempLine);</span>
				}
<span class="fc" id="L209">				Element elem = Utilities.getParagraphElement(this, word.start);</span>
<span class="fc" id="L210">				int lineStart = elem.getStartOffset();</span>
<span class="fc" id="L211">				int lineEnd = elem.getEndOffset();</span>
<span class="fc" id="L212">				tempLine = new LineResult(line, lineStart, lineEnd);</span>
			}
<span class="fc" id="L214">			updateWordResult(word, tempLine);</span>
<span class="fc" id="L215">			lastLine = line;</span>
			// allow other things to happen in case the search takes a while
<span class="fc" id="L217">			Thread.yield();</span>
<span class="fc" id="L218">		}</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">		if (tempLine != null)</span>
		{
<span class="fc" id="L221">			lines.add(tempLine);</span>
		}
<span class="fc" id="L223">		return lines;</span>
	}

	/**
	 * Adds word result to line result and updates line information
	 * 
	 * @param wordResult
	 * @param lineResult
	 */
	private void updateWordResult(WordResult wordResult, LineResult lineResult)
			throws BadLocationException
	{
<span class="fc" id="L235">		lineResult.addWord(wordResult);</span>
		// increase by 1 because offset starts at 0.
		// 1 is clearer to the user since most people don't start counting
		// at 0
<span class="fc" id="L239">		int line = getLineOfOffset(wordResult.start);</span>
<span class="fc" id="L240">		wordResult.parent.lineNumber = line + 1;</span>
<span class="fc" id="L241">		int lineOffset = getLineStartOffset(line);</span>
<span class="fc" id="L242">		wordResult.setLineOffset(lineOffset);</span>
<span class="fc" id="L243">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>