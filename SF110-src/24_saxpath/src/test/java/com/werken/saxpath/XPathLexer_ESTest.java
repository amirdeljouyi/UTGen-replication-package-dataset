/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Mar 12 01:28:37 GMT 2024
 */

package com.werken.saxpath;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import com.werken.saxpath.Token;
import com.werken.saxpath.XPathLexer;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class XPathLexer_ESTest extends XPathLexer_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetXPath() throws Throwable  {
      // Set up an XPathLexer and assign it to a variable
      XPathLexer xPathLexer = new XPathLexer("* }#D");
      
      // Set the XPath for the lexer
      xPathLexer.setXPath("* }#D");
      
      // Assert that the XPath is set correctly
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLiteralReturningTokenWhereGetTokenTypeIsPositive() throws Throwable  {
      // Given a valid XPath expression "bbm9-Y."
      XPathLexer xPathLexer = new XPathLexer("bbm9-Y.");
      
      // When the literal token is extracted from the XPath expression
      Token literal = xPathLexer.literal();
      
      // Then the literal token should have a token type of 27 and an empty string as its token text
      assertEquals(27, literal.getTokenType());
      assertEquals("", literal.getTokenText());
      
      // And the literal token should not be null
      assertNotNull(literal);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsIdentifierStartCharReturningTrue() throws Throwable  {
      // Test that the lexer recognizes 'o' as an identifier start character
      XPathLexer xPathLexer = new XPathLexer("M3XD");
      boolean identifierStartChar = xPathLexer.isIdentifierStartChar('o');
      assertTrue(identifierStartChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsIdentifierStartCharReturningFalse() throws Throwable  {
      // Given an XPath lexer with a valid input string
      String input = "|A?fG#TW6xV87:BB+O/";
      XPathLexer xPathLexer = new XPathLexer(input);
      
      // When the method is called with a character that is not an identifier start char
      boolean identifierStartChar = xPathLexer.isIdentifierStartChar('!');
      
      // Then, the method should return false
      assertFalse(identifierStartChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsIdentifierCharReturningTrue() throws Throwable  {
      // Given an instance of XPathLexer and a string containing an identifier character
      XPathLexer xPathLexer = new XPathLexer("$dyi");
      boolean identifierChar = xPathLexer.isIdentifierChar('u');
      
      // When the method is called with the identifier character as input
      assertTrue(identifierChar);
      
      // Then the method should return true, indicating that the character is a valid identifier character in XPath syntax
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIsIdentifierCharReturningFalse() throws Throwable  {
      // No Comments were added
      XPathLexer xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      boolean identifierChar = xPathLexer.isIdentifierChar('[');
      assertFalse(identifierChar);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHasMoreCharsReturningTrue() throws Throwable  {
      // Given a valid XPath expression "G>oHDs"
      XPathLexer xPathLexer = new XPathLexer("G>oHDs");
      
      // When the lexer is created with this expression
      
      // Then the lexer should have more characters to parse
      assertTrue(xPathLexer.hasMoreChars());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetXPathReturningNull() throws Throwable  {
      // Arrange
      XPathLexer xPathLexer = new XPathLexer();
      
      // Act
      String actualXPath = xPathLexer.getXPath();
      
      // Assert
      assertEquals("", actualXPath);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetXPathReturningNonEmptyString() throws Throwable  {
      // Given a XPath lexer with a valid XPath expression
      XPathLexer xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      
      // When the getXPath method is called on the lexer
      String xPath = xPathLexer.getXPath();
      
      // Then the method should return the original XPath expression
      assertEquals("com.werken.saxpath.XPathLexer", xPath);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPreviousTokenReturningTokenWhereGetTokenTypeIsZero() throws Throwable  {
      // Given a XPathLexer object with a previously set token
      XPathLexer lexer = new XPathLexer();
      Token previousToken = new Token(0, "l4;Y5:1#)", 0, 0);
      lexer.setPreviousToken(previousToken);
      
      // When the getPreviousToken method is called
      Token actualToken = lexer.getPreviousToken();
      
      // Then the correct previous token should be returned
      assertEquals(previousToken, actualToken);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPreviousTokenReturningTokenWhereGetTokenTypeIsNegative() throws Throwable  {
      // Given: We have a XPathLexer instance with a valid input string.
      XPathLexer xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      
      // When: We call the identifierOrOperatorName method on the lexer to get the next token.
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      
      // Then: The token should have the correct text and type, and not be null.
      assertEquals("com.werken.saxpath.XPathLexer", identifierOrOperatorName.getTokenText());
      assertEquals(15, identifierOrOperatorName.getTokenType());
      assertNotNull(identifierOrOperatorName);
      
      // And: The previous token should have an invalid type.
      xPathLexer.nextToken();
      Token previousToken = xPathLexer.getPreviousToken();
      assertEquals((-1), previousToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEndPositionReturningZero() throws Throwable  {
      // Given a XPath Lexer instance
      XPathLexer lexer = new XPathLexer();
      
      // When the lexer is asked for its end position
      int endPosition = lexer.endPosition();
      
      // Then the end position should be 0
      assertEquals(0, endPosition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEndPositionReturningPositive() throws Throwable  {
      // Test that the XPathLexer correctly identifies the end position of a given input string
      XPathLexer xPathLexer = new XPathLexer("\"#Z\"q}L.Mj3");
      int endPosition = xPathLexer.endPosition();
      assertEquals(11, endPosition);
      // The end position of the given input string is 11, as it is the last character of the string
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDots() throws Throwable  {
      // Given a XPathLexer instance
      XPathLexer xPathLexer = new XPathLexer();
      
      // When the dots method is called on the lexer
      Token dots = xPathLexer.dots();
      
      // Then the token type should be equal to 13
      assertEquals(13, dots.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCurrentPositionReturningZero() throws Throwable  {
      // Given a non-empty input string for the XPath lexer
      String input = "&.Zw";
      
      // When the current position is obtained from the lexer
      XPathLexer xPathLexer = new XPathLexer(input);
      int currentPosition = xPathLexer.currentPosition();
      
      // Then the current position should be 0
      assertEquals(0, currentPosition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCurrentPositionReturningPositive() throws Throwable  {
      // Given an XPath expression with a slash character
      String xpathExpression = "|A?fG#TW6xV87:BB+O/";
      
      // When the lexer is created with the XPath expression
      XPathLexer xPathLexer = new XPathLexer(xpathExpression);
      
      // Then the slash character should be recognized as a token
      Token slashes = xPathLexer.slashes();
      assertEquals(11, slashes.getTokenType());
      assertEquals("|", slashes.getTokenText());
      
      // And the current position of the lexer should be at the beginning of the XPath expression
      int currentPosition = xPathLexer.currentPosition();
      assertEquals(1, currentPosition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLAReturningOtherChar() throws Throwable  {
      // Tests that the lexer properly handles invalid character references in XPath expressions
      XPathLexer xPathLexer = new XPathLexer("n$/nSW4!b\t}");
      char LA = xPathLexer.LA(12);
      assertEquals('\uFFFF', LA);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testColon() throws Throwable  {
      // Given a string of text that represents an XPath expression
      String input = "WF+VJ(nWq.l`F2";
      
      // When we create a lexer instance with the input string
      XPathLexer xPathLexer = new XPathLexer(input);
      
      // Then the colon token is returned and has the expected type and text
      Token colon = xPathLexer.colon();
      assertEquals(18, colon.getTokenType());
      assertEquals("W", colon.getTokenText());
      
      // And the plus token is returned and has the expected type and text
      Token plus = xPathLexer.plus();
      assertEquals("F", plus.getTokenText());
      assertEquals(5, plus.getTokenType());
      
      // And the literal token is returned and has the expected type and text
      xPathLexer.literal();
      
      // Then the comma token is returned and has the expected type and text
      Token comma = xPathLexer.comma();
      assertEquals(32, comma.getTokenType());
      
      // And the lookahead (LA) method returns the expected character
      char LA = xPathLexer.LA((-1));
      assertEquals('2', LA);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLAReturningAlphabeticChar() throws Throwable  {
      // Given a XPath expression "x[Bt:e!Pi`;CZ^"
      String xpath = "x[Bt:e!Pi`;CZ^";
      
      // When we create an instance of XPathLexer with this expression
      XPathLexer lexer = new XPathLexer(xpath);
      
      // Then we should be able to retrieve the first token "$"
      Token dollar = lexer.dollar();
      assertEquals("$", dollar.getTokenText());
      assertEquals(26, dollar.getTokenType());
      
      // When we call consume() method on XPathLexer
      lexer.consume();
      
      // Then the current token should be "+"
      Token plus = lexer.plus();
      assertEquals("+", plus.getTokenText());
      assertEquals(5, plus.getTokenType());
      
      // When we call consume() method on XPathLexer again
      lexer.consume();
      
      // Then the current token should be ","
      Token comma = lexer.comma();
      assertEquals(",", comma.getTokenText());
      assertEquals(32, comma.getTokenType());
      
      // When we call LA(-1) method on XPathLexer
      char la = lexer.LA(-1);
      
      // Then the result should be "B"
      assertEquals('B', la);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetXPathReturningEmptyString() throws Throwable  {
      // Create a new instance of the XPathLexer class with an empty string as input
      XPathLexer xPathLexer = new XPathLexer("");
      
      // Call the getXPath method on the lexer and store its result in a variable
      String xPath = xPathLexer.getXPath();
      
      // Assert that the result of getXPath is an empty string
      assertEquals("", xPath);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConsumeTakingNoArgumentsAndSlashes() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("n$/nSW4!b\t}");
      xPathLexer.consume();
      Token slashes = xPathLexer.slashes();
      assertEquals(12, slashes.getTokenType());
      assertEquals("$/", slashes.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRelationalOperatorReturningNull() throws Throwable  {
      // Given a XPathLexer instance with a relational operator tokenizer
      XPathLexer lexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      
      // When the relational operator method is called
      Token relationalOperator = lexer.relationalOperator();
      
      // Then the returned token should be null
      assertNull(relationalOperator);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWhitespace() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("* }#D");
      Token whitespace = xPathLexer.whitespace();
      assertEquals((-2), whitespace.getTokenType());
      assertEquals("", whitespace.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNumber() throws Throwable  {
      // Given
      XPathLexer xPathLexer = new XPathLexer("..wEMr7Tm");
      Token number = xPathLexer.number();
      
      // When
      number = xPathLexer.nextToken();
      
      // Then
      assertEquals(31, number.getTokenType());
      assertEquals(".", number.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRightParen() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("n$/nSW4!b\t}");
      Token rightParen = xPathLexer.rightParen();
      assertEquals("n", rightParen.getTokenText());
      assertEquals(2, rightParen.getTokenType());
      
      Token dollar = xPathLexer.dollar();
      assertEquals("$", dollar.getTokenText());
      assertEquals(26, dollar.getTokenType());
      
      Token number = xPathLexer.number();
      assertEquals("", number.getTokenText());
      assertEquals(30, number.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testOr() throws Throwable  {
      // Given a string that contains an XPath expression with an OR operator
      String input = "<]Z(";
      
      // When the input is passed to the XPathLexer constructor
      XPathLexer xPathLexer = new XPathLexer(input);
      
      // Then the lexer should recognize the OR operator and return a non-null token
      Token or = xPathLexer.or();
      assertNotNull(or);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAnd() throws Throwable  {
      // Create a new instance of the XPathLexer with an empty string as input
      XPathLexer xPathLexer = new XPathLexer("");
      
      // Call the and() method on the lexer to get the next token
      Token andToken = xPathLexer.and();
      
      // Assert that the token is null, indicating that there are no more tokens in the input
      assertNull(andToken);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testAtAndOperatorName() throws Throwable  {
      // Test that the lexer recognizes an identifier as a valid name
      XPathLexer lexer = new XPathLexer("s$di");
      lexer.identifierOrOperatorName();
      lexer.at();
      Token operatorName = lexer.operatorName();
      assertNull(operatorName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDiv() throws Throwable  {
      // No Comments were added
      XPathLexer xPathLexer = new XPathLexer("n$/nSW4!b\t}");
      Token div = xPathLexer.div();
      assertNull(div);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMod() throws Throwable  {
      // Given a XPath Lexer with an invalid XPath string
      XPathLexer xPathLexer = new XPathLexer("*Bx2,45m6/zCo");
      
      // When the mod method is called with the invalid XPath string
      Token mod = xPathLexer.mod();
      
      // Then the method should return null as it is an invalid XPath expression
      assertNull(mod);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNotEquals() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("..wEMr7m");
      Token arg0 = xPathLexer.notEquals();
      xPathLexer.setPreviousToken(arg0);
      assertEquals(22, arg0.getTokenType());
      assertEquals("..", arg0.getTokenText());
      
      Token nextToken = xPathLexer.nextToken();
      assertEquals("wEMr7m", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetPreviousToken() throws Throwable  {
      // Given: We have an XPathLexer instance with the input string "com.werken.saxpath.XPathLexer"
      XPathLexer xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      
      // When: We call the doubleColon() method on the XPathLexer instance
      Token arg0 = xPathLexer.doubleColon();
      
      // Then: The method returns a Token object with the token type ":" and the token text "co"
      assertEquals(19, arg0.getTokenType());
      assertEquals("co", arg0.getTokenText());
      
      // When: We set the previous token on the XPathLexer instance to the returned token
      xPathLexer.setPreviousToken(arg0);
      
      // Then: The nextToken() method on the XPathLexer instance returns a Token object with the token type ":" and the token text "m.werken.saxpath.XPathLexer"
      Token nextToken = xPathLexer.nextToken();
      assertEquals(15, nextToken.getTokenType());
      assertEquals("m.werken.saxpath.XPathLexer", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive0() throws Throwable  {
      // Create a new instance of XPathLexer with the input text ".6f&<"
      XPathLexer xPathLexer = new XPathLexer(".6f&<");
      
      // Call the nextToken method on the lexer and assign the result to the variable 'nextToken'
      Token nextToken = xPathLexer.nextToken();
      
      // Verify that the token type is equal to 31 (i.e., a floating point number)
      assertEquals(31, nextToken.getTokenType());
      
      // Verify that the token text is equal to ".6"
      assertEquals(".6", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsNegative0() throws Throwable  {
      // No Comments were added
      XPathLexer xPathLexer = new XPathLexer("{o{9oqiM");
      Token nextToken = xPathLexer.nextToken();
      assertEquals("{o{9oqiM", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive1() throws Throwable  {
      // No Comments were added
      XPathLexer xPathLexer = new XPathLexer("z?/fiP7\"&Q;1WM;");
      Token nextToken = xPathLexer.nextToken();
      assertEquals("z", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive2() throws Throwable  {
      // Given: A valid XPath expression "y8U5!(:MRpRm!,H|`y"
      XPathLexer xPathLexer = new XPathLexer("y8U5!(:MRpRm!,H|`y");
      
      // When: The next token is requested from the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then: The returned token should be of type IDENTIFIER and have the value "y8U5"
      assertEquals(15, nextToken.getTokenType()); // TokenType.IDENTIFIER
      assertEquals("y8U5", nextToken.getTokenText()); // The textual representation of the token
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive3() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer("x[Bt:e!Pi`;CZ^");
      Token nextToken = xPathLexer.nextToken();
      // Asserts that the next token has a text value of "x" and a token type of 15 (XPATH_IDENTIFIER).
      assertEquals("x", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive4() throws Throwable  {
      // Given: we have an instance of XPathLexer with a string input "vOeN^\"a+=`\"H]\bmk]i".
      XPathLexer xPathLexer = new XPathLexer("vOeN^\"a+=`\"H]\bmk]i");
      
      // When: we call the nextToken method on the lexer.
      Token nextToken = xPathLexer.nextToken();
      
      // Then: we expect the tokenText to be "vOeN" and the tokenType to be 15.
      assertEquals("vOeN", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive5() throws Throwable  {
      // Given a XPathLexer object with input "u"
      XPathLexer xPathLexer = new XPathLexer("u");
      
      // When we call nextToken() on the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then we expect to get a token of type 15 and with text "u"
      assertEquals(15, nextToken.getTokenType());
      assertEquals("u", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive6() throws Throwable  {
      // Given a XPath expression "tyCGm-mt"
      XPathLexer xPathLexer = new XPathLexer("tyCGm-mt");
      
      // When the next token is retrieved from the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token text should be "tyCGm-mt"
      assertEquals("tyCGm-mt", nextToken.getTokenText());
      
      // And the token type should be XPATH_EXPRESSION
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive7() throws Throwable  {
      // Given an XPath expression "s$di"
      XPathLexer xPathLexer = new XPathLexer("s$di");
      
      // When the next token is retrieved from the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token text should be "s" and the token type should be 15 (string)
      assertEquals("s", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive8() throws Throwable  {
      // Given an XPathLexer with a valid input string
      String input = "r?>>,SV;*eeL";
      XPathLexer lexer = new XPathLexer(input);
      
      // When the nextToken method is called
      Token nextToken = lexer.nextToken();
      
      // Then the method should return a valid token
      assertNotNull(nextToken);
      assertEquals("r", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive9() throws Throwable  {
      // Given: A XPath lexer is created with a valid input string
      XPathLexer xPathLexer = new XPathLexer("qwUM-pLHL;@a~qQF");
      
      // When: The next token is retrieved from the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then: The token should be of type IDENTIFIER and have the correct text
      assertEquals(15, nextToken.getTokenType());
      assertEquals("qwUM-pLHL", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive10() throws Throwable  {
      // Given an XPath lexer with input "jO+nt';~"
      XPathLexer xpathLexer = new XPathLexer("jO+nt';~");
      
      // When the next token is retrieved
      Token nextToken = xpathLexer.nextToken();
      
      // Then the token text should be "jO" and the token type should be 15
      assertEquals("jO", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive11() throws Throwable  {
      // Create a new instance of the XPathLexer class with the input string "hU]"
      XPathLexer xPathLexer = new XPathLexer("hU]");
      
      // Call the nextToken method on the lexer to get the next token
      Token nextToken = xPathLexer.nextToken();
      
      // Assert that the token type is 15 (i.e., a variable)
      assertEquals(15, nextToken.getTokenType());
      
      // Assert that the token text is "hU"
      assertEquals("hU", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive12() throws Throwable  {
      // Given a XPathLexer instance with an invalid input string
      XPathLexer xPathLexer = new XPathLexer("g!<");
      
      // When the nextToken method is called
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token type should be 15 and the token text should be "g"
      assertEquals(15, nextToken.getTokenType());
      assertEquals("g", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive13() throws Throwable  {
      // Given a string of XPath query
      String xpathQuery = "f;N4W58n";
      
      // When we create an instance of XPathLexer and pass in the query
      XPathLexer lexer = new XPathLexer(xpathQuery);
      
      // Then we should be able to get the next token from the lexer
      Token nextToken = lexer.nextToken();
      
      // And that token should have a type of "f" (the first character in the query)
      assertEquals(15, nextToken.getTokenType());
      
      // And its text should be the entire string "f;N4W58n"
      assertEquals("f", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive14() throws Throwable  {
      // Given an XPathLexer instance and a string representing an XPath expression,
      // when the nextToken method is called on the lexer,
      // then the method should return the next token in the stream of tokens.
      XPathLexer xPathLexer = new XPathLexer("euO9");
      Token nextToken = xPathLexer.nextToken();
      
      // Assert that the returned token is a NUMBER token with the correct value.
      assertEquals(15, nextToken.getTokenType()); // Token type should be NUMBER
      assertEquals("euO9", nextToken.getTokenText()); // Token text should match the input string
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHasMoreCharsReturningFalse() throws Throwable  {
      // Given a new instance of the XPathLexer with the input string "com.werken.saxpath.XPathLexer"
      XPathLexer xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      
      // When the nextToken method is called on the XPathLexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token type should be 15 (i.e., the token type for a keyword)
      assertEquals(15, nextToken.getTokenType());
      
      // And the token text should be "com.werken.saxpath.XPathLexer"
      assertEquals("com.werken.saxpath.XPathLexer", nextToken.getTokenText());
      
      // And there should be no more characters left in the input string
      boolean moreChars = xPathLexer.hasMoreChars();
      assertFalse(moreChars);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive15() throws Throwable  {
      // Given a XPath expression "aX71U$=7sT8jnF77;n0"
      String xpath = "aX71U$=7sT8jnF77;n0";
      
      // When the XPathLexer is created with this expression
      XPathLexer lexer = new XPathLexer(xpath);
      
      // And a next token is requested from the lexer
      Token nextToken = lexer.nextToken();
      
      // Then the next token should be of type IDENTIFIER and have text "aX71U"
      assertEquals(15, nextToken.getTokenType());
      assertEquals("aX71U", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsNegative1() throws Throwable  {
      // Given an XPathLexer instance with a valid input string
      XPathLexer xPathLexer = new XPathLexer("`Lgtjb-TCu4;MHO!d4");
      
      // When the nextToken method is called on the XPathLexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then the returned token should have the expected token text
      assertEquals("`Lgtjb-TCu4;MHO!d4", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive16() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("_8H 5(]`gFoW@");
      Token nextToken = xPathLexer.nextToken();
      assertEquals(15, nextToken.getTokenType());
      assertEquals("_8H", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsNegative2() throws Throwable  {
      // Arrange
      XPathLexer xPathLexer = new XPathLexer("^HuQ|Poq#9);O?+M>");
      
      // Act
      Token nextToken = xPathLexer.nextToken();
      
      // Assert
      assertEquals("^HuQ|Poq#9);O?+M>", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndIdentifierOrOperatorNameReturningNull0() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer("][ $BzIfqk`#Jp");
      xPathLexer.nextToken();
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      // Assert that the token is not an identifier or operator name
      assertNotNull(identifierOrOperatorName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive17() throws Throwable  {
      // Create a new XPathLexer with the input string "Z"
      XPathLexer xPathLexer = new XPathLexer("Z");
      
      // Call the nextToken method and assert that the token text is equal to "Z"
      Token nextToken = xPathLexer.nextToken();
      assertEquals("Z", nextToken.getTokenText());
      
      // Assert that the token type is equal to 15 (the value of the XPATH_TOKEN_TYPE constant)
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive18() throws Throwable  {
      // Given an XPath expression "Y:E+h$/+4+A5X b"
      String xpathExpression = "Y:E+h$/+4+A5X b";
      
      // When the XPathLexer is created with the expression
      XPathLexer xPathLexer = new XPathLexer(xpathExpression);
      
      // Then the next token should be a string token with value "Y"
      Token nextToken = xPathLexer.nextToken();
      assertEquals(15, nextToken.getTokenType()); // Check that the token is of type STRING
      assertEquals("Y", nextToken.getTokenText()); // Check that the token text is "Y"
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive19() throws Throwable  {
      // Test that the XPathLexer correctly tokenizes a valid XPath expression
      XPathLexer xPathLexer = new XPathLexer("XA bx3$!:qeEAw}JZ");
      Token nextToken = xPathLexer.nextToken();
      // Verify that the first token is "XA" and its type is 15 (a valid XPath token)
      assertEquals("XA", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive20() throws Throwable  {
      // Create an instance of the XPathLexer with a valid input string
      XPathLexer xPathLexer = new XPathLexer("W7:80Ct]&@L3%!jc}H");
      
      // Call the nextToken() method and store the result in a variable
      Token nextToken = xPathLexer.nextToken();
      
      // Assert that the token text is "W7"
      assertEquals("W7", nextToken.getTokenText());
      
      // Assert that the token type is 15 (WORD)
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive21() throws Throwable  {
      // Given a XPath lexer with input string "V<)|QN"
      XPathLexer xPathLexer = new XPathLexer("V<)|QN");
      
      // When the next token is requested
      Token nextToken = xPathLexer.nextToken();
      
      // Then the lexer should return the token "V" with type 15
      assertEquals("V", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive22() throws Throwable  {
      // Given a XPath expression "U?>>92ZV&;*eueL"
      XPathLexer xPathLexer = new XPathLexer("U?>>92ZV&;*eueL");
      
      // When the next token is retrieved from the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token text should be "U" and its type should be 15 (IDENTIFIER)
      assertEquals("U", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive23() throws Throwable  {
      // Given a valid XPath expression "TrW~"
      XPathLexer xPathLexer = new XPathLexer("TrW~");
      
      // When the lexer is asked for the next token
      Token nextToken = xPathLexer.nextToken();
      
      // Then the resulting token should have the expected token text and type
      assertEquals("TrW", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive24() throws Throwable  {
      // Arrange
      XPathLexer xPathLexer = new XPathLexer("R9mD[");
      
      // Act
      Token nextToken = xPathLexer.nextToken();
      
      // Assert
      assertEquals(15, nextToken.getTokenType()); // 15 is the type of token for a literal string in XPath
      assertEquals("R9mD", nextToken.getTokenText()); // The text value of the token is "R9mD"
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive25() throws Throwable  {
      // Given: We have an XPath lexer with a valid input string
      XPathLexer xPathLexer = new XPathLexer("PA@9Y6*O+,");
      
      // When: We call the nextToken() method to get the next token from the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then: The returned token should be a NUMBER token with value 15
      assertEquals(15, nextToken.getTokenType());
      
      // And: The token text should be "PA"
      assertEquals("PA", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive26() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("O$Zxros7{PcdY{");
      Token nextToken = xPathLexer.nextToken();
      assertEquals(15, nextToken.getTokenType());
      assertEquals("O", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive27() throws Throwable  {
      // Initialize the XPathLexer with a valid input string
      XPathLexer lexer = new XPathLexer("NLbz]zaX]h3V4|{*F");
      
      // Call the nextToken method to retrieve the next token from the input string
      Token nextToken = lexer.nextToken();
      
      // Check that the token text is "NLbz" and its type is 15 (see XPathLexer for more details on token types)
      assertEquals("NLbz", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPreviousTokenReturningTokenWhereGetTokenTypeIsPositive() throws Throwable  {
      // Given a XPathLexer instance initialized with the input string "M3XD"
      XPathLexer xPathLexer = new XPathLexer("M3XD");
      
      // When the nextToken method is called on the lexer
      xPathLexer.nextToken();
      
      // Then the previous token should have the expected type and text
      Token previousToken = xPathLexer.getPreviousToken();
      assertEquals(15, previousToken.getTokenType());
      assertEquals("M3XD", previousToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive28() throws Throwable  {
      // Test the XPath lexer's ability to handle a valid XPath expression
      XPathLexer xPathLexer = new XPathLexer("L7!<");
      Token nextToken = xPathLexer.nextToken();
      assertEquals(15, nextToken.getTokenType()); // Expecting a token of type 15 (identifying a variable name)
      assertEquals("L7", nextToken.getTokenText()); // Asserting the text of the token is "L7"
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndIdentifierOrOperatorNameReturningNull1() throws Throwable  {
      // Given a XPathLexer with an invalid input
      XPathLexer xPathLexer = new XPathLexer("K7:6yPJ*Xuj}");
      
      // When the nextToken method is called
      Token token = xPathLexer.nextToken();
      
      // Then the method should return null
      assertNull(token);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive29() throws Throwable  {
      // Given: A XPath expression containing a semicolon and an ampersand
      String xPathExpression = "I;GcWG}yQ%&JaR\"y|8";
      
      // When: The XPath expression is lexed using the XPathLexer class
      XPathLexer xPathLexer = new XPathLexer(xPathExpression);
      Token nextToken = xPathLexer.nextToken();
      
      // Then: The first token should be "I" with a token type of IDENTIFIER
      assertEquals("I", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive30() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer("G>");
      // Create an instance of the lexer with the input string "G>"
      
      Token nextToken = xPathLexer.nextToken();
      // Get the next token from the lexer
      
      assertEquals(15, nextToken.getTokenType());
      // Assert that the token type is 15 (i.e., greater than sign)
      
      assertEquals("G", nextToken.getTokenText());
      // Assert that the token text is "G"
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive31() throws Throwable  {
      // Given the input string "FaieCES06s"
      String input = "FaieCES06s";
      
      // When the XPathLexer is created with this input
      XPathLexer xPathLexer = new XPathLexer(input);
      
      // Then the next token returned should be "FaieCES06s"
      Token nextToken = xPathLexer.nextToken();
      assertEquals("FaieCES06s", nextToken.getTokenText());
      
      // And the token type should be 15
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testMinus() throws Throwable  {
      // Given a XPath expression "..wEMr7m"
      XPathLexer xPathLexer = new XPathLexer("..wEMr7m");
      
      // When the XPathLexer is used to parse the expression
      Token notEquals = xPathLexer.notEquals();
      Token minus = xPathLexer.minus();
      Token nextToken = xPathLexer.nextToken();
      
      // Then the tokens are parsed correctly and the expected types are returned
      assertEquals(22, notEquals.getTokenType());
      assertEquals("..", notEquals.getTokenText());
      
      assertEquals("w", minus.getTokenText());
      assertEquals(6, minus.getTokenType());
      
      assertEquals(15, nextToken.getTokenType());
      assertEquals("EMr7m", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive32() throws Throwable  {
      // Given: We have a XPathLexer object created with the input string "D!<"
      XPathLexer xPathLexer = new XPathLexer("D!<");
      
      // When: We call the nextToken() method on the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then: The returned token should have the expected properties
      assertEquals("D", nextToken.getTokenText()); // The token text should be "D"
      assertEquals(15, nextToken.getTokenType()); // The token type should be 15 (the token for "D")
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive33() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer("Caq*Vly@");
      // Given an input string "Caq*Vly@" that contains a valid XPath query
      Token nextToken = xPathLexer.nextToken();
      // When the tokenizer parses the input string
      assertEquals(15, nextToken.getTokenType()); // Then the lexer should return a token with type 15 (which is for an identifier) and text "Caq"
      assertEquals("Caq", nextToken.getTokenText()); // And the token's text should be "Caq"
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive34() throws Throwable  {
      // Given an XPathLexer object initialized with the string "AX"
      XPathLexer xPathLexer = new XPathLexer("AX");
      
      // When the nextToken() method is called on the XPathLexer object
      Token nextToken = xPathLexer.nextToken();
      
      // Then the token type should be 15 (the type for the "AX" token)
      assertEquals(15, nextToken.getTokenType());
      
      // And the token text should be "AX"
      assertEquals("AX", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierAndNot() throws Throwable  {
      // No Comments were added
      XPathLexer xPathLexer = new XPathLexer("wW8X}?lx,oq\"");
      Token identifier = xPathLexer.identifier();
      assertEquals(15, identifier.getTokenType());
      assertEquals("wW8X", identifier.getTokenText());
      
      Token not = xPathLexer.not();
      assertEquals(23, not.getTokenType());
      assertEquals("}", not.getTokenText());
      
      Token nextToken = xPathLexer.nextToken();
      assertEquals("?lx,oq\"", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndIdentifierOrOperatorNameReturningTokenWhereGetTokenTypeIsPositive0() throws Throwable  {
      // Test that the lexer returns the correct token type and text for a "<" operator
      XPathLexer xPathLexer = new XPathLexer("<>S-Q");
      Token nextToken = xPathLexer.nextToken();
      assertEquals(7, nextToken.getTokenType()); // Check that the token is of type "operator"
      assertEquals("<", nextToken.getTokenText()); // Check that the token text is "<"
      
      // Test that the lexer returns the correct token type and text for an empty identifier or operator name
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      assertEquals("", identifierOrOperatorName.getTokenText()); // Check that the token text is ""
      assertEquals(15, identifierOrOperatorName.getTokenType()); // Check that the token type is "empty"
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsNegative3() throws Throwable  {
      XPathLexer xpathLexer = new XPathLexer(";i5/");
      Token nextToken = xpathLexer.nextToken();
      // Assert that the token text matches the expected value
      assertEquals(";i5/", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive35() throws Throwable  {
      XPathLexer lexer = new XPathLexer("8f/ZQp\u0003D)4au9ERmB");
      Token token = lexer.nextToken();
      // Given an XPath expression "8f/ZQp\u0003D)4au9ERmB"
      assertEquals(30, token.getTokenType()); // Then the token type is 30 (number)
      assertEquals("8", token.getTokenText()); // And the token text is "8"
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndIdentifierOrOperatorNameReturningNull2() throws Throwable  {
      // Given
      XPathLexer xPathLexer = new XPathLexer("5a<z7Se:YkoR5.P4");
      
      // When
      xPathLexer.nextToken();
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      
      // Then
      assertNull(identifierOrOperatorName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive36() throws Throwable  {
      XPathLexer lexer = new XPathLexer("3?>>92ZV&;*eueL");
      // Given a string containing an XPath expression
      
      Token nextToken = lexer.nextToken();
      // When the lexer is asked for the next token in the expression
      
      assertEquals(30, nextToken.getTokenType());
      // Then the lexer should return a token with the type of "number" and the text "3"
      
      assertEquals("3", nextToken.getTokenText());
      // And the token's text should be the actual number 3
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive37() throws Throwable  {
      // Given a valid XPath expression "1w&_N0~d<P"
      XPathLexer xPathLexer = new XPathLexer("1w&_N0~d<P");
      
      // When the next token is extracted from the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then the extracted token should have the expected token text and type
      assertEquals("1", nextToken.getTokenText());
      assertEquals(30, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive38() throws Throwable  {
      // Given a string representing an XPath expression
      String xpathExpr = "0.GHnLPYg!7BAoEg~";
      
      // When the XPathLexer is created with this expression
      XPathLexer lexer = new XPathLexer(xpathExpr);
      
      // And the next token is retrieved
      Token nextToken = lexer.nextToken();
      
      // Then the token type should be 31 (a number)
      assertEquals(31, nextToken.getTokenType());
      
      // And the token text should be "0."
      assertEquals("0.", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsPositive39() throws Throwable  {
      // This test verifies that the XPathLexer correctly lexicalizes a simple XPath expression containing a decimal number
      XPathLexer xPathLexer = new XPathLexer(".0RC`CZI+`6CHeI");
      Token nextToken = xPathLexer.nextToken();
      assertEquals(31, nextToken.getTokenType()); // This assertion checks that the token type is correctly identified as a decimal number
      assertEquals(".0", nextToken.getTokenText()); // This assertion checks that the token text is correctly identified as the decimal number ".0"
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndIdentifierOrOperatorNameReturningTokenWhereGetTokenTypeIsPositive1() throws Throwable  {
      // Given: the XPathLexer class is initialized with a valid XPath expression string
      XPathLexer xPathLexer = new XPathLexer("(XbQG-HC6bJA_G(Y x5");
      
      // When: we call the nextToken() method on the XPathLexer object
      Token nextToken = xPathLexer.nextToken();
      
      // Then: the nextToken() method should return an instance of Token with a token text value of "("
      assertEquals("(", nextToken.getTokenText());
      
      // Given: we have called the identifierOrOperatorName() method on the XPathLexer object
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      
      // Then: the identifierOrOperatorName() method should return an instance of Token with a token text value of "XbQG-HC6bJA_G" and a token type of 15
      assertEquals("XbQG-HC6bJA_G", identifierOrOperatorName.getTokenText());
      assertNotNull(identifierOrOperatorName);
      assertEquals(15, identifierOrOperatorName.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsNegative4() throws Throwable  {
      // Tests for invalid XPath syntax
      XPathLexer xPathLexer = new XPathLexer("'(1;l");
      Token nextToken = xPathLexer.nextToken();
      
      // Given a string of invalid XPath syntax
      // When the lexer is created and the next token is requested
      // Then the token should be an error token with no text
      assertEquals((-1), nextToken.getTokenType());
      assertEquals("", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsNegative5() throws Throwable  {
      // Given a string representing an XPath expression
      String xPathExpression = "&Xt%L9r(%Dq";
      
      // When we create a new XPathLexer using this expression
      XPathLexer xPathLexer = new XPathLexer(xPathExpression);
      
      // Then the next token should be the same as the original expression
      Token nextToken = xPathLexer.nextToken();
      assertEquals("&Xt%L9r(%Dq", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsNegative6() throws Throwable  {
      // Test that the XPathLexer correctly tokenizes a simple string of characters
      XPathLexer xPathLexer = new XPathLexer("%J$;B,xb[)lF");
      
      // Given a string with special characters and numbers, when we create an instance of the XPathLexer,
      // Then the lexer should return a Token object with the original string value
      Token nextToken = xPathLexer.nextToken();
      assertEquals("%J$;B,xb[)lF", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndIdentifierOrOperatorNameReturningNull3() throws Throwable  {
      // Given a XPath lexer with an input string containing a quoted string with a special character (#)
      XPathLexer xPathLexer = new XPathLexer("\"#Z\"q}L.Mj3");
      
      // When the nextToken method is called to advance to the next token
      xPathLexer.nextToken();
      
      // Then the identifierOrOperatorName method should return null, since the input string is a quoted string and not a valid identifier or operator name
      assertNull(xPathLexer.identifierOrOperatorName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testNextTokenReturningTokenWhereGetTokenTypeIsNegative7() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer(" ");
      Token nextToken = xPathLexer.nextToken();
      assertEquals((-1), nextToken.getTokenType());
      assertEquals("", nextToken.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testConsumeTakingInt() throws Throwable  {
      // XPathLexer class is being instantiated with an input string.
      XPathLexer xPathLexer = new XPathLexer("n$/nSW4!b\t}");
      
      // consume() method is called on the XPathLexer object with a negative value.
      xPathLexer.consume((-2231));
      
      // currentPosition() method is called to get the current position of the lexer after consuming the input string.
      int currentPosition = xPathLexer.currentPosition();
      
      // Assert that the current position of the lexer matches the negative value passed as an argument to the consume() method.
      assertEquals((-2231), currentPosition);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndIdentifierOrOperatorNameReturningTokenWhereGetTokenTypeIsPositive2() throws Throwable  {
      // Given: The XPathLexer is instantiated with the string "-8"
      XPathLexer xPathLexer = new XPathLexer("-8");
      
      // When: The nextToken method is called on the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then: The resulting token should be a minus sign and have a token type of 6
      assertEquals("-", nextToken.getTokenText());
      assertEquals(6, nextToken.getTokenType());
      
      // Given: The identifierOrOperatorName method is called on the lexer
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      
      // Then: The resulting token should be an identifier or operator name and have a token type of 15
      assertEquals(15, identifierOrOperatorName.getTokenType());
      
      // Then: The text of the token should be "8"
      assertEquals("8", identifierOrOperatorName.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndIdentifierOrOperatorNameReturningTokenWhereGetTokenTypeIsPositive3() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("* }#D");
      Token nextToken = xPathLexer.nextToken();
      assertEquals(20, nextToken.getTokenType());
      assertEquals("*", nextToken.getTokenText());
      
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      assertEquals("", identifierOrOperatorName.getTokenText());
      assertEquals(15, identifierOrOperatorName.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndIdentifierOrOperatorNameReturningNull4() throws Throwable  {
      // Given
      String invalidInput = ") (";
      XPathLexer xPathLexer = new XPathLexer(invalidInput);
      
      // When
      Token identifierOrOperatorName = xPathLexer.nextToken();
      
      // Then
      assertNull(identifierOrOperatorName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testEquals() throws Throwable  {
      // Given a XPath lexer with an input string "com.werken.saxpath.XPathLexer"
      XPathLexer xPathLexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      
      // When the equals method is called on the lexer with an argument "c"
      Token arg0 = xPathLexer.equals();
      
      // Then the previous token should be set to the current token
      xPathLexer.setPreviousToken(arg0);
      
      // And the current token should have the correct text and type
      assertEquals("c", arg0.getTokenText());
      assertEquals(21, arg0.getTokenType());
      
      // When the next token is requested from the lexer
      Token nextToken = xPathLexer.nextToken();
      
      // Then the next token should have the correct text and type
      assertEquals("om.werken.saxpath.XPathLexer", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndIdentifierOrOperatorNameReturningTokenWhereGetTokenTypeIsPositive4() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("$VK}X(6kL&*C/");
      Token nextToken = xPathLexer.nextToken();
      assertEquals("$", nextToken.getTokenText());
      assertEquals(26, nextToken.getTokenType());
      
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      assertEquals("VK", identifierOrOperatorName.getTokenText());
      assertEquals(15, identifierOrOperatorName.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetPreviousTokenReturningNull() throws Throwable  {
      // Given a previously written JUnit test that uses the XPathLexer class to analyze an XML document
      XPathLexer xPathLexer = new XPathLexer();
      
      // When the previous token is retrieved from the lexer
      Token previousToken = xPathLexer.getPreviousToken();
      
      // Then the previous token should be null, as there are no tokens in the document yet
      assertNull(previousToken);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndIdentifierOrOperatorNameReturningNull5() throws Throwable  {
      // Given
      XPathLexer xPathLexer = new XPathLexer("!YBFr");
      
      // When
      xPathLexer.nextToken();
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      
      // Then
      assertNull(identifierOrOperatorName);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRightBracket() throws Throwable  {
      // Given a XPathLexer with input "com.werken.saxpath.XPathLexer"
      XPathLexer lexer = new XPathLexer("com.werken.saxpath.XPathLexer");
      
      // When the rightBracket method is called on the XPathLexer
      Token token = lexer.rightBracket();
      
      // Then the returned Token should have a token type of 4 and text "c"
      assertEquals(4, token.getTokenType());
      assertEquals("c", token.getTokenText());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testDoubleColon() throws Throwable  {
      // Given: The XPathLexer class is initialized with a string input of ".Jiz".
      XPathLexer xPathLexer = new XPathLexer(".Jiz");
      
      // When: The doubleColon method is called on the XPathLexer object.
      Token doubleColon = xPathLexer.doubleColon();
      
      // Then: The token type of the returned token should be 19 and the token text should be ".J".
      assertEquals(19, doubleColon.getTokenType());
      assertEquals(".J", doubleColon.getTokenText());
      
      // When: The nextToken method is called on the XPathLexer object.
      Token nextToken = xPathLexer.nextToken();
      
      // Then: The token type of the returned token should be 15 and the token text should be "iz".
      assertEquals("iz", nextToken.getTokenText());
      assertEquals(15, nextToken.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLeftBracket() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer();
      Token leftBracket = xPathLexer.leftBracket();
      assertEquals(3, leftBracket.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testIdentifierOrOperatorNameAndIdentifierOrOperatorNameReturningTokenWhereGetTokenTypeIsPositive5() throws Throwable  {
      XPathLexer xPathLexer = new XPathLexer(":#[YvYY]Zyu");
      // Parse the input string and retrieve the next token
      Token nextToken = xPathLexer.nextToken();
      
      // Assert that the token text is ":"
      assertEquals(":", nextToken.getTokenText());
      
      // Assert that the token type is 18 (colon)
      assertEquals(18, nextToken.getTokenType());
      
      // Parse the input string and retrieve the identifier or operator name
      Token identifierOrOperatorName = xPathLexer.identifierOrOperatorName();
      
      // Assert that the identifier or operator name is empty ("")
      assertEquals("", identifierOrOperatorName.getTokenText());
      
      // Assert that the token type for the identifier or operator name is 15 (empty)
      assertEquals(15, identifierOrOperatorName.getTokenType());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testPipe() throws Throwable  {
      // Test the XPathLexer with a complex query
      XPathLexer xPathLexer = new XPathLexer("G>oHDs");
      
      // Check that the pipe token is correctly identified
      Token pipe = xPathLexer.pipe();
      assertEquals(17, pipe.getTokenType()); // 17 is the token type for "|"
      assertEquals("G", pipe.getTokenText()); // "G" is the first part of the query
      
      // Check that the relational operator is correctly identified
      Token relationalOperator = xPathLexer.relationalOperator();
      assertNotNull(relationalOperator); // Make sure the relational operator was found
      assertEquals(9, relationalOperator.getTokenType()); // 9 is the token type for ">"
      assertEquals(">", relationalOperator.getTokenText()); // ">" is the text of the relational operator
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testLeftParen() throws Throwable  {
      // rollbacked to evosuite
      XPathLexer xPathLexer = new XPathLexer("\"#Z\"q}L.Mj3");
      Token leftParen = xPathLexer.leftParen();
      assertEquals("\"", leftParen.getTokenText());
      assertEquals(1, leftParen.getTokenType());
  }
}
