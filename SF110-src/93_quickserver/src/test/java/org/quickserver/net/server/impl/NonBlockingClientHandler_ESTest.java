/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Thu Mar 14 11:15:40 GMT 2024
 */

package org.quickserver.net.server.impl;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Timeout;
import java.util.concurrent.TimeUnit;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.PipedInputStream;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;
import java.util.logging.Logger;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import org.quickserver.net.server.ClientEvent;
import org.quickserver.net.server.ClientWriteHandler;
import org.quickserver.net.server.DataMode;
import org.quickserver.net.server.DataType;
import org.quickserver.net.server.QuickServer;
import org.quickserver.net.server.TheClient;
import org.quickserver.net.server.impl.NonBlockingClientHandler;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class NonBlockingClientHandler_ESTest extends NonBlockingClientHandler_ESTest_scaffolding {

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testWaitTillFullyWritten() throws Throwable  {
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      // Undeclared exception!
      try { 
        nonBlockingClientHandler.waitTillFullyWritten();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testUpdateInputOutputStreams() throws Throwable  {
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(65536);
      // Undeclared exception!
      try { 
        nonBlockingClientHandler.updateInputOutputStreams();
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Null charset name
         //
         verifyException("java.nio.charset.Charset", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRegisterWrite() throws Throwable  {
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      // Undeclared exception!
      try { 
        nonBlockingClientHandler.registerWrite();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRegisterForRead() throws Throwable  {
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      // Undeclared exception!
      try { 
        nonBlockingClientHandler.registerForRead();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testHandleClient() throws Throwable  {
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      TheClient arg0 = new TheClient();
      QuickServer arg0 = new QuickServer();
      arg0.setServer(arg0);
      nonBlockingClientHandler.handleClient(arg0);
      assertEquals("<ClientHandler-Pool#-1-ID:577>", nonBlockingClientHandler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReadInputStream() throws Throwable  {
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      byte[] arg0 = new byte[7];
      ByteArrayInputStream arg0 = new ByteArrayInputStream(arg0, (byte)3, (byte)9);
      nonBlockingClientHandler.setInputStream(arg0);
      nonBlockingClientHandler.readInputStream();
      assertEquals("<ClientHandler-Pool#-1-ID:568>", nonBlockingClientHandler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetWakeupSelectorAfterRegisterRead() throws Throwable  {
      NonBlockingClientHandler.setWakeupSelectorAfterRegisterRead(false);
      boolean wakeupSelectorAfterRegisterRead = NonBlockingClientHandler.getWakeupSelectorAfterRegisterRead();
      assertFalse(wakeupSelectorAfterRegisterRead);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetThreadAccessCountReturningNegative() throws Throwable  {
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      nonBlockingClientHandler.returnThread();
      int threadAccessCount = nonBlockingClientHandler.getThreadAccessCount();
      assertEquals("<ClientHandler-Pool#-1-ID:521>", nonBlockingClientHandler.getName());
      assertEquals((-1), threadAccessCount);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetSelectionKey() throws Throwable  {
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(1521);
      // Undeclared exception!
      try { 
        nonBlockingClientHandler.getSelectionKey();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClean0() throws Throwable  {
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      nonBlockingClientHandler.clean();
      assertEquals("<ClientHandler-Pool#-1-ID:495>", nonBlockingClientHandler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetSocketChannel() throws Throwable  {
      // rollbacked to evosuite
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(5);
      nonBlockingClientHandler.getSocketChannel();
      assertEquals("<ClientHandler-Pool#5-ID:22>", nonBlockingClientHandler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRegisterForWriteThrowsIllegalStateException() throws Throwable  {
      // Given: A non-blocking client handler with a null client write handler
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      
      // When: The method registerForWrite is called without setting the client write handler first
      try {
      nonBlockingClientHandler.registerForWrite();
      } catch (IllegalStateException e) {
      // Then: An IllegalStateException should be thrown indicating that the client write handler has not been set
      verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetDataMode0() throws Throwable  {
      // Given a NonBlockingClientHandler instance with a Logger set as its appLogger
      NonBlockingClientHandler handler = new NonBlockingClientHandler();
      Logger global = Logger.getGlobal();
      handler.appLogger = global;
      
      // When the method setDataMode is called with arguments DataMode.BYTE and DataType.OUT
      handler.setDataMode(DataMode.BYTE, DataType.OUT);
      
      // Then the name of the NonBlockingClientHandler should be "<ClientHandler-Pool#-1-ID:453>"
      assertEquals("<ClientHandler-Pool#-1-ID:453>", handler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetDataModeThrowsNullPointerException() throws Throwable  {
      // rollbacked to evosuite
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      DataType arg1 = DataType.OUT;
      Logger global = Logger.getGlobal();
      nonBlockingClientHandler.appLogger = global;
      DataMode arg0 = DataMode.OBJECT;
      // Undeclared exception!
      try { 
        nonBlockingClientHandler.setDataMode(arg0, arg1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetDataMode1() throws Throwable  {
      // rollbacked to evosuite
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      DataType arg1 = DataType.OUT;
      Logger global = Logger.getGlobal();
      nonBlockingClientHandler.appLogger = global;
      QuickServer quickServer = new QuickServer();
      DataMode arg0 = quickServer.getDefaultDataMode(arg1);
      nonBlockingClientHandler.setDataMode(arg0, arg1);
      assertEquals("<ClientHandler-Pool#-1-ID:404>", nonBlockingClientHandler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetDataMode2() throws Throwable  {
      // Given a NonBlockingClientHandler instance with a global logger
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      Logger globalLogger = Logger.getGlobal();
      nonBlockingClientHandler.appLogger = globalLogger;
      
      // When the setDataMode method is called with a DataMode argument
      DataMode arg0 = DataMode.BINARY;
      nonBlockingClientHandler.setDataMode(arg0, DataType.OUT);
      
      // Then the name of the NonBlockingClientHandler instance should be "<ClientHandler-Pool#-1-ID:384>"
      assertEquals("<ClientHandler-Pool#-1-ID:384>", nonBlockingClientHandler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetDataModeWithNull() throws Throwable  {
      // Given a NonBlockingClientHandler instance with a pool size of 5
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(5);
      
      // And a data mode of OUT
      DataType arg1 = DataType.OUT;
      
      // When the setDataMode method is called with null and the OUT direction
      nonBlockingClientHandler.setDataMode((DataMode) null, arg1);
      
      // Then the name of the NonBlockingClientHandler should be "<ClientHandler-Pool#5-ID:14>"
      assertEquals("<ClientHandler-Pool#5-ID:14>", nonBlockingClientHandler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testReturnClientHandler() throws Throwable  {
      // rollbacked to evosuite
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      nonBlockingClientHandler.returnThread();
      nonBlockingClientHandler.returnClientHandler();
      assertEquals((-1), nonBlockingClientHandler.getThreadAccessCount());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCheckReturnClientHandler() throws Throwable  {
      // Given a NonBlockingClientHandler instance
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      
      // When we check if the returned client handler is the same as the previous one
      boolean checkReturnClientHandler = nonBlockingClientHandler.checkReturnClientHandler();
      
      // Then the returned client handler should be different from the previous one
      assertNotEquals(nonBlockingClientHandler, checkReturnClientHandler);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCreatesNonBlockingClientHandlerTakingInt() throws Throwable  {
      // Given: A NonBlockingClientHandler with an id of 5
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(5);
      
      // When: The run method is called on the NonBlockingClientHandler
      nonBlockingClientHandler.run();
      
      // Then: The name of the NonBlockingClientHandler should be "<ClientHandler-Pool#5-ID:6>"
      assertEquals("<ClientHandler-Pool#5-ID:6>", nonBlockingClientHandler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCloseIfSSLOutboundDoneThrowsIllegalStateException() throws Throwable  {
      // rollbacked to evosuite
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      // Undeclared exception!
      try { 
        nonBlockingClientHandler.closeIfSSLOutboundDone();
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Client is not in secure mode!
         //
         verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCloseIfSSLOutboundDoneThrowsNullPointerException() throws Throwable  {
      // Given: A NonBlockingClientHandler instance has been created
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      
      // When: The secure flag is set to true
      nonBlockingClientHandler.setSecure(true);
      
      // Then: An exception is thrown when attempting to close the connection if the SSL outbound done flag has been set
      try {
      // This method throws a NullPointerException if the SSL outbound done flag has not been set
      nonBlockingClientHandler.closeIfSSLOutboundDone();
      
      // Failure: An exception is expected but was not thrown
      fail("Expecting exception: NullPointerException");
      } catch (NullPointerException e) {
      // Verify that the expected exception has been thrown
      verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCloseConnection() throws Throwable  {
      // Given a NonBlockingClientHandler object
      NonBlockingClientHandler handler = new NonBlockingClientHandler();
      
      // When the closeConnection method is called
      handler.closeConnection();
      
      // Then the connection should be closed
      assertTrue(handler.isClosed());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testCloseConnectionThrowsNullPointerException() throws Throwable  {
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      // Given that we have a valid instance of NonBlockingClientHandler
      
      nonBlockingClientHandler.connection = true;
      // And the connection is initialized and set to true
      
      try {
      nonBlockingClientHandler.closeConnection();
      fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      // When we call closeConnection() on the NonBlockingClientHandler instance
      
      // Then an exception should be thrown, specifically a NullPointerException
      verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetInputStreamWithNull() throws Throwable  {
      // Given a new NonBlockingClientHandler instance
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      
      // When dataMode is set to BYTE
      DataMode dataMode = DataMode.BYTE;
      nonBlockingClientHandler.dataModeIN = dataMode;
      
      // And the input stream is set to null
      nonBlockingClientHandler.setInputStream((InputStream) null);
      
      // Then the name of the NonBlockingClientHandler instance should be "<ClientHandler-Pool#-1-ID:220>"
      assertEquals("<ClientHandler-Pool#-1-ID:220>", nonBlockingClientHandler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetInputStream() throws Throwable  {
      // Given
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      DataMode dataMode = DataMode.STRING;
      
      // When
      nonBlockingClientHandler.dataModeIN = dataMode;
      PipedInputStream pipedInputStream = new PipedInputStream();
      nonBlockingClientHandler.setInputStream(pipedInputStream);
      
      // Then
      assertEquals("ClientHandler-Pool#-1-ID:213", nonBlockingClientHandler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testClean1() throws Throwable  {
      // Given a non-blocking client handler with 53 threads accessing it
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      nonBlockingClientHandler.threadAccessCount = 53;
      
      // When the clean method is called on the non-blocking client handler
      nonBlockingClientHandler.clean();
      
      // Then the thread access count should be set to 0
      assertEquals(0, nonBlockingClientHandler.getThreadAccessCount());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMaxThreadAccessCountReturningNegative() throws Throwable  {
      // Set the maximum number of threads to -1
      NonBlockingClientHandler.setMaxThreadAccessCount(-1);
      
      // Verify that the maximum number of threads is -1
      int maxThreadAccessCount = NonBlockingClientHandler.getMaxThreadAccessCount();
      assertEquals(-1, maxThreadAccessCount);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetMaxThreadAccessCountThrowsIllegalArgumentException() throws Throwable  {
      // No Comments were added
      // Undeclared exception!
      try { 
        NonBlockingClientHandler.setMaxThreadAccessCount((-974));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Value should be >=3 or -1
         //
         verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);
      }
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetMaxThreadAccessCountWithPositive() throws Throwable  {
      // Given a non-blocking client handler with a maximum thread access count of 10
      NonBlockingClientHandler handler = new NonBlockingClientHandler();
      handler.setMaxThreadAccessCount(10);
      
      // When the maximum thread access count is set to a value greater than 10
      int maxThreadAccessCount = 20;
      handler.setMaxThreadAccessCount(maxThreadAccessCount);
      
      // Then the maximum thread access count should be updated to the new value
      assertEquals(maxThreadAccessCount, handler.getMaxThreadAccessCount());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testRun() throws Throwable  {
      // Given a NonBlockingClientHandler instance with a RUN_BLOCKING event added
      NonBlockingClientHandler handler = new NonBlockingClientHandler();
      ClientEvent event = ClientEvent.RUN_BLOCKING;
      handler.addEvent(event);
      
      // When the run() method is called on the handler
      handler.run();
      
      // Then the willClean field should be set to true
      assertTrue(handler.getWillClean());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetSelectionKey() throws Throwable  {
      // Create a new NonBlockingClientHandler instance
      NonBlockingClientHandler handler = new NonBlockingClientHandler();
      
      // Set the selection key to null
      handler.setSelectionKey(null);
      
      // Verify that the name of the handler is correct
      assertEquals("<ClientHandler-Pool#-1-ID:77>", handler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetBufferedReaderThrowsIllegalStateException() throws Throwable  {
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      
      // Given: A NonBlockingClientHandler instance
      
      try {
      // When: Calling getBufferedReader method
      nonBlockingClientHandler.getBufferedReader();
      
      // Then: An IllegalStateException is thrown as expected
      fail("Expecting exception: IllegalStateException");
      } catch(IllegalStateException e) {
      // Verify that the expected exception is thrown with the correct message
      verifyException("org.quickserver.net.server.impl.NonBlockingClientHandler", e);}
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetWakeupSelectorAfterRegisterWrite() throws Throwable  {
      // Set the wakeup selector after register write flag to false
      NonBlockingClientHandler.setWakeupSelectorAfterRegisterWrite(false);
      
      // Verify that the flag is set correctly
      boolean wakeupSelectorAfterRegisterWrite = NonBlockingClientHandler.getWakeupSelectorAfterRegisterWrite();
      assertFalse(wakeupSelectorAfterRegisterWrite);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetThreadAccessCountReturningZero() throws Throwable  {
      // Given: A new NonBlockingClientHandler instance
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      
      // When: The getThreadAccessCount method is called on the instance
      int threadAccessCount = nonBlockingClientHandler.getThreadAccessCount();
      
      // Then: The returned value should be zero
      assertEquals(0, threadAccessCount);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetSocketChannel() throws Throwable  {
      // Given a NonBlockingClientHandler with 5 connections in the pool
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler(5);
      
      // When a SocketChannel is set to the NonBlockingClientHandler
      nonBlockingClientHandler.setSocketChannel((SocketChannel) null);
      
      // Then the name of the NonBlockingClientHandler should be "<ClientHandler-Pool#5-ID:1>"
      assertEquals("<ClientHandler-Pool#5-ID:1>", nonBlockingClientHandler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetBlockingMode() throws Throwable  {
      // Given a NonBlockingClientHandler instance in non-blocking mode
      NonBlockingClientHandler handler = new NonBlockingClientHandler();
      boolean blockingMode = handler.getBlockingMode();
      assertEquals("<ClientHandler-Pool#-1-ID:52>", handler.getName());
      
      // When the getBlockingMode() method is called
      boolean result = handler.getBlockingMode();
      
      // Then the result should be false, indicating that the NonBlockingClientHandler is in non-blocking mode
      assertFalse(result);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testSetClientWriteHandler() throws Throwable  {
      // Given: a new instance of NonBlockingClientHandler
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      
      // When: setting the client write handler to null
      nonBlockingClientHandler.setClientWriteHandler(null);
      
      // Then: the name of the nonBlockingClientHandler should be "<ClientHandler-Pool#-1-ID:46>"
      assertEquals("<ClientHandler-Pool#-1-ID:46>", nonBlockingClientHandler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetWakeupSelectorAfterRegisterWriteReturningTrue() throws Throwable  {
      // Given
      NonBlockingClientHandler handler = new NonBlockingClientHandler();
      
      // When
      boolean wakeupSelectorAfterRegisterWrite = handler.getWakeupSelectorAfterRegisterWrite();
      
      // Then
      assertTrue(wakeupSelectorAfterRegisterWrite);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetInitialHandshakeStatus() throws Throwable  {
      // Given a new instance of NonBlockingClientHandler
      NonBlockingClientHandler nonBlockingClientHandler = new NonBlockingClientHandler();
      
      // When the initial handshake status is retrieved
      boolean initialHandshakeStatus = nonBlockingClientHandler.getInitialHandshakeStatus();
      
      // Then the name of the client handler should be "<ClientHandler-Pool#-1-ID:31>"
      assertEquals("<ClientHandler-Pool#-1-ID:31>", nonBlockingClientHandler.getName());
      
      // And the initial handshake status should be false
      assertFalse(initialHandshakeStatus);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testFinalize() throws Throwable  {
      // Given a new NonBlockingClientHandler instance
      NonBlockingClientHandler handler = new NonBlockingClientHandler();
      
      // When the finalize method is called on the handler
      handler.finalize();
      
      // Then the name of the handler should be "<ClientHandler-Pool#-1-ID:1>"
      assertEquals("<ClientHandler-Pool#-1-ID:1>", handler.getName());
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetWakeupSelectorAfterRegisterReadReturningTrue() throws Throwable  {
      // Given
      NonBlockingClientHandler handler = new NonBlockingClientHandler();
      
      // When
      boolean wakeupSelectorAfterRegisterRead = handler.getWakeupSelectorAfterRegisterRead();
      
      // Then
      assertTrue(wakeupSelectorAfterRegisterRead);
  }

  @Test
  @Timeout(value = 4000 , unit = TimeUnit.MILLISECONDS)
  public void testGetMaxThreadAccessCountReturningPositive() throws Throwable  {
      // Given: A non-blocking client handler
      NonBlockingClientHandler handler = new NonBlockingClientHandler();
      
      // When: The maximum number of threads to access the handler is retrieved
      int maxThreadAccessCount = handler.getMaxThreadAccessCount();
      
      // Then: The correct maximum number of threads is returned
      assertEquals(5, maxThreadAccessCount);
  }
}
