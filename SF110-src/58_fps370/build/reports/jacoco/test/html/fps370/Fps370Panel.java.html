<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Fps370Panel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">58_fps370</a> &gt; <a href="index.source.html" class="el_package">fps370</a> &gt; <span class="el_source">Fps370Panel.java</span></div><h1>Fps370Panel.java</h1><pre class="source lang-java linenums">/**
 * Fps370Panel
 * 3D game template panel
 *
 * Created for cpsc370 at Chapman University
 * http://www.gamedev370.com
 * (c) copyright 2006 - W. Wood Harter
 *
 * Licensed under GNU General Public License
 * http://www.gnu.org
 *
 * This is the main panel for fps370.
 * This needs to be refactored into a bunch of subclasses.
 **
 * In order to run this you will have to download the Milkshap model loader
 * http://home.earthlink.net/~kduling/Milkshape/
 * Place the MS3DLoader-1.0.8.jar in the fps370/lib/ext directory.
 */
package fps370;

import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import java.io.*;
import java.util.*;
import javax.media.j3d.*;
import javax.swing.*;
import javax.vecmath.*;

import com.sun.j3d.utils.universe.*;
import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.image.*;
import com.sun.j3d.utils.behaviors.mouse.*;
import com.sun.j3d.utils.picking.*;

import com.sun.j3d.loaders.*;
//import com.mnstarfire.loaders3d.Loader3DS; 
import com.glyphein.j3d.loaders.milkshape.MS3DLoader;
import teder.*;

public class Fps370Panel extends JPanel implements KeyListener
  {
  // parent window
  Fps370 parent;
  
  // 3d frame and universe
  SimpleUniverse su;
  Canvas3D c3d;
 
  // scene graph to display
  BranchGroup bgMain;
  
  TransformGroup tgFloor;
  AxisAngle4f    aaFloor;
  Transform3D    t3dFloorRotate;
  
  // temporary holding variables
  Transform3D t3dTmp;
  Transform3D t3dTmp2;
  Vector3f v3fTmp;
  Vector3f v3fTmp2;
  Vector3f v3fTmp3;
  Matrix4f m3fTmp1;
  Matrix4f m3fTmp2;
  
  BoundingSphere boundsMain;
  
  Sphere         sphere;
  TransformGroup tgSphere;
  Transform3D t3dSphereTranslate;
<span class="fc" id="L71">  Vector3f vSphereVel = new Vector3f(0.0f,0.0f,0.0f);</span>
<span class="fc" id="L72">  Vector3f vSpherePos = new Vector3f(6.5f,3.2f,5.0f);</span>
            
<span class="fc" id="L74">  Vector3f vViewPos = new Vector3f(0.0f,0.5f,5.0f);</span>
<span class="fc" id="L75">  Vector3f vViewOri = new Vector3f(0.0f,1.0f,1.0f);</span>

  private static final float TILE_WIDTH = 1.0f;
  private static final int NUM_TILE_TEXTURES = 10;
  Appearance tileTextures[];
  Appearance textureStone;
  TederLayer tl;
  TederData td;

  TransformGroup tgView;
  Transform3D t3dYPR; // the current YPR rotation
  AxisAngle4f aaYPR; // temporary calculatiosn for YPR changes
<span class="fc" id="L87">  float lookUpAngle=5.0f; // the angle to look in the viewport</span>
  private static final float TURNDELTA = 0.5f;
  
  boolean keyLeft;
  boolean keyRight;
  boolean keyForward;
  boolean keyBackward;
  boolean keyStrafeLeft;
  boolean keyStrafeRight;
  boolean keyLookUp;
  boolean keyLookDown;
  
  // mouse movement
  int diffx,diffy;
  int lastMouseX,lastMouseY;
  int offcenterX,offcenterY;
  Robot robot;
  
  // collision detection with map
  BranchGroup bgMap;
  PickCylinderRay pickCylinder;
  PickTool pickTool;
  
  
  // HUD
  PlatformGeometry bgHud;
  Point3f hudPlane[];
  Appearance appHud;
  Shape3D shapeHud;
  Texture2D textureHud;
  ImageComponent2D icHud; // the 2d texture image 
  HudUpdater hudUpdater;
  Image imgHudBack;
  BufferedImage imgHud;
  
  public Fps370Panel(Fps370 parentInit)
<span class="fc" id="L123">    {</span>
<span class="fc" id="L124">    parent = parentInit;</span>
    
<span class="fc" id="L126">    setLayout(new BorderLayout());</span>
    
<span class="fc" id="L128">    setPreferredSize(new Dimension(800,600));</span>
    
<span class="nc" id="L130">    GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();</span>
<span class="nc" id="L131">    c3d = new Canvas3D(config);</span>
<span class="nc" id="L132">    add(&quot;Center&quot;, c3d);</span>
   
    // allow the canvas to get focus and give it focus
<span class="nc" id="L135">    c3d.setFocusable(true);</span>
<span class="nc" id="L136">    c3d.requestFocus();</span>
   
<span class="nc" id="L138">    c3d.addKeyListener(this);</span>
    
<span class="nc" id="L140">    su = new SimpleUniverse(c3d);</span>
   
<span class="nc" id="L142">    t3dTmp = new Transform3D();</span>
<span class="nc" id="L143">    t3dTmp2 = new Transform3D();</span>
<span class="nc" id="L144">    v3fTmp = new Vector3f(0,0,0);</span>
<span class="nc" id="L145">    v3fTmp2 = new Vector3f(0,0,0);</span>
<span class="nc" id="L146">    v3fTmp3 = new Vector3f(0,0,0);</span>
<span class="nc" id="L147">    m3fTmp1 = new Matrix4f();</span>
<span class="nc" id="L148">    m3fTmp2 = new Matrix4f();</span>
    //m3fYPR = new Matrix4f();
<span class="nc" id="L150">    t3dYPR = new Transform3D();</span>
<span class="nc" id="L151">    aaYPR = new AxisAngle4f();</span>
    
    try
      {
<span class="nc" id="L155">      robot = new Robot();</span>
      }
<span class="nc" id="L157">    catch (AWTException e)</span>
      {
<span class="nc" id="L159">      e.printStackTrace();</span>
<span class="nc" id="L160">      }</span>
    
<span class="nc" id="L162">    td = new TederData(30,30,64,64,&quot;images/floor/tiles.gif&quot;,this);</span>
<span class="nc" id="L163">    loadTileTextures();</span>
    
<span class="nc" id="L165">    createSceneGraph();</span>
    
<span class="nc" id="L167">    initViewPosition();</span>
    
<span class="nc" id="L169">    }</span>
  
  // create appearances with each individual tile
  // used to texture the individual floor tiles
  public void loadTileTextures()
    {
<span class="nc" id="L175">    tileTextures = new Appearance[NUM_TILE_TEXTURES];</span>
    
    int i;
<span class="nc bnc" id="L178" title="All 2 branches missed.">    for (i=0;i&lt;NUM_TILE_TEXTURES;i++)</span>
      {
<span class="nc" id="L180">      tileTextures[i] = new Appearance();</span>

      // mix the texture and the material colour
<span class="nc" id="L183">      TextureAttributes ta = new TextureAttributes();</span>
      //ta.setTextureMode(TextureAttributes.MODULATE);
<span class="nc" id="L185">      ta.setTextureMode(TextureAttributes.REPLACE);</span>
<span class="nc" id="L186">      tileTextures[i].setTextureAttributes(ta);</span>

      // load and set the texture
<span class="nc" id="L189">      TextureLoader loader = new TextureLoader(&quot;images/floor/tile&quot;+i+&quot;.jpg&quot;, null);</span>
      //TextureLoader loader = new TextureLoader(&quot;images/floor/stone.jpg&quot;, null);
<span class="nc" id="L191">      Texture2D texture = (Texture2D) loader.getTexture();</span>
<span class="nc" id="L192">      tileTextures[i].setTexture(texture);      // set the texture</span>

      // set a default white material
<span class="nc" id="L195">      Material mat = new Material();</span>
<span class="nc" id="L196">      mat.setLightingEnable(true);    // lighting switched on</span>
<span class="nc" id="L197">      tileTextures[i].setMaterial(mat);</span>
      }
    
<span class="nc" id="L200">    textureStone = new Appearance();</span>

    // the default texture if one isn't given (ie. -1)
      // mix the texture and the material colour
<span class="nc" id="L204">      TextureAttributes ta = new TextureAttributes();</span>
      //ta.setTextureMode(TextureAttributes.MODULATE);
<span class="nc" id="L206">      ta.setTextureMode(TextureAttributes.REPLACE);</span>
<span class="nc" id="L207">      textureStone.setTextureAttributes(ta);</span>

      // load and set the texture
<span class="nc" id="L210">      TextureLoader loader = new TextureLoader(&quot;images/floor/stone.jpg&quot;, null);</span>
      //TextureLoader loader = new TextureLoader(&quot;images/floor/stone.jpg&quot;, null);
<span class="nc" id="L212">      Texture2D texture = (Texture2D) loader.getTexture();</span>
<span class="nc" id="L213">      textureStone.setTexture(texture);      // set the texture</span>

      // set a default white material
<span class="nc" id="L216">      Material mat = new Material();</span>
<span class="nc" id="L217">      mat.setLightingEnable(true);    // lighting switched on</span>
<span class="nc" id="L218">      textureStone.setMaterial(mat);</span>
<span class="nc" id="L219">    }</span>
 
  public Scene loadModel(String fname)
  {
<span class="nc" id="L223">    Scene theScene = null;</span>
    // setup a file name &quot;fileName&quot;
    try
    {

      //Loader3DS loader = new Loader3DS();
      // optional options to be used
      //loader.setLogging(true); // turns on writing a log file
      //loader.setDetail(7); // sets level of detail of report log
      //loader.setTextureLightingOn(); // turns on texture modulate mode
      //loader.setTexturePath(&quot;models&quot;); // optional alternate path to find texture files
      // loader.noTextures(); // if you do not want to load textures
      //theScene = loader.load(fname);
      
      // milkshape loader
<span class="nc" id="L238">      File file = new java.io.File(fname);</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">      if (file.getParent().length() &gt; 0) // figure out the base path</span>
      {
<span class="nc" id="L241">        Loader loader = new MS3DLoader(MS3DLoader.LOAD_ALL);</span>
<span class="nc" id="L242">        loader.setBasePath(file.getParent() + java.io.File.separator);</span>
<span class="nc" id="L243">        theScene = loader.load(file.getName());</span>
        //BranchGroup group = scene.getSceneGroup();
      }
      
      // load a sphere model twice for testing
      
    }
<span class="nc" id="L250">    catch(FileNotFoundException fnf)</span>
    {
      // Couldn't find the file you requested - deal with it!
<span class="nc" id="L253">      fnf.printStackTrace();</span>
<span class="nc" id="L254">    }</span>
    
<span class="nc" id="L256">    return theScene;</span>
  }
  
  public void createSceneGraph()
    {
    // create a new scene branch
<span class="nc" id="L262">    bgMain = new BranchGroup();</span>
<span class="nc" id="L263">    boundsMain = new BoundingSphere(new Point3d(0,0,0),300);</span>
    
<span class="nc" id="L265">    createLights();</span>

    // create the temporary location for sphere translation - used in tick
    
    // create a sphere
<span class="nc" id="L270">    t3dSphereTranslate = new Transform3D();</span>
<span class="nc" id="L271">    t3dSphereTranslate.set(vSpherePos);</span>
<span class="nc" id="L272">    tgSphere = new TransformGroup(t3dSphereTranslate);</span>
<span class="nc" id="L273">    tgSphere.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);</span>
<span class="nc" id="L274">    tgSphere.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);</span>
<span class="nc" id="L275">    sphere = new Sphere(1.0f);</span>
<span class="nc" id="L276">    tgSphere.addChild(sphere);</span>
    
    // allow picking on the sphere
<span class="nc" id="L279">    PickTool.setCapabilities(sphere.getShape(),PickTool.INTERSECT_COORD);</span>

<span class="nc" id="L281">    bgMain.addChild(tgSphere);</span>
    
    // create the floor
    /*
     * I sort of decided to only use models to build the map
    aaFloor = new AxisAngle4f(0.0f, 1.0f, 0.0f, 0.0f);
    t3dFloorRotate = new Transform3D();
    t3dFloorRotate.setRotation(aaFloor);
    tgFloor = new TransformGroup();
    tgFloor.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);
    tgFloor.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
    tgFloor.setTransform(t3dFloorRotate);
    

    // add a floor tile
    addFloorTiles(tgFloor);
    bgMain.addChild(tgFloor);
    
    addFloorTiles(tgFloor);
    */
 
<span class="nc" id="L302">    ViewingPlatform vp = su.getViewingPlatform();</span>
<span class="nc" id="L303">    tgView = vp.getViewPlatformTransform();   // view point TG</span>

<span class="nc" id="L305">    KeyUpBehavior bup = new KeyUpBehavior(this);   </span>
<span class="nc" id="L306">    bup.setSchedulingBounds( boundsMain );</span>
<span class="nc" id="L307">    bgMain.addChild( bup );</span>

<span class="nc" id="L309">    KeyDownBehavior bdn = new KeyDownBehavior(this);   </span>
<span class="nc" id="L310">    bdn.setSchedulingBounds( boundsMain );</span>
<span class="nc" id="L311">    bgMain.addChild( bdn );</span>
    
<span class="nc" id="L313">    MouseMoveBehavior mmb = new MouseMoveBehavior(this);   </span>
<span class="nc" id="L314">    mmb.setSchedulingBounds( boundsMain );</span>
<span class="nc" id="L315">    bgMain.addChild( mmb );</span>
      
    // create the ticker behavior for the scene
<span class="nc" id="L318">    Fps370Ticker tt = new Fps370Ticker(20,this);</span>
<span class="nc" id="L319">    tt.setSchedulingBounds(boundsMain);</span>
<span class="nc" id="L320">    bgMain.addChild(tt);</span>
    
    // get the temple model
<span class="nc" id="L323">    Scene sc = loadModel(&quot;./models/map2.ms3d&quot;);</span>
    // need to scale the model some, then slide it up and towards the origin
    
    // allow picking on the cube for collision detection
<span class="nc" id="L327">    bgMap = sc.getSceneGroup();</span>
    //bgModel.setPickable(true);
<span class="nc" id="L329">    pickableModel(bgMap);</span>
    //PickTool.setCapabilities(bgModel,PickTool.INTERSECT_COORD);
<span class="nc" id="L331">    bgMain.addChild(bgMap);</span>
    
    // used to see aim location during debugging
    //addPickCylinder();
    
    // add the hud to the display
<span class="nc" id="L337">    addHud();</span>
    
<span class="nc" id="L339">    bgMain.compile();</span>
    
<span class="nc" id="L341">    su.addBranchGraph(bgMain);</span>
<span class="nc" id="L342">    }</span>
  
  // changes all the faces on a give model to allow picking
  private void pickableModel(BranchGroup bg)
  {
    // go through the model and set each Shape3D to pickable
<span class="nc" id="L348">    Enumeration e = bg.getAllChildren();</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">    while (e.hasMoreElements())</span>
    {
<span class="nc" id="L351">      Object o = e.nextElement();</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">      if (o instanceof Shape3D)</span>
      {
<span class="nc" id="L354">        PickTool.setCapabilities((Shape3D)o,PickTool.INTERSECT_COORD);</span>
        
        // need to also get normals for collision detection
<span class="nc" id="L357">        ((Shape3D)o).getGeometry().setCapability(GeometryArray.ALLOW_NORMAL_READ);</span>
      }
<span class="nc" id="L359">    }</span>
<span class="nc" id="L360">  }</span>
  
  // adds a hud image to the viewing platform
  public void addHud()
  {
<span class="nc" id="L365">    ViewingPlatform vp = su.getViewingPlatform();</span>

<span class="nc" id="L367">    bgHud = new PlatformGeometry();</span>

    // create a plane to add the hud image to
<span class="nc bnc" id="L370" title="All 2 branches missed.">    if (hudPlane==null)</span>
    {
<span class="nc" id="L372">      hudPlane = new Point3f[4];</span>
      
      // these coordinates were created with trial and error
<span class="nc" id="L375">      hudPlane[0] = new Point3f(-0.29f,-0.22f,-0.7f);</span>
<span class="nc" id="L376">      hudPlane[1] = new Point3f(0.304f,-0.22f,-0.7f);</span>
<span class="nc" id="L377">      hudPlane[2] = new Point3f(0.304f,-0.1f,-0.7f);</span>
<span class="nc" id="L378">      hudPlane[3] = new Point3f(-0.29f,-0.1f,-0.7f);</span>
      
      // create a 4 point quad array (a plane)
<span class="nc" id="L381">      QuadArray qaHud = new QuadArray(4,       GeometryArray.COORDINATES | </span>
                                               GeometryArray.TEXTURE_COORDINATE_2 |
                                               GeometryArray.NORMALS);

<span class="nc" id="L385">      qaHud.setCoordinates(0, hudPlane);</span>
      
      // assign texture coords to each quad
      // counter-clockwise, from bottom left
<span class="nc" id="L389">      TexCoord2f[] tcoords = new TexCoord2f[4];</span>
<span class="nc" id="L390">      tcoords[0] = new TexCoord2f(0.0f, 0.0f);   // for 1 point</span>
<span class="nc" id="L391">      tcoords[1] = new TexCoord2f(1.0f, 0.0f);</span>
<span class="nc" id="L392">      tcoords[2] = new TexCoord2f(1.0f, 1.0f);</span>
<span class="nc" id="L393">      tcoords[3] = new TexCoord2f(0.0f, 1.0f);</span>
<span class="nc" id="L394">      qaHud.setTextureCoordinates(0, 0, tcoords);</span>
      
      // set the surface normal
<span class="nc" id="L397">      Vector3f upNorm = new Vector3f(0.0f, 1.0f, 0.0f);   // pointing up</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">      for(int i=0; i &lt; 4; i++)</span>
<span class="nc" id="L399">        qaHud.setNormal(i, upNorm);</span>
      
<span class="nc" id="L401">      shapeHud = new Shape3D();</span>
<span class="nc" id="L402">      shapeHud.setGeometry(qaHud);</span>

<span class="nc" id="L404">      appHud = new Appearance();</span>

      // the texture blends with color on shape
<span class="nc" id="L407">      TransparencyAttributes  ta = new TransparencyAttributes ();</span>
<span class="nc" id="L408">      ta.setTransparencyMode(TransparencyAttributes.BLENDED);</span>
<span class="nc" id="L409">      appHud.setTransparencyAttributes(ta);</span>

      // need to load the hud background
<span class="nc" id="L412">      Toolkit tk = Toolkit.getDefaultToolkit();</span>
<span class="nc" id="L413">      imgHudBack = tk.getImage(&quot;images/hud/hud2.gif&quot;);</span>
      // set up the media tracker to wait for the image
<span class="nc" id="L415">      MediaTracker tracker = new MediaTracker(this);</span>
<span class="nc" id="L416">      tracker.addImage(imgHudBack,0);</span>

      // wait for the image to load
      try
        {
<span class="nc" id="L421">        tracker.waitForID(0);</span>
        }
<span class="nc" id="L423">      catch (InterruptedException e)</span>
        {
<span class="nc" id="L425">        e.printStackTrace();</span>
<span class="nc" id="L426">        }</span>
    
      // create the hud offscreen image
<span class="nc" id="L429">      imgHud = new BufferedImage(imgHudBack.getWidth(this),imgHudBack.getHeight(this),BufferedImage.TYPE_4BYTE_ABGR);</span>
<span class="nc" id="L430">      drawHudImage();</span>
      
      // load and set the texture
      // we specify by reference so we can update the image dynamically
<span class="nc" id="L434">      TextureLoader loader = new TextureLoader(imgHud,TextureLoader.BY_REFERENCE);</span>
<span class="nc" id="L435">      textureHud = (Texture2D) loader.getTexture();</span>
<span class="nc" id="L436">      icHud = (ImageComponent2D) textureHud.getImage(0);</span>
<span class="nc" id="L437">      appHud.setTexture(textureHud);      // set the texture</span>
<span class="nc" id="L438">      hudUpdater = new HudUpdater(this);</span>
      
      // set a default white material
      //Material mat = new Material();
      //mat.setLightingEnable(true);    // lighting switched on
      //appHud.setMaterial(mat);
      
<span class="nc" id="L445">      shapeHud.setAppearance(appHud);</span>
<span class="nc" id="L446">      icHud.setCapability(ImageComponent.ALLOW_IMAGE_WRITE);</span>
<span class="nc" id="L447">      bgHud.addChild(shapeHud);</span>
<span class="nc" id="L448">      vp.setPlatformGeometry(bgHud);</span>
    }
<span class="nc" id="L450">  }</span>
  
  // draw the hud background image
  public void drawHudImage()
  {
      // a test
      //imgHud = new BufferedImage(imgHudBack.getWidth(this),imgHudBack.getHeight(this),BufferedImage.TYPE_4BYTE_ABGR);
      // a test
      
      
<span class="nc" id="L460">      Graphics gtmp = imgHud.getGraphics();</span>
<span class="nc" id="L461">      gtmp.drawImage(imgHudBack,0,0,this);</span>
      //gtmp.drawLine(0,0,100,100);
<span class="nc" id="L463">      String stmp = &quot;X=&quot;+vViewPos.x+&quot; Y=&quot;+vViewPos.y+&quot; Z=&quot;+vViewPos.z;</span>
<span class="nc" id="L464">      gtmp.drawString(stmp,10,imgHudBack.getHeight(this)-20);</span>
      //System.out.println(&quot;strtmp=&quot;+stmp);
<span class="nc" id="L466">  }</span>
  
  public void updateHud()
  {
<span class="nc" id="L470">    icHud.updateData(hudUpdater,0,0,imgHudBack.getWidth(this),imgHudBack.getHeight(this));</span>
<span class="nc" id="L471">  }</span>
  
  // test routine which adds a cylinder to the view platform to
  // give an idea as to where a &quot;weapon&quot; is pointing.
  public void addPickCylinder()
  {
<span class="nc" id="L477">    ViewingPlatform vp = su.getViewingPlatform();</span>
<span class="nc" id="L478">    tgView = vp.getViewPlatformTransform();   // view point TG</span>

<span class="nc" id="L480">    PlatformGeometry bgPickCyl = new PlatformGeometry();</span>
<span class="nc" id="L481">    t3dTmp.rotX(Math.toRadians(90.0f));</span>
<span class="nc" id="L482">    v3fTmp.set(0.0f,0.0f,1.0f);</span>
<span class="nc" id="L483">    t3dTmp2.set(v3fTmp);</span>
<span class="nc" id="L484">    t3dTmp.mul(t3dTmp2);</span>
<span class="nc" id="L485">    TransformGroup tgPickCyl = new TransformGroup(t3dTmp);</span>
<span class="nc" id="L486">    tgPickCyl.addChild(new Cylinder(0.05f,300.0f));</span>
<span class="nc" id="L487">    bgPickCyl.addChild(tgPickCyl);</span>

<span class="nc" id="L489">    vp.setPlatformGeometry(bgPickCyl);</span>
    
<span class="nc" id="L491">  }</span>

 /*
  public void loadFloorData()
    {
    tl = new TederLayer(30,30);
    td.doLoadSingleLayer(tl,&quot;tiles.dat&quot;);
    }
    
  public void addFloorTiles(TransformGroup tgParent)
    {
    loadFloorData();
    
    ArrayList al = new ArrayList(4);
    float tilex = 0.0f;
    float tilez = 0.0f;
    Point3f p1 = new Point3f(tilex,      0.0f,   tilez+TILE_WIDTH);
    Point3f p2 = new Point3f(tilex+TILE_WIDTH, 0.0f,   tilez+TILE_WIDTH);
    Point3f p3 = new Point3f(tilex+TILE_WIDTH, 0.0f,   tilez);
    Point3f p4 = new Point3f(tilex,      0.0f,   tilez);   
    al.add(p1); al.add(p2);  
    al.add(p3); al.add(p4);  
   
    // width is the x direction
    // height is the +z direction
    int i,j;
    int idx = 0;
    for (i=0;i&lt;tl.wid;i++)
      {
      tilex = 0.0f;
      for (j=0;j&lt;tl.hei;j++)
        {
        // change the points, they are already inside the array list
        p1.set(tilex,0.0f,tilez+TILE_WIDTH);
        p2.set(tilex+TILE_WIDTH,0.0f,tilez+TILE_WIDTH);
        p3.set(tilex+TILE_WIDTH,0.0f,tilez);
        p4.set(tilex,0.0f,tilez);
        
        // only add the tile if it has a texture
        if (tl.tiles[idx]&gt;=0)
          tgFloor.addChild(new Tile(al,tl.tiles[idx]));
        else
          tgFloor.addChild(new Tile(al,-1));
        tilex = tilex + TILE_WIDTH;
        idx++;
        }
      tilez = tilez + TILE_WIDTH;
      }
    
    }
  public void addFloorCoords(ArrayList al)
    {
    float x = -0.5f;
    float z = -0.5f;
    // points created in counter-clockwise order
    Point3f p1 = new Point3f(x,      0.0f,   z+5.0f);
    Point3f p2 = new Point3f(x+5.0f, 0.0f,   z+5.0f);
    Point3f p3 = new Point3f(x+5.0f, 0.0f,   z);
    Point3f p4 = new Point3f(x,      0.0f,   z);   
    al.add(p1); al.add(p2);  
    al.add(p3); al.add(p4);  
    }
  
      class Tile extends Shape3D
        {
        private QuadArray tile;
        private int itexture;
        
        public Tile(ArrayList alCoords,int itextureInit)
          {
          itexture = itextureInit;
          Vector3f upNorm = new Vector3f(0.0f, 1.0f, 0.0f);   // pointing up
          
          tile = new QuadArray(alCoords.size(),GeometryArray.COORDINATES | 
                                               GeometryArray.TEXTURE_COORDINATE_2 |
                                               GeometryArray.NORMALS);
          Point3f[] points = new Point3f[alCoords.size()];
          alCoords.toArray( points );
          tile.setCoordinates(0, points);
 
          // assign texture coords to each quad
          // counter-clockwise, from bottom left
          TexCoord2f[] tcoords = new TexCoord2f[alCoords.size()];
          for(int i=0; i &lt; alCoords.size(); i=i+4) 
            {
            tcoords[i] = new TexCoord2f(0.0f, 0.0f);   // for 1 point
            tcoords[i+1] = new TexCoord2f(1.0f, 0.0f);
            tcoords[i+2] = new TexCoord2f(1.0f, 1.0f);
            tcoords[i+3] = new TexCoord2f(0.0f, 1.0f);
            }
          tile.setTextureCoordinates(0, 0, tcoords);
         
          // set the surface normal
          for(int i=0; i &lt; alCoords.size(); i++)
            tile.setNormal(i, upNorm);
            
          setGeometry(tile);
          
          Appearance app = new Appearance();

          if (itexture&gt;=0)
            setAppearance(tileTextures[itexture]);
          else
            setAppearance(textureStone);

          }
        }
*/    
  public void createLights()
    {
    // simple ambient white light
<span class="nc" id="L602">    Color3f cWhite = new Color3f(1.0f,1.0f,1.0f);</span>
    
<span class="nc" id="L604">    AmbientLight amb = new AmbientLight(cWhite);</span>
<span class="nc" id="L605">    amb.setInfluencingBounds(boundsMain);</span>
<span class="nc" id="L606">    bgMain.addChild(amb);</span>
    
    // add one directional light pointing straight down
<span class="nc" id="L609">    Vector3f vLight1 = new Vector3f(-1.0f,1.0f,-1.0f);</span>
<span class="nc" id="L610">    DirectionalLight light = new DirectionalLight(cWhite,vLight1);</span>
<span class="nc" id="L611">    light.setInfluencingBounds(boundsMain);</span>
<span class="nc" id="L612">    light.setDirection(new Vector3f(1.0f,-1.0f,1.0f));</span>
<span class="nc" id="L613">    bgMain.addChild(light);</span>
<span class="nc" id="L614">    }</span>
  
  public void initViewPosition()
    {
<span class="nc" id="L618">    ViewingPlatform vp = su.getViewingPlatform();</span>
<span class="nc" id="L619">    TransformGroup tgView = vp.getViewPlatformTransform();</span>
    
<span class="nc" id="L621">    Transform3D t3d = new Transform3D();</span>
    
    // setup the initial yaw pitch roll
<span class="nc" id="L624">    t3d.rotY(Math.toRadians(-90.0));</span>
<span class="nc" id="L625">    t3dYPR.mul(t3d);</span>

    // set the initial view position and orientation
<span class="nc" id="L628">    t3d.set(t3dYPR);</span>
<span class="nc" id="L629">    t3dTmp2.set(vViewPos);</span>
<span class="nc" id="L630">    t3d.mul(t3dTmp2);</span>
    
    //tgView.getTransform(t3d);
    
    // look at the origin, orient up
    //t3d.lookAt(vViewPos,new Point3d(0,0,0),vViewOri);
    //t3d.invert();
    
<span class="nc" id="L638">    tgView.setTransform(t3d);</span>
<span class="nc" id="L639">    }</span>
  
  public boolean adjustMoveDistance(Vector3f vMove)
  {
    // NOTE: I do not like creating the point3d and v3d everytime in this method
    // it will have problems with performance and will need to be addressed
    // WWH
    
    // create the pick tool on first distance check, reuse for all later checks
<span class="nc bnc" id="L648" title="All 2 branches missed.">    if (pickTool==null)</span>
    {
      // create the picktool to always use the map
<span class="nc" id="L651">      pickTool = new PickTool(bgMap);</span>
      /*
      pickCylinder = new PickCylinderRay(new Point3d(vViewPos.x,vViewPos.y,vViewPos.z), 
                                         new Vector3d(vMove.x,vMove.y,vMove.z), 
                                         0.10d);
      */
    }
      
    // set the shape of the pick tool as a ray from the current location
    // in the direction of the move
<span class="nc" id="L661">    pickTool.setShapeRay(new Point3d(vViewPos.x,vViewPos.y,vViewPos.z), </span>
                       new Vector3d(vMove.x,vMove.y,vMove.z));
    
    // get a pick to the closest shape
<span class="nc" id="L665">    PickResult res = pickTool.pickClosest();</span>
    
    // if we got a result, check for the closest intersection distance
<span class="nc bnc" id="L668" title="All 2 branches missed.">    if (res!=null)</span>
    {
      int j;
<span class="nc" id="L671">      float closestIntersect = 10000000.0f; // a big number just in case</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">      for (j=0;j&lt;res.numIntersections();j++)</span>
      {
<span class="nc bnc" id="L674" title="All 4 branches missed.">        if ((j==0) || (res.getIntersection(j).getDistance()&lt;closestIntersect))</span>
<span class="nc" id="L675">          closestIntersect = (float) res.getIntersection(j).getDistance();</span>
      }
    
      //System.out.println(&quot;closestIntersect = &quot;+closestIntersect);        
<span class="nc bnc" id="L679" title="All 2 branches missed.">      if (closestIntersect&lt;2.0)</span>
      {
        // collision, adjust accordingly
<span class="nc" id="L682">        vMove.set(0.0f,0.0f,0.0f);</span>

<span class="nc" id="L684">        return true;</span>
      }
      
    }    

<span class="nc" id="L689">    return false;</span>
  }
  
  public void checkSphereHit()
  {
<span class="nc" id="L694">    boolean didHit = true;</span>
    
    // we keep checking because one bounce may lead to another until we
    // are headed away from all the walls
<span class="nc bnc" id="L698" title="All 2 branches missed.">    while (didHit)</span>
    {
<span class="nc" id="L700">      didHit = false;</span>
      
      // we are sharing the pick tool
<span class="nc bnc" id="L703" title="All 2 branches missed.">      if (pickTool==null)</span>
      {
        // create the picktool to always use the map
<span class="nc" id="L706">        pickTool = new PickTool(bgMap);</span>
      }
      // check for collision with a wall
<span class="nc" id="L709">      pickTool.setShapeRay(new Point3d(vSpherePos.x,vSpherePos.y,vSpherePos.z), </span>
                         new Vector3d(vSphereVel.x,vSphereVel.y,vSphereVel.z));

      // get a pick to the closest shape
<span class="nc" id="L713">      PickResult res = pickTool.pickClosest();</span>

      // if we got a result, check for the closest intersection distance
<span class="nc bnc" id="L716" title="All 2 branches missed.">      if (res!=null)</span>
      {
        int j;
<span class="nc" id="L719">        float closestIntersect = 10000000.0f; // a big number just in case</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">        for (j=0;j&lt;res.numIntersections();j++)</span>
        {

<span class="nc bnc" id="L723" title="All 4 branches missed.">          if ((j==0) || (res.getIntersection(j).getDistance()&lt;closestIntersect))</span>
<span class="nc" id="L724">            closestIntersect = (float) res.getIntersection(j).getDistance();</span>
        }

        // bounce if we are going to move beyond the wall
<span class="nc" id="L728">        float magVel = vSphereVel.length();</span>
        //System.out.println(&quot;closestIntersect = &quot;+closestIntersect+&quot; velLen=&quot;+magVel);    
<span class="nc bnc" id="L730" title="All 2 branches missed.">        if (closestIntersect&lt;magVel)</span>
        {
          //System.out.println(&quot;sphere hit dist=&quot;+closestIntersect+&quot; node=&quot;+res.getObject());

          // need the surface normal for the object it just hit
<span class="nc" id="L735">          Node nd = res.getObject();</span>

          // we have it as a node, make sure it is a shape 3d
<span class="nc bnc" id="L738" title="All 2 branches missed.">          if (nd instanceof Shape3D)</span>
          {
<span class="nc" id="L740">            Shape3D sh = (Shape3D) nd;</span>
<span class="nc" id="L741">            Geometry geo = sh.getGeometry();</span>

            // we have the geometry, make sure it is a GeometryArray we can get a surface normal from
<span class="nc bnc" id="L744" title="All 2 branches missed.">            if (geo instanceof GeometryArray)</span>
            {
              // finally!, after all that, we can get the surface normal
              // just use the normal from the first vertex.
<span class="nc" id="L748">              ((GeometryArray)geo).getNormal(0,v3fTmp);</span>

              // get a unit vector from the velocity
              //v3fTmp3.normalize(vSphereVel);
              // I had to double normalize here because a 180 degree vector with value
              // = 0.99999994 caused the normal to not be unit length - very odd
<span class="nc" id="L754">              v3fTmp3.set(vSphereVel);</span>
<span class="nc" id="L755">              v3fTmp3.normalize();</span>
<span class="nc" id="L756">              v3fTmp3.normalize();</span>

              // get the dot product between the two
<span class="nc" id="L759">              float f = (float) v3fTmp.dot(v3fTmp3);</span>

              // -1 for the dot product means the vectors are parallel and 180 in direction
<span class="nc bnc" id="L762" title="All 2 branches missed.">              if (f==-1.0f)</span>
              {
                // direct hit, the vectors face each other exactly, just reverse the velocity
                //System.out.println(&quot;negate the velocity&quot;);
<span class="nc" id="L766">                vSphereVel.negate();</span>

                // subtract a little friction to make up for the fact that the
                // sphere didn't actually touch the wall
<span class="nc" id="L770">                vSphereVel.scale(0.90f);</span>

<span class="nc" id="L772">                didHit = true;</span>

                // set the sphere to that intersection point
                // WWH - exercise for later

              }
<span class="nc bnc" id="L778" title="All 2 branches missed.">              else  if (f&lt;0.0f)  // obtuse angle dot product - headed towards object</span>
              {
                /* now for the not so simple case of an arbitrary hit */
                /* dot &lt; 0.0 means we are headed towards the object (obtuse angle) */

                /* what we do here is rotate the velocity vector around the
                 * cross product of the two vectors
                 */
<span class="nc" id="L786">                v3fTmp2.cross(v3fTmp,v3fTmp3);            </span>
                //System.out.println(&quot;Normal = &quot;+v3fTmp+&quot;  vel=&quot;+vSphereVel+&quot; normvel=&quot;+v3fTmp3+&quot;  dot=&quot;+v3fTmp.dot(v3fTmp3)+&quot; cross=&quot;+v3fTmp2);

                // convert it to an angle
<span class="nc" id="L790">                f = (float) Math.toDegrees(Math.acos(f));</span>

                // ret ang is the angle from the surface normal and the new bounce/return angle
                // draw some pictures to decide why 180-f
<span class="nc" id="L794">                float retang = 180.0f - f;</span>

                // reflect the velocity as we will rotate that through the surface normal
<span class="nc" id="L797">                vSphereVel.negate();</span>
                
                // rotate that the angle between the normal *2
<span class="nc" id="L800">                float frot = retang * 2.0f;</span>

                // reusing the temporary AxisAngle that YPR uses
                //System.out.println(&quot;rot ang = &quot;+frot);
<span class="nc" id="L804">                aaYPR.set(v3fTmp2,(float)Math.toRadians(frot));</span>

                // create a matrix then transform with this rotate
<span class="nc" id="L807">                m3fTmp1.set(aaYPR);</span>
<span class="nc" id="L808">                t3dTmp.set(m3fTmp1);</span>

                // multiply the current velocity by that rotation
<span class="nc" id="L811">                t3dTmp.transform(vSphereVel);</span>

                // subtract a little friction to make up for the fact that the
                // sphere didn't actually touch the wall
                // otherwise the bounce gets larger and larger. This is a kludge
<span class="nc" id="L816">                vSphereVel.scale(0.90f);</span>

                //System.out.println(&quot; post bounce vel=&quot;+vSphereVel);

<span class="nc" id="L820">                didHit = true;</span>
              }
            }
            //System.out.println(&quot;is a shape3d &quot;+((Shape3D)nd).getGeometry());
          }
        } // closest intersect

      } // check pick result
<span class="nc" id="L828">    } // while didHit</span>
<span class="nc" id="L829">  }</span>
  
  public void tickSphere()
  { 
    // add some gravity to the sphere
<span class="nc" id="L834">    vSphereVel.y = vSphereVel.y - 0.05f;</span>

<span class="nc" id="L836">    checkSphereHit();</span>
    
    // add the current velocity to the sphere
<span class="nc" id="L839">    vSpherePos.add(vSphereVel);</span>

    // create a location translation transform for the sphere
<span class="nc" id="L842">    t3dTmp.setTranslation(vSpherePos);</span>
        
    // set the changed transform
<span class="nc" id="L845">    tgSphere.setTransform(t3dTmp);    </span>
<span class="nc" id="L846"> }</span>
    
  public void tick()
    {
<span class="nc" id="L850">    tickSphere();</span>
<span class="nc" id="L851">    updateHud();</span>
 
<span class="nc bnc" id="L853" title="All 4 branches missed.">    if ((keyForward==true) || (keyBackward==true))</span>
      {
<span class="nc bnc" id="L855" title="All 2 branches missed.">      if (keyForward)</span>
<span class="nc" id="L856">        v3fTmp.set(0.0f,0.0f,-1.0f);</span>
      else
<span class="nc" id="L858">        v3fTmp.set(0.0f,0.0f,1.0f);</span>
     
      // transform the unit vector
<span class="nc" id="L861">      t3dYPR.transform(v3fTmp);</span>
      
      // don't want a full unit, or it goes too fast
<span class="nc" id="L864">      v3fTmp.scale(0.1f);</span>
     
      // map collision detection
<span class="nc" id="L867">      adjustMoveDistance(v3fTmp);</span>

      // add that direction to the current position
<span class="nc" id="L870">      vViewPos.add(v3fTmp);</span>
      }
      
<span class="nc bnc" id="L873" title="All 2 branches missed.">    if (keyLeft == true)</span>
      {
      // create a vector in the y direction
<span class="nc" id="L876">      v3fTmp.set(0.0f,1.0f,0.0f);</span>
      
      // rotate that vector into the current orientation
<span class="nc" id="L879">      t3dYPR.transform(v3fTmp);</span>
      
      // create axis to rotate around that y axis in our orientation coordinate space
<span class="nc" id="L882">      aaYPR.set(v3fTmp,(float)Math.toRadians(TURNDELTA));</span>
      
      // set a temporary transform
<span class="nc" id="L885">      m3fTmp1.set(aaYPR);</span>
<span class="nc" id="L886">      t3dTmp.set(m3fTmp1);</span>
      
      // multiply the current view by that rotation
<span class="nc" id="L889">      t3dYPR.mul(t3dTmp);</span>
<span class="nc" id="L890">      t3dYPR.normalize();</span>
      }
<span class="nc bnc" id="L892" title="All 2 branches missed.">    if (keyRight == true) </span>
      {
      // create a vector in the y direction
<span class="nc" id="L895">      v3fTmp.set(0.0f,1.0f,0.0f);</span>
      
      // rotate that vector into the current orientation
<span class="nc" id="L898">      t3dYPR.transform(v3fTmp);</span>
      
      // create axis to rotate around that y axis in our orientation coordinate space
<span class="nc" id="L901">      aaYPR.set(v3fTmp,(float)-Math.toRadians(TURNDELTA));</span>
      
      // set a temporary transform
<span class="nc" id="L904">      m3fTmp1.set(aaYPR);</span>
<span class="nc" id="L905">      t3dTmp.set(m3fTmp1);</span>
      
      // multiply the current view by that rotation
<span class="nc" id="L908">      t3dYPR.mul(t3dTmp);</span>
<span class="nc" id="L909">      t3dYPR.normalize();</span>
      }
<span class="nc bnc" id="L911" title="All 2 branches missed.">    if (keyStrafeLeft == true)</span>
      {
      // movement in the -x direction
<span class="nc" id="L914">      v3fTmp.set(-1.0f,0.0f,0.0f);</span>
      
      // rotate that vector into the current orientation
<span class="nc" id="L917">      t3dYPR.transform(v3fTmp);</span>
      
      // don't want a full unit, or it goes too fast
<span class="nc" id="L920">      v3fTmp.scale(0.1f);</span>

      // map collision detection
<span class="nc" id="L923">      adjustMoveDistance(v3fTmp);</span>

      // add that direction to the current position
<span class="nc" id="L926">      vViewPos.add(v3fTmp);</span>
     }
     
<span class="nc bnc" id="L929" title="All 2 branches missed.">    if (keyStrafeRight == true)</span>
      {
      // movement in the x direction
<span class="nc" id="L932">      v3fTmp.set(1.0f,0.0f,0.0f);</span>
      
      // rotate that vector into the current orientation
<span class="nc" id="L935">      t3dYPR.transform(v3fTmp);</span>
      
      // don't want a full unit, or it goes too fast
<span class="nc" id="L938">      v3fTmp.scale(0.1f);</span>
      
      // map collision detection
<span class="nc" id="L941">      adjustMoveDistance(v3fTmp);</span>

      // add that direction to the current position
<span class="nc" id="L944">      vViewPos.add(v3fTmp);</span>
     }
   
<span class="nc bnc" id="L947" title="All 2 branches missed.">    if (keyLookDown == true)</span>
      {
<span class="nc" id="L949">      lookUpAngle = lookUpAngle+0.5f;</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">      if (lookUpAngle&gt;45.0f)</span>
<span class="nc" id="L951">        lookUpAngle=45.0f;</span>
      }
<span class="nc bnc" id="L953" title="All 2 branches missed.">    if (keyLookUp == true)</span>
      {
<span class="nc" id="L955">      lookUpAngle = lookUpAngle-0.5f;</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">      if (lookUpAngle&lt;-45.0f)</span>
<span class="nc" id="L957">        lookUpAngle = -45.0f;</span>
      }
   
    // set the temporary transform to the view/camera location
<span class="nc" id="L961">    t3dTmp.setIdentity();</span>
<span class="nc" id="L962">    t3dTmp.setTranslation(vViewPos);</span>

    // add the y lookup angle
    // create a vector in the x direction
<span class="nc" id="L966">    v3fTmp.set(1.0f,0.0f,0.0f);</span>
      
    // rotate that vector into the current orientation
<span class="nc" id="L969">    t3dYPR.transform(v3fTmp);</span>
      
    // create axis to rotate around that y axis in our orientation coordinate space
<span class="nc" id="L972">    aaYPR.set(v3fTmp,(float)-Math.toRadians(lookUpAngle));</span>
      
    // set a temporary transform
<span class="nc" id="L975">    m3fTmp1.set(aaYPR);</span>
<span class="nc" id="L976">    t3dTmp2.set(m3fTmp1);</span>
      
    // multiply the current view by that rotation
<span class="nc" id="L979">    t3dTmp.mul(t3dTmp2);</span>
    
    // multiply the transform by the current view orientation
<span class="nc" id="L982">    t3dTmp2.set(t3dYPR);</span>
<span class="nc" id="L983">    t3dTmp.mul(t3dTmp2);</span>
   
<span class="nc" id="L985">    tgView.setTransform(t3dTmp);</span>
<span class="nc" id="L986">    }</span>
  
  public void doFire()
  {
    // pick
<span class="nc" id="L991">    v3fTmp.set(0.0f,0.0f,-1.0f);</span>
    
    // rotate the pick vector into the current view
<span class="nc" id="L994">    t3dYPR.transform( v3fTmp );</span>
    
<span class="nc" id="L996">    PickCanvas pickCanvas = new PickCanvas(c3d, bgMain);</span>
<span class="nc" id="L997">    pickCanvas.setMode(PickTool.GEOMETRY_INTERSECT_INFO);</span>
<span class="nc" id="L998">    pickCanvas.setTolerance(4.0f);</span>
        
<span class="nc" id="L1000">    pickCanvas.setShapeLocation(getWidth()/2,getHeight()/2);</span>
<span class="nc" id="L1001">    PickResult[] results = pickCanvas.pickAll();</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">    if (results!=null)</span>
    {
      // find the closest object that we clicked on
      int i,j;
<span class="nc" id="L1006">      int idx=0;</span>
<span class="nc" id="L1007">      float dst=100000000.0f; // a big number just in case</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">      for (i=0;i&lt;results.length;i++)</span>
      {
<span class="nc" id="L1010">        float closestIntersect = 10000000.0f; // a big number just in case</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">        for (j=0;j&lt;results[i].numIntersections();j++)</span>
        {
<span class="nc bnc" id="L1013" title="All 4 branches missed.">          if ((j==0) || (results[i].getIntersection(j).getDistance()&lt;closestIntersect))</span>
<span class="nc" id="L1014">            closestIntersect = (float) results[i].getIntersection(j).getDistance();</span>
        }
        
<span class="nc bnc" id="L1017" title="All 4 branches missed.">        if ((i==0) || (closestIntersect&lt;dst))</span>
        {
<span class="nc" id="L1019">          idx = i;</span>
<span class="nc" id="L1020">          dst = closestIntersect;</span>
        }
      }
      
      // is the closest object the sphere
<span class="nc bnc" id="L1025" title="All 2 branches missed.">      if (results[idx].getObject()==sphere.getShape())</span>
      {
        // v3fTmp now contains the ray that we hit the sphere with
        // we need to change the ball's velocity with it
<span class="nc" id="L1029">        v3fTmp.normalize();</span>
        
<span class="nc" id="L1031">        vSphereVel.add(v3fTmp);</span>
      }
    }
    
<span class="nc" id="L1035">  }</span>
  
  public void keyPressed(KeyEvent e)
    { 
<span class="nc" id="L1039">    int keyCode = e.getKeyCode();</span>
<span class="nc bnc" id="L1040" title="All 6 branches missed.">    if ((keyCode == KeyEvent.VK_ESCAPE) || (keyCode == KeyEvent.VK_Q) ||</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">       ((keyCode == KeyEvent.VK_C) &amp;&amp; e.isControlDown()) ) </span>
      {
<span class="nc" id="L1043">      parent.dispose();</span>
<span class="nc" id="L1044">      System.exit(0);    // exit() alone isn't sufficient most of the time</span>
      }
<span class="nc" id="L1046">    }</span>
  public void keyReleased(KeyEvent e)
    {
<span class="nc" id="L1049">    }</span>
  public void keyTyped(KeyEvent e)
    {
<span class="nc" id="L1052">    }</span>
  
  protected void processKeyDown(int keycode)
    {
<span class="nc bnc" id="L1056" title="All 2 branches missed.">    if(keycode == KeyEvent.VK_W )</span>
<span class="nc" id="L1057">      keyForward = true;</span>
<span class="nc bnc" id="L1058" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_S)</span>
<span class="nc" id="L1059">      keyBackward = true;</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_LEFT)</span>
<span class="nc" id="L1061">      keyLeft = true;</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_RIGHT)</span>
<span class="nc" id="L1063">      keyRight = true;</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_A)</span>
<span class="nc" id="L1065">      keyStrafeLeft = true;</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_D)</span>
<span class="nc" id="L1067">      keyStrafeRight = true;</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_UP)</span>
<span class="nc" id="L1069">      keyLookUp = true;</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_DOWN)</span>
<span class="nc" id="L1071">      keyLookDown = true;</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_SPACE)</span>
<span class="nc" id="L1073">      doFire();</span>
<span class="nc" id="L1074">    } </span>
    
  protected void processKeyUp(int keycode)
    {
<span class="nc bnc" id="L1078" title="All 2 branches missed.">    if(keycode == KeyEvent.VK_W )</span>
<span class="nc" id="L1079">      keyForward = false;</span>
<span class="nc bnc" id="L1080" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_S)</span>
<span class="nc" id="L1081">      keyBackward = false;</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_LEFT)</span>
<span class="nc" id="L1083">      keyLeft = false;</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_RIGHT)</span>
<span class="nc" id="L1085">      keyRight = false;</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_A)</span>
<span class="nc" id="L1087">      keyStrafeLeft = false;</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_D)</span>
<span class="nc" id="L1089">      keyStrafeRight = false;</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_UP)</span>
<span class="nc" id="L1091">      keyLookUp = false;</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">    else if (keycode == KeyEvent.VK_DOWN)</span>
<span class="nc" id="L1093">      keyLookDown = false;</span>
<span class="nc" id="L1094">    }</span>
  protected void processMouseMove(MouseEvent me)
    {
    //System.out.println(&quot;mex = &quot;+me.getX());
    //System.out.println(&quot;mey = &quot;+me.getY());
<span class="nc" id="L1099">    diffx = lastMouseX - me.getX();</span>
<span class="nc" id="L1100">    diffy = lastMouseY - me.getY();</span>
    
    //offcenterX = me.getX() - (getWidth()/2);
    //offcenterY = me.getY() - (getHeight()/2);
<span class="nc" id="L1104">    offcenterX = me.getX() - lastMouseX;</span>
<span class="nc" id="L1105">    offcenterY = me.getY() - lastMouseY;</span>
    
<span class="nc" id="L1107">    lastMouseX = me.getX();</span>
<span class="nc" id="L1108">    lastMouseY = me.getY();</span>
 
<span class="nc" id="L1110">    lastMouseX = getWidth()/2;</span>
<span class="nc" id="L1111">    lastMouseY = getHeight()/2;</span>
    // put the mouse back in the center
<span class="nc" id="L1113">    Point p = getLocationOnScreen();</span>
<span class="nc" id="L1114">    robot.mouseMove(p.x+lastMouseX, p.y+lastMouseY);</span>
    
    // probably too much processing to use a float for this check
    // fix later
<span class="nc" id="L1118">    float abs = Math.abs(offcenterX);</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">    if (abs&gt;0.0f)</span>
      {
      // create a vector in the y direction
<span class="nc" id="L1122">      v3fTmp.set(0.0f,1.0f,0.0f);</span>
      // rotate that vector into the current orientation
<span class="nc" id="L1124">      t3dYPR.transform(v3fTmp);</span>
    
      // muck with the turn delta
      // bigger offsets make bigger turns
<span class="nc" id="L1128">      float td = (float)-offcenterX*0.0005f;</span>
      // maximum turns
<span class="nc bnc" id="L1130" title="All 2 branches missed.">      if (Math.abs(td)&gt;0.02)</span>
        {
<span class="nc bnc" id="L1132" title="All 2 branches missed.">        if (td&gt;0.0f)</span>
<span class="nc" id="L1133">          td = 0.02f;</span>
        else
<span class="nc" id="L1135">          td = -0.02f;</span>
        }
      
      // create axis to rotate around that y axis in our orientation coordinate space
<span class="nc" id="L1139">      aaYPR.set(v3fTmp,td);</span>
      
      // set a temporary transform
<span class="nc" id="L1142">      m3fTmp1.set(aaYPR);</span>
<span class="nc" id="L1143">      t3dTmp.set(m3fTmp1);</span>
      
      // multiply the current view by that rotation
<span class="nc" id="L1146">      t3dYPR.mul(t3dTmp);</span>
<span class="nc" id="L1147">      t3dYPR.normalize();</span>
      }
     
<span class="nc" id="L1150">    abs = Math.abs(offcenterY);</span>
<span class="nc bnc" id="L1151" title="All 4 branches missed.">    if ((abs&gt;0.0f) &amp;&amp; (abs&lt;120.0))</span>
      {
<span class="nc" id="L1153">      float rotAng = offcenterY * 0.05f;</span>
      //System.out.println(&quot;rotAng = &quot;+rotAng);
<span class="nc" id="L1155">      lookUpAngle = lookUpAngle + rotAng;</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">      if (lookUpAngle&gt;45.0f)</span>
<span class="nc" id="L1157">        lookUpAngle=45.0f;</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">      else if (lookUpAngle&lt;-45.0f)</span>
<span class="nc" id="L1159">        lookUpAngle=-45.0f;</span>
      }
<span class="nc" id="L1161">    }</span>
  
  protected void processMouseClicked(MouseEvent me)
    {
<span class="nc" id="L1165">    doFire();</span>
    
    
<span class="nc" id="L1168">    }</span>

  } // Fps370Panel
  
class KeyUpBehavior extends Behavior
  {
  Fps370Panel t3p;
  WakeupCondition keyRelease;
  
  public KeyUpBehavior(Fps370Panel t3pInit)
<span class="nc" id="L1178">    {</span>
<span class="nc" id="L1179">    t3p = t3pInit;</span>
    
<span class="nc" id="L1181">    keyRelease = new WakeupOnAWTEvent( KeyEvent.KEY_RELEASED );</span>
<span class="nc" id="L1182">    }</span>
  
  public void initialize()
    {
<span class="nc" id="L1186">    wakeupOn(keyRelease);</span>
<span class="nc" id="L1187">    }</span>
    
  public void processStimulus(Enumeration criteria)
    {
    WakeupCriterion wakeup;
    AWTEvent[] event;
<span class="nc" id="L1193">    boolean resetKeyDown = false;</span>
<span class="nc" id="L1194">    boolean resetKeyUp = false;</span>

    //System.out.println(&quot;process stimulus: &quot;+criteria);
<span class="nc bnc" id="L1197" title="All 2 branches missed.">    while( criteria.hasMoreElements() ) </span>
      {
<span class="nc" id="L1199">      wakeup = (WakeupCriterion) criteria.nextElement();</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">      if( wakeup instanceof WakeupOnAWTEvent ) </span>
        {
<span class="nc" id="L1202">        event = ((WakeupOnAWTEvent)wakeup).getAWTEvent();</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">        for( int i = 0; i &lt; event.length; i++ ) </span>
          {
<span class="nc bnc" id="L1205" title="All 2 branches missed.">          if ( event[i].getID() == KeyEvent.KEY_RELEASED )</span>
            {
<span class="nc" id="L1207">            t3p.processKeyUp(((KeyEvent)event[i]).getKeyCode());</span>
            }
          }
        }
      }
<span class="nc" id="L1212">    wakeupOn( keyRelease );</span>
<span class="nc" id="L1213">    } // end of processStimulus()</span>
  }
 
class KeyDownBehavior extends Behavior
  {
  Fps370Panel t3p;
  WakeupCondition keyPress;
  
  public KeyDownBehavior(Fps370Panel t3pInit)
<span class="nc" id="L1222">    {</span>
<span class="nc" id="L1223">    t3p = t3pInit;</span>
    
<span class="nc" id="L1225">    keyPress = new WakeupOnAWTEvent( KeyEvent.KEY_PRESSED);</span>
<span class="nc" id="L1226">    }</span>
  
  public void initialize()
    {
<span class="nc" id="L1230">    wakeupOn(keyPress);</span>
<span class="nc" id="L1231">    }</span>
    
  public void processStimulus(Enumeration criteria)
    {
    WakeupCriterion wakeup;
    AWTEvent[] event;
<span class="nc" id="L1237">    boolean resetKeyDown = false;</span>
<span class="nc" id="L1238">    boolean resetKeyUp = false;</span>

    //System.out.println(&quot;process stimulus: &quot;+criteria);
<span class="nc bnc" id="L1241" title="All 2 branches missed.">    while( criteria.hasMoreElements() ) </span>
      {
<span class="nc" id="L1243">      wakeup = (WakeupCriterion) criteria.nextElement();</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">      if( wakeup instanceof WakeupOnAWTEvent ) </span>
        {
<span class="nc" id="L1246">        event = ((WakeupOnAWTEvent)wakeup).getAWTEvent();</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">        for( int i = 0; i &lt; event.length; i++ ) </span>
          {
<span class="nc bnc" id="L1249" title="All 2 branches missed.">          if ( event[i].getID() == KeyEvent.KEY_PRESSED )</span>
            {
<span class="nc" id="L1251">            t3p.processKeyDown(((KeyEvent)event[i]).getKeyCode());</span>
            }
          }
        }
      }
<span class="nc" id="L1256">    wakeupOn( keyPress );</span>
<span class="nc" id="L1257">    } // end of processStimulus()</span>
  }

class MouseMoveBehavior extends MouseBehavior
  {
  Fps370Panel t3p;
  WakeupCondition mouseMove;
  
  public MouseMoveBehavior(Fps370Panel t3pInit)
    {
<span class="nc" id="L1267">    super(t3pInit,MouseEvent.MOUSE_MOVED);</span>
    
<span class="nc" id="L1269">    t3p = t3pInit;</span>
    
<span class="nc" id="L1271">    mouseMove = new WakeupOnAWTEvent( (long)(MouseEvent.MOUSE_MOVED | MouseEvent.MOUSE_CLICKED));</span>
<span class="nc" id="L1272">    }</span>
  public void initialize()
    {
<span class="nc" id="L1275">    wakeupOn(mouseMove);</span>
<span class="nc" id="L1276">    }</span>
    
  public void processStimulus(Enumeration criteria)
    {
    WakeupCriterion wakeup;
    AWTEvent[] event;
<span class="nc" id="L1282">    boolean resetKeyDown = false;</span>
<span class="nc" id="L1283">    boolean resetKeyUp = false;</span>

    //System.out.println(&quot;process stimulus: &quot;+criteria);
<span class="nc bnc" id="L1286" title="All 2 branches missed.">    while( criteria.hasMoreElements() ) </span>
      {
<span class="nc" id="L1288">      wakeup = (WakeupCriterion) criteria.nextElement();</span>
<span class="nc bnc" id="L1289" title="All 2 branches missed.">      if( wakeup instanceof WakeupOnAWTEvent ) </span>
        {
<span class="nc" id="L1291">        event = ((WakeupOnAWTEvent)wakeup).getAWTEvent();</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">        for( int i = 0; i &lt; event.length; i++ ) </span>
          {
<span class="nc bnc" id="L1294" title="All 2 branches missed.">          if ( event[i].getID() == MouseEvent.MOUSE_MOVED )</span>
            {
            //System.out.println(&quot;Mouse moved&quot;);
<span class="nc" id="L1297">            t3p.processMouseMove(((MouseEvent)event[i]));</span>
            }
<span class="nc bnc" id="L1299" title="All 2 branches missed.">          else if ( event[i].getID() == MouseEvent.MOUSE_CLICKED)</span>
          {
            //System.out.println(&quot;mouse clicked&quot;);
<span class="nc" id="L1302">            t3p.processMouseClicked((MouseEvent)event[i]);</span>
          }
          }
        }
      }
<span class="nc" id="L1307">    wakeupOn( mouseMove );</span>
<span class="nc" id="L1308">    } // end of processStimulus()</span>
  
  }

  class HudUpdater implements ImageComponent2D.Updater
  {
    private Fps370Panel parent;
    public HudUpdater(Fps370Panel parentInit)
<span class="nc" id="L1316">    {</span>
<span class="nc" id="L1317">      parent = parentInit;</span>
<span class="nc" id="L1318">    }</span>
    public void updateData(ImageComponent2D icUpdate, int x, int y, int width, int height)
    {
      //System.out.println(&quot;HUD Update Data x=&quot;+x+&quot; y=&quot;+y+&quot; w=&quot;+width+&quot; h=&quot;+height);
<span class="nc" id="L1322">      parent.drawHudImage();</span>
      //sicUpdate.set(parent.imgHud);
      
<span class="nc" id="L1325">    }</span>
  }
  
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>