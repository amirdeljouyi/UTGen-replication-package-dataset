<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UUIDGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">66_openjms</a> &gt; <a href="index.source.html" class="el_package">org.exolab.jms.common.uuid</a> &gt; <span class="el_source">UUIDGenerator.java</span></div><h1>UUIDGenerator.java</h1><pre class="source lang-java linenums">/**
 * Redistribution and use of this software and associated documentation
 * (&quot;Software&quot;), with or without modification, are permitted provided
 * that the following conditions are met:
 *
 * 1. Redistributions of source code must retain copyright
 *    statements and notices.  Redistributions must also contain a
 *    copy of this document.
 *
 * 2. Redistributions in binary form must reproduce the
 *    above copyright notice, this list of conditions and the
 *    following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 *
 * 3. The name &quot;Exolab&quot; must not be used to endorse or promote
 *    products derived from this Software without prior written
 *    permission of Intalio.  For written permission,
 *    please contact info@exolab.org.
 *
 * 4. Products derived from this Software may not be called &quot;Exolab&quot;
 *    nor may &quot;Exolab&quot; appear in their names without prior written
 *    permission of Intalio. Exolab is a registered
 *    trademark of Intalio.
 *
 * 5. Due credit should be given to the Exolab Project
 *    (http://www.exolab.org/).
 *
 * THIS SOFTWARE IS PROVIDED BY INTALIO AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * INTALIO OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Copyright 1999-2004 (C) Intalio Inc. All Rights Reserved.
 *
 * $Id: UUIDGenerator.java,v 1.1 2004/11/26 01:50:35 tanderson Exp $
 */

package org.exolab.jms.common.uuid;

import java.security.SecureRandom;
import java.util.HashSet;
import java.util.Random;


/**
 * Universally Unique Identifier (UUID) generator.
 * &lt;p&gt;
 * A UUID is an identifier that is unique across both space and time,
 * with respect to the space of all UUIDs. A UUID can be used for
 * objects with an extremely short lifetime, and to reliably identifying
 * very persistent objects across a network. UUIDs are 128 bit values
 * and encoded as 36 character identifiers.
 * &lt;p&gt;
 * This generator produces time-based UUIDs based on the varient
 * specified in a February 4, 1998 IETF draft.
 * &lt;p&gt;
 * Unprefixed identifiers are generated by calling {@link #create()
 * create}. A method is also provided to create prefixed identifiers.
 * Prefixed identifiers are useful for logging and associating
 * identifiers to application objects.
 * &lt;p&gt;
 * To assure that identifiers can be presisted, identifiers must be
 * kept within the limit of {@link #MAXIMUM_LENGTH} characters.
 * This includes both prefixed identifiers and identifiers created
 * by the application. The {@link #trim trim} method can be used to
 * trim an identifier to the maximum allowed length. If an* identifier
 * was generated with no prefix, or with the maximum supported prefix
 * legnth, the identifier is guaranteed to be short enough and this
 * method is not required.
 * &lt;p&gt;
 * Convenience methods are also provided for converting an identifier
 * to and from an array of bytes. The conversion methods assume that
 * the identifier is a prefixed or unprefixed encoding of the byte
 * array as pairs of hexadecimal digits.
 * &lt;p&gt;
 * The UUID specification prescribes the following format for
 * representing UUIDs. Four octets encode the low field of the time
 * stamp, two octects encode the middle field of the timestamp,
 * and two octets encode the high field of the timestamp with the
 * version number. Two octets encode the clock sequence number and
 * six octets encode the unique node identifier.
 * &lt;p&gt;
 * The timestamp is a 60 bit value holding UTC time as a count of 100
 * nanosecond intervals since October 15, 1582. UUIDs generated in
 * this manner are guaranteed not to roll over until 3400 AD.
 * &lt;p&gt;
 * The clock sequence is used to help avoid duplicates that could arise
 * when the clock is set backward in time or if the node ID changes.
 * Although the system clock is guaranteed to be monotonic, the system
 * clock is not guaranteed to be monotonic across system failures.
 * The UUID cannot be sure that no UUIDs were generated with timestamps
 * larger than the current timestamp.
 * &lt;p&gt;
 * If the clock sequence can be determined at initialization, it is
 * incremented by one, otherwise it is set to a random number.
 * The clock sequence MUST be originally (i.e. once in the lifetime
 * of a system) initialized to a random number to minimize the
 * correlation across systems. The initial value must not be correlated
 * to the node identifier.
 * &lt;p&gt;
 * The node identifier must be unique for each UUID generator.
 * This is accomplished using the IEEE 802 network card address.
 * For systems with multiple IEEE 802 addresses, any available address
 * can be used. For systems with no IEEE address, a 47 bit random value
 * is used and the multicast bit is set so it will never conflict with
 * addresses obtained from network cards.
 * &lt;p&gt;
 * The UUID state consists of the node identifier and clock sequence.
 * The state need only be read once when the generator is initialized,
 * and the clock sequence must be incremented and stored back. If the
 * UUID state cannot be read and updated, a random number is used.
 * &lt;p&gt;
 * The UUID generator is thread-safe.
 * &lt;p&gt;
 * This class originally came from Tyrex: http://tyrex.sourceforge.net
 *
 * @author &lt;a href=&quot;mailto:arkin@intalio.com&quot;&gt;Assaf Arkin&lt;/a&gt;
 * @version $Revision: 1.1 $ $Date: 2004/11/26 01:50:35 $
 */
<span class="nc" id="L128">public final class UUIDGenerator {</span>

    /**
     /**
     * The identifier resolution in bytes. Identifiers are 16-byte
     * long, or 128 bits. Without a prefix, an identifier can be
     * represented as 36 hexadecimal digits and hyphens.
     * (4 hyphens are used in the UUID format)
     */
    public static final int RESOLUTION_BYTES = 16;


    /**
     * The maximum length of an identifier in textual form.
     * Prefixed identifiers and application identifiers must be
     * less or equal to the maximum length to allow persistence.
     * This maximum length is 64 characters.
     */
    public static final int MAXIMUM_LENGTH = 64;


    /**
     * The maximum length of an identifier prefix. Identifiers
     * created using {@link #create(String) create(String)} with
     * a prefix that is no longer than the maximum prefix size
     * are guaranteed to be within the maximum length allowed
     * and need not be trimmed.
     */
    public static final int MAXIMUM_PREFIX = 28;


    /**
     * The variant value determines the layout of the UUID. This
     * variant is specified in the IETF February 4, 1998 draft.
     * Used for character octets.
     */
    private static final int UUID_VARIANT_OCTET = 0x08;


    /**
     * The variant value determines the layout of the UUID. This
     * variant is specified in the IETF February 4, 1998 draft.
     * Used for byte array.
     */
    private static final int UUID_VARIANT_BYTE = 0x80;


    /**
     * The version identifier for a time-based UUID. This version
     * is specified in the IETF February 4, 1998 draft. Used for
     * character octets.
     */
    private static final int UUID_VERSION_CLOCK_OCTET = 0x01;


    /**
     * The version identifier for a time-based UUID. This version
     * is specified in the IETF February 4, 1998 draft. Used for
     * byte array.
     */
    private static final int UUID_VERSION_CLOCK_BYTE = 0x10;


    /**
     * The version identifier for a name-based UUID. This version
     * is specified in the IETF February 4, 1998 draft. Used for
     * character octets.
     */
    private static final int UUID_VERSION_NAME_OCTET = 0x03;


    /**
     * The version identifier for a name-based UUID. This version
     * is specified in the IETF February 4, 1998 draft. Used for
     * byte array.
     */
    private static final int UUID_VERSION_NAME_BYTE = 0x30;


    /**
     * The version identifier for a random-based UUID. This version
     * is specified in the IETF February 4, 1998 draft. Used for
     * character octets.
     */
    private static final int UUID_VERSION_RANDOM_CLOCK = 0x04;


    /**
     * The version identifier for a random-based UUID. This version
     * is specified in the IETF February 4, 1998 draft. Used for
     * byte array.
     */
    private static final int UUID_VERSION_RANDOM_BYTE = 0x40;


    /**
     * The difference between Java clock and UUID clock. Java clock
     * is base time is January 1, 1970. UUID clock base time is
     * October 15, 1582.
     */
    private static final long JAVA_UUID_CLOCK_DIFF = 0x0b1d069b5400L;


    /**
     * Efficient mapping from 4 bit value to lower case hexadecimal digit.
     */
<span class="nc" id="L234">    private final static char[] HEX_DIGITS = new char[]{</span>
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};


    /**
     * The number of UUIDs that can be generated per clock tick.
     * UUID assumes a clock tick every 100 nanoseconds. The actual
     * clock ticks are measured in milliseconds and based on the
     * sync-every property of the clock. The product of these two
     * values is used to set this variable.
     */
    private static int _uuidsPerTick;


    /**
     * The number of UUIDs generated in this clock tick. This counter
     * is reset each time the clock is advanced a tick. When it reaches
     * the maximum number of UUIDs allowed per tick, we block until the
     * clock advances.
     */
    private static int _uuidsThisTick;


    /**
     * The last clock. Whenever the clock changes, we record the last clock
     * to identify when we get a new clock, or when we should increments
     * the UUIDs per tick counter.
     */
    private static long _lastClock;


    /**
     * The clock sequence. This is randomly initialised, and is made of
     * four hexadecimal digits.
     */
    private static char[] _clockSeqOctet;


    /**
     * The clock sequence. The clock sequence is obtained from the UUID
     * properties and incremented by one each time we boot, or is
     * generated randomaly if missing in the UUID properties. The clock
     * sequence is made of two bytes.
     */
    private static byte[] _clockSeqByte;


    /**
     * The node identifier. The node identifier is obtained from the
     * UUID properties, or is generated if missing in the UUID properties.
     * The node identifier is made of twelve hexadecimal digits.
     */
    private static char[] _nodeIdentifierOctet;


    /**
     * The node identifier. The node identifier is obtained from the
     * UUID properties, or is generated if missing in the UUID properties.
     * The node identifier is made of six bytes.
     */
    private static byte[] _nodeIdentifierByte;


    /**
     * Creates and returns a new identifier.
     *
     * @return An identifier
     */
    public static String create() {
<span class="nc" id="L304">        return String.valueOf(createTimeUUIDChars());</span>
    }


    /**
     * Creates and returns a new prefixed identifier.
     * &lt;p&gt;
     * This method is equivalent to &lt;code&gt;prefix + create()&lt;/code&gt;.
     *
     * @param prefix The prefix to use
     * @return A prefixed identifier
     */
    public static String create(String prefix) {
        StringBuffer buffer;

<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (prefix == null) {</span>
<span class="nc" id="L320">            throw new IllegalArgumentException(&quot;Argument 'prefix' is null&quot;);</span>
        }
<span class="nc" id="L322">        buffer = new StringBuffer(MAXIMUM_LENGTH - MAXIMUM_PREFIX + prefix.length());</span>
<span class="nc" id="L323">        buffer.append(prefix);</span>
<span class="nc" id="L324">        buffer.append(createTimeUUIDChars());</span>
<span class="nc" id="L325">        return buffer.toString();</span>
    }


    /**
     * Creates and returns a new identifier.
     *
     * @return An identifier
     */
    public static byte[] createBinary() {
<span class="nc" id="L335">        return createTimeUUIDBytes();</span>
    }


    /**
     * Converts a prefixed identifier into a byte array. An exception
     * is thrown if the identifier does not match the excepted textual
     * encoding.
     * &lt;p&gt;
     * The format for the identifier is &lt;code&gt;prefix{nn|-}*&lt;/code&gt;:
     * a prefix followed by a sequence of bytes, optionally separated
     * by hyphens. Each byte is encoded as a pair of hexadecimal digits.
     *
     * @param prefix The identifier prefix
     * @param identifier The prefixed identifier
     * @return The identifier as an array of bytes
     * @throws InvalidIDException The identifier does not begin with
     * the prefix, or does not consist of a sequence of hexadecimal
     * digit pairs, optionally separated by hyphens
     */
    public static byte[] toBytes(String prefix, String identifier)
        throws InvalidIDException {

        int index;
        char digit;
        byte nibble;
        byte[] bytes;
        byte[] newBytes;

<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (identifier == null) {</span>
<span class="nc" id="L365">            throw new IllegalArgumentException(&quot;Argument identifier is null&quot;);</span>
        }
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (prefix == null) {</span>
<span class="nc" id="L368">            throw new IllegalArgumentException(&quot;Argument prefix is null&quot;);</span>
        }
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (!identifier.startsWith(prefix)) {</span>
<span class="nc" id="L371">            throw new InvalidIDException(</span>
                &quot;Invalid identifier: expected prefix &quot; + prefix
                + &quot;in identifier &quot; + identifier);
        }

<span class="nc" id="L376">        index = 0;</span>
<span class="nc" id="L377">        bytes = new byte[(identifier.length() - prefix.length()) / 2];</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        for (int i = prefix.length(); i &lt; identifier.length(); ++i) {</span>
<span class="nc" id="L379">            digit = identifier.charAt(i);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">            if (digit == '-') {</span>
<span class="nc" id="L381">                continue;</span>
            }
<span class="nc bnc" id="L383" title="All 4 branches missed.">            if (digit &gt;= '0' &amp;&amp; digit &lt;= '9') {</span>
<span class="nc" id="L384">                nibble = (byte) ((digit - '0') &lt;&lt; 4);</span>
<span class="nc bnc" id="L385" title="All 4 branches missed.">            } else if (digit &gt;= 'A' &amp;&amp; digit &lt;= 'F') {</span>
<span class="nc" id="L386">                nibble = (byte) ((digit - ('A' - 0x0A)) &lt;&lt; 4);</span>
<span class="nc bnc" id="L387" title="All 4 branches missed.">            } else if (digit &gt;= 'a' &amp;&amp; digit &lt;= 'f') {</span>
<span class="nc" id="L388">                nibble = (byte) ((digit - ('a' - 0x0A)) &lt;&lt; 4);</span>
            } else {
<span class="nc" id="L390">                throw new InvalidIDException(</span>
<span class="nc" id="L391">                    &quot;character &quot; + String.valueOf(digit)</span>
                    + &quot; encountered, expected hexadecimal digit in identifier &quot;
                    + identifier);
            }
<span class="nc" id="L395">            ++i;</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (i == identifier.length()) {</span>
<span class="nc" id="L397">                throw new InvalidIDException(</span>
                    &quot;Invalid identifier: odd number of hexadecimal digits in &quot;
                    + &quot;identifier &quot; + identifier);
            }
<span class="nc" id="L401">            digit = identifier.charAt(i);</span>
<span class="nc bnc" id="L402" title="All 4 branches missed.">            if (digit &gt;= '0' &amp;&amp; digit &lt;= '9') {</span>
<span class="nc" id="L403">                nibble = (byte) (nibble | (digit - '0'));</span>
<span class="nc bnc" id="L404" title="All 4 branches missed.">            } else if (digit &gt;= 'A' &amp;&amp; digit &lt;= 'F') {</span>
<span class="nc" id="L405">                nibble = (byte) (nibble | (digit - ('A' - 0x0A)));</span>
<span class="nc bnc" id="L406" title="All 4 branches missed.">            } else if (digit &gt;= 'a' &amp;&amp; digit &lt;= 'f') {</span>
<span class="nc" id="L407">                nibble = (byte) (nibble | (digit - ('a' - 0x0A)));</span>
            } else {
<span class="nc" id="L409">                throw new InvalidIDException(</span>
<span class="nc" id="L410">                    &quot;character &quot; + String.valueOf(digit)</span>
                    + &quot; encountered, expected hexadecimal digit in identifier &quot;
                    + identifier);
            }
<span class="nc" id="L414">            bytes[index] = nibble;</span>
<span class="nc" id="L415">            ++index;</span>
        }
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (index == bytes.length) {</span>
<span class="nc" id="L418">            return bytes;</span>
        }
<span class="nc" id="L420">        newBytes = new byte[index];</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        while (index-- &gt; 0) {</span>
<span class="nc" id="L422">            newBytes[index] = bytes[index];</span>
        }
<span class="nc" id="L424">        return newBytes;</span>
    }


    /**
     * Converts an identifier into a byte array. An exception is
     * thrown if the identifier does not match the excepted textual
     * encoding.
     * &lt;p&gt;
     * The format for the identifier is &lt;code&gt;{nn|-}*&lt;/code&gt;:
     * a sequence of bytes, optionally separated by hyphens.
     * Each byte is encoded as a pair of hexadecimal digits.
     *
     * @param identifier The identifier
     * @return The identifier as an array of bytes
     * @throws InvalidIDException The identifier does not consist
     * of a sequence of hexadecimal digit pairs, optionally separated
     * by hyphens
     */
    public static byte[] toBytes(String identifier) throws InvalidIDException {
        int index;
        char digit;
        byte nibble;
        byte[] bytes;
        byte[] newBytes;

<span class="nc bnc" id="L450" title="All 2 branches missed.">        if (identifier == null) {</span>
<span class="nc" id="L451">            throw new IllegalArgumentException(&quot;Argument identifier is null&quot;);</span>
        }
<span class="nc" id="L453">        index = 0;</span>
<span class="nc" id="L454">        bytes = new byte[identifier.length() / 2];</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        for (int i = 0; i &lt; identifier.length(); ++i) {</span>
<span class="nc" id="L456">            digit = identifier.charAt(i);</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">            if (digit == '-')</span>
<span class="nc" id="L458">                continue;</span>
<span class="nc bnc" id="L459" title="All 4 branches missed.">            if (digit &gt;= '0' &amp;&amp; digit &lt;= '9')</span>
<span class="nc" id="L460">                nibble = (byte) ((digit - '0') &lt;&lt; 4);</span>
<span class="nc bnc" id="L461" title="All 4 branches missed.">            else if (digit &gt;= 'A' &amp;&amp; digit &lt;= 'F')</span>
<span class="nc" id="L462">                nibble = (byte) ((digit - ('A' - 0x0A)) &lt;&lt; 4);</span>
<span class="nc bnc" id="L463" title="All 4 branches missed.">            else if (digit &gt;= 'a' &amp;&amp; digit &lt;= 'f')</span>
<span class="nc" id="L464">                nibble = (byte) ((digit - ('a' - 0x0A)) &lt;&lt; 4);</span>
            else {
<span class="nc" id="L466">                throw new InvalidIDException(</span>
<span class="nc" id="L467">                    &quot;character &quot; + String.valueOf(digit)</span>
                    + &quot; encountered, expected hexadecimal digit in identifier &quot;
                    + identifier);
            }
<span class="nc" id="L471">            ++i;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">            if (i == identifier.length()) {</span>
<span class="nc" id="L473">                throw new InvalidIDException(</span>
                    &quot;Invalid identifier: odd number of hexadecimal digits in &quot;
                    + &quot;identifier &quot; + identifier);
            }
<span class="nc" id="L477">            digit = identifier.charAt(i);</span>
<span class="nc bnc" id="L478" title="All 4 branches missed.">            if (digit &gt;= '0' &amp;&amp; digit &lt;= '9')</span>
<span class="nc" id="L479">                nibble = (byte) (nibble | (digit - '0'));</span>
<span class="nc bnc" id="L480" title="All 4 branches missed.">            else if (digit &gt;= 'A' &amp;&amp; digit &lt;= 'F')</span>
<span class="nc" id="L481">                nibble = (byte) (nibble | (digit - ('A' - 0x0A)));</span>
<span class="nc bnc" id="L482" title="All 4 branches missed.">            else if (digit &gt;= 'a' &amp;&amp; digit &lt;= 'f')</span>
<span class="nc" id="L483">                nibble = (byte) (nibble | (digit - ('a' - 0x0A)));</span>
            else {
<span class="nc" id="L485">                throw new InvalidIDException(</span>
<span class="nc" id="L486">                    &quot;character &quot; + String.valueOf(digit)</span>
                    + &quot; encountered, expected hexadecimal digit in identifier &quot;
                    + identifier);
            }
<span class="nc" id="L490">            bytes[index] = nibble;</span>
<span class="nc" id="L491">            ++index;</span>
        }
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (index == bytes.length)</span>
<span class="nc" id="L494">            return bytes;</span>
<span class="nc" id="L495">        newBytes = new byte[index];</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        while (index-- &gt; 0)</span>
<span class="nc" id="L497">            newBytes[index] = bytes[index];</span>
<span class="nc" id="L498">        return newBytes;</span>
    }


    /**
     * Converts a byte array into a prefixed identifier.
     * &lt;p&gt;
     * The format for the identifier is &lt;code&gt;prefix{nn|-}*&lt;/code&gt;:
     * a prefix followed by a sequence of bytes, optionally separated
     * by hyphens. Each byte is encoded as a pair of hexadecimal digits.
     *
     * @param prefix The identifier prefix
     * @param byte An array of bytes
     * @return A string representation of the identifier
     */
    public static String fromBytes(String prefix, byte[] bytes) {
        StringBuffer buffer;

<span class="nc bnc" id="L516" title="All 2 branches missed.">        if (prefix == null)</span>
<span class="nc" id="L517">            throw new IllegalArgumentException(&quot;Argument prefix is null&quot;);</span>
<span class="nc bnc" id="L518" title="All 4 branches missed.">        if (bytes == null || bytes.length == 0)</span>
<span class="nc" id="L519">            throw new IllegalArgumentException(&quot;Argument bytes is null or an empty array&quot;);</span>
<span class="nc" id="L520">        buffer = new StringBuffer(prefix);</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        for (int i = 0; i &lt; bytes.length; ++i) {</span>
<span class="nc" id="L522">            buffer.append(HEX_DIGITS[(bytes[i] &amp; 0xF0) &gt;&gt; 4]);</span>
<span class="nc" id="L523">            buffer.append(HEX_DIGITS[(bytes[i] &amp; 0x0F)]);</span>
        }
<span class="nc" id="L525">        return buffer.toString();</span>
    }


    /**
     * Converts a byte array into an identifier.
     * &lt;p&gt;
     * The format for the identifier is &lt;code&gt;{nn|-}*&lt;/code&gt;: a sequence
     * of bytes, optionally separated by hyphens. Each byte is encoded as
     * a pair of hexadecimal digits.
     *
     * @param bytes An array of bytes
     * @return A string representation of the identifier
     */
    public static String fromBytes(byte[] bytes) {
        StringBuffer buffer;

<span class="nc bnc" id="L542" title="All 4 branches missed.">        if (bytes == null || bytes.length == 0)</span>
<span class="nc" id="L543">            throw new IllegalArgumentException(&quot;Argument bytes is null or an empty array&quot;);</span>
<span class="nc" id="L544">        buffer = new StringBuffer();</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">        for (int i = 0; i &lt; bytes.length; ++i) {</span>
<span class="nc" id="L546">            buffer.append(HEX_DIGITS[(bytes[i] &amp; 0xF0) &gt;&gt; 4]);</span>
<span class="nc" id="L547">            buffer.append(HEX_DIGITS[(bytes[i] &amp; 0x0F)]);</span>
        }
<span class="nc" id="L549">        return buffer.toString();</span>
    }


    /**
     * Truncates an identifier so that it does not extend beyond
     * {@link #MAXIMUM_LENGTH} characters in length.
     *
     * @param identifier An identifier
     * @return An identifier trimmed to {@link #MAXIMUM_LENGTH} characters
     */
    public static String trim(String identifier) {
<span class="nc bnc" id="L561" title="All 2 branches missed.">        if (identifier == null)</span>
<span class="nc" id="L562">            throw new IllegalArgumentException(&quot;Argument identifier is null&quot;);</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">        if (identifier.length() &gt; MAXIMUM_LENGTH)</span>
<span class="nc" id="L564">            return identifier.substring(0, MAXIMUM_LENGTH);</span>
<span class="nc" id="L565">        return identifier;</span>
    }


    /**
     * Returns a time-based UUID as a character array. The UUID
     * identifier is always 36 characters long.
     *
     * @return A time-based UUID
     */
    public static char[] createTimeUUIDChars() {
        long clock;
        char[] chars;
        long nextClock;

        // Acquire lock to assure synchornized generation
<span class="nc" id="L581">        synchronized (UUID.class) {</span>
<span class="nc" id="L582">            clock = Clock.clock();</span>
            while (true) {
<span class="nc bnc" id="L584" title="All 2 branches missed.">                if (clock &gt; _lastClock) {</span>
                    // Since we are using the clock interval for the UUID space,
                    // we must make sure the next clock provides sufficient
                    // room so UUIDs do not roll over.
<span class="nc" id="L588">                    nextClock = _lastClock + (_uuidsThisTick / 100);</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">                    if (clock &lt;= nextClock)</span>
<span class="nc" id="L590">                        clock = Clock.synchronize();</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">                    if (clock &gt; nextClock) {</span>
                        // Clock reading changed since last UUID generated,
                        // reset count of UUIDs generated with this clock.
<span class="nc" id="L594">                        _uuidsThisTick = 0;</span>
<span class="nc" id="L595">                        _lastClock = clock;</span>
                        // Adjust UUIDs per tick in case the clock sleep ticks
                        // have changed.
<span class="nc" id="L598">                        _uuidsPerTick = Clock.getUnsynchTicks() * 100;</span>
<span class="nc" id="L599">                        break;</span>
                    }
                }

<span class="nc bnc" id="L603" title="All 2 branches missed.">                if (_uuidsThisTick + 1 &lt; _uuidsPerTick) {</span>
                    // Clock did not advance, but able to create more UUIDs
                    // for this clock, proceed.
<span class="nc" id="L606">                    ++_uuidsThisTick;</span>
<span class="nc" id="L607">                    break;</span>
                }

                // Running out of UUIDs for the current clock tick, must
                // wait until clock advances. Possible that clock did not
                // advance in background, so try to synchronize it first.
<span class="nc" id="L613">                clock = Clock.synchronize();</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">                if (clock &lt;= _lastClock) {</span>
                    // if (Configuration.verbose)
                    //Logger.tyrex.debug(Messages.message(&quot;tyrex.uuid.fastHolding&quot;));
<span class="nc bnc" id="L617" title="All 2 branches missed.">                    while (clock &lt;= _lastClock) {</span>
                        // UUIDs generated too fast, suspend for a while.
                        try {
<span class="nc" id="L620">                            Thread.currentThread().sleep(Clock.getUnsynchTicks());</span>
<span class="nc" id="L621">                        } catch (InterruptedException except) {</span>
<span class="nc" id="L622">                        }</span>
<span class="nc" id="L623">                        clock = Clock.synchronize();</span>
                    }
                }
            }

            // Modify Java clock (milliseconds) to UUID clock (100 nanoseconds).
            // Add the count of uuids to low order bits of the clock reading,
            // assuring we get a unique clock.
<span class="nc" id="L631">            clock = (_lastClock + JAVA_UUID_CLOCK_DIFF) * 100 + _uuidsThisTick;</span>

<span class="nc" id="L633">            chars = new char[36];</span>
            // Add the low field of the clock (4 octets)
<span class="nc" id="L635">            chars[0] = HEX_DIGITS[(int) ((clock &gt;&gt; 28) &amp; 0x0F)];</span>
<span class="nc" id="L636">            chars[1] = HEX_DIGITS[(int) ((clock &gt;&gt; 24) &amp; 0x0F)];</span>
<span class="nc" id="L637">            chars[2] = HEX_DIGITS[(int) ((clock &gt;&gt; 20) &amp; 0x0F)];</span>
<span class="nc" id="L638">            chars[3] = HEX_DIGITS[(int) ((clock &gt;&gt; 16) &amp; 0x0F)];</span>
<span class="nc" id="L639">            chars[4] = HEX_DIGITS[(int) ((clock &gt;&gt; 12) &amp; 0x0F)];</span>
<span class="nc" id="L640">            chars[5] = HEX_DIGITS[(int) ((clock &gt;&gt; 8) &amp; 0x0F)];</span>
<span class="nc" id="L641">            chars[6] = HEX_DIGITS[(int) ((clock &gt;&gt; 4) &amp; 0x0F)];</span>
<span class="nc" id="L642">            chars[7] = HEX_DIGITS[(int) (clock &amp; 0x0F)];</span>
<span class="nc" id="L643">            chars[8] = '-';</span>
            // Add the medium field of the clock (2 octets)
<span class="nc" id="L645">            chars[9] = HEX_DIGITS[(int) ((clock &gt;&gt; 44) &amp; 0x0F)];</span>
<span class="nc" id="L646">            chars[10] = HEX_DIGITS[(int) ((clock &gt;&gt; 40) &amp; 0x0F)];</span>
<span class="nc" id="L647">            chars[11] = HEX_DIGITS[(int) ((clock &gt;&gt; 36) &amp; 0x0F)];</span>
<span class="nc" id="L648">            chars[12] = HEX_DIGITS[(int) ((clock &gt;&gt; 32) &amp; 0x0F)];</span>
<span class="nc" id="L649">            chars[13] = '-';</span>
            // Add the high field of the clock multiplexed with version number (2 octets)
<span class="nc" id="L651">            chars[14] = HEX_DIGITS[(int) (((clock &gt;&gt; 60) &amp; 0x0F) | UUID_VERSION_CLOCK_OCTET)];</span>
<span class="nc" id="L652">            chars[15] = HEX_DIGITS[(int) ((clock &gt;&gt; 56) &amp; 0x0F)];</span>
<span class="nc" id="L653">            chars[16] = HEX_DIGITS[(int) ((clock &gt;&gt; 52) &amp; 0x0F)];</span>
<span class="nc" id="L654">            chars[17] = HEX_DIGITS[(int) ((clock &gt;&gt; 48) &amp; 0x0F)];</span>
<span class="nc" id="L655">            chars[18] = '-';</span>
            // Add the clock sequence and version identifier (2 octets)
<span class="nc" id="L657">            chars[19] = _clockSeqOctet[0];</span>
<span class="nc" id="L658">            chars[20] = _clockSeqOctet[1];</span>
<span class="nc" id="L659">            chars[21] = _clockSeqOctet[2];</span>
<span class="nc" id="L660">            chars[22] = _clockSeqOctet[3];</span>
<span class="nc" id="L661">            chars[23] = '-';</span>
            // Add the node identifier (6 octets)
<span class="nc" id="L663">            chars[24] = _nodeIdentifierOctet[0];</span>
<span class="nc" id="L664">            chars[25] = _nodeIdentifierOctet[1];</span>
<span class="nc" id="L665">            chars[26] = _nodeIdentifierOctet[2];</span>
<span class="nc" id="L666">            chars[27] = _nodeIdentifierOctet[3];</span>
<span class="nc" id="L667">            chars[28] = _nodeIdentifierOctet[4];</span>
<span class="nc" id="L668">            chars[29] = _nodeIdentifierOctet[5];</span>
<span class="nc" id="L669">            chars[30] = _nodeIdentifierOctet[6];</span>
<span class="nc" id="L670">            chars[31] = _nodeIdentifierOctet[7];</span>
<span class="nc" id="L671">            chars[32] = _nodeIdentifierOctet[8];</span>
<span class="nc" id="L672">            chars[33] = _nodeIdentifierOctet[9];</span>
<span class="nc" id="L673">            chars[34] = _nodeIdentifierOctet[10];</span>
<span class="nc" id="L674">            chars[35] = _nodeIdentifierOctet[11];</span>
<span class="nc" id="L675">        }</span>
<span class="nc" id="L676">        return chars;</span>
    }


    /**
     * Returns a time-based UUID as a character array. The UUID
     * identifier is always 16 bytes long.
     *
     * @return A time-based UUID
     */
    public static byte[] createTimeUUIDBytes() {
        long clock;
        byte[] bytes;
        long nextClock;

        // Acquire lock to assure synchronized generation
<span class="nc" id="L692">        synchronized (UUIDGenerator.class) {</span>
<span class="nc" id="L693">            clock = Clock.clock();</span>
            while (true) {
<span class="nc bnc" id="L695" title="All 2 branches missed.">                if (clock &gt; _lastClock) {</span>
                    // Since we are using the clock interval for the UUID
                    // space, we must make sure the next clock provides
                    // sufficient room so UUIDs do not roll over.
<span class="nc" id="L699">                    nextClock = _lastClock + (_uuidsThisTick / 100);</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">                    if (clock &lt;= nextClock) {</span>
<span class="nc" id="L701">                        clock = Clock.synchronize();</span>
                    }
<span class="nc bnc" id="L703" title="All 2 branches missed.">                    if (clock &gt; nextClock) {</span>
                        // Clock reading changed since last UUID generated,
                        // reset count of UUIDs generated with this clock.
<span class="nc" id="L706">                        _uuidsThisTick = 0;</span>
<span class="nc" id="L707">                        _lastClock = clock;</span>
                        // Adjust UUIDs per tick in case the clock sleep ticks
                        // have changed.
<span class="nc" id="L710">                        _uuidsPerTick = Clock.getUnsynchTicks() * 100;</span>
<span class="nc" id="L711">                        break;</span>
                    }
                }

<span class="nc bnc" id="L715" title="All 2 branches missed.">                if (_uuidsThisTick + 1 &lt; _uuidsPerTick) {</span>
                    // Clock did not advance, but able to create more UUIDs
                    // for this clock, proceed.
<span class="nc" id="L718">                    ++_uuidsThisTick;</span>
<span class="nc" id="L719">                    break;</span>
                }

                // Running out of UUIDs for the current clock tick, must
                // wait until clock advances. Possible that clock did not
                // advance in background, so try to synchronize it first.
<span class="nc" id="L725">                clock = Clock.synchronize();</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">                if (clock &lt;= _lastClock) {</span>
                    // if (Configuration.verbose)
                    // Logger.tyrex.debug(Messages.message(&quot;tyrex.uuid.fastHolding&quot;));
<span class="nc bnc" id="L729" title="All 2 branches missed.">                    while (clock &lt;= _lastClock) {</span>
                        // UUIDs generated too fast, suspend for a while.
                        try {
<span class="nc" id="L732">                            Thread.currentThread().sleep(Clock.getUnsynchTicks());</span>
<span class="nc" id="L733">                        } catch (InterruptedException ignore) {</span>
<span class="nc" id="L734">                        }</span>
<span class="nc" id="L735">                        clock = Clock.synchronize();</span>
                    }
                }
            }

            // Modify Java clock (milliseconds) to UUID clock (100 nanoseconds).
            // Add the count of uuids to low order bits of the clock reading,
            // assuring we get a unique clock.
<span class="nc" id="L743">            clock = (_lastClock + JAVA_UUID_CLOCK_DIFF) * 100 + _uuidsThisTick;</span>

<span class="nc" id="L745">            bytes = new byte[16];</span>
            // Add the low field of the clock (4 octets)
<span class="nc" id="L747">            bytes[0] = (byte) ((clock &gt;&gt; 24) &amp; 0xFF);</span>
<span class="nc" id="L748">            bytes[1] = (byte) ((clock &gt;&gt; 16) &amp; 0xFF);</span>
<span class="nc" id="L749">            bytes[2] = (byte) ((clock &gt;&gt; 8) &amp; 0xFF);</span>
<span class="nc" id="L750">            bytes[3] = (byte) (clock &amp; 0xFF);</span>
            // Add the medium field of the clock (2 octets)
<span class="nc" id="L752">            bytes[4] = (byte) ((clock &gt;&gt; 40) &amp; 0xFF);</span>
<span class="nc" id="L753">            bytes[5] = (byte) ((clock &gt;&gt; 32) &amp; 0xFF);</span>
            // Add the high field of the clock multiplexed with version
            // number (2 octets)
<span class="nc" id="L756">            bytes[6] = (byte) (((clock &gt;&gt; 60) &amp; 0xFF)</span>
                | UUID_VERSION_CLOCK_BYTE);
<span class="nc" id="L758">            bytes[7] = (byte) ((clock &gt;&gt; 48) &amp; 0xFF);</span>
            // Add the clock sequence and version identifier (2 octets)
<span class="nc" id="L760">            bytes[8] = _clockSeqByte[0];</span>
<span class="nc" id="L761">            bytes[9] = _clockSeqByte[1];</span>
            // Add the node identifier (6 octets)
<span class="nc" id="L763">            bytes[10] = _nodeIdentifierByte[0];</span>
<span class="nc" id="L764">            bytes[11] = _nodeIdentifierByte[1];</span>
<span class="nc" id="L765">            bytes[12] = _nodeIdentifierByte[2];</span>
<span class="nc" id="L766">            bytes[13] = _nodeIdentifierByte[3];</span>
<span class="nc" id="L767">            bytes[14] = _nodeIdentifierByte[4];</span>
<span class="nc" id="L768">            bytes[15] = _nodeIdentifierByte[5];</span>
<span class="nc" id="L769">        }</span>
<span class="nc" id="L770">        return bytes;</span>
    }


    /**
     * Returns true if the UUID was created on this machine.
     * Determines the source of the UUID based on the node
     * identifier.
     *
     * @param uuid The UUID as a byte array
     * @return True if created on this machine
     */
    public static boolean isLocal(byte[] uuid) {
<span class="nc bnc" id="L783" title="All 2 branches missed.">        if (uuid == null)</span>
<span class="nc" id="L784">            throw new IllegalArgumentException(&quot;Argument uuid is null&quot;);</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">        if (uuid.length != 16)</span>
<span class="nc" id="L786">            return false;</span>
<span class="nc bnc" id="L787" title="All 12 branches missed.">        return (uuid[10] == _nodeIdentifierByte[0] &amp;&amp;</span>
            uuid[11] == _nodeIdentifierByte[1] &amp;&amp;
            uuid[12] == _nodeIdentifierByte[2] &amp;&amp;
            uuid[13] == _nodeIdentifierByte[3] &amp;&amp;
            uuid[14] == _nodeIdentifierByte[4] &amp;&amp;
            uuid[15] == _nodeIdentifierByte[5]);
    }

    /**
     * Initialise the generator
     * &lt;p&gt;
     * This method generates the node identifier and clock sequence, and
     * sets {@link #_uuidsPerTick} to the number of UUIDs allowed per clock
     * tick.
     */
    private static void initialize() {
        // Random random = new SecureRandom();
<span class="nc" id="L804">        Random random = new Random();</span>
        String nodeIdString;
        long nodeIdLong;
        String seqString;
        int seqInt;

        // Generate the node identifier, as we can't determine the IEEE 802
        // address of the local host.
        // As a result, it must have bit 48 set.
<span class="nc" id="L813">        nodeIdLong = random.nextLong();</span>
<span class="nc" id="L814">        nodeIdLong = nodeIdLong | (1 &lt;&lt; 47);</span>

        // Generate the clock sequence
<span class="nc" id="L817">        seqInt = random.nextInt(1 &lt;&lt; 12);</span>
<span class="nc" id="L818">        seqInt = seqInt &amp; 0x1FFF;</span>

        // Convert clock sequence to 4 hexadecimal digits
<span class="nc" id="L821">        _clockSeqOctet = new char[4];</span>
<span class="nc" id="L822">        _clockSeqOctet[0] = HEX_DIGITS[(int) ((seqInt &gt;&gt; 12) &amp; 0x0F)];</span>
<span class="nc" id="L823">        _clockSeqOctet[1] = HEX_DIGITS[(int) ((seqInt &gt;&gt; 8) &amp; 0x0F)];</span>
<span class="nc" id="L824">        _clockSeqOctet[2] = HEX_DIGITS[(int) ((seqInt &gt;&gt; 4) &amp; 0x0F)];</span>
<span class="nc" id="L825">        _clockSeqOctet[3] = HEX_DIGITS[(int) (seqInt &amp; 0x0F)];</span>

<span class="nc" id="L827">        _clockSeqByte = new byte[2];</span>
<span class="nc" id="L828">        _clockSeqByte[0] = (byte) ((seqInt &gt;&gt; 8) &amp; 0xFF);</span>
<span class="nc" id="L829">        _clockSeqByte[1] = (byte) (seqInt &amp; 0xFF);</span>

        // Need to mask UUID variant on clock sequence
<span class="nc" id="L832">        _clockSeqOctet[0] = HEX_DIGITS[(int) ((seqInt &gt;&gt; 12) &amp; 0x0F)</span>
            | UUID_VARIANT_OCTET];
<span class="nc" id="L834">        _clockSeqByte[0] = (byte) (((seqInt &gt;&gt; 8) &amp; 0xFF)</span>
            | UUID_VARIANT_BYTE);

        // Convert node identifier to 12 hexadecimal digits
<span class="nc" id="L838">        _nodeIdentifierOctet = new char[12];</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">        for (int i = 0; i &lt; 12; ++i) {</span>
<span class="nc" id="L840">            _nodeIdentifierOctet[i] =</span>
                HEX_DIGITS[(int) ((nodeIdLong &gt;&gt; ((11 - i) * 4)) &amp; 0x0F)];
        }
<span class="nc" id="L843">        _nodeIdentifierByte = new byte[6];</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">        for (int i = 0; i &lt; 6; ++i) {</span>
<span class="nc" id="L845">            _nodeIdentifierByte[i] =</span>
                (byte) ((nodeIdLong &gt;&gt; ((5 - i) * 8)) &amp; 0xFF);
        }

        // The number of UUIDs allowed per tick depends on the number of
        // ticks between each advance of the clock, adjusted for 100
        // nanosecond precision.
<span class="nc" id="L852">        _uuidsPerTick = Clock.getUnsynchTicks() * 100;</span>
<span class="nc" id="L853">    }</span>

    static {
<span class="nc" id="L856">        initialize();</span>
        // This makes sure we miss at least one clock tick, just to be safe.
<span class="nc" id="L858">        _uuidsThisTick = _uuidsPerTick;</span>
<span class="nc" id="L859">        _lastClock = Clock.clock();</span>
<span class="nc" id="L860">    }</span>


    public static void main(String[] args) {
        long clock;
        HashSet hash;
        String id;
<span class="nc" id="L867">        int count = 1000000;</span>

<span class="nc bnc" id="L869" title="All 2 branches missed.">        for (int i = 0; i &lt; 10; ++i) {</span>
<span class="nc" id="L870">            System.out.println(create());</span>
        }
<span class="nc" id="L872">        clock = System.currentTimeMillis();</span>
<span class="nc" id="L873">        hash = new HashSet(count / 100, 100);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">        for (int i = 0; i &lt; count; ++i) {</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">            if ((i % 10000) == 0)</span>
<span class="nc" id="L876">                System.out.println(&quot;Checked &quot; + i);</span>
<span class="nc" id="L877">            id = create();</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">            if (hash.contains(id))</span>
<span class="nc" id="L879">                System.out.println(&quot;Duplicate id &quot; + id);</span>
            else
<span class="nc" id="L881">                hash.add(id);</span>
        }
<span class="nc" id="L883">        clock = System.currentTimeMillis() - clock;</span>
<span class="nc" id="L884">        System.out.println(&quot;Generated &quot; + count + &quot; UUIDs in &quot; + clock + &quot;ms&quot;);</span>
<span class="nc" id="L885">    }</span>

    /**
     * An exception indicating the identifier is invalid and
     * cannot be converted into an array of bytes.
     */
    public static class InvalidIDException extends Exception {

        public InvalidIDException(String message) {
<span class="nc" id="L894">            super(message);</span>
<span class="nc" id="L895">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>