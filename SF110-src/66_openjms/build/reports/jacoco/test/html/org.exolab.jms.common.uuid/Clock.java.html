<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Clock.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">66_openjms</a> &gt; <a href="index.source.html" class="el_package">org.exolab.jms.common.uuid</a> &gt; <span class="el_source">Clock.java</span></div><h1>Clock.java</h1><pre class="source lang-java linenums">/**
 * Redistribution and use of this software and associated documentation
 * (&quot;Software&quot;), with or without modification, are permitted provided
 * that the following conditions are met:
 *
 * 1. Redistributions of source code must retain copyright
 *    statements and notices.  Redistributions must also contain a
 *    copy of this document.
 *
 * 2. Redistributions in binary form must reproduce the
 *    above copyright notice, this list of conditions and the
 *    following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 *
 * 3. The name &quot;Exolab&quot; must not be used to endorse or promote
 *    products derived from this Software without prior written
 *    permission of Intalio.  For written permission,
 *    please contact info@exolab.org.
 *
 * 4. Products derived from this Software may not be called &quot;Exolab&quot;
 *    nor may &quot;Exolab&quot; appear in their names without prior written
 *    permission of Intalio. Exolab is a registered
 *    trademark of Intalio.
 *
 * 5. Due credit should be given to the Exolab Project
 *    (http://www.exolab.org/).
 *
 * THIS SOFTWARE IS PROVIDED BY INTALIO AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * INTALIO OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Copyright 1999-2005 (C) Intalio Inc. All Rights Reserved.
 *
 * $Id: Clock.java,v 1.2 2005/03/25 13:22:01 tanderson Exp $
 */
package org.exolab.jms.common.uuid;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;


/**
 * Provides an efficient mechanism for obtaining the current
 * system time. Uses a background thread to automatically increment
 * an internal clock and periodically synchronize with the system clock.
 * The method {@link #clock clock} is more efficient than 
 * &lt;code&gt;java.lang.System.currentTimeMillis&lt;/code&gt;, and also
 * allows the clock to be artificially advanced for testing purposes.
 * &lt;p&gt;
 * The clock is thread-safe and consumes a single thread.
 * &lt;p&gt;
 * This class originally came from Tyrex: http://tyrex.sourceforge.net
 *
 * @author &lt;a href=&quot;mailto:arkin@intalio.com&quot;&gt;Assaf Arkin&lt;/a&gt;
 * @version $Revision: 1.2 $
 */
public final class Clock extends Thread {

    /**
     * The number of clock ticks in each unsynchronized cycle.
     * The default is 100 milliseconds.
     */
    public static final int UNSYNCH_TICKS = 100;


    /**
     * The number of unsychronized cycles before the clock is
     * synchronized with the system clock. The default is 10.
     */
    public static final int SYNCH_EVERY = 10;


    /**
     * The current clock.
     */
    private static long _clock;


    /**
     * The number of clock ticks to skip before incrementing the internal
     * clock.
     */
<span class="nc" id="L92">    private static int _unsynchTicks = UNSYNCH_TICKS;</span>

    /**
     * The number of cycles to skip before synchronizing with the system
     * clock.
     */
<span class="nc" id="L98">    private static int _synchEvery = SYNCH_EVERY;</span>


    /**
     * The amount of time in milliseconds by which to advance the clock
     * compared to the system clock.
     */
    private static long _advance;


    /**
     * Used to adjust the clock when it gets out of synch. Based on the
     * difference between the last clock and the system clock at the point of
     * synchronization, divided by synchEvery.
     */
    private static int _adjust;

    /**
     * The logger
     */
<span class="nc" id="L118">    private static final Log _log = LogFactory.getLog(Clock.class);</span>


    /**
     * Returns the current clock.
     *
     * @return The current clock
     */
    public static synchronized long clock() {
        // Synchronization is required since clock is a long.
<span class="nc" id="L128">        return _clock;</span>
    }


    /**
     * Sets the number of clock ticks in each unsynchronized cycle.
     * Use zero to restore the default value.
     * &lt;p&gt;
     * The internal clock is advanced every cycle, the length of the
     * cycle is controlled by this property. A higher value results
     * in a lower clock resolution.
     *
     * @param ticks The number of clock ticks (milliseconds) for
     * each unsynchronized cycle
     */
    public static void setUnsynchTicks(int ticks) {
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (ticks &lt;= 0) {</span>
<span class="nc" id="L145">            ticks = UNSYNCH_TICKS;</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        } else if (ticks &lt; 100) {</span>
<span class="nc" id="L147">            ticks = 100;</span>
        }
<span class="nc" id="L149">        _unsynchTicks = ticks;</span>
<span class="nc" id="L150">    }</span>


    /**
     * Returns the number of clock ticks in each unsynchronized cycle.
     *
     * @return The number of clock ticks (milliseconds) for
     * each unsynchronized cycle
     */
    public static int getUnsynchTicks() {
<span class="nc" id="L160">        return _unsynchTicks;</span>
    }


    /**
     * Sets the number of unsynchronized cycles before the clock
     * is synchronized with the system clock.
     * &lt;p&gt;
     * Synchronization will occur every &lt;tt&gt;unsynchTicks * synchEvery&lt;/tt&gt;
     * milliseconds. The larger the value, the less accurate
     * the clock is.
     *
     * @param every The number of unsynchronized cycles
     */
    public static void setSynchEvery(int every) {
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (every &lt;= 0)</span>
<span class="nc" id="L176">            every = SYNCH_EVERY;</span>
<span class="nc" id="L177">        _synchEvery = every;</span>
<span class="nc" id="L178">    }</span>


    /**
     * Artficially advances the clock.
     *
     * @param byMillis The number of milliseconds by which to
     * advance the clock (must be positive)
     */
    public synchronized static void advance(long byMillis) {
        // Synchronization is required since clock is a long.
<span class="nc" id="L189">        _advance += byMillis;</span>
<span class="nc" id="L190">        _clock += byMillis;</span>
<span class="nc" id="L191">    }</span>


    /**
     * Returns the number of milliseconds by which the clock is
     * advanced.
     *
     * @return The number of milliseconds by which the clock is
     * advanced
     */
    public static long getAdvance() {
<span class="nc" id="L202">        return _advance;</span>
    }


    public void run() {
        while (true) {
            try {
<span class="nc bnc" id="L209" title="All 2 branches missed.">                for (int i = 0; i &lt; _synchEvery; ++i) {</span>
<span class="nc" id="L210">                    sleep(_unsynchTicks);</span>
<span class="nc" id="L211">                    synchronized (Clock.class) {</span>
<span class="nc" id="L212">                        _clock += _unsynchTicks + _adjust;</span>
<span class="nc" id="L213">                    }</span>
                }
<span class="nc" id="L215">                synchronize();</span>
<span class="nc" id="L216">            } catch (InterruptedException exception) {</span>
                // interrupted - need to resynchronize
<span class="nc" id="L218">                synchronize();</span>
<span class="nc" id="L219">            } catch (ThreadDeath exception) {</span>
                // allow this to be terminated when Thread.stop() is
                // invoked. This occurs when applets are destroyed.
<span class="nc" id="L222">                _log.debug(&quot;clock daemon terminating&quot;, exception);</span>
<span class="nc" id="L223">                throw exception;</span>
<span class="nc" id="L224">            } catch (Throwable exception) {</span>
<span class="nc" id="L225">                _log.error(&quot;Internal error in clock daemon&quot;, exception);</span>
<span class="nc" id="L226">            }</span>
        }
    }


    public static synchronized long synchronize() {
        long current;
        long retarded;
        long clock;
        int adjust;

<span class="nc" id="L237">        current = System.currentTimeMillis();</span>
<span class="nc" id="L238">        clock = _clock;</span>
<span class="nc" id="L239">        retarded = clock - _advance;</span>
        // Adjust clock to new difference
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (current != retarded) {</span>
<span class="nc" id="L242">            adjust = (int) (current - retarded) / _synchEvery;</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">            if (adjust != 0) {</span>
<span class="nc" id="L244">                _adjust += adjust;</span>
                /*
                if ( Configuration.verbose )
                    Logger.tyrex.debug( &quot;Clock late by &quot; + ( current - retarded ) +
                                        &quot;ms -&gt; synchronized, adjusting by &quot; + _clock._adjust );
                */
            }
        }
        // Make sure clock is progressive
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (current &gt; retarded) {</span>
<span class="nc" id="L254">            clock = current + _advance;</span>
<span class="nc" id="L255">            _clock = clock;</span>
        }
<span class="nc" id="L257">        return clock;</span>
    }


    private Clock() {
<span class="nc" id="L262">        super(&quot;Clock Daemon&quot;);</span>
<span class="nc" id="L263">        _clock = System.currentTimeMillis();</span>
<span class="nc" id="L264">        setPriority(Thread.MAX_PRIORITY);</span>
<span class="nc" id="L265">        setDaemon(true);</span>
<span class="nc" id="L266">        start();</span>
<span class="nc" id="L267">    }</span>

    static {
<span class="nc" id="L270">        new Clock();</span>
<span class="nc" id="L271">    }</span>

    public static void main(String[] args) {
        long clock;
        int count;

        try {
<span class="nc" id="L278">            count = 1000000;</span>
<span class="nc" id="L279">            System.out.println(&quot;Using Clock.clock()&quot;);</span>
<span class="nc" id="L280">            clock = System.currentTimeMillis();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">            for (int i = 0; i &lt; count; ++i) {</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                if ((i % 100) == 0)</span>
<span class="nc" id="L283">                    synchronize();</span>
                else
<span class="nc" id="L285">                    clock();</span>
            }
<span class="nc" id="L287">            clock = System.currentTimeMillis() - clock;</span>
<span class="nc" id="L288">            System.out.println(&quot;Performed &quot; + count + &quot; in &quot; + clock + &quot;ms&quot;);</span>
<span class="nc" id="L289">            System.out.println(&quot;Using System.currentTimeMillis()&quot;);</span>
<span class="nc" id="L290">            clock = System.currentTimeMillis();</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">            for (int i = 0; i &lt; count; ++i)</span>
<span class="nc" id="L292">                System.currentTimeMillis();</span>
<span class="nc" id="L293">            clock = System.currentTimeMillis() - clock;</span>
<span class="nc" id="L294">            System.out.println(&quot;Performed &quot; + count + &quot; in &quot; + clock + &quot;ms&quot;);</span>
<span class="nc" id="L295">        } catch (Exception except) {</span>
<span class="nc" id="L296">        }</span>
<span class="nc" id="L297">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>