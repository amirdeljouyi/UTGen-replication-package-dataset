<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapMessageImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">66_openjms</a> &gt; <a href="index.source.html" class="el_package">org.exolab.jms.message</a> &gt; <span class="el_source">MapMessageImpl.java</span></div><h1>MapMessageImpl.java</h1><pre class="source lang-java linenums">/**
 * Redistribution and use of this software and associated documentation
 * (&quot;Software&quot;), with or without modification, are permitted provided
 * that the following conditions are met:
 *
 * 1. Redistributions of source code must retain copyright
 *    statements and notices.  Redistributions must also contain a
 *    copy of this document.
 *
 * 2. Redistributions in binary form must reproduce the
 *    above copyright notice, this list of conditions and the
 *    following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 *
 * 3. The name &quot;Exolab&quot; must not be used to endorse or promote
 *    products derived from this Software without prior written
 *    permission of Exoffice Technologies.  For written permission,
 *    please contact info@exolab.org.
 *
 * 4. Products derived from this Software may not be called &quot;Exolab&quot;
 *    nor may &quot;Exolab&quot; appear in their names without prior written
 *    permission of Exoffice Technologies. Exolab is a registered
 *    trademark of Exoffice Technologies.
 *
 * 5. Due credit should be given to the Exolab Project
 *    (http://www.exolab.org/).
 *
 * THIS SOFTWARE IS PROVIDED BY EXOFFICE TECHNOLOGIES AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * EXOFFICE TECHNOLOGIES OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Copyright 2000-2003 (C) Exoffice Technologies Inc. All Rights Reserved.
 *
 * $Id: MapMessageImpl.java,v 1.1 2004/11/26 01:50:43 tanderson Exp $
 *
 * Date         Author  Changes
 * 02/26/2000   jimm    Created
 */

package org.exolab.jms.message;

import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;

import javax.jms.JMSException;
import javax.jms.MapMessage;
import javax.jms.MessageFormatException;
import javax.jms.MessageNotWriteableException;


/**
 * This class implements the {@link javax.jms.MapMessage} interface.
 * &lt;p&gt;
 * A MapMessage is used to send a set of name-value pairs where names are
 * Strings and values are Java primitive types. The entries can be accessed
 * sequentially or randomly by name. The order of the entries is undefined.
 * It inherits from &lt;code&gt;Message&lt;/code&gt; and adds a map message body.
 * &lt;p&gt;
 * The primitive types can be read or written explicitly using methods
 * for each type. They may also be read or written generically as objects.
 * For instance, a call to &lt;code&gt;MapMessage.setInt(&quot;foo&quot;, 6)&lt;/code&gt; is
 * equivalent to &lt;code&gt;MapMessage.setObject(&quot;foo&quot;, new Integer(6))&lt;/code&gt;.
 * Both forms are provided because the explicit form is convenient for
 * static programming and the object form is needed when types are not known
 * at compile time.
 * &lt;p&gt;
 * When a client receives a MapMessage, it is in read-only mode. If a
 * client attempts to write to the message at this point, a
 * MessageNotWriteableException is thrown. If {@link #clearBody} is
 * called, the message can now be both read from and written to.
 * &lt;p&gt;
 * Map messages support the following conversion table. The marked cases
 * must be supported. The unmarked cases must throw a JMSException. The
 * String to primitive conversions may throw a runtime exception if the
 * primitives &lt;code&gt;valueOf()&lt;/code&gt; method does not accept it as a valid
 * String representation of the primitive.
 * &lt;p&gt;
 * A value written as the row type can be read as the column type.
 *
 * &lt;pre&gt;
 * |        | boolean byte short char int long float double String byte[]
 * |----------------------------------------------------------------------
 * |boolean |    X                                            X
 * |byte    |          X     X         X   X                  X
 * |short   |                X         X   X                  X
 * |char    |                     X                           X
 * |int     |                          X   X                  X
 * |long    |                              X                  X
 * |float   |                                    X     X      X
 * |double  |                                          X      X
 * |String  |    X     X     X         X   X     X     X      X
 * |byte[]  |                                                        X
 * |----------------------------------------------------------------------
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Attempting to read a null value as a Java primitive type must be treated
 * as calling the primitive's corresponding &lt;code&gt;valueOf(String)&lt;/code&gt;
 * conversion method with a null value. Since char does not support a
 * String conversion, attempting to read a null value as a char must
 * throw NullPointerException.
 *
 * @version     $Revision: 1.1 $ $Date: 2004/11/26 01:50:43 $
 * @author      &lt;a href=&quot;mailto:mourikis@exolab.org&quot;&gt;Jim Mourikis&lt;/a&gt;
 * @see         javax.jms.MapMessage
 */
public class MapMessageImpl extends MessageImpl implements MapMessage {

    /**
     * Object version no. for serialization
     */
    static final long serialVersionUID = 2;

    /**
     * The initial size of the map
     */
    private static final int INITIAL_SIZE = 20;

    /**
     * The container for all message data
     */
<span class="nc" id="L135">    private HashMap _map = new HashMap(INITIAL_SIZE);</span>

    /**
     * Construct a new MapMessage
     *
     * @throws JMSException if the message type can't be set
     */
<span class="nc" id="L142">    public MapMessageImpl() throws JMSException {</span>
<span class="nc" id="L143">        setJMSType(&quot;MapMessage&quot;);</span>
<span class="nc" id="L144">    }</span>

    /**
     * Clone an instance of this object
     *
     * @return a copy of this object
     * @throws CloneNotSupportedException if object or attributes aren't
     * cloneable
     */
    public final Object clone() throws CloneNotSupportedException {
<span class="nc" id="L154">        MapMessageImpl result = (MapMessageImpl) super.clone();</span>
<span class="nc" id="L155">        result._map = (HashMap) _map.clone();</span>
<span class="nc" id="L156">        return result;</span>
    }

    /**
     * Serialize out this message's data
     *
     * @param out the stream to serialize out to
     * @throws IOException if any I/O exceptions occurr
     */
    public final void writeExternal(ObjectOutput out) throws IOException {
<span class="nc" id="L166">        super.writeExternal(out);</span>
<span class="nc" id="L167">        out.writeLong(serialVersionUID);</span>
<span class="nc" id="L168">        out.writeObject(_map);</span>
<span class="nc" id="L169">    }</span>

    /**
     * Serialize in this message's data
     *
     * @param in the stream to serialize in from
     * @throws ClassNotFoundException if the class for an object being
     * restored cannot be found.
     * @throws IOException if any I/O exceptions occur
     */
    public final void readExternal(ObjectInput in)
        throws ClassNotFoundException, IOException {
<span class="nc" id="L181">        super.readExternal(in);</span>
<span class="nc" id="L182">        long version = in.readLong();</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (version == serialVersionUID) {</span>
<span class="nc" id="L184">            _map = (HashMap) in.readObject();</span>
        } else {
<span class="nc" id="L186">            throw new IOException(&quot;Incorrect version enountered: &quot; + version +</span>
                &quot;. This version = &quot; + serialVersionUID);
        }
<span class="nc" id="L189">    }</span>

    /**
     * Return the boolean value with the given name
     *
     * @param name the name of the boolean
     * @return the boolean value with the given name
     * @throws JMSException if JMS fails to read the message due to some
     * internal JMS error
     * @throws MessageFormatException if this type conversion is invalid
     */
    public final boolean getBoolean(String name)
        throws JMSException, MessageFormatException {
<span class="nc" id="L202">        return FormatConverter.getBoolean(_map.get(name));</span>
    }

    /**
     * Return the byte value with the given name
     *
     * @param name the name of the byte
     * @return the byte value with the given name
     * @throws JMSException if JMS fails to read the message due to some
     * internal JMS error
     * @throws MessageFormatException if this type conversion is invalid
     */
    public final byte getByte(String name)
        throws JMSException, MessageFormatException {
<span class="nc" id="L216">        return FormatConverter.getByte(_map.get(name));</span>
    }

    /**
     * Return the short value with the given name
     *
     * @param name the name of the short
     * @return the short value with the given name
     * @throws JMSException if JMS fails to read the message due to some
     * internal JMS error
     * @throws MessageFormatException if this type conversion is invalid
     */
    public final short getShort(String name)
        throws JMSException, MessageFormatException {
<span class="nc" id="L230">        return FormatConverter.getShort(_map.get(name));</span>
    }

    /**
     * Return the Unicode character value with the given name
     *
     * @param name the name of the Unicode character
     * @return the Unicode character value with the given name
     * @throws JMSException if JMS fails to read the message due to some
     * internal JMS error
     * @throws MessageFormatException if this type conversion is invalid
     */
    public final char getChar(String name)
        throws JMSException, MessageFormatException {
<span class="nc" id="L244">        return FormatConverter.getChar(_map.get(name));</span>
    }

    /**
     * Return the integer value with the given name
     *
     * @param name the name of the integer
     * @return the integer value with the given name
     * @throws JMSException if JMS fails to read the message due to some
     * internal JMS error
     * @throws MessageFormatException if this type conversion is invalid
     */
    public final int getInt(String name)
        throws JMSException, MessageFormatException {
<span class="nc" id="L258">        return FormatConverter.getInt(_map.get(name));</span>
    }

    /**
     * Return the long value with the given name
     *
     * @param name the name of the long
     * @return the long value with the given name
     * @throws JMSException if JMS fails to read the message due to some
     * internal JMS error
     * @throws MessageFormatException if this type conversion is invalid
     */
    public final long getLong(String name)
        throws JMSException, MessageFormatException {
<span class="nc" id="L272">        return FormatConverter.getLong(_map.get(name));</span>
    }

    /**
     * Return the float value with the given name
     *
     * @param name the name of the float
     * @return the float value with the given name
     * @throws JMSException if JMS fails to read the message due to some
     * internal JMS error
     * @throws MessageFormatException if this type conversion is invalid
     */
    public final float getFloat(String name)
        throws JMSException, MessageFormatException {
<span class="nc" id="L286">        return FormatConverter.getFloat(_map.get(name));</span>
    }

    /**
     * Return the double value with the given name
     *
     * @param name the name of the double
     * @return the double value with the given name
     * @throws JMSException if JMS fails to read the message due to some
     * internal JMS error
     * @throws MessageFormatException if this type conversion is invalid
     */
    public final double getDouble(String name)
        throws JMSException, MessageFormatException {
<span class="nc" id="L300">        return FormatConverter.getDouble(_map.get(name));</span>
    }

    /**
     * Return the String value with the given name
     *
     * @param name the name of the String
     * @return the String value with the given name. If there is no item
     * by this name, a null value is returned.
     * @throws JMSException if JMS fails to read the message due to some
     * internal JMS error
     * @throws MessageFormatException if this type conversion is invalid
     */
    public final String getString(String name)
        throws JMSException, MessageFormatException {
<span class="nc" id="L315">        return FormatConverter.getString(_map.get(name));</span>
    }

    /**
     * Return the byte array value with the given name
     *
     * @param name the name of the byte array
     * @return a copy of the byte array value with the given name.
     * If there is no item by this name, a null value is returned.
     * @throws JMSException if JMS fails to read the message due to some
     * internal JMS error
     * @throws MessageFormatException if this type conversion is invalid
     */
    public final byte[] getBytes(String name)
        throws JMSException, MessageFormatException {
<span class="nc" id="L330">        return FormatConverter.getBytes(_map.get(name));</span>
    }

    /**
     * Return the Java object value with the given name
     * &lt;p&gt;
     * Note that this method can be used to return in objectified format,
     * an object that had been stored in the Map with the equivalent
     * &lt;code&gt;setObject&lt;/code&gt; method call, or it's equivalent primitive
     * set&lt;type&gt; method.
     *
     * @param name the name of the Java object
     * @return a copy of the Java object value with the given name, in
     * objectified format (eg. if it set as an int, then an Integer is
     * returned).
     * Note that byte values are returned as byte[], not Byte[].
     * If there is no item by this name, a null value is returned.
     * @throws JMSException if JMS fails to read the message due to some
     * internal JMS error
     */
    public final Object getObject(String name) throws JMSException {
<span class="nc" id="L351">        Object result = null;</span>
<span class="nc" id="L352">        Object value = _map.get(name);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">            if (value instanceof Boolean) {</span>
<span class="nc" id="L355">                result = new Boolean(((Boolean) value).booleanValue());</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">            } else if (value instanceof Byte) {</span>
<span class="nc" id="L357">                result = new Byte(((Byte) value).byteValue());</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">            } else if (value instanceof Short) {</span>
<span class="nc" id="L359">                result = new Short(((Short) value).shortValue());</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">            } else if (value instanceof Character) {</span>
<span class="nc" id="L361">                result = new Character(((Character) value).charValue());</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">            } else if (value instanceof Integer) {</span>
<span class="nc" id="L363">                result = new Integer(((Integer) value).intValue());</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">            } else if (value instanceof Long) {</span>
<span class="nc" id="L365">                result = new Long(((Long) value).longValue());</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">            } else if (value instanceof Float) {</span>
<span class="nc" id="L367">                result = new Float(((Float) value).floatValue());</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">            } else if (value instanceof Double) {</span>
<span class="nc" id="L369">                result = new Double(((Double) value).doubleValue());</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">            } else if (value instanceof String) {</span>
<span class="nc" id="L371">                result = (String) value;</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            } else if (value instanceof byte[]) {</span>
<span class="nc" id="L373">                result = getBytes(name);</span>
            } else {
<span class="nc" id="L375">                throw new MessageFormatException(</span>
                    &quot;MapMessage contains an unsupported object of type=&quot; +
<span class="nc" id="L377">                    value.getClass().getName());</span>
            }
        }
<span class="nc" id="L380">        return result;</span>
    }

    /**
     * Return an Enumeration of all the Map message's names.
     *
     * @return an enumeration of all the names in this Map message.
     */
    public final Enumeration getMapNames() {
<span class="nc" id="L389">        return Collections.enumeration(_map.keySet());</span>
    }

    /**
     * Set a boolean value with the given name, into the Map
     *
     * @param name the name of the boolean
     * @param value the boolean value to set in the Map
     * @throws MessageNotWriteableException if the message is in read-only mode
     */
    public final void setBoolean(String name, boolean value)
        throws MessageNotWriteableException {
<span class="nc" id="L401">        checkWrite();</span>
<span class="nc" id="L402">        _map.put(name, new Boolean(value));</span>
<span class="nc" id="L403">    }</span>

    /**
     * Set a byte value with the given name, into the Map
     *
     * @param name the name of the byte
     * @param value the byte value to set in the Map
     * @throws MessageNotWriteableException if the message is in read-only mode
     */
    public final void setByte(String name, byte value)
        throws MessageNotWriteableException {
<span class="nc" id="L414">        checkWrite();</span>
<span class="nc" id="L415">        _map.put(name, new Byte(value));</span>
<span class="nc" id="L416">    }</span>

    /**
     * Set a short value with the given name, into the Map
     *
     * @param name the name of the short
     * @param value the short value to set in the Map
     * @throws MessageNotWriteableException if the message is in read-only mode
     */
    public final void setShort(String name, short value)
        throws MessageNotWriteableException {
<span class="nc" id="L427">        checkWrite();</span>
<span class="nc" id="L428">        _map.put(name, new Short(value));</span>
<span class="nc" id="L429">    }</span>

    /**
     * Set a Unicode character value with the given name, into the Map
     *
     * @param name the name of the Unicode character
     * @param value the Unicode character value to set in the Map
     * @throws MessageNotWriteableException if the message is in read-only mode
     */
    public final void setChar(String name, char value)
        throws MessageNotWriteableException {
<span class="nc" id="L440">        checkWrite();</span>
<span class="nc" id="L441">        _map.put(name, new Character(value));</span>
<span class="nc" id="L442">    }</span>

    /**
     * Set an integer value with the given name, into the Map
     *
     * @param name the name of the integer
     * @param value the integer value to set in the Map
     * @throws MessageNotWriteableException if the message is in read-only mode
     */
    public final void setInt(String name, int value)
        throws MessageNotWriteableException {
<span class="nc" id="L453">        checkWrite();</span>
<span class="nc" id="L454">        _map.put(name, new Integer(value));</span>
<span class="nc" id="L455">    }</span>

    /**
     * Set a long value with the given name, into the Map
     *
     * @param name the name of the long
     * @param value the long value to set in the Map
     * @throws MessageNotWriteableException if the message is in read-only mode
     */
    public final void setLong(String name, long value)
        throws MessageNotWriteableException {
<span class="nc" id="L466">        checkWrite();</span>
<span class="nc" id="L467">        _map.put(name, new Long(value));</span>
<span class="nc" id="L468">    }</span>

    /**
     * Set a float value with the given name, into the Map
     *
     * @param name the name of the float
     * @param value the float value to set in the Map
     * @throws MessageNotWriteableException if the message is in read-only mode
     */
    public final void setFloat(String name, float value)
        throws MessageNotWriteableException {
<span class="nc" id="L479">        checkWrite();</span>
<span class="nc" id="L480">        _map.put(name, new Float(value));</span>
<span class="nc" id="L481">    }</span>

    /**
     * Set a double value with the given name, into the Map
     *
     * @param name the name of the double
     * @param value the double value to set in the Map
     * @throws MessageNotWriteableException if the message is in read-only mode
     */
    public final void setDouble(String name, double value)
        throws MessageNotWriteableException {
<span class="nc" id="L492">        checkWrite();</span>
<span class="nc" id="L493">        _map.put(name, new Double(value));</span>
<span class="nc" id="L494">    }</span>

    /**
     * Set a String value with the given name, into the Map
     *
     * @param name the name of the String
     * @param value the String value to set in the Map
     * @throws MessageNotWriteableException if the message is in read-only mode
     */
    public final void setString(String name, String value)
        throws MessageNotWriteableException {
<span class="nc" id="L505">        checkWrite();</span>
<span class="nc" id="L506">        _map.put(name, value);</span>
<span class="nc" id="L507">    }</span>

    /**
     * Set a byte array value with the given name, into the Map
     *
     * @param name the name of the byte array
     * @param value the byte array value to set in the Map. The array is
     * copied so the value for name will not be altered by future
     * modifications.
     * @throws MessageNotWriteableException if the message is in read-only mode
     */
    public final void setBytes(String name, byte[] value)
        throws MessageNotWriteableException {
<span class="nc" id="L520">        checkWrite();</span>
<span class="nc" id="L521">        byte[] bytes = null;</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc" id="L523">            bytes = new byte[value.length];</span>
<span class="nc" id="L524">            System.arraycopy(value, 0, bytes, 0, bytes.length);</span>
        }
<span class="nc" id="L526">        _map.put(name, bytes);</span>
<span class="nc" id="L527">    }</span>

    /**
     * Set a portion of the byte array value with the given name, into the Map
     *
     * @param name the name of the byte array
     * @param value the byte array value to set in the Map.
     * @param offset the initial offset within the byte array.
     * @param length the number of bytes to use.
     * @throws MessageNotWriteableException if the message is in read-only mode
     */
    public final void setBytes(String name, byte[] value,
                               int offset, int length)
        throws MessageNotWriteableException {
<span class="nc" id="L541">        checkWrite();</span>
<span class="nc" id="L542">        byte[] bytes = null;</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc" id="L544">            bytes = new byte[length];</span>
<span class="nc" id="L545">            System.arraycopy(value, offset, bytes, 0, length);</span>
        }
<span class="nc" id="L547">        _map.put(name, bytes);</span>
<span class="nc" id="L548">    }</span>

    /**
     * Set a Java object value with the given name, into the Map
     * &lt;p&gt;
     * Note that this method only works for the objectified primitive
     * object types (Integer, Double, Long ...), String's and byte arrays.
     *
     * @param name the name of the Java object
     * @param value the Java object value to set in the Map
     * @throws MessageFormatException if object is invalid
     * @throws MessageNotWriteableException if message in read-only mode.
     */
    public final void setObject(String name, Object value)
        throws MessageFormatException, MessageNotWriteableException {
<span class="nc" id="L563">        checkWrite();</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L565">            _map.put(name, null);</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">        } else if (value instanceof Boolean) {</span>
<span class="nc" id="L567">            setBoolean(name, ((Boolean) value).booleanValue());</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">        } else if (value instanceof Byte) {</span>
<span class="nc" id="L569">            setByte(name, ((Byte) value).byteValue());</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">        } else if (value instanceof Short) {</span>
<span class="nc" id="L571">            setShort(name, ((Short) value).shortValue());</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">        } else if (value instanceof Character) {</span>
<span class="nc" id="L573">            setChar(name, ((Character) value).charValue());</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">        } else if (value instanceof Integer) {</span>
<span class="nc" id="L575">            setInt(name, ((Integer) value).intValue());</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">        } else if (value instanceof Long) {</span>
<span class="nc" id="L577">            setLong(name, ((Long) value).longValue());</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">        } else if (value instanceof Float) {</span>
<span class="nc" id="L579">            setFloat(name, ((Float) value).floatValue());</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">        } else if (value instanceof Double) {</span>
<span class="nc" id="L581">            setDouble(name, ((Double) value).doubleValue());</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">        } else if (value instanceof String) {</span>
<span class="nc" id="L583">            setString(name, (String) value);</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">        } else if (value instanceof byte[]) {</span>
<span class="nc" id="L585">            setBytes(name, (byte[]) value);</span>
        } else {
<span class="nc" id="L587">            throw new MessageFormatException(</span>
                &quot;MapMessage does not support objects of type=&quot; +
<span class="nc" id="L589">                value.getClass().getName());</span>
        }
<span class="nc" id="L591">    }</span>

    /**
     * Check if an item exists in this MapMessage
     *
     * @param name the name of the item to test
     * @return true if the item exists
     */
    public final boolean itemExists(String name) {
<span class="nc" id="L600">        return _map.containsKey(name);</span>
    }

    /**
     * Clear out the message body. Clearing a message's body does not clear
     * its header values or property entries.
     * If this message body was read-only, calling this method leaves the
     * message body is in the same state as an empty body in a newly created
     * message
     */
    public final void clearBody() throws JMSException {
<span class="nc" id="L611">        super.clearBody();</span>
<span class="nc" id="L612">        _map = new HashMap(INITIAL_SIZE);</span>
<span class="nc" id="L613">    }</span>

} // End MapMessageImpl
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>