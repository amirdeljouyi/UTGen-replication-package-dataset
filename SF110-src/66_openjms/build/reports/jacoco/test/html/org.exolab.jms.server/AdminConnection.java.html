<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AdminConnection.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">66_openjms</a> &gt; <a href="index.source.html" class="el_package">org.exolab.jms.server</a> &gt; <span class="el_source">AdminConnection.java</span></div><h1>AdminConnection.java</h1><pre class="source lang-java linenums">/**
 * Redistribution and use of this software and associated documentation
 * (&quot;Software&quot;), with or without modification, are permitted provided
 * that the following conditions are met:
 *
 * 1. Redistributions of source code must retain copyright
 *    statements and notices.  Redistributions must also contain a
 *    copy of this document.
 *
 * 2. Redistributions in binary form must reproduce the
 *    above copyright notice, this list of conditions and the
 *    following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 *
 * 3. The name &quot;Exolab&quot; must not be used to endorse or promote
 *    products derived from this Software without prior written
 *    permission of Exoffice Technologies.  For written permission,
 *    please contact info@exolab.org.
 *
 * 4. Products derived from this Software may not be called &quot;Exolab&quot;
 *    nor may &quot;Exolab&quot; appear in their names without prior written
 *    permission of Exoffice Technologies. Exolab is a registered
 *    trademark of Exoffice Technologies.
 *
 * 5. Due credit should be given to the Exolab Project
 *    (http://www.exolab.org/).
 *
 * THIS SOFTWARE IS PROVIDED BY EXOFFICE TECHNOLOGIES AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * EXOFFICE TECHNOLOGIES OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Copyright 2000-2005 (C) Exoffice Technologies Inc. All Rights Reserved.
 */
package org.exolab.jms.server;

import java.sql.Connection;
import java.util.Enumeration;
import java.util.Vector;
import javax.jms.JMSException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.exolab.jms.authentication.AuthenticationMgr;
import org.exolab.jms.authentication.User;
import org.exolab.jms.client.JmsDestination;
import org.exolab.jms.client.JmsQueue;
import org.exolab.jms.client.JmsTopic;
import org.exolab.jms.config.Configuration;
import org.exolab.jms.config.Connector;
import org.exolab.jms.config.types.SchemeType;
import org.exolab.jms.messagemgr.ConsumerEndpoint;
import org.exolab.jms.messagemgr.ConsumerManager;
import org.exolab.jms.messagemgr.DestinationCache;
import org.exolab.jms.messagemgr.DestinationManager;
import org.exolab.jms.messagemgr.DurableConsumerEndpoint;
import org.exolab.jms.persistence.DatabaseService;
import org.exolab.jms.persistence.PersistenceException;
import org.exolab.jms.service.ServiceException;
import org.exolab.jms.service.Services;


/**
 * A connection is created for every adminclient connecting to the JmsServer.
 *
 * @author &lt;a href=&quot;mailto:knut@lerpold.no&quot;&gt;Knut Lerpold&lt;/a&gt;
 * @version $Revision: 1.7 $ $Date: 2005/12/23 12:17:45 $
 * @see org.exolab.jms.server.AdminConnectionManager
 */
public class AdminConnection {

    /**
     * The configuration.
     */
    private final Configuration _config;

    /**
     * The authentication manager.
     */
    private final AuthenticationMgr _authenticator;

    /**
     * The destination manager.
     */
    private final DestinationManager _destinations;

    /**
     * The consumer manager.
     */
    private final ConsumerManager _consumers;

    /**
     * The database service.
     */
    private final DatabaseService _database;

    /**
     * The services.
     */
    private final Services _services;

    /**
     * The logger
     */
<span class="nc" id="L114">    private static final Log _log = LogFactory.getLog(AdminConnection.class);</span>


    /**
     * Construct a new &lt;code&gt;AdminConnection&lt;/code&gt;.
     *
     * @param config        the configuration
     * @param authenticator the authentication manager
     * @param destinations  the destination manager
     * @param database      the database service
     * @param services      the services
     */
    protected AdminConnection(Configuration config, AuthenticationMgr authenticator,
                              DestinationManager destinations, ConsumerManager consumers,
                              DatabaseService database,
<span class="nc" id="L129">                              Services services) {</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (config == null) {</span>
<span class="nc" id="L131">            throw new IllegalArgumentException(&quot;Argument 'config' is null&quot;);</span>
        }
<span class="nc bnc" id="L133" title="All 2 branches missed.">        if (authenticator == null) {</span>
<span class="nc" id="L134">            throw new IllegalArgumentException(</span>
                    &quot;Argument 'authenticator' is null&quot;);
        }
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (destinations == null) {</span>
<span class="nc" id="L138">            throw new IllegalArgumentException(</span>
                    &quot;Argument 'destinations' is null&quot;);
        }
<span class="nc bnc" id="L141" title="All 2 branches missed.">        if (consumers == null) {</span>
<span class="nc" id="L142">            throw new IllegalArgumentException(&quot;Argument 'consumers' is null&quot;);</span>
        }
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (database == null) {</span>
<span class="nc" id="L145">            throw new IllegalArgumentException(&quot;Argument 'database' is null&quot;);</span>
        }
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (services == null) {</span>
<span class="nc" id="L148">            throw new IllegalArgumentException(&quot;Argument 'services' is null&quot;);</span>
        }
<span class="nc" id="L150">        _config = config;</span>
<span class="nc" id="L151">        _authenticator = authenticator;</span>
<span class="nc" id="L152">        _destinations = destinations;</span>
<span class="nc" id="L153">        _consumers = consumers;</span>
<span class="nc" id="L154">        _database = database;</span>
<span class="nc" id="L155">        _services = services;</span>
<span class="nc" id="L156">    }</span>

    /**
     * Close the admin connection
     */
    public void close() {
<span class="nc" id="L162">    }</span>

    /**
     * Return the number of messages for a durable consumer.
     *
     * @param topic name of the topic
     * @param name  consumer name
     * @return int                 number of unsent or unacked messages
     */
    public int getDurableConsumerMessageCount(String topic, String name) {
<span class="nc" id="L172">        int count = -1;</span>
        try {
            // first see if the cache is loaded in memory
<span class="nc" id="L175">            JmsDestination dest = _destinations.getDestination(topic);</span>
<span class="nc" id="L176">            ConsumerEndpoint endpoint = null;</span>
<span class="nc bnc" id="L177" title="All 4 branches missed.">            if ((dest != null)</span>
                    &amp;&amp; ((name != null)
<span class="nc bnc" id="L179" title="All 2 branches missed.">                    || (name.length() &gt; 0))) {</span>

<span class="nc" id="L181">                endpoint = _consumers.getConsumerEndpoint(name);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">                if ((endpoint != null)</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">                        &amp;&amp; (endpoint.getDestination().equals(dest))) {</span>
                    // retrieve the number of handles for the endpoint, which
                    // reflects the number of messages
<span class="nc" id="L186">                    count = endpoint.getMessageCount();</span>
                } else {
                    // there is no cache with this name stored in memory. If
                    // this is an administered destination then read the count
                    //  directly from the database.
<span class="nc bnc" id="L191" title="All 2 branches missed.">                    if (dest.getPersistent()) {</span>
                        try {
<span class="nc" id="L193">                            _database.begin();</span>
<span class="nc" id="L194">                            Connection connection = _database.getConnection();</span>
<span class="nc" id="L195">                            count = _database.getAdapter().</span>
<span class="nc" id="L196">                                    getDurableConsumerMessageCount(connection, topic,</span>
                                                                   name);
<span class="nc" id="L198">                            _database.commit();</span>
<span class="nc" id="L199">                        } catch (PersistenceException exception) {</span>
<span class="nc" id="L200">                            _log.error(exception, exception);</span>
                            try {
<span class="nc" id="L202">                                _database.rollback();</span>
<span class="nc" id="L203">                            } catch (PersistenceException error) {</span>
                                // no-op
<span class="nc" id="L205">                            }</span>
<span class="nc" id="L206">                        }</span>
                    }
                }
            }
<span class="nc" id="L210">        } catch (Exception exception) {</span>
<span class="nc" id="L211">            _log.error(&quot;Failed to get message count for topic=&quot; + topic,</span>
                       exception);
<span class="nc" id="L213">        } finally {</span>
<span class="nc" id="L214">        }</span>

<span class="nc" id="L216">        return count;</span>
    }

    /**
     * First use the destination manager to return the number of persistent and
     * non-persistent messages in a queue.
     *
     * @param queue name of the queue
     * @return int - the number of messages for that destination or -1 if the
     *         destination is invalid
     */
    public int getQueueMessageCount(String queue) {
<span class="nc" id="L228">        int count = -1;</span>

        try {
            // first see if the cache is loaded in memory
<span class="nc" id="L232">            JmsDestination dest = _destinations.getDestination(queue);</span>
<span class="nc" id="L233">            DestinationCache cache = null;</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">            if (dest != null) {</span>
<span class="nc" id="L235">                _database.begin();</span>
<span class="nc" id="L236">                cache = _destinations.getDestinationCache(dest);</span>
                // retrieve the number of handles for the cache, which
                // reflects the number of messages
<span class="nc" id="L239">                count = cache.getMessageCount();</span>
<span class="nc" id="L240">                _database.commit();</span>
            }
<span class="nc" id="L242">        } catch (Exception exception) {</span>
<span class="nc" id="L243">            _log.error(&quot;Failed to get message count for queue=&quot; + queue,</span>
                       exception);
<span class="nc" id="L245">            rollback();</span>
<span class="nc" id="L246">        }</span>
<span class="nc" id="L247">        return count;</span>
    }

    /**
     * Add the specified durable consumer to the database.
     *
     * @param topic name of the destination
     * @param name  name of the consumer
     * @return boolean             true if successful
     */
    public boolean addDurableConsumer(String topic, String name) {
<span class="nc" id="L258">        boolean result = false;</span>
        try {
<span class="nc" id="L260">            JmsTopic t = new JmsTopic(topic);</span>
<span class="nc" id="L261">            t.setPersistent(true);</span>
<span class="nc" id="L262">            _consumers.subscribe(t, name, null);</span>
<span class="nc" id="L263">            result = true;</span>
<span class="nc" id="L264">        } catch (JMSException exception) {</span>
<span class="nc" id="L265">            _log.error(&quot;Failed to add durable consumer=&quot; + name</span>
                       + &quot; for topic=&quot; + topic, exception);
<span class="nc" id="L267">        }</span>

<span class="nc" id="L269">        return result;</span>
    }

    /**
     * Remove the consumer attached to the specified destination and with the
     * passed in name.
     *
     * @param name name of the consumer
     * @return boolean             true if successful
     */
    public boolean removeDurableConsumer(String name) {
<span class="nc" id="L280">        boolean result = false;</span>
        try {
<span class="nc" id="L282">            _consumers.unsubscribe(name, null);</span>
<span class="nc" id="L283">            result = true;</span>
<span class="nc" id="L284">        } catch (JMSException exception) {</span>
<span class="nc" id="L285">            _log.debug(&quot;Failed to remove durable consumer=&quot; + name, exception);</span>
<span class="nc" id="L286">        }</span>

<span class="nc" id="L288">        return result;</span>
    }

    /**
     * Check if the durable consumer exists.
     *
     * @param name name of the durable conusmer
     * @return boolean             true if it exists and false otherwise
     */
    public boolean durableConsumerExists(String name) {
<span class="nc bnc" id="L298" title="All 2 branches missed.">        return (_consumers.getConsumerEndpoint(name) != null);</span>
    }

    /**
     * Return the collection of durable consumer names for a particular topic
     * destination.
     *
     * @param topic the topic name
     * @return Vector              collection of strings
     */
    public Vector getDurableConsumers(String topic) {
<span class="nc" id="L309">        Enumeration iter = null;</span>
<span class="nc" id="L310">        Vector result = new Vector();</span>

        try {
<span class="nc" id="L313">            _database.begin();</span>
<span class="nc" id="L314">            Connection connection = _database.getConnection();</span>

<span class="nc" id="L316">            iter = _database.getAdapter().getDurableConsumers(connection,</span>
                                                              topic);
            // copy the elements into the vector
<span class="nc bnc" id="L319" title="All 2 branches missed.">            while (iter.hasMoreElements()) {</span>
<span class="nc" id="L320">                result.addElement(iter.nextElement());</span>
            }
<span class="nc" id="L322">            _database.commit();</span>
<span class="nc" id="L323">        } catch (Exception exception) {</span>
<span class="nc" id="L324">            _log.error(&quot;Failed on get durable consumers for topic=&quot; + topic,</span>
                       exception);
<span class="nc" id="L326">            rollback();</span>
<span class="nc" id="L327">        }</span>

<span class="nc" id="L329">        return result;</span>
    }

    /**
     * De-Activate an active persistent consumer.
     *
     * @param name name of the consumer
     * @return boolean             true if successful
     */
    public boolean unregisterConsumer(String name) {
<span class="nc" id="L339">        boolean success = false;</span>

<span class="nc" id="L341">        ConsumerEndpoint endpoint = _consumers.getConsumerEndpoint(name);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (endpoint != null) {</span>
<span class="nc" id="L343">            _consumers.closeConsumer(endpoint);</span>
        }
<span class="nc" id="L345">        success = true;</span>

<span class="nc" id="L347">        return success;</span>
    }

    /**
     * Check to see if the given consumer is currently connected to the
     * OpenJMSServer. This is only valid when in online mode.
     *
     * @param name The name of the onsumer.
     * @return boolean True if the consumer is connected.
     */
    public boolean isConnected(String name) {
<span class="nc" id="L358">        boolean result = false;</span>
<span class="nc" id="L359">        ConsumerEndpoint endpoint = _consumers.getConsumerEndpoint(name);</span>
<span class="nc bnc" id="L360" title="All 4 branches missed.">        if (endpoint != null &amp;&amp; endpoint instanceof DurableConsumerEndpoint) {</span>
<span class="nc" id="L361">            result = ((DurableConsumerEndpoint) endpoint).isActive();</span>
        }
<span class="nc" id="L363">        return result;</span>
    }

    /**
     * Return a list of all registered destinations.
     *
     * @return Vector     collection of strings
     */
    public Vector getAllDestinations() {
<span class="nc" id="L372">        Enumeration iter = null;</span>
<span class="nc" id="L373">        Vector result = new Vector();</span>

        try {
<span class="nc" id="L376">            _database.begin();</span>
<span class="nc" id="L377">            Connection connection = _database.getConnection();</span>

<span class="nc" id="L379">            iter = _database.getAdapter().getAllDestinations(connection);</span>
            // copy the elements into the vector
<span class="nc bnc" id="L381" title="All 2 branches missed.">            while (iter.hasMoreElements()) {</span>
<span class="nc" id="L382">                result.addElement(iter.nextElement());</span>
            }
<span class="nc" id="L384">            _database.commit();</span>
<span class="nc" id="L385">        } catch (Exception exception) {</span>
<span class="nc" id="L386">            _log.error(&quot;Failed to get all destinations&quot;, exception);</span>
<span class="nc" id="L387">            rollback();</span>
<span class="nc" id="L388">        }</span>

<span class="nc" id="L390">        return result;</span>
    }

    /**
     * Add an administered destination with the specified name.
     *
     * @param name  destination name
     * @param queue whether it is queue or a topic
     * @return boolean             true if successful
     */
    public boolean addDestination(String name, Boolean queue) {

<span class="nc" id="L402">        boolean success = false;</span>

        // create the appropriate destination object
<span class="nc bnc" id="L405" title="All 2 branches missed.">        JmsDestination destination = (queue.booleanValue())</span>
                ? (JmsDestination) new JmsQueue(name)
                : (JmsDestination) new JmsTopic(name);
<span class="nc" id="L408">        destination.setPersistent(true);</span>

        // create the administered destination
        try {
<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (_destinations.getDestination(name) == null) {</span>
<span class="nc" id="L413">                _destinations.createDestination(destination);</span>
<span class="nc" id="L414">                success = true;</span>
            }
<span class="nc" id="L416">        } catch (JMSException exception) {</span>
<span class="nc" id="L417">            _log.error(&quot;Failed to add destination=&quot; + name, exception);</span>
<span class="nc" id="L418">        }</span>

<span class="nc" id="L420">        return success;</span>
    }

    /**
     * Destroy the specified destination and all associated messsages and
     * consumers. This is a very dangerous operation to execute while there are
     * clients online
     *
     * @param name destination to destroy
     * @return boolean             true if successful
     */
    public boolean removeDestination(String name) {

<span class="nc" id="L433">        boolean success = false;</span>
<span class="nc" id="L434">        JmsDestination dest = _destinations.getDestination(name);</span>

        // ensure that the destination actually translates to a valid
        // object.
<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (dest != null) {</span>
            try {
<span class="nc" id="L440">                _destinations.removeDestination(dest);</span>
<span class="nc" id="L441">                success = true;</span>
<span class="nc" id="L442">            } catch (JMSException exception) {</span>
<span class="nc" id="L443">                _log.error(&quot;Failed to remove destination=&quot; + name, exception);</span>
<span class="nc" id="L444">            }</span>
        }

<span class="nc" id="L447">        return success;</span>
    }

    /**
     * Check whether the specified destination exists
     *
     * @param name - the name of the destination to check
     * @return boolean - true if it does and false otherwise
     */
    public boolean destinationExists(String name) {

<span class="nc" id="L458">        JmsDestination dest = _destinations.getDestination(name);</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">        return (dest != null);</span>
    }

    /**
     * Terminate the JMS Server. If it is running as a standalone application
     * then exit the application. It is running as an embedded application then
     * just terminate the thread
     */
    public void stopServer() {
<span class="nc" id="L468">        boolean isEmbedded = false;</span>
<span class="nc" id="L469">        Connector[] connectors = _config.getConnectors().getConnector();</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">        for (int i = 0; i &lt; connectors.length; ++i) {</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (connectors[i].getScheme().equals(SchemeType.EMBEDDED)) {</span>
<span class="nc" id="L472">                isEmbedded = true;</span>
<span class="nc" id="L473">                break;</span>
            }
        }

<span class="nc bnc" id="L477" title="All 2 branches missed.">        final boolean exit = !isEmbedded;</span>

<span class="nc" id="L479">        Runnable r = new Runnable() {</span>

            public void run() {
                try {
                    // give the caller a chance to return before shutting
                    // down services
<span class="nc" id="L485">                    Thread.sleep(1000);</span>
<span class="nc" id="L486">                } catch (InterruptedException ignore) {</span>
<span class="nc" id="L487">                }</span>
<span class="nc" id="L488">                _log.info(&quot;Stopping all services&quot;);</span>
                try {
<span class="nc" id="L490">                    _services.stop();</span>
<span class="nc" id="L491">                } catch (ServiceException exception) {</span>
<span class="nc" id="L492">                    _log.error(exception, exception);</span>
<span class="nc" id="L493">                }</span>

<span class="nc bnc" id="L495" title="All 2 branches missed.">                if (exit) {</span>
<span class="nc" id="L496">                    _log.info(&quot;Server shutdown scheduled for 5 secs&quot;);</span>
                    try {
<span class="nc" id="L498">                        Thread.sleep(5000);</span>
<span class="nc" id="L499">                    } catch (InterruptedException ignore) {</span>
<span class="nc" id="L500">                    }</span>
<span class="nc" id="L501">                    System.exit(0);</span>
                }
<span class="nc" id="L503">            }</span>
        };
<span class="nc" id="L505">        Thread t = new Thread(r);</span>
<span class="nc" id="L506">        t.start();</span>
<span class="nc" id="L507">    }</span>

    /**
     * Purge all processed messages from the database
     *
     * @return int         number of messages purged
     */
    public int purgeMessages() {
<span class="nc" id="L515">        return _database.getAdapter().purgeMessages();</span>
    }

    /**
     * Add a user with the specified name
     *
     * @param username the users name
     * @param password the users password
     * @return &lt;code&gt;true&lt;/code&gt; if the user is added otherwise
     *         &lt;code&gt;false&lt;/code&gt;
     */
    public boolean addUser(String username, String password) {
<span class="nc" id="L527">        return _authenticator.addUser(new User(username, password));</span>
    }

    /**
     * Change password for the specified user
     *
     * @param username the users name
     * @param password the users password
     * @return &lt;code&gt;true&lt;/code&gt; if the password is changed otherwise
     *         &lt;code&gt;false&lt;/code&gt;
     */
    public boolean changePassword(String username, String password) {
<span class="nc" id="L539">        return _authenticator.updateUser(new User(username, password));</span>
    }

    /**
     * Remove the specified user
     *
     * @param username the users name
     * @return &lt;code&gt;true&lt;/code&gt; if the user is removed otherwise
     *         &lt;code&gt;false&lt;/code&gt;
     */
    public boolean removeUser(String username) {
<span class="nc" id="L550">        return _authenticator.removeUser(new User(username, null));</span>
    }

    /**
     * Return a list of all registered users.
     *
     * @return Vector of users
     */
    public Vector getAllUsers() {
<span class="nc" id="L559">        Enumeration iter = null;</span>
<span class="nc" id="L560">        Vector result = new Vector();</span>

        try {
<span class="nc" id="L563">            _database.begin();</span>
<span class="nc" id="L564">            Connection connection = _database.getConnection();</span>

<span class="nc" id="L566">            iter = _database.getAdapter().getAllUsers(connection);</span>
            // copy the elements into the vector
<span class="nc bnc" id="L568" title="All 2 branches missed.">            while (iter.hasMoreElements()) {</span>
<span class="nc" id="L569">                result.addElement(iter.nextElement());</span>
            }
<span class="nc" id="L571">            _database.commit();</span>
<span class="nc" id="L572">        } catch (Exception exception) {</span>
<span class="nc" id="L573">            _log.error(&quot;Failed on get all users&quot;, exception);</span>
<span class="nc" id="L574">            rollback();</span>
<span class="nc" id="L575">        }</span>

<span class="nc" id="L577">        return result;</span>
    }

    /**
     * Rollback the current transaction, logging any error.
     */
    private void rollback() {
        try {
<span class="nc" id="L585">            _database.rollback();</span>
<span class="nc" id="L586">        } catch (PersistenceException exception) {</span>
<span class="nc" id="L587">            _log.error(exception, exception);</span>
<span class="nc" id="L588">        }</span>
<span class="nc" id="L589">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>