<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SessionConsumer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">66_openjms</a> &gt; <a href="index.source.html" class="el_package">org.exolab.jms.server</a> &gt; <span class="el_source">SessionConsumer.java</span></div><h1>SessionConsumer.java</h1><pre class="source lang-java linenums">/**
 * Redistribution and use of this software and associated documentation
 * (&quot;Software&quot;), with or without modification, are permitted provided
 * that the following conditions are met:
 *
 * 1. Redistributions of source code must retain copyright
 *    statements and notices.  Redistributions must also contain a
 *    copy of this document.
 *
 * 2. Redistributions in binary form must reproduce the
 *    above copyright notice, this list of conditions and the
 *    following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 *
 * 3. The name &quot;Exolab&quot; must not be used to endorse or promote
 *    products derived from this Software without prior written
 *    permission of Exoffice Technologies.  For written permission,
 *    please contact info@exolab.org.
 *
 * 4. Products derived from this Software may not be called &quot;Exolab&quot;
 *    nor may &quot;Exolab&quot; appear in their names without prior written
 *    permission of Exoffice Technologies. Exolab is a registered
 *    trademark of Exoffice Technologies.
 *
 * 5. Due credit should be given to the Exolab Project
 *    (http://www.exolab.org/).
 *
 * THIS SOFTWARE IS PROVIDED BY EXOFFICE TECHNOLOGIES AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * EXOFFICE TECHNOLOGIES OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Copyright 2005 (C) Exoffice Technologies Inc. All Rights Reserved.
 *
 * $Id: SessionConsumer.java,v 1.4 2007/01/24 12:00:28 tanderson Exp $
 */
package org.exolab.jms.server;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.exolab.jms.client.JmsMessageListener;
import org.exolab.jms.message.MessageImpl;
import org.exolab.jms.messagemgr.Condition;
import org.exolab.jms.messagemgr.ConsumerEndpoint;
import org.exolab.jms.messagemgr.ConsumerEndpointListener;
import org.exolab.jms.messagemgr.Flag;
import org.exolab.jms.messagemgr.MessageHandle;
import org.exolab.jms.messagemgr.QueueBrowserEndpoint;
import org.exolab.jms.messagemgr.TimedCondition;
import org.exolab.jms.persistence.DatabaseService;
import org.exolab.jms.persistence.PersistenceException;
import org.exolab.jms.scheduler.Scheduler;
import org.exolab.jms.scheduler.SerialTask;

import javax.jms.JMSException;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;


/**
 * Manages all consumers for a session.
 *
 * @author &lt;a href=&quot;mailto:tma@netspace.net.au&quot;&gt;Tim Anderson&lt;/a&gt;
 * @version $Revision: 1.4 $ $Date: 2007/01/24 12:00:28 $
 */
class SessionConsumer implements ConsumerEndpointListener {

    /**
     * The message listener is the reference to a remote client that will
     * receive the messages.
     */
    private JmsMessageListener _listener;

    /**
     * Maintain a set of ConsumerEndpoint instances, keyed on id.
     */
<span class="nc" id="L89">    private final HashMap _consumers = new HashMap();</span>

    /**
     * Caches all sent messages.
     */
    private final SentMessageCache _sent;

    /**
     * The database service.
     */
    private final DatabaseService _database;

    /**
     * The set of consumer endpoints with messages pending.
     */
<span class="nc" id="L104">    private final LinkedList _pending = new LinkedList();</span>

    /**
     * Determines if the sender is stopping/stopped.
     */
<span class="nc" id="L109">    private Flag _stop = new Flag(true);</span>

    /**
     * Stop/start lock.
     */
<span class="nc" id="L114">    private final Object _restartLock = new Object();</span>

    /**
     * The active consumer lock.
     */
<span class="nc" id="L119">    private final Object _removeLock = new Object();</span>

    /**
     * The consumer currently being dispatched to.
     */
<span class="nc" id="L124">    private long _consumerId = -1;</span>

    /**
     * The maximum number of messages that a dispatch can deliver at any one
     * time
     */
<span class="nc" id="L130">    private final int MAX_MESSAGES = 200;</span>

    /**
     * The logger.
     */
<span class="nc" id="L135">    private static final Log _log = LogFactory.getLog(SessionConsumer.class);</span>


    private final SerialTask _runner;

    /**
     * Construct a new &lt;code&gt;SessionConsumer&lt;/code&gt;.
     *
     * @param ackMode   the message acknowledgement mode, or
     *                  &lt;code&gt;Session.TRANSACTED_SESSION&lt;/code&gt;
     *                  if the session is transactional
     * @param database  the database service
     * @param scheduler the scheduler
     */
    public SessionConsumer(int ackMode, DatabaseService database,
<span class="nc" id="L150">                           Scheduler scheduler) {</span>
<span class="nc" id="L151">        _database = database;</span>
<span class="nc" id="L152">        _sent = new SentMessageCache(ackMode);</span>
<span class="nc" id="L153">        Runnable task = new Runnable() {</span>
            public void run() {
<span class="nc" id="L155">                dispatch();</span>
<span class="nc" id="L156">            }</span>
        };

<span class="nc" id="L159">        _runner = new SerialTask(task, scheduler);</span>
<span class="nc" id="L160">    }</span>

    /**
     * Set the listener for this session.
     * &lt;p/&gt;
     * The listener is notified whenever a message for the session is present.
     *
     * @param listener the message listener
     */
    public synchronized void setMessageListener(JmsMessageListener listener) {
<span class="nc" id="L170">        _listener = listener;</span>
<span class="nc" id="L171">    }</span>

    /**
     * Register a consumer.
     *
     * @param consumer the consumer to add
     */
    public synchronized void addConsumer(ConsumerEndpoint consumer) {
<span class="nc" id="L179">        final long id = consumer.getId();</span>
<span class="nc" id="L180">        _consumers.put(new Long(id), consumer);</span>
<span class="nc" id="L181">        consumer.setListener(this);</span>
<span class="nc" id="L182">    }</span>

    /**
     * Deregister a consumer.
     *
     * @param consumerId the consumer identifier
     * @return the consumer
     * @throws JMSException if the consumer can't be removed
     */
    public ConsumerEndpoint removeConsumer(long consumerId)
            throws JMSException {
        ConsumerEndpoint consumer;
<span class="nc" id="L194">        synchronized (_removeLock) {</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">            while (consumerId == _consumerId) {</span>
                try {
<span class="nc" id="L197">                    _removeLock.wait();</span>
<span class="nc" id="L198">                } catch (InterruptedException ignore) {</span>
                    // do nothing
<span class="nc" id="L200">                }</span>
            }
<span class="nc" id="L202">            synchronized (this) {</span>
<span class="nc" id="L203">                consumer = (ConsumerEndpoint) _consumers.remove(</span>
                        new Long(consumerId));
<span class="nc bnc" id="L205" title="All 2 branches missed.">                if (consumer == null) {</span>
<span class="nc" id="L206">                    throw new JMSException(&quot;No consumer with id=&quot; + consumerId);</span>
                }
<span class="nc" id="L208">                consumer.setListener(null);</span>
<span class="nc" id="L209">            }</span>
<span class="nc" id="L210">            synchronized (_pending) {</span>
<span class="nc" id="L211">                _pending.remove(consumer);</span>
<span class="nc" id="L212">            }</span>
<span class="nc" id="L213">        }</span>

<span class="nc" id="L215">        return consumer;</span>
    }

    /**
     * Returns the consumers.
     *
     * @return the consumers
     */
    public synchronized ConsumerEndpoint[] getConsumers() {
<span class="nc" id="L224">        return (ConsumerEndpoint[]) _consumers.values()</span>
<span class="nc" id="L225">                .toArray(new ConsumerEndpoint[0]);</span>
    }

    /**
     * Enable or disable asynchronous message delivery for a consumer.
     *
     * @param consumerId the consumer identifier
     * @param enable     &lt;code&gt;true&lt;/code&gt; to enable; &lt;code&gt;false&lt;/code&gt; to
     *                   disable
     * @throws JMSException for any JMS error
     */
    public void setAsynchronous(long consumerId, boolean enable)
            throws JMSException {
<span class="nc" id="L238">        ConsumerEndpoint consumer = getConsumer(consumerId);</span>
<span class="nc" id="L239">        consumer.setAsynchronous(enable);</span>
<span class="nc bnc" id="L240" title="All 4 branches missed.">        if (enable &amp;&amp; consumer.getMessageCount() != 0) {</span>
<span class="nc" id="L241">            messageAvailable(consumer);</span>
        }

<span class="nc" id="L244">    }</span>

    /**
     * Stop message delivery.
     */
    public void stop() {
<span class="nc" id="L250">        synchronized (_restartLock) {</span>
<span class="nc" id="L251">            _stop.set(true);</span>
<span class="nc" id="L252">            _runner.stop();</span>
<span class="nc" id="L253">            _log.debug(&quot;stopped delivery&quot;);</span>
<span class="nc" id="L254">        }</span>
<span class="nc" id="L255">    }</span>

    /**
     * Start message delivery.
     */
    public void start() throws JMSException {
<span class="nc" id="L261">        synchronized (_restartLock) {</span>
<span class="nc" id="L262">            _log.debug(&quot;start&quot;);</span>
<span class="nc" id="L263">            _stop.set(false);</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">            for (Iterator i = _consumers.values().iterator(); i.hasNext();) {</span>
<span class="nc" id="L265">                ConsumerEndpoint consumer = (ConsumerEndpoint) i.next();</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">                if (needsScheduling(consumer)) {</span>
<span class="nc" id="L267">                    queue(consumer);</span>
                }
<span class="nc" id="L269">            }</span>
            try {
<span class="nc" id="L271">                _runner.schedule();</span>
<span class="nc" id="L272">            } catch (InterruptedException exception) {</span>
<span class="nc" id="L273">                _log.error(&quot;Failed to start worker&quot;, exception);</span>
<span class="nc" id="L274">                throw new JMSException(&quot;Failed to start worker: &quot; + exception);</span>
<span class="nc" id="L275">            }</span>
<span class="nc" id="L276">        }</span>
<span class="nc" id="L277">    }</span>

    /**
     * Recover the session.
     * &lt;p/&gt;
     * This will cause all unacknowledged messages to be redelivered.
     *
     * @throws JMSException if the session can't be recovered
     */
    public synchronized void recover() throws JMSException {
<span class="nc" id="L287">        stop();             // stop message delivery</span>
        try {
<span class="nc" id="L289">            _database.begin();</span>
<span class="nc" id="L290">            _sent.clear();  // clear the messages in the sent message cache</span>
<span class="nc" id="L291">            _database.commit();</span>
<span class="nc" id="L292">        } catch (Exception exception) {</span>
<span class="nc" id="L293">            rethrow(exception.getMessage(), exception);</span>
<span class="nc" id="L294">        }</span>
<span class="nc" id="L295">        start();           // restart message delivery</span>
<span class="nc" id="L296">    }</span>

    /**
     * Commit the sesion.
     * &lt;p/&gt;
     * This will acknowledge all sent messages for all consumers.
     *
     * @throws JMSException if the session fails to commit
     */
    public synchronized void commit() throws JMSException {
        try {
<span class="nc" id="L307">            _database.begin();</span>
<span class="nc" id="L308">            _sent.acknowledgeAll();</span>
<span class="nc" id="L309">            _database.commit();</span>
<span class="nc" id="L310">        } catch (OutOfMemoryError exception) {</span>
<span class="nc" id="L311">            rethrow(&quot;Failed to commit session due to out-of-memory error&quot;,</span>
                    exception);
<span class="nc" id="L313">        } catch (Exception exception) {</span>
<span class="nc" id="L314">            rethrow(exception.getMessage(), exception);</span>
<span class="nc" id="L315">        }</span>
<span class="nc" id="L316">    }</span>

    /**
     * Rollback the session.
     * &lt;p/&gt;
     * This will cause all unacknowledged messages to be redelivered.
     *
     * @throws JMSException for any error
     */
    public synchronized void rollback() throws JMSException {
<span class="nc" id="L326">        stop();             // stop message delivery</span>
        try {
<span class="nc" id="L328">            _database.begin();</span>
<span class="nc" id="L329">            _sent.clear();  // clear the messages in the sent message cache</span>
<span class="nc" id="L330">            _database.commit();</span>
<span class="nc" id="L331">        } catch (Exception exception) {</span>
<span class="nc" id="L332">            rethrow(exception.getMessage(), exception);</span>
<span class="nc" id="L333">        }</span>
<span class="nc" id="L334">        start();           // restart message delivery</span>
<span class="nc" id="L335">    }</span>

    /**
     * Return the next available mesage to the specified consumer.
     * &lt;p/&gt;
     * This method is non-blocking. If no messages are available, it will return
     * immediately.
     *
     * @param consumerId the consumer identifier
     * @return the next message or &lt;code&gt;null&lt;/code&gt; if none is available
     * @throws JMSException for any JMS error
     */
    public MessageImpl receiveNoWait(long consumerId) throws JMSException {
<span class="nc" id="L348">        MessageImpl result = null;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (!_stop.get()) {</span>
<span class="nc" id="L350">            result = doReceive(consumerId, null);</span>
        }
<span class="nc" id="L352">        return result;</span>
    }

    /**
     * Return the next available message to the specified consumer.
     * &lt;p/&gt;
     * This method is non-blocking. However, clients can specify a
     * &lt;code&gt;wait&lt;/code&gt; interval to indicate how long they are prepared to wait
     * for a message. If no message is available, and the client indicates that
     * it will wait, it will be notified via the registered {@link
     * JmsMessageListener} if one subsequently becomes available.
     *
     * @param consumerId the consumer identifier
     * @param wait       number of milliseconds to wait. A value of &lt;code&gt;0
     *                   &lt;/code&gt; indicates to wait indefinitely
     * @return the next message or &lt;code&gt;null&lt;/code&gt; if none is available
     * @throws JMSException for any JMS error
     */
    public MessageImpl receive(long consumerId, long wait) throws JMSException {
<span class="nc" id="L371">        MessageImpl result = null;</span>
        Condition condition;
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (wait &gt; 0) {</span>
<span class="nc" id="L374">            condition = TimedCondition.before(wait);</span>
        } else {
<span class="nc" id="L376">            condition = new Flag(true);</span>
        }
<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (!_stop.get()) {</span>
<span class="nc" id="L379">            result = doReceive(consumerId, condition);</span>
        } else {
<span class="nc" id="L381">            ConsumerEndpoint consumer = getConsumer(consumerId);</span>
<span class="nc" id="L382">            consumer.setWaitingForMessage(condition);</span>
        }
<span class="nc" id="L384">        return result;</span>
    }

    /**
     * Browse up to count messages.
     *
     * @param consumerId the consumer identifier
     * @param count      the maximum number of messages to receive
     * @return a list of {@link MessageImpl} instances
     * @throws JMSException for any JMS error
     */
    public List browse(long consumerId, int count) throws JMSException {
<span class="nc" id="L396">        ConsumerEndpoint consumer = getConsumer(consumerId);</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (!(consumer instanceof QueueBrowserEndpoint)) {</span>
<span class="nc" id="L398">            throw new JMSException(&quot;Can't browse messages: invalid consumer&quot;);</span>
        }

<span class="nc" id="L401">        List messages = new ArrayList(count);</span>

        try {
<span class="nc" id="L404">            _database.begin();</span>
<span class="nc bnc" id="L405" title="All 4 branches missed.">            for (int i = 0; i &lt; count &amp;&amp; !_stop.get();) {</span>
<span class="nc" id="L406">                MessageHandle handle = consumer.receive(_stop);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">                if (handle == null) {</span>
<span class="nc" id="L408">                    break;</span>
                }
<span class="nc" id="L410">                MessageImpl orig = handle.getMessage();</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                if (orig != null) {</span>
<span class="nc" id="L412">                    messages.add(copy(orig, handle));</span>
<span class="nc" id="L413">                    ++i;</span>
                }
<span class="nc" id="L415">            }</span>
<span class="nc" id="L416">            _database.commit();</span>
<span class="nc" id="L417">        } catch (Exception exception) {</span>
<span class="nc" id="L418">            rethrow(&quot;Failed to browse messages&quot;, exception);</span>
<span class="nc" id="L419">        }</span>
<span class="nc" id="L420">        return messages;</span>
    }

    /**
     * Acknowledge that a message has been processed.
     *
     * @param consumerId the identity of the consumer performing the ack
     * @param messageId  the message identifier
     * @throws JMSException for any error
     */
    public synchronized void acknowledge(long consumerId, String messageId)
            throws JMSException {
        try {
<span class="nc" id="L433">            _database.begin();</span>
<span class="nc" id="L434">            _sent.acknowledge(messageId, consumerId);</span>
<span class="nc" id="L435">            _database.commit();</span>
<span class="nc" id="L436">        } catch (Exception exception) {</span>
<span class="nc" id="L437">            rethrow(&quot;Failed to acknowledge message&quot;, exception);</span>
<span class="nc" id="L438">        }</span>
<span class="nc" id="L439">    }</span>

    /**
     * Close the consumer.
     *
     * @throws JMSException for any eror
     */
    public synchronized void close() throws JMSException {
<span class="nc" id="L447">        _log.debug(&quot;close&quot;);</span>
<span class="nc" id="L448">        stop();</span>
<span class="nc" id="L449">        _listener = null;</span>
        try {
<span class="nc" id="L451">            _database.begin();</span>
<span class="nc" id="L452">            _sent.clear();</span>
<span class="nc" id="L453">            _database.commit();</span>
<span class="nc" id="L454">        } catch (Exception exception) {</span>
<span class="nc" id="L455">            rethrow(exception.getMessage(), exception);</span>
<span class="nc" id="L456">        }</span>
<span class="nc" id="L457">    }</span>

    /**
     * Notifies that a message is available for a particular consumer.
     *
     * @param consumer the consumer
     */
    public void messageAvailable(ConsumerEndpoint consumer) {
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (queue(consumer)) {</span>
            try {
<span class="nc" id="L467">                _runner.schedule();</span>
<span class="nc" id="L468">            } catch (InterruptedException exception) {</span>
<span class="nc" id="L469">                _log.error(&quot;Failed to schedule worker&quot;, exception);</span>
<span class="nc" id="L470">            }</span>
        }
<span class="nc" id="L472">    }</span>

    /**
     * Send messages to the client.
     */
    private void dispatch() {
<span class="nc" id="L478">        final Condition timeout = TimedCondition.after(30 * 1000);</span>
<span class="nc" id="L479">        Condition done = new Condition() {</span>
            public boolean get() {
<span class="nc bnc" id="L481" title="All 4 branches missed.">                return _stop.get() || timeout.get();</span>
            }
        };

<span class="nc" id="L485">        _log.debug(&quot;dispatch&quot;);</span>
<span class="nc" id="L486">        int sent = 0;</span>
<span class="nc bnc" id="L487" title="All 4 branches missed.">        while (sent &lt; MAX_MESSAGES &amp;&amp; !done.get()) {</span>
            ConsumerEndpoint consumer;
<span class="nc" id="L489">            synchronized (_pending) {</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                if (!_pending.isEmpty()) {</span>
<span class="nc" id="L491">                    consumer = (ConsumerEndpoint) _pending.removeFirst();</span>
                } else {
<span class="nc" id="L493">                    break;</span>
                }
<span class="nc" id="L495">            }</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">            if (wantsMessages(consumer)) {</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                if (consumer.isAsynchronous()) {</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                    if (send(consumer, done)) {</span>
<span class="nc" id="L499">                        ++sent;</span>
                    }
<span class="nc bnc" id="L501" title="All 2 branches missed.">                    if (needsScheduling(consumer)) {</span>
<span class="nc" id="L502">                        queue(consumer);</span>
                    }
                } else {
<span class="nc" id="L505">                    notifyMessageAvailable();</span>
                }
            }
<span class="nc" id="L508">        }</span>
        boolean empty;
<span class="nc" id="L510">        synchronized (_pending) {</span>
<span class="nc" id="L511">            empty = _pending.isEmpty();</span>
<span class="nc" id="L512">        }</span>
<span class="nc bnc" id="L513" title="All 4 branches missed.">        if (!empty &amp;&amp; !_stop.get()) {</span>
            // reschedule this if needed
            try {
<span class="nc" id="L516">                _runner.schedule();</span>
<span class="nc" id="L517">            } catch (InterruptedException exception) {</span>
<span class="nc" id="L518">                _log.error(&quot;Failed to reschedule worker&quot;, exception);</span>
<span class="nc" id="L519">            }</span>
        }
<span class="nc" id="L521">        _log.debug(&quot;dispatch[sent=&quot; + sent + &quot;]&quot;);</span>
<span class="nc" id="L522">    }</span>

    private void notifyMessageAvailable() {
        try {
            // notify the client sesssion.
<span class="nc" id="L527">            _listener.onMessageAvailable();</span>
<span class="nc" id="L528">        } catch (RemoteException exception) {</span>
<span class="nc" id="L529">            _log.debug(&quot;Failed to notify client&quot;, exception);</span>
<span class="nc" id="L530">        }</span>
<span class="nc" id="L531">    }</span>

    private boolean queue(ConsumerEndpoint consumer) {
<span class="nc" id="L534">        boolean queued = false;</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">        if (!_stop.get()) {</span>
<span class="nc" id="L536">            synchronized (_pending) {</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                if (!_pending.contains(consumer)) {</span>
<span class="nc" id="L538">                    _pending.add(consumer);</span>
<span class="nc" id="L539">                    queued = true;</span>
                }
<span class="nc" id="L541">            }</span>
        }
<span class="nc" id="L543">        return queued;</span>
    }

    private boolean send(ConsumerEndpoint consumer, Condition cancel) {
<span class="nc" id="L547">        boolean sent = false;</span>
<span class="nc" id="L548">        MessageHandle handle = null;</span>
        try {
<span class="nc" id="L550">            _database.begin();</span>
            try {
<span class="nc" id="L552">                synchronized (_removeLock) {</span>
<span class="nc" id="L553">                    _consumerId = consumer.getId();</span>
<span class="nc" id="L554">                }</span>
<span class="nc" id="L555">                handle = consumer.receive(cancel);</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">                if (handle != null) {</span>
<span class="nc" id="L557">                    MessageImpl message = handle.getMessage();</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">                    if (message != null) {</span>
                        // send the client a copy.
<span class="nc" id="L560">                        message = copy(message, handle);</span>

                        // clear any wait condition
                        // @todo - possible race condition? Could
                        // syncbronous client timeout and request again,
                        // and this trash subsequent wait?
<span class="nc" id="L566">                        consumer.setWaitingForMessage(null);</span>

<span class="nc" id="L568">                        _sent.preSend(handle);</span>
<span class="nc" id="L569">                        _database.commit();</span>

                        // send the message
<span class="nc" id="L572">                        sent = send(message);</span>

<span class="nc bnc" id="L574" title="All 2 branches missed.">                        if (sent) {</span>
<span class="nc" id="L575">                            _database.begin();</span>
<span class="nc" id="L576">                            _sent.postSend(handle);</span>
<span class="nc" id="L577">                            _database.commit();</span>
                        }
                    }
<span class="nc" id="L580">                } else {</span>
<span class="nc" id="L581">                    _database.commit();</span>
                }
            } finally {
<span class="nc" id="L584">                synchronized (_removeLock) {</span>
<span class="nc" id="L585">                    _consumerId = -1;</span>
<span class="nc" id="L586">                    _removeLock.notify();</span>
<span class="nc" id="L587">                }</span>
            }
<span class="nc" id="L589">        } catch (Exception exception) {</span>
<span class="nc" id="L590">            cleanup(exception.getMessage(), exception);</span>
<span class="nc" id="L591">        }</span>
<span class="nc bnc" id="L592" title="All 4 branches missed.">        if (!sent &amp;&amp; handle != null) {</span>
            try {
<span class="nc" id="L594">                _database.begin();</span>
<span class="nc" id="L595">                handle.release();</span>
<span class="nc" id="L596">                _database.commit();</span>
<span class="nc" id="L597">            } catch (Exception exception) {</span>
<span class="nc" id="L598">                cleanup(&quot;Failed to release unsent message&quot;, exception);</span>
<span class="nc" id="L599">            }</span>
        }
<span class="nc" id="L601">        return sent;</span>
    }

    /**
     * Send the specified message to the client.
     *
     * @param message the message
     * @return &lt;code&gt;true&lt;/code&gt; if the message was successfully sent
     */
    protected boolean send(MessageImpl message) {
<span class="nc" id="L611">        boolean delivered = false;</span>
        try {
            // send the message to the listener.
<span class="nc" id="L614">            delivered = _listener.onMessage(message);</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">            if (_log.isDebugEnabled()) {</span>
<span class="nc" id="L616">                _log.debug(&quot;send[JMSMessageID=&quot; + message.getMessageId()</span>
                        + &quot;, delivered=&quot; + delivered + &quot;]&quot;);
            }
<span class="nc" id="L619">        } catch (RemoteException exception) {</span>
<span class="nc" id="L620">            _log.info(&quot;Failed to notify client&quot;, exception);</span>
<span class="nc" id="L621">        }</span>
<span class="nc" id="L622">        return delivered;</span>
    }

    private boolean wantsMessages(ConsumerEndpoint consumer) {
<span class="nc" id="L626">        boolean result = false;</span>
<span class="nc bnc" id="L627" title="All 4 branches missed.">        if (consumer.isAsynchronous() || consumer.isWaitingForMessage()) {</span>
<span class="nc" id="L628">            result = true;</span>
        }
<span class="nc" id="L630">        return result;</span>
    }

    private boolean needsScheduling(ConsumerEndpoint consumer) {
<span class="nc" id="L634">        boolean result = false;</span>
<span class="nc bnc" id="L635" title="All 4 branches missed.">        if (wantsMessages(consumer) &amp;&amp; consumer.getMessageCount() != 0) {</span>
<span class="nc" id="L636">            result = true;</span>
        }
<span class="nc" id="L638">        return result;</span>
    }

    private MessageImpl doReceive(long consumerId, final Condition wait)
            throws JMSException {
<span class="nc" id="L643">        ConsumerEndpoint consumer = getConsumer(consumerId);</span>

        Condition cancel;
<span class="nc bnc" id="L646" title="All 2 branches missed.">        if (wait != null) {</span>
<span class="nc" id="L647">            cancel = new Condition() {</span>
                public boolean get() {
<span class="nc bnc" id="L649" title="All 4 branches missed.">                    return _stop.get() || !wait.get();</span>
                }
            };
        } else {
<span class="nc" id="L653">            cancel = _stop;</span>
        }

<span class="nc" id="L656">        MessageImpl message = null;</span>
        try {
<span class="nc" id="L658">            _database.begin();</span>
<span class="nc" id="L659">            MessageHandle handle = consumer.receive(cancel);</span>

<span class="nc bnc" id="L661" title="All 2 branches missed.">            if (handle != null) {</span>
                // retrieve the message and copy it
<span class="nc" id="L663">                message = handle.getMessage();</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">                if (message != null) {</span>
<span class="nc" id="L665">                    message = copy(message, handle);</span>
                }
            }
<span class="nc bnc" id="L668" title="All 2 branches missed.">            if (message == null) {</span>
                // no message available. Mark the consumer as (possibly) waiting
                // for a message.
<span class="nc" id="L671">                consumer.setWaitingForMessage(wait);</span>
            } else {
                // clear any wait condition
<span class="nc" id="L674">                consumer.setWaitingForMessage(null);</span>

                // if we have a non-null message then add it to the sent message
                // cache. Additionally, if we are part of a global transaction
                // then we must also send it to the ResourceManager for recovery.
<span class="nc" id="L679">                _sent.preSend(handle);</span>
            }
<span class="nc" id="L681">            _database.commit();</span>
<span class="nc" id="L682">        } catch (Exception exception) {</span>
<span class="nc" id="L683">            rethrow(exception.getMessage(), exception);</span>
<span class="nc" id="L684">        }</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">        if (_log.isDebugEnabled()) {</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">            if (message != null) {</span>
<span class="nc" id="L687">                _log.debug(&quot;doReceive(consumerId=&quot; + consumerId +</span>
<span class="nc" id="L688">                        &quot;) -&gt; JMSMesssageID=&quot; + message.getMessageId());</span>
            }
        }

<span class="nc" id="L692">        return message;</span>
    }

    /**
     * Helper to copy a message.
     *
     * @param message the message to copy
     * @param handle  the handle the message came from
     * @return a copy of the message
     * @throws JMSException if the copy fails
     */
    private MessageImpl copy(MessageImpl message, MessageHandle handle)
            throws JMSException {
        MessageImpl result;
        try {
<span class="nc" id="L707">            result = (MessageImpl) message.clone();</span>
<span class="nc" id="L708">            result.setJMSRedelivered(handle.getDelivered());</span>
<span class="nc" id="L709">            result.setConsumerId(handle.getConsumerId());</span>
<span class="nc" id="L710">        } catch (JMSException exception) {</span>
<span class="nc" id="L711">            throw exception;</span>
<span class="nc" id="L712">        } catch (CloneNotSupportedException exception) {</span>
<span class="nc" id="L713">            _log.error(exception, exception);</span>
<span class="nc" id="L714">            throw new JMSException(exception.getMessage());</span>
<span class="nc" id="L715">        }</span>
<span class="nc" id="L716">        return result;</span>
    }

    /**
     * Returns the consumer endpoint given its identifier.
     *
     * @param consumerId the consumer identifier
     * @return the consumer endpoint corresponding to &lt;code&gt;consumerId&lt;/code&gt;
     * @throws JMSException if the consumer doesn't exist
     */
    private ConsumerEndpoint getConsumer(long consumerId)
            throws JMSException {
<span class="nc" id="L728">        ConsumerEndpoint consumer</span>
<span class="nc" id="L729">                = (ConsumerEndpoint) _consumers.get(new Long(consumerId));</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">        if (consumer == null) {</span>
<span class="nc" id="L731">            throw new JMSException(&quot;Consumer not registered: &quot; + consumerId);</span>
        }
<span class="nc" id="L733">        return consumer;</span>
    }

    /**
     * Helper to clean up after a failed call.
     *
     * @param message   the message to log
     * @param exception the exception to log
     */
    private void cleanup(String message, Throwable exception) {
<span class="nc" id="L743">        _log.error(message, exception);</span>
        try {
<span class="nc bnc" id="L745" title="All 2 branches missed.">            if (_database.isTransacted()) {</span>
<span class="nc" id="L746">                _database.rollback();</span>
            }
<span class="nc" id="L748">        } catch (PersistenceException error) {</span>
<span class="nc" id="L749">            _log.warn(&quot;Failed to rollback after error&quot;, error);</span>
<span class="nc" id="L750">        }</span>
<span class="nc" id="L751">    }</span>

    /**
     * Helper to clean up after a failed call, and rethrow.
     *
     * @param message   the message to log
     * @param exception the exception
     * @throws JMSException the original exception adapted to a
     *                      &lt;code&gt;JMSException&lt;/code&gt; if necessary
     */
    private void rethrow(String message, Throwable exception)
            throws JMSException {
<span class="nc" id="L763">        cleanup(message, exception);</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">        if (exception instanceof JMSException) {</span>
<span class="nc" id="L765">            throw (JMSException) exception;</span>
        }
<span class="nc" id="L767">        throw new JMSException(exception.getMessage());</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>