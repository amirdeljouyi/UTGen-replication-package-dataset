<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>URI.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">66_openjms</a> &gt; <a href="index.source.html" class="el_package">org.exolab.jms.net.uri</a> &gt; <span class="el_source">URI.java</span></div><h1>URI.java</h1><pre class="source lang-java linenums">/*

 * The Apache Software License, Version 1.1

 *

 *

 * Copyright (c) 1999 The Apache Software Foundation.  All rights

 * reserved.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions

 * are met:

 *

 * 1. Redistributions of source code must retain the above copyright

 *    notice, this list of conditions and the following disclaimer.

 *

 * 2. Redistributions in binary form must reproduce the above copyright

 *    notice, this list of conditions and the following disclaimer in

 *    the documentation and/or other materials provided with the

 *    distribution.

 *

 * 3. The end-user documentation included with the redistribution,

 *    if any, must include the following acknowledgment:

 *       &quot;This product includes software developed by the

 *        Apache Software Foundation (http://www.apache.org/).&quot;

 *    Alternately, this acknowledgment may appear in the software itself,

 *    if and wherever such third-party acknowledgments normally appear.

 *

 * 4. The names &quot;Xalan&quot; and &quot;Apache Software Foundation&quot; must

 *    not be used to endorse or promote products derived from this

 *    software without prior written permission. For written

 *    permission, please contact apache@apache.org.

 *

 * 5. Products derived from this software may not be called &quot;Apache&quot;,

 *    nor may &quot;Apache&quot; appear in their name, without prior written

 *    permission of the Apache Software Foundation.

 *

 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED

 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES

 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR

 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,

 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT

 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF

 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,

 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT

 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF

 * SUCH DAMAGE.

 * ====================================================================

 *

 * This software consists of voluntary contributions made by many

 * individuals on behalf of the Apache Software Foundation and was

 * originally based on software copyright (c) 1999, Lotus

 * Development Corporation., http://www.lotus.com.  For more

 * information on the Apache Software Foundation, please see

 * &lt;http://www.apache.org/&gt;.

 */





package org.exolab.jms.net.uri;



import java.io.IOException;

import java.io.Serializable;





/**

 * A class to represent a Uniform Resource Identifier (URI). This class

 * is designed to handle the parsing of URIs and provide access to

 * the various components (scheme, host, port, userinfo, path, query

 * string and fragment) that may constitute a URI.

 * &lt;p&gt;

 * Parsing of a URI specification is done according to the URI

 * syntax described in RFC 2396

 * &lt;http://www.ietf.org/rfc/rfc2396.txt?number=2396&gt;. Every URI consists

 * of a scheme, followed by a colon (':'), followed by a scheme-specific

 * part. For URIs that follow the &quot;generic URI&quot; syntax, the scheme-

 * specific part begins with two slashes (&quot;//&quot;) and may be followed

 * by an authority segment (comprised of user information, host, and

 * port), path segment, query segment and fragment. Note that RFC 2396

 * no longer specifies the use of the parameters segment and excludes

 * the &quot;user:password&quot; syntax as part of the authority segment. If

 * &quot;user:password&quot; appears in a URI, the entire user/password string

 * is stored as userinfo.

 * &lt;p&gt;

 * For URIs that do not follow the &quot;generic URI&quot; syntax (e.g. mailto),

 * the entire scheme-specific part is treated as the &quot;path&quot; portion

 * of the URI.

 * &lt;p&gt;

 * Note that, unlike the java.net.URL class, this class does not provide

 * any built-in network access functionality nor does it provide any

 * scheme-specific functionality (for example, it does not know a

 * default port for a specific scheme). Rather, it only knows the

 * grammar and basic set of operations that can be applied to a URI.

 *

 * @version  $Id: URI.java,v 1.1 2004/11/26 01:51:06 tanderson Exp $

 *

 */

public final class URI

{





  /**

   * MalformedURIExceptions are thrown in the process of building a URI

   * or setting fields on a URI when an operation would result in an

   * invalid URI specification.

   */

  public static class MalformedURIException

      extends IOException

  {





      /**

       * Constructs a &lt;code&gt;MalformedURIException&lt;/code&gt; with no specified

       * detail message.

       */

      public MalformedURIException()

      {

<span class="nc" id="L233">          super();</span>

<span class="nc" id="L235">      }</span>





      /**

       * Constructs a &lt;code&gt;MalformedURIException&lt;/code&gt; with the

       * specified detail message.

       *

       * @param message the detail message.

       */

      public MalformedURIException( String message )

      {

<span class="fc" id="L257">          super( message );</span>

<span class="fc" id="L259">      }</span>





  }





    /**

     * reserved characters

     */

    private static final String RESERVED_CHARACTERS = &quot;;/?:@&amp;=+$,&quot;;





    /**

     * URI punctuation mark characters - these, combined with

     * alphanumerics, constitute the &quot;unreserved&quot; characters

     */

    private static final String MARK_CHARACTERS = &quot;-_.!~*'() &quot;;





    /**

     * scheme can be composed of alphanumerics and these characters

     */

    private static final String SCHEME_CHARACTERS = &quot;+-.&quot;;





    /**

     * userinfo can be composed of unreserved, escaped and these

     * characters

     */

    private static final String USERINFO_CHARACTERS = &quot;;:&amp;=+$,&quot;;





    /**

     * Stores the scheme (usually the protocol) for this URI.

     */

<span class="pc" id="L329">    private String _scheme = null;</span>





    /**

     * If specified, stores the userinfo for this URI; otherwise null

     */

<span class="pc" id="L341">    private String _userinfo = null;</span>





    /**

     * If specified, stores the host for this URI; otherwise null

     */

<span class="pc" id="L353">    private String _host = null;</span>





    /**

     * If specified, stores the port for this URI; otherwise -1

     */

<span class="pc" id="L365">    private int _port = -1;</span>





    /**

     * If specified, stores the path for this URI; otherwise null

     */

<span class="pc" id="L377">    private String _path = null;</span>





    /**

     * If specified, stores the query string for this URI; otherwise

     * null.

     */

<span class="pc" id="L391">    private String _queryString = null;</span>





    /**

     * If specified, stores the fragment for this URI; otherwise null

     */

<span class="pc" id="L403">    private String _fragment = null;</span>





    /**

     * Indicate whether in DEBUG mode

     */

<span class="fc" id="L415">    private static boolean DEBUG = false;</span>





    /**

     * Construct a new and uninitialized URI.

     */

    public URI()

<span class="fc" id="L429">    {</span>

<span class="fc" id="L431">    }</span>





    /**

     * Construct a new URI from another URI. All fields for this URI are

     * set equal to the fields of the URI passed in.

     *

     * @param other the URI to copy (cannot be null)

     */

    public URI( URI other)

<span class="fc" id="L451">    {</span>

<span class="fc" id="L453">        initialize( other );</span>

<span class="fc" id="L455">    }</span>





    /**

     * Construct a new URI from a URI specification string. If the

     * specification follows the &quot;generic URI&quot; syntax, (two slashes

     * following the first colon), the specification will be parsed

     * accordingly - setting the scheme, userinfo, host,port, path, query

     * string and fragment fields as necessary. If the specification does

     * not follow the &quot;generic URI&quot; syntax, the specification is parsed

     * into a scheme and scheme-specific part (stored as the path) only.

     *

     * @param uriSpec the URI specification string (cannot be null or empty)

     * @throws MalformedURIException uriSpec violates any syntax rules

     */

    public URI( String uriSpec )

        throws MalformedURIException

    {

<span class="nc" id="L491">        this( (URI) null, uriSpec);</span>

<span class="nc" id="L493">    }</span>





    /**

     * Construct a new URI from a base URI and a URI specification string.

     * The URI specification string may be a relative URI.

     *

     * @param base the base URI (cannot be null if uriSpec is null or empty)

     * @param uriSpec the URI specification string (cannot be null or empty

     * if base is null)

     * @throws MalformedURIException uriSpec violates any syntax rules

     */

    public URI( URI base, String uriSpec)

        throws MalformedURIException

<span class="fc" id="L521">    {</span>

<span class="nc" id="L523">        initialize( base, uriSpec );</span>

<span class="nc" id="L525">    }</span>





    /**

     * Construct a new URI that does not follow the generic URI syntax.

     * Only the scheme and scheme-specific part (stored as the path) are

     * initialized.

     *

     * @param scheme the URI scheme (cannot be null or empty)

     * @param schemeSpecificPart the scheme-specific part (cannot be

     * null or empty)

     * @throws MalformedURIException scheme violates any syntax rules

     */

    public URI( String scheme, String schemeSpecificPart )

        throws MalformedURIException

<span class="nc" id="L555">    {</span>

<span class="nc bnc" id="L557" title="All 4 branches missed.">        if ( scheme == null || scheme.trim().length() == 0 )</span>

<span class="nc" id="L559">            throw new MalformedURIException( &quot;Argument scheme is null or an empty string&quot; );</span>

<span class="nc bnc" id="L561" title="All 4 branches missed.">        if ( schemeSpecificPart == null || schemeSpecificPart.trim().length() == 0 )</span>

<span class="nc" id="L563">            throw new MalformedURIException( &quot;Argument schemeSpecificPart is null or an empty string&quot; );</span>

<span class="nc" id="L565">        setScheme( scheme );</span>

<span class="nc" id="L567">        setPath( schemeSpecificPart );</span>

<span class="nc" id="L569">    }</span>





    /**

     * Construct a new URI that follows the generic URI syntax from its

     * component parts. Each component is validated for syntax and some

     * basic semantic checks are performed as well.  See the individual

     * setter methods for specifics.

     *

     * @param scheme the URI scheme (cannot be null or empty)

     * @param host the hostname or IPv4 address for the URI

     * @param path the URI path - if the path contains '?' or '#',

     * then the query string and/or fragment will be set from the path;

     * however, if the query and fragment are specified both in the path

     * and as separate parameters, an exception is thrown

     * @param queryString the URI query string (cannot be specified

     * if path is null)

     * @param fragment the URI fragment (cannot be specified if path is null)

     * @throws MalformedURIException Any of the parameters violates

     * syntax rules or semantic rules

     */

    public URI( String scheme, String host, String path,

                String queryString, String fragment )

        throws MalformedURIException

    {

<span class="fc" id="L619">        this( scheme, null, host, -1, path, queryString, fragment );</span>

<span class="fc" id="L621">    }</span>





    /**

     * Construct a new URI that follows the generic URI syntax from its

     * component parts. Each component is validated for syntax and some

     * basic semantic checks are performed as well.  See the individual

     * setter methods for specifics.

     *

     * @param scheme the URI scheme (cannot be null or empty)

     * @param userinfo the URI userinfo (cannot be specified if host is null)

     * @param host the hostname or IPv4 address for the URI

     * @param port the URI port (may be -1 for &quot;unspecified&quot;; cannot

     * be specified if host is null)

     * @param path the URI path - if the path contains '?' or '#',

     * then the query string and/or fragment will be set from the path;

     * however, if the query and fragment are specified both in the path

     * and as separate parameters, an exception is thrown

     * @param queryString the URI query string (cannot be specified

     * if path is null)

     * @param fragment the URI fragment (cannot be specified if path is null)

     * @throws MalformedURIException Any of the parameters violates

     *  syntax rules or semantic rules

     */

    public URI( String scheme, String userinfo, String host, int port,

                String path, String queryString, String fragment )

        throws MalformedURIException

<span class="fc" id="L675">    {</span>

<span class="pc bpc" id="L677" title="2 of 4 branches missed.">        if ( scheme == null || scheme.trim().length() == 0 )</span>

<span class="nc" id="L679">            throw new MalformedURIException( &quot;Argument scheme is null or an empty string&quot; );</span>

<span class="pc bpc" id="L681" title="1 of 2 branches missed.">        if ( host == null ) {</span>

<span class="nc bnc" id="L683" title="All 2 branches missed.">            if ( userinfo != null )</span>

<span class="nc" id="L685">                throw new MalformedURIException( &quot;Argument userInfo must be null if host is null&quot; );</span>

<span class="nc bnc" id="L687" title="All 2 branches missed.">            if ( port != -1 )</span>

<span class="nc" id="L689">                throw new MalformedURIException( &quot;Argument port must be null if host is null&quot; );</span>

<span class="pc bpc" id="L691" title="1 of 2 branches missed.">        } else if ( host.trim().length() == 0 )</span>

<span class="nc" id="L693">            throw new IllegalArgumentException( &quot;Argument host is an empty string&quot; );</span>

<span class="pc bpc" id="L695" title="1 of 2 branches missed.">        if ( path != null ) {</span>

<span class="pc bpc" id="L697" title="3 of 4 branches missed.">            if ( path.indexOf('?') != -1 &amp;&amp; queryString != null )</span>

<span class="nc" id="L699">                throw new MalformedURIException( &quot;Argument queryString is illegal if path includes query string&quot; );</span>

<span class="pc bpc" id="L701" title="3 of 4 branches missed.">            if ( path.indexOf('#') != -1 &amp;&amp; fragment != null )</span>

<span class="nc" id="L703">                throw new MalformedURIException( &quot;Argument fragment is illegal if path includes fragment identifier&quot; );</span>

<span class="nc bnc" id="L705" title="All 2 branches missed.">        } else if ( path.trim().length() == 0 )</span>

<span class="nc" id="L707">            throw new IllegalArgumentException( &quot;Argument path is an empty string&quot; );</span>

<span class="fc" id="L709">        setScheme( scheme );</span>

<span class="fc" id="L711">        setHost( host );</span>

<span class="fc" id="L713">        setPort( port );</span>

<span class="fc" id="L715">        setUserinfo( userinfo );</span>

<span class="fc" id="L717">        setPath( path );</span>

<span class="fc" id="L719">        setQueryString( queryString );</span>

<span class="fc" id="L721">        setFragment( fragment );</span>

<span class="fc" id="L723">    }</span>





    /**

     * Initialize all fields of this URI from another URI.

     *

     * @param other the URI to copy (cannot be null)

     */

    private void initialize( URI other )

    {

<span class="fc" id="L743">        _scheme = other.getScheme();</span>

<span class="fc" id="L745">        _userinfo = other.getUserinfo();</span>

<span class="fc" id="L747">        _host = other.getHost();</span>

<span class="fc" id="L749">        _port = other.getPort();</span>

<span class="fc" id="L751">        _path = other.getPath();</span>

<span class="fc" id="L753">        _queryString = other.getQueryString();</span>

<span class="fc" id="L755">        _fragment = other.getFragment();</span>

<span class="fc" id="L757">    }</span>





    /**

     * Initializes this URI from a base URI and a URI specification string.

     * See RFC 2396 Section 4 and Appendix B for specifications on parsing

     * the URI and Section 5 for specifications on resolving relative URIs

     * and relative paths.

     *

     * @param base the base URI (may be null if uriSpec is an absolute URI)

     * @param uriSpec the URI spec string which may be an absolute or

     * relative URI (can only be null/empty if base is not null)

     * @throws MalformedURIException base is null and uriSpec is not an

     * absolute URI or uriSpec violates syntax rules

     */

    private void initialize( URI base, String uriSpec )

        throws MalformedURIException

    {

        int    uriSpecLen;

        int    index;

        int    startPos;

        char   testChar;



<span class="pc bpc" id="L803" title="3 of 6 branches missed.">        if ( base == null &amp;&amp; ( uriSpec == null || uriSpec.trim().length() == 0) )</span>

<span class="fc" id="L805">            throw new MalformedURIException( &quot;Argument base is null and argument uriSpec is null or an empty string&quot; );</span>

        // just make a copy of the base if spec is empty

<span class="nc bnc" id="L809" title="All 4 branches missed.">        if ( uriSpec == null || uriSpec.trim().length() == 0 ) {</span>

<span class="nc" id="L811">            initialize( base );</span>

<span class="nc" id="L813">            return;</span>

        }



<span class="nc" id="L819">        uriSpec = uriSpec.trim();</span>

<span class="nc" id="L821">        uriSpecLen = uriSpec.length();</span>

<span class="nc" id="L823">        index = 0;</span>



        // check for scheme

<span class="nc bnc" id="L829" title="All 2 branches missed.">        if ( uriSpec.indexOf( ':' ) == -1 ) {</span>

<span class="nc bnc" id="L831" title="All 2 branches missed.">            if ( base == null )</span>

<span class="nc" id="L833">                throw new MalformedURIException( &quot;No scheme found in URI.&quot; );</span>

        } else {

<span class="nc" id="L837">            initializeScheme( uriSpec );</span>

<span class="nc" id="L839">            index = _scheme.length() + 1;</span>

        }



        // two slashes means generic URI syntax, so we get the authority

<span class="nc bnc" id="L847" title="All 4 branches missed.">        if ( ( index + 1 &lt; uriSpecLen ) &amp;&amp; ( uriSpec.substring( index ).startsWith( &quot;//&quot; ) ) ) {</span>

<span class="nc" id="L849">            index += 2;</span>

<span class="nc" id="L851">            startPos = index;</span>

            // get authority - everything up to path, query or fragment

<span class="nc" id="L855">            testChar = '\0';</span>

<span class="nc bnc" id="L857" title="All 2 branches missed.">            while ( index &lt; uriSpecLen ) {</span>

<span class="nc" id="L859">                testChar = uriSpec.charAt( index );</span>

<span class="nc bnc" id="L861" title="All 6 branches missed.">                if ( testChar == '/' || testChar == '?' || testChar == '#' )</span>

<span class="nc" id="L863">                    break;</span>

<span class="nc" id="L865">                index++;</span>

            }



            // if we found authority, parse it out, otherwise we set the

            // host to empty string

<span class="nc bnc" id="L875" title="All 2 branches missed.">            if ( index &gt; startPos )</span>

<span class="nc" id="L877">                initializeAuthority( uriSpec.substring( startPos, index ) );</span>

            else

<span class="nc" id="L881">                _host = &quot;&quot;;</span>

        }



<span class="nc" id="L887">        initializePath( uriSpec.substring( index ) );</span>



        // Resolve relative URI to base URI - see RFC 2396 Section 5.2

        // In some cases, it might make more sense to throw an exception

        // (when scheme is specified is the string spec and the base URI

        // is also specified, for example), but we're just following the

        // RFC specifications

<span class="nc bnc" id="L901" title="All 2 branches missed.">        if ( base != null ) {</span>



            // check to see if this is the current doc - RFC 2396 5.2 #2

            // note that this is slightly different from the RFC spec in that

            // we don't include the check for query string being null

            // - this handles cases where the urispec is just a query

            // string or a fragment (e.g. &quot;?y&quot; or &quot;#s&quot;) -

            // see &lt;http://www.ics.uci.edu/~fielding/url/test1.html&gt; which

            // identified this as a bug in the RFC

<span class="nc bnc" id="L919" title="All 6 branches missed.">            if ( _path.length() == 0 &amp;&amp; _scheme == null &amp;&amp; _host == null ) {</span>

<span class="nc" id="L921">                _scheme = base.getScheme();</span>

<span class="nc" id="L923">                _userinfo = base.getUserinfo();</span>

<span class="nc" id="L925">                _host = base.getHost();</span>

<span class="nc" id="L927">                _port = base.getPort();</span>

<span class="nc" id="L929">                _path = base.getPath();</span>

<span class="nc bnc" id="L931" title="All 2 branches missed.">                if ( _queryString == null )</span>

<span class="nc" id="L933">                    _queryString = base.getQueryString();</span>

<span class="nc" id="L935">                return;</span>

            }



            // check for scheme - RFC 2396 5.2 #3

            // if we found a scheme, it means absolute URI, so we're done

<span class="nc bnc" id="L945" title="All 2 branches missed.">            if ( _scheme == null )</span>

<span class="nc" id="L947">                _scheme = base.getScheme();</span>

            else

<span class="nc" id="L951">                return;</span>



            // check for authority - RFC 2396 5.2 #4

            // if we found a host, then we've got a network path, so we're done

<span class="nc bnc" id="L959" title="All 2 branches missed.">            if ( _host == null ) {</span>

<span class="nc" id="L961">                _userinfo = base.getUserinfo();</span>

<span class="nc" id="L963">                _host = base.getHost();</span>

<span class="nc" id="L965">                _port = base.getPort();</span>

            } else

<span class="nc" id="L969">                return;</span>



            // check for absolute path - RFC 2396 5.2 #5

<span class="nc bnc" id="L975" title="All 4 branches missed.">            if ( _path.length() &gt; 0 &amp;&amp; _path.startsWith( &quot;/&quot; ) )</span>

<span class="nc" id="L977">                return;</span>



            // if we get to this point, we need to resolve relative path

            // RFC 2396 5.2 #6

<span class="nc" id="L985">            String tmpPath = new String();</span>

<span class="nc" id="L987">            String basePath = base.getPath();</span>



            // 6a - get all but the last segment of the base URI path

<span class="nc bnc" id="L993" title="All 2 branches missed.">            if ( basePath != null ) {</span>

<span class="nc" id="L995">                int lastSlash = basePath.lastIndexOf( '/' );</span>

<span class="nc bnc" id="L997" title="All 2 branches missed.">                if ( lastSlash != -1 )</span>

<span class="nc" id="L999">                    tmpPath = basePath.substring( 0, lastSlash + 1 );</span>

            }



            // 6b - append the relative URI path

<span class="nc" id="L1007">            tmpPath = tmpPath.concat( tmpPath );</span>

            // 6c - remove all &quot;./&quot; where &quot;.&quot; is a complete path segment

<span class="nc" id="L1011">            index = -1;</span>

<span class="nc bnc" id="L1013" title="All 2 branches missed.">            while ( ( index = tmpPath.indexOf( &quot;/./&quot; ) ) != -1 )</span>

<span class="nc" id="L1015">                tmpPath = tmpPath.substring( 0, index + 1 ).concat( tmpPath.substring( index + 3 ) );</span>



            // 6d - remove &quot;.&quot; if path ends with &quot;.&quot; as a complete path segment

<span class="nc bnc" id="L1021" title="All 2 branches missed.">            if ( tmpPath.endsWith(&quot;/.&quot;) )</span>

<span class="nc" id="L1023">                tmpPath = tmpPath.substring( 0, tmpPath.length() - 1 );</span>



            // 6e - remove all &quot;&lt;segment&gt;/../&quot; where &quot;&lt;segment&gt;&quot; is a complete

            // path segment not equal to &quot;..&quot;

<span class="nc" id="L1031">            index = -1;</span>



<span class="nc" id="L1035">            int segIndex = -1;</span>

<span class="nc" id="L1037">            String tempString = null;</span>



<span class="nc bnc" id="L1041" title="All 2 branches missed.">            while ( ( index = tmpPath.indexOf( &quot;/../&quot; ) ) &gt; 0 ) {</span>

<span class="nc" id="L1043">                tempString = tmpPath.substring( 0, tmpPath.indexOf( &quot;/../&quot; ) );</span>

<span class="nc" id="L1045">                segIndex = tempString.lastIndexOf( '/' );</span>

<span class="nc bnc" id="L1047" title="All 2 branches missed.">                if ( segIndex != -1 )</span>

<span class="nc bnc" id="L1049" title="All 2 branches missed.">                    if ( !tempString.substring( segIndex++ ).equals( &quot;..&quot; ) )</span>

<span class="nc" id="L1051">                        tmpPath = tmpPath.substring( 0, segIndex ).concat( tmpPath.substring( index + 4 ) );</span>

            }



            // 6f - remove ending &quot;&lt;segment&gt;/..&quot; where &quot;&lt;segment&gt;&quot; is a

            // complete path segment

<span class="nc bnc" id="L1061" title="All 2 branches missed.">            if ( tmpPath.endsWith( &quot;/..&quot; ) ) {</span>

<span class="nc" id="L1063">                tempString = tmpPath.substring( 0, tmpPath.length() - 3 );</span>

<span class="nc" id="L1065">                segIndex = tempString.lastIndexOf( '/' );</span>

<span class="nc bnc" id="L1067" title="All 2 branches missed.">                if ( segIndex != -1 )</span>

<span class="nc" id="L1069">                    tmpPath = tmpPath.substring( 0, segIndex + 1 );</span>

            }

<span class="nc" id="L1073">            _path = tmpPath;</span>

        }

<span class="nc" id="L1077">    }</span>





    /**

     * Initialize the scheme for this URI from a URI string spec.

     *

     * @param uriSpec the URI specification (cannot be null)

     * @throws MalformedURIException URI does not have a conformant scheme

     */

    private void initializeScheme( String uriSpec )

        throws MalformedURIException

    {

<span class="nc" id="L1101">        int uriSpecLen = uriSpec.length();</span>

<span class="nc" id="L1103">        int index = 0;</span>

<span class="nc" id="L1105">        String scheme = null;</span>

<span class="nc" id="L1107">        char testChar = '\0';</span>



<span class="nc bnc" id="L1111" title="All 2 branches missed.">        while ( index &lt; uriSpecLen ) {</span>

<span class="nc" id="L1113">            testChar = uriSpec.charAt( index );</span>

<span class="nc bnc" id="L1115" title="All 8 branches missed.">            if ( testChar == ':' || testChar == '/' || testChar == '?' || testChar == '#' )</span>

<span class="nc" id="L1117">                break;</span>

<span class="nc" id="L1119">            index++;</span>

        }

<span class="nc" id="L1123">        scheme = uriSpec.substring( 0, index );</span>

<span class="nc bnc" id="L1125" title="All 2 branches missed.">        if ( scheme.length() == 0 )</span>

<span class="nc" id="L1127">            throw new MalformedURIException( &quot;No scheme found in URI.&quot; );</span>

        else

<span class="nc" id="L1131">            setScheme( scheme );</span>

<span class="nc" id="L1133">    }</span>





    /**

     * Initialize the authority (userinfo, host and port) for this

     * URI from a URI string spec.

     *

     * @param uriSpec the URI specification (cannot be null)

     * @throws MalformedURIException uriSpec violates syntax rules

     */

    private void initializeAuthority( String uriSpec )

        throws MalformedURIException

    {

<span class="nc" id="L1159">        int index = 0;</span>

<span class="nc" id="L1161">        int start = 0;</span>

<span class="nc" id="L1163">        int end = uriSpec.length();</span>

<span class="nc" id="L1165">        char testChar = '\0';</span>

<span class="nc" id="L1167">        String userinfo = null;</span>



        // userinfo is everything up @

<span class="nc bnc" id="L1173" title="All 2 branches missed.">        if ( uriSpec.indexOf( '@', start ) != -1 ) {</span>

<span class="nc bnc" id="L1175" title="All 2 branches missed.">            while ( index &lt; end ) {</span>

<span class="nc" id="L1177">                testChar = uriSpec.charAt( index );</span>

<span class="nc bnc" id="L1179" title="All 2 branches missed.">                if ( testChar == '@' )</span>

<span class="nc" id="L1181">                    break;</span>

<span class="nc" id="L1183">                index++;</span>

            }

<span class="nc" id="L1187">            userinfo = uriSpec.substring( start, index );</span>

<span class="nc" id="L1189">            index++;</span>

        }



        // host is everything up to ':'

<span class="nc" id="L1197">        String host = null;</span>



<span class="nc" id="L1201">        start = index;</span>

<span class="nc bnc" id="L1203" title="All 2 branches missed.">        while ( index &lt; end ) {</span>

<span class="nc" id="L1205">            testChar = uriSpec.charAt( index );</span>

<span class="nc bnc" id="L1207" title="All 2 branches missed.">            if ( testChar == ':' )</span>

<span class="nc" id="L1209">                break;</span>

<span class="nc" id="L1211">            index++;</span>

        }

<span class="nc" id="L1215">        host = uriSpec.substring( start, index );</span>



<span class="nc" id="L1219">        int port = -1;</span>



<span class="nc bnc" id="L1223" title="All 2 branches missed.">        if ( host.length() &gt; 0 ) {</span>

            // port

<span class="nc bnc" id="L1227" title="All 2 branches missed.">            if ( testChar == ':' ) {</span>

<span class="nc" id="L1229">                index++;</span>

<span class="nc" id="L1231">                start = index;</span>

<span class="nc bnc" id="L1233" title="All 2 branches missed.">                while ( index &lt; end )</span>

<span class="nc" id="L1235">                    index++;</span>



<span class="nc" id="L1239">                String portStr = uriSpec.substring( start, index );</span>

<span class="nc bnc" id="L1241" title="All 2 branches missed.">                if ( portStr.length() &gt; 0 ) {</span>

<span class="nc bnc" id="L1243" title="All 2 branches missed.">                    for ( int i = 0 ; i &lt; portStr.length() ; i++ )</span>

<span class="nc bnc" id="L1245" title="All 2 branches missed.">                        if ( !isDigit( portStr.charAt( i ) ) )</span>

<span class="nc" id="L1247">                            throw new MalformedURIException( portStr + &quot; is invalid. Port should only contain digits!&quot; );</span>

                    try {

<span class="nc" id="L1251">                        port = Integer.parseInt( portStr );</span>

<span class="nc" id="L1253">                    } catch ( NumberFormatException nfe ) {</span>

                        // can't happen

<span class="nc" id="L1257">                    }</span>

                }

            }

        }



<span class="nc" id="L1267">        setHost( host );</span>

<span class="nc" id="L1269">        setPort( port );</span>

<span class="nc" id="L1271">        setUserinfo( userinfo );</span>

<span class="nc" id="L1273">    }</span>





    /**

     * Initialize the path for this URI from a URI string spec.

     *

     * @param uriSpec the URI specification (cannot be null)

     * @throws MalformedURIException uriSpec violates syntax rules

     */

    private void initializePath( String uriSpec )

        throws MalformedURIException

    {

<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">        if ( uriSpec == null )</span>

<span class="nc" id="L1299">            throw new MalformedURIException( &quot;Argument uriSpec is null&quot; );</span>



<span class="fc" id="L1303">        int index = 0;</span>

<span class="fc" id="L1305">        int start = 0;</span>

<span class="fc" id="L1307">        int end = uriSpec.length();</span>

<span class="fc" id="L1309">        char testChar = '\0';</span>



        // path - everything up to query string or fragment

<span class="fc bfc" id="L1315" title="All 2 branches covered.">        while ( index &lt; end ) {</span>

<span class="fc" id="L1317">            testChar = uriSpec.charAt( index );</span>

<span class="pc bpc" id="L1319" title="2 of 4 branches missed.">            if ( testChar == '?' || testChar == '#' )</span>

<span class="nc" id="L1321">                break;</span>

            // check for valid escape sequence

<span class="pc bpc" id="L1325" title="1 of 2 branches missed.">            if ( testChar == '%' ) {</span>

<span class="nc bnc" id="L1327" title="All 4 branches missed.">                if ( index + 2 &gt;= end || ! isHex( uriSpec.charAt( index + 1 ) ) ||</span>

<span class="nc bnc" id="L1329" title="All 2 branches missed.">                     ! isHex( uriSpec.charAt( index + 2 ) ) )</span>

<span class="nc" id="L1331">                    throw new MalformedURIException( &quot;Path contains invalid escape sequence!&quot; );</span>

<span class="pc bpc" id="L1333" title="1 of 2 branches missed.">            } else if ( ! isReservedCharacter( testChar ) &amp;&amp;</span>

<span class="pc bpc" id="L1335" title="1 of 2 branches missed.">                        ! isUnreservedCharacter( testChar ) ) {</span>

<span class="nc bnc" id="L1337" title="All 2 branches missed.">                if ( '\\' != testChar )</span>

<span class="nc" id="L1339">                    throw new MalformedURIException( &quot;Path contains invalid character: &quot; + testChar );</span>

            }

<span class="fc" id="L1343">            index++;</span>

        }

<span class="fc" id="L1347">        _path = uriSpec.substring( start, index );</span>



        // query - starts with ? and up to fragment or end

<span class="pc bpc" id="L1353" title="1 of 2 branches missed.">        if ( testChar == '?' ) {</span>

<span class="nc" id="L1355">            index++;</span>

<span class="nc" id="L1357">            start = index;</span>

<span class="nc bnc" id="L1359" title="All 2 branches missed.">            while ( index &lt; end ) {</span>

<span class="nc" id="L1361">                testChar = uriSpec.charAt( index );</span>

<span class="nc bnc" id="L1363" title="All 2 branches missed.">                if ( testChar == '#' )</span>

<span class="nc" id="L1365">                    break;</span>

<span class="nc bnc" id="L1367" title="All 2 branches missed.">                if ( testChar == '%' ) {</span>

<span class="nc bnc" id="L1369" title="All 4 branches missed.">                    if ( index + 2 &gt;= end || ! isHex( uriSpec.charAt( index + 1 ) ) ||</span>

<span class="nc bnc" id="L1371" title="All 2 branches missed.">                  ! isHex( uriSpec.charAt( index + 2 ) ) )</span>

<span class="nc" id="L1373">                        throw new MalformedURIException( &quot;Query string contains invalid escape sequence!&quot; );</span>

<span class="nc bnc" id="L1375" title="All 2 branches missed.">                } else if ( ! isReservedCharacter( testChar ) &amp;&amp;</span>

<span class="nc bnc" id="L1377" title="All 2 branches missed.">                            ! isUnreservedCharacter( testChar ) )</span>

<span class="nc" id="L1379">                    throw new MalformedURIException( &quot;Query string contains invalid character:&quot; + testChar );</span>

<span class="nc" id="L1381">                index++;</span>

            }

<span class="nc" id="L1385">            _queryString = uriSpec.substring( start, index );</span>

        }



        // fragment - starts with #

<span class="pc bpc" id="L1393" title="1 of 2 branches missed.">        if ( testChar == '#' ) {</span>

<span class="nc" id="L1395">            index++;</span>

<span class="nc" id="L1397">            start = index;</span>

<span class="nc bnc" id="L1399" title="All 2 branches missed.">            while ( index &lt; end ) {</span>

<span class="nc" id="L1401">                testChar = uriSpec.charAt( index );</span>

<span class="nc bnc" id="L1403" title="All 2 branches missed.">                if ( testChar == '%' ) {</span>

<span class="nc bnc" id="L1405" title="All 4 branches missed.">                    if ( index + 2 &gt;= end || ! isHex( uriSpec.charAt( index + 1 ) ) ||</span>

<span class="nc bnc" id="L1407" title="All 2 branches missed.">                         !isHex( uriSpec.charAt( index + 2 ) ) )</span>

<span class="nc" id="L1409">                        throw new MalformedURIException( &quot;Fragment contains invalid escape sequence!&quot; );</span>

<span class="nc bnc" id="L1411" title="All 2 branches missed.">                } else if ( ! isReservedCharacter( testChar ) &amp;&amp;</span>

<span class="nc bnc" id="L1413" title="All 2 branches missed.">                            ! isUnreservedCharacter( testChar ) )</span>

<span class="nc" id="L1415">                    throw new MalformedURIException( &quot;Fragment contains invalid character:&quot; + testChar );</span>

<span class="nc" id="L1417">                index++;</span>

            }

<span class="nc" id="L1421">            _fragment = uriSpec.substring( start, index );</span>

        }

<span class="fc" id="L1425">    }</span>





    /**

     * Get the scheme for this URI.

     *

     * @return the scheme for this URI

     */

    public String getScheme()

    {

<span class="fc" id="L1445">        return _scheme;</span>

    }





    /**

     * Get the scheme-specific part for this URI (everything following the

     * scheme and the first colon). See RFC 2396 Section 5.2 for spec.

     *

     * @return the scheme-specific part for this URI

     */

    public String getSchemeSpecificPart()

    {

<span class="fc" id="L1469">        StringBuffer schemespec = new StringBuffer();</span>

<span class="pc bpc" id="L1471" title="3 of 6 branches missed.">        if ( _userinfo != null || _host != null || _port != -1 ) {</span>

<span class="nc" id="L1473">            schemespec.append( &quot;//&quot; );</span>

<span class="nc bnc" id="L1475" title="All 2 branches missed.">            if ( _userinfo != null) {</span>

<span class="nc" id="L1477">                schemespec.append( _userinfo );</span>

<span class="nc" id="L1479">                schemespec.append( '@' );</span>

            }

<span class="nc bnc" id="L1483" title="All 2 branches missed.">            if ( _host != null )</span>

<span class="nc" id="L1485">                schemespec.append( _host );</span>

<span class="nc bnc" id="L1487" title="All 2 branches missed.">            if ( _port != -1 ) {</span>

<span class="nc" id="L1489">                schemespec.append( ':' );</span>

<span class="nc" id="L1491">                schemespec.append( _port );</span>

            }

        }

<span class="pc bpc" id="L1497" title="1 of 2 branches missed.">        if ( _path != null )</span>

<span class="nc" id="L1499">            schemespec.append( _path );</span>

<span class="pc bpc" id="L1501" title="1 of 2 branches missed.">        if ( _queryString != null ) {</span>

<span class="nc" id="L1503">            schemespec.append( '?' );</span>

<span class="nc" id="L1505">            schemespec.append( _queryString );</span>

        }

<span class="pc bpc" id="L1509" title="1 of 2 branches missed.">        if ( _fragment != null ) {</span>

<span class="nc" id="L1511">            schemespec.append( '#' );</span>

<span class="nc" id="L1513">            schemespec.append( _fragment );</span>

        }

<span class="fc" id="L1517">        return schemespec.toString();</span>

    }





    /**

     * Get the userinfo for this URI.

     *

     * @return the userinfo for this URI (null if not specified).

     */

    public String getUserinfo()

    {

<span class="fc" id="L1539">        return _userinfo;</span>

    }





    /**

     * Get the host for this URI.

     *

     * @return the host for this URI (null if not specified).

     */

    public String getHost()

    {

<span class="fc" id="L1561">        return _host;</span>

    }





    /**

     * Get the port for this URI.

     *

     * @return the port for this URI (-1 if not specified).

     */

    public int getPort()

    {

<span class="fc" id="L1583">        return _port;</span>

    }





    /**

     * Get the path for this URI (optionally with the query string and

     * fragment).

     *

     * @param includeQueryString if true (and query string is not null),

     * then a &quot;?&quot; followed by the query string will be appended

     * @param includeFragment if true (and fragment is not null),

     * then a &quot;#&quot; followed by the fragment will be appended

     * @return the path for this URI possibly including the query string and fragment

     */

    public String getPath( boolean includeQueryString,

                           boolean includeFragment )

    {

<span class="nc" id="L1617">        StringBuffer pathString = new StringBuffer( _path );</span>

<span class="nc bnc" id="L1619" title="All 4 branches missed.">        if ( includeQueryString &amp;&amp; _queryString != null ) {</span>

<span class="nc" id="L1621">            pathString.append( '?' );</span>

<span class="nc" id="L1623">            pathString.append( _queryString );</span>

        }

<span class="nc bnc" id="L1627" title="All 4 branches missed.">        if ( includeFragment &amp;&amp; _fragment != null ) {</span>

<span class="nc" id="L1629">            pathString.append( '#' );</span>

<span class="nc" id="L1631">            pathString.append( _fragment );</span>

        }

<span class="nc" id="L1635">        return pathString.toString();</span>

    }





    /**

     * Get the path for this URI. Note that the value returned is the path

     * only and does not include the query string or fragment.

     *

     * @return the path for this URI.

     */

    public String getPath()

    {

<span class="fc" id="L1659">        return _path;</span>

    }





    /**

     * Get the query string for this URI.

     *

     * @return the query string for this URI. Null is returned if there

     * was no &quot;?&quot; in the URI spec, empty string if there was a &quot;?&quot; but no

     * query string following it.

     */

    public String getQueryString()

    {

<span class="fc" id="L1685">        return _queryString;</span>

    }





    /**

     * Get the fragment for this URI.

     *

     * @return the fragment for this URI. Null is returned if there

     * was no &quot;#&quot; in the URI spec, empty string if there was a

     *  &quot;#&quot; but no fragment following it.

     */

    public String getFragment()

    {

<span class="fc" id="L1711">        return _fragment;</span>

    }





    /**

     * Set the scheme for this URI. The scheme is converted to lowercase

     * before it is set.

     *

     * @param scheme the scheme for this URI (cannot be null)

     * @throws MalformedURIException scheme is not a conformant scheme name

     */

    public void setScheme( String scheme )

        throws MalformedURIException

    {

<span class="pc bpc" id="L1739" title="1 of 2 branches missed.">        if ( scheme == null )</span>

<span class="nc" id="L1741">            throw new MalformedURIException( &quot;Argument scheme is null&quot; );</span>

<span class="pc bpc" id="L1743" title="1 of 2 branches missed.">        if ( ! isConformantSchemeName( scheme ) )</span>

<span class="nc" id="L1745">            throw new MalformedURIException( &quot;The scheme is not conformant.&quot; );</span>

<span class="fc" id="L1747">        _scheme = scheme.toLowerCase();</span>

<span class="fc" id="L1749">    }</span>





    /**

     * Set the userinfo for this URI. If a non-null value is passed in and

     * the host value is null, then an exception is thrown.

     *

     * @param userinfo the userinfo for this URI

     * @throws MalformedURIException userinfo contains invalid characters

     */

    public void setUserinfo( String userinfo )

        throws MalformedURIException

    {

<span class="fc bfc" id="L1775" title="All 2 branches covered.">        if ( userinfo == null )</span>

<span class="fc" id="L1777">            _userinfo = null;</span>

        else {

<span class="pc bpc" id="L1781" title="1 of 2 branches missed.">            if ( _host == null)</span>

<span class="nc" id="L1783">                throw new MalformedURIException( &quot;Userinfo cannot be set when host is null!&quot; );</span>

            // userinfo can contain alphanumerics, mark characters, escaped

            // and ';',':','&amp;','=','+','$',','

<span class="fc" id="L1789">            int index = 0;</span>

<span class="fc" id="L1791">            int end = userinfo.length();</span>

<span class="fc" id="L1793">            char testChar = '\0';</span>



<span class="pc bpc" id="L1797" title="1 of 2 branches missed.">            while ( index &lt; end ) {</span>

<span class="nc" id="L1799">                testChar = userinfo.charAt( index );</span>

<span class="nc bnc" id="L1801" title="All 2 branches missed.">                if ( testChar == '%' ) {</span>

<span class="nc bnc" id="L1803" title="All 4 branches missed.">                    if ( index + 2 &gt;= end || ! isHex( userinfo.charAt( index + 1 ) ) ||</span>

<span class="nc bnc" id="L1805" title="All 2 branches missed.">                         ! isHex( userinfo.charAt( index + 2 ) ) )</span>

<span class="nc" id="L1807">                        throw new MalformedURIException( &quot;Userinfo contains invalid escape sequence!&quot; );</span>

<span class="nc bnc" id="L1809" title="All 4 branches missed.">                } else if ( ! isUnreservedCharacter( testChar ) &amp;&amp; USERINFO_CHARACTERS.indexOf( testChar ) == -1 )</span>

<span class="nc" id="L1811">                    throw new MalformedURIException( &quot;Userinfo contains invalid character:&quot; + testChar );</span>

<span class="nc" id="L1813">                index++;</span>

            }

        }

<span class="fc" id="L1819">        _userinfo = userinfo;</span>

<span class="fc" id="L1821">    }</span>





    /**

     * Set the host for this URI. If null is passed in, the userinfo

     * field is also set to null and the port is set to -1.

     *

     * @param host the host for this URI

     * @throws MalformedURIException host is not a valid IP address or DNS hostname.

     */

    public void setHost( String host )

        throws MalformedURIException

    {

<span class="pc bpc" id="L1847" title="2 of 4 branches missed.">        if ( host == null || host.trim().length() == 0 ) {</span>

<span class="nc" id="L1849">            _host = host;</span>

<span class="nc" id="L1851">            _userinfo = null;</span>

<span class="nc" id="L1853">            _port = -1;</span>

<span class="fc bfc" id="L1855" title="All 2 branches covered.">        } else if ( ! isWellFormedAddress( host ) )</span>

<span class="fc" id="L1857">            throw new MalformedURIException( &quot;Host is not a well formed address!&quot; );</span>

<span class="fc" id="L1859">        _host = host;</span>

<span class="fc" id="L1861">    }</span>





    /**

     * Set the port for this URI. -1 is used to indicate that the port is

     * not specified, otherwise valid port numbers are  between 0 and 65535.

     * If a valid port number is passed in and the host field is null,

     * an exception is thrown.

     *

     * @param port the port number for this URI

     * @throws MalformedURIException port is not -1 and not a valid port number

     */

    public void setPort( int port )

        throws MalformedURIException

    {

<span class="pc bpc" id="L1891" title="1 of 4 branches missed.">        if ( port &gt;= 0 &amp;&amp; port &lt;= 65535 ) {</span>

<span class="pc bpc" id="L1893" title="1 of 2 branches missed.">            if ( _host == null )</span>

<span class="nc" id="L1895">                throw new MalformedURIException( &quot;Port cannot be set when host is null!&quot; );</span>

<span class="pc bpc" id="L1897" title="1 of 2 branches missed.">        } else if ( port != -1 )</span>

<span class="nc" id="L1899">            throw new MalformedURIException( &quot;Invalid port number!&quot; );</span>

<span class="fc" id="L1901">        _port = port;</span>

<span class="fc" id="L1903">    }</span>





    /**

     * Set the path for this URI. If the supplied path is null, then the

     * query string and fragment are set to null as well. If the supplied

     * path includes a query string and/or fragment, these fields will be

     * parsed and set as well. Note that, for URIs following the &quot;generic

     * URI&quot; syntax, the path specified should start with a slash.

     * For URIs that do not follow the generic URI syntax, this method

     * sets the scheme-specific part.

     *

     * @param path the path for this URI (may be null)

     * @throws MalformedURIException path contains invalid characters

     */

    public void setPath( String path )

        throws MalformedURIException

    {

<span class="pc bpc" id="L1939" title="1 of 2 branches missed.">        if ( path == null ) {</span>

<span class="nc" id="L1941">            _path = null;</span>

<span class="nc" id="L1943">            _queryString = null;</span>

<span class="nc" id="L1945">            _fragment = null;</span>

        } else

<span class="fc" id="L1949">            initializePath( path );</span>

<span class="fc" id="L1951">    }</span>





    /**

     * Append to the end of the path of this URI. If the current path does

     * not end in a slash and the path to be appended does not begin with

     * a slash, a slash will be appended to the current path before the

     * new segment is added. Also, if the current path ends in a slash

     * and the new segment begins with a slash, the extra slash will be

     * removed before the new segment is appended.

     *

     * @param addToPath the new segment to be added to the current path

     * @exception MalformedURIException addToPath contains syntax errors

     */

    public void appendPath( String addToPath )

        throws MalformedURIException

    {

<span class="nc bnc" id="L1985" title="All 4 branches missed.">        if ( addToPath == null || addToPath.trim().length() == 0 )</span>

<span class="nc" id="L1987">            return;</span>

<span class="nc bnc" id="L1989" title="All 2 branches missed.">        if ( ! isURIString( addToPath ) )</span>

<span class="nc" id="L1991">            throw new MalformedURIException( &quot;Path contains invalid character!&quot; );</span>

<span class="nc bnc" id="L1993" title="All 4 branches missed.">        if ( _path == null || _path.trim().length() == 0 ) {</span>

<span class="nc bnc" id="L1995" title="All 2 branches missed.">            if ( addToPath.startsWith( &quot;/&quot; ) )</span>

<span class="nc" id="L1997">                _path = addToPath;</span>

            else

<span class="nc" id="L2001">                _path = &quot;/&quot; + addToPath;</span>

<span class="nc bnc" id="L2003" title="All 2 branches missed.">        } else if ( _path.endsWith( &quot;/&quot; ) ) {</span>

<span class="nc bnc" id="L2005" title="All 2 branches missed.">            if ( addToPath.startsWith( &quot;/&quot; ) )</span>

<span class="nc" id="L2007">                _path = _path.concat( addToPath.substring( 1 ) );</span>

            else

<span class="nc" id="L2011">                _path = _path.concat( addToPath );</span>

        } else {

<span class="nc bnc" id="L2015" title="All 2 branches missed.">            if ( addToPath.startsWith( &quot;/&quot; ) )</span>

<span class="nc" id="L2017">                _path = _path.concat( addToPath );</span>

            else

<span class="nc" id="L2021">                _path = _path.concat( &quot;/&quot; + addToPath );</span>

        }

<span class="nc" id="L2025">    }</span>





    /**

     * Set the query string for this URI. A non-null value is valid only

     * if this is an URI conforming to the generic URI syntax and

     * the path value is not null.

     *

     * @param queryString the query string for this URI

     * @exception MalformedURIException queryString is not null and this

     * URI does not conform to the generic URI syntax or if the path is null

     */

    public void setQueryString( String queryString )

        throws MalformedURIException

    {

<span class="fc bfc" id="L2055" title="All 2 branches covered.">        if ( queryString == null )</span>

<span class="fc" id="L2057">            _queryString = null;</span>

<span class="pc bpc" id="L2059" title="1 of 2 branches missed.">        else if ( ! isGenericURI() )</span>

<span class="nc" id="L2061">            throw new MalformedURIException( &quot;Query string can only be set for a generic URI!&quot; );</span>

<span class="pc bpc" id="L2063" title="1 of 2 branches missed.">        else if ( getPath() == null )</span>

<span class="nc" id="L2065">            throw new MalformedURIException( &quot;Query string cannot be set when path is null!&quot; );</span>

<span class="pc bpc" id="L2067" title="1 of 2 branches missed.">        else if ( ! isURIString( queryString ) )</span>

<span class="nc" id="L2069">            throw new MalformedURIException( &quot;Query string contains invalid character!&quot; );</span>

        else

<span class="fc" id="L2073">            _queryString = queryString;</span>

<span class="fc" id="L2075">    }</span>





    /**

     * Set the fragment for this URI. A non-null value is valid only

     * if this is a URI conforming to the generic URI syntax and

     * the path value is not null.

     *

     * @param fragment the fragment for this URI

     * @exception MalformedURIException fragment is not null and this

     * URI does not conform to the generic URI syntax or if the path is null

     */

    public void setFragment( String fragment )

        throws MalformedURIException

    {

<span class="fc bfc" id="L2105" title="All 2 branches covered.">        if ( fragment == null )</span>

<span class="fc" id="L2107">            _fragment = null;</span>

<span class="pc bpc" id="L2109" title="1 of 2 branches missed.">        else if ( ! isGenericURI() )</span>

<span class="nc" id="L2111">            throw new MalformedURIException( &quot;Fragment can only be set for a generic URI!&quot; );</span>

<span class="pc bpc" id="L2113" title="1 of 2 branches missed.">        else if ( getPath() == null )</span>

<span class="nc" id="L2115">            throw new MalformedURIException( &quot;Fragment cannot be set when path is null!&quot; );</span>

<span class="pc bpc" id="L2117" title="1 of 2 branches missed.">        else if ( ! isURIString( fragment ) )</span>

<span class="nc" id="L2119">            throw new MalformedURIException( &quot;Fragment contains invalid character!&quot; );</span>

        else

<span class="fc" id="L2123">            _fragment = fragment;</span>

<span class="fc" id="L2125">    }</span>





    /**

     * Determines if the passed-in Object is equivalent to this URI.

     *

     * @param test the Object to test for equality.

     * @return true if test is a URI with all values equal to this

     * URI, false otherwise

     */

    public boolean equals( Object test )

    {

<span class="nc bnc" id="L2149" title="All 2 branches missed.">        if ( test instanceof URI ) {</span>

<span class="nc" id="L2151">            URI testURI = (URI) test;</span>

<span class="nc bnc" id="L2153" title="All 8 branches missed.">            return ( ( ( _scheme == null &amp;&amp; testURI._scheme == null ) ||</span>

<span class="nc bnc" id="L2155" title="All 10 branches missed.">                       ( _scheme != null &amp;&amp; testURI._scheme != null &amp;&amp; _scheme.equals( testURI._scheme) ) ) &amp;&amp;</span>

                     ( ( _userinfo == null &amp;&amp; testURI._userinfo == null ) ||

<span class="nc bnc" id="L2159" title="All 10 branches missed.">                       ( _userinfo != null &amp;&amp; testURI._userinfo != null &amp;&amp; _userinfo.equals( testURI._userinfo ) ) ) &amp;&amp;</span>

                     ( ( _host == null &amp;&amp; testURI._host == null ) ||

<span class="nc bnc" id="L2163" title="All 12 branches missed.">                       ( _host != null &amp;&amp; testURI._host != null &amp;&amp; _host.equals( testURI._host ) ) ) &amp;&amp;</span>

                     _port == testURI._port &amp;&amp;

                     ( ( _path == null &amp;&amp; testURI._path == null ) ||

<span class="nc bnc" id="L2169" title="All 10 branches missed.">                       ( _path != null &amp;&amp; testURI._path != null &amp;&amp; _path.equals( testURI._path ) ) ) &amp;&amp;</span>

                     ( ( _queryString == null &amp;&amp; testURI._queryString == null ) ||

                       ( _queryString != null &amp;&amp; testURI._queryString != null &amp;&amp;

<span class="nc bnc" id="L2175" title="All 10 branches missed.">                         _queryString.equals( testURI._queryString ) ) ) &amp;&amp;</span>

                     ( ( _fragment == null &amp;&amp; testURI._fragment == null ) ||

<span class="nc bnc" id="L2179" title="All 2 branches missed.">                       ( _fragment != null &amp;&amp; testURI._fragment != null &amp;&amp; _fragment.equals( testURI._fragment ) ) ) );</span>

        }

<span class="nc" id="L2183">        return false;</span>

    }





    /**

     * Get the URI as a string specification. See RFC 2396 Section 5.2.

     *

     * @return the URI string specification

     */

    public String toString()

    {

<span class="fc" id="L2205">        StringBuffer uriSpecString = new StringBuffer();</span>



<span class="pc bpc" id="L2209" title="1 of 2 branches missed.">        if ( _scheme != null ) {</span>

<span class="nc" id="L2211">            uriSpecString.append( _scheme );</span>

<span class="nc" id="L2213">            uriSpecString.append( ':' );</span>

        }

<span class="fc" id="L2217">        uriSpecString.append( getSchemeSpecificPart() );</span>

<span class="fc" id="L2219">        return uriSpecString.toString();</span>

    }

    /**
     * Returns the hash code of this URI
     *
     * @return the hash code of this URI
     */
    public int hashCode() {
<span class="nc" id="L2229">        return toString().hashCode();</span>
    }

    /**

     * Get the indicator as to whether this URI uses the &quot;generic URI&quot;

     * syntax.

     *

     * @return true if this URI uses the &quot;generic URI&quot; syntax, false otherwise

     */

    public boolean isGenericURI()

    {

        // presence of the host (whether valid or empty) means

        // double-slashes which means generic uri

<span class="pc bpc" id="L2252" title="1 of 2 branches missed.">        return ( _host != null );</span>

    }





    /**

     * Determine whether a scheme conforms to the rules for a scheme name.

     * A scheme is conformant if it starts with an alphanumeric, and

     * contains only alphanumerics, '+','-' and '.'.

     *

     *

     * @param scheme The sheme name to check

     * @return true if the scheme is conformant, false otherwise

     */

    public static boolean isConformantSchemeName( String scheme )

    {

<span class="pc bpc" id="L2282" title="2 of 4 branches missed.">        if ( scheme == null || scheme.trim().length() == 0 )</span>

<span class="nc" id="L2284">            return false;</span>

<span class="pc bpc" id="L2286" title="1 of 2 branches missed.">        if ( ! isAlpha( scheme.charAt( 0 ) ) )</span>

<span class="nc" id="L2288">            return false;</span>

        char testChar;

<span class="fc bfc" id="L2292" title="All 2 branches covered.">        for ( int i = 1 ; i &lt; scheme.length() ; i++ ) {</span>

<span class="fc" id="L2294">            testChar = scheme.charAt( i );</span>

<span class="pc bpc" id="L2296" title="1 of 4 branches missed.">            if ( ! isAlphanum( testChar ) &amp;&amp; SCHEME_CHARACTERS.indexOf( testChar ) == -1 )</span>

<span class="nc" id="L2298">                return false;</span>

        }

<span class="fc" id="L2302">        return true;</span>

    }





    /**

     * Determine whether a string is syntactically capable of representing

     * a valid IPv4 address or the domain name of a network host. A valid

     * IPv4 address consists of four decimal digit groups separated by a

     * '.'. A hostname consists of domain labels (each of which must

     * begin and end with an alphanumeric but may contain '-') separated

     * &amp; by a '.'. See RFC 2396 Section 3.2.2.

     *

     * @param address The address string to check

     * @return true if the string is a syntactically valid IPv4 address or hostname

     */

    public static boolean isWellFormedAddress( String address )

    {

        char testChar;



<span class="pc bpc" id="L2340" title="1 of 2 branches missed.">        if ( address == null )</span>

<span class="nc" id="L2342">            return false;</span>

<span class="fc" id="L2344">        address = address.trim();</span>

<span class="fc" id="L2346">        int addrLength = address.length();</span>



<span class="pc bpc" id="L2350" title="2 of 4 branches missed.">        if ( addrLength == 0 || addrLength &gt; 255 )</span>

<span class="nc" id="L2352">            return false;</span>



<span class="pc bpc" id="L2356" title="2 of 4 branches missed.">        if ( address.startsWith( &quot;.&quot; ) || address.startsWith( &quot;-&quot; ) )</span>

<span class="nc" id="L2358">            return false;</span>



        // rightmost domain label starting with digit indicates IP address

        // since top level domain label can only start with an alpha

        // see RFC 2396 Section 3.2.2

<span class="fc" id="L2368">        int index = address.lastIndexOf( '.' );</span>

<span class="pc bpc" id="L2370" title="1 of 2 branches missed.">        if ( address.endsWith( &quot;.&quot; ) )</span>

<span class="nc" id="L2372">            index = address.substring( 0, index ).lastIndexOf( '.' );</span>

<span class="pc bpc" id="L2374" title="2 of 4 branches missed.">        if ( index + 1 &lt; addrLength &amp;&amp; isDigit( address.charAt( index + 1 ) ) ) {</span>

<span class="nc" id="L2376">            int numDots = 0;</span>



            // make sure that 1) we see only digits and dot separators, 2) that

            // any dot separator is preceded and followed by a digit and

            // 3) that we find 3 dots

<span class="nc bnc" id="L2386" title="All 2 branches missed.">            for ( int i = 0 ; i &lt; addrLength ; i++) {</span>

<span class="nc" id="L2388">                testChar = address.charAt( i );</span>

<span class="nc bnc" id="L2390" title="All 2 branches missed.">                if ( testChar == '.' ) {</span>

<span class="nc bnc" id="L2392" title="All 4 branches missed.">                    if ( ! isDigit( address.charAt( i - 1 ) ) ||</span>

<span class="nc bnc" id="L2394" title="All 2 branches missed.">                         ( i + 1 &lt; addrLength &amp;&amp; ! isDigit( address.charAt( i + 1 ) ) ) )</span>

<span class="nc" id="L2396">                        return false;</span>



<span class="nc" id="L2400">                    numDots++;</span>

<span class="nc bnc" id="L2402" title="All 2 branches missed.">                } else if ( ! isDigit( testChar ) )</span>

<span class="nc" id="L2404">                    return false;</span>

            }

<span class="nc bnc" id="L2408" title="All 2 branches missed.">            if ( numDots != 3 )</span>

<span class="nc" id="L2410">                return false;</span>

<span class="nc" id="L2412">        } else {</span>

            // domain labels can contain alphanumerics and '-&quot;

            // but must start and end with an alphanumeric

<span class="fc bfc" id="L2418" title="All 2 branches covered.">            for ( int i = 0 ; i &lt; addrLength ; i++ ) {</span>

<span class="fc" id="L2420">                testChar = address.charAt( i );</span>

<span class="fc bfc" id="L2422" title="All 2 branches covered.">                if ( testChar == '.' ) {</span>

<span class="pc bpc" id="L2424" title="1 of 2 branches missed.">                    if ( ! isAlphanum( address.charAt( i - 1 ) ) )</span>

<span class="nc" id="L2426">                        return false;</span>

<span class="pc bpc" id="L2428" title="2 of 4 branches missed.">                    if ( i + 1 &lt; addrLength &amp;&amp; ! isAlphanum( address.charAt( i + 1 ) ) )</span>

<span class="nc" id="L2430">                        return false;</span>

<span class="pc bpc" id="L2432" title="1 of 4 branches missed.">                } else if ( ! isAlphanum( testChar ) &amp;&amp; testChar != '-' )</span>

<span class="fc" id="L2434">                    return false;</span>

            }

        }

<span class="fc" id="L2440">        return true;</span>

    }





    /**

     * Determine whether a char is a digit.

     *

     * @param ch the character to check

     * @return true if the char is betweeen '0' and '9', false otherwise

     */

    private static boolean isDigit( char ch )

    {

<span class="pc bpc" id="L2464" title="1 of 4 branches missed.">        return ch &gt;= '0' &amp;&amp; ch &lt;= '9';</span>

    }





    /**

     * Determine whether a character is a hexadecimal character.

     *

     * @param ch the character to check

     * @return true if the char is betweeen '0' and '9', 'a' and 'f'

     * or 'A' and 'F', false otherwise

     */

    private static boolean isHex( char ch )

    {

<span class="nc bnc" id="L2490" title="All 10 branches missed.">        return ( isDigit( ch ) || ( ch &gt;= 'a' &amp;&amp; ch &lt;= 'f' ) ||</span>

                 ( ch &gt;= 'A' &amp;&amp; ch &lt;= 'F' ) );

    }





    /**

     * Determine whether a char is an alphabetic character: a-z or A-Z

     *

     * @param ch the character to check

     * @return true if the char is alphabetic, false otherwise

     */

    private static boolean isAlpha( char ch )

    {

<span class="pc bpc" id="L2516" title="2 of 8 branches missed.">        return ( ( ch &gt;= 'a' &amp;&amp; ch &lt;= 'z' ) ||</span>

                 ( ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z' ) );

    }





    /**

     * Determine whether a char is an alphanumeric: 0-9, a-z or A-Z

     *

     * @param ch the character to check

     * @return true if the char is alphanumeric, false otherwise

     */

    private static boolean isAlphanum( char ch )

    {

<span class="pc bpc" id="L2542" title="1 of 4 branches missed.">        return ( isAlpha( ch ) || isDigit( ch ) );</span>

    }





    /**

     * Determine whether a character is a reserved character:

     * ';', '/', '?', ':', '@', '&amp;', '=', '+', '$' or ','

     *

     * @param ch the character to check

     * @return true if the string contains any reserved characters

     */

    private static boolean isReservedCharacter( char ch )

    {

<span class="pc bpc" id="L2568" title="1 of 2 branches missed.">        return RESERVED_CHARACTERS.indexOf( ch ) != -1;</span>

    }





    /**

     * Determine whether a char is an unreserved character.

     *

     * @param ch the character to check

     * @return true if the char is unreserved, false otherwise

     */

    private static boolean isUnreservedCharacter( char ch )

    {

<span class="pc bpc" id="L2592" title="1 of 4 branches missed.">        return ( isAlphanum( ch ) || MARK_CHARACTERS.indexOf( ch ) != -1 );</span>

    }





    /**

     * Determine whether a given string contains only URI characters (also

     * called &quot;uric&quot; in RFC 2396). uric consist of all reserved

     * characters, unreserved characters and escaped characters.

     *

     * @param uric URI string

     * @return true if the string is comprised of uric, false otherwise

     */

    private static boolean isURIString( String uric )

    {

<span class="pc bpc" id="L2620" title="1 of 2 branches missed.">        if ( uric == null )</span>

<span class="nc" id="L2622">            return false;</span>

<span class="fc" id="L2624">        int end = uric.length();</span>

<span class="fc" id="L2626">        char testChar = '\0';</span>

<span class="fc bfc" id="L2628" title="All 2 branches covered.">        for ( int i = 0 ; i &lt; end ; i++ ) {</span>

<span class="fc" id="L2630">            testChar = uric.charAt( i );</span>

<span class="pc bpc" id="L2632" title="1 of 2 branches missed.">            if ( testChar == '%' ) {</span>

<span class="nc bnc" id="L2634" title="All 4 branches missed.">                if ( i + 2 &gt;= end || ! isHex( uric.charAt( i + 1 ) ) ||</span>

<span class="nc bnc" id="L2636" title="All 2 branches missed.">                     ! isHex( uric.charAt( i + 2 ) ) )</span>

<span class="nc" id="L2638">                    return false;</span>

                else {

<span class="nc" id="L2642">                    i += 2;</span>

<span class="nc" id="L2644">                    continue;</span>

                }

            }

<span class="pc bpc" id="L2650" title="2 of 4 branches missed.">            if ( isReservedCharacter( testChar ) || isUnreservedCharacter( testChar ) )</span>

<span class="fc" id="L2652">                continue;</span>

            else

<span class="nc" id="L2656">                return false;</span>

        }

<span class="fc" id="L2660">        return true;</span>

    }





}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>