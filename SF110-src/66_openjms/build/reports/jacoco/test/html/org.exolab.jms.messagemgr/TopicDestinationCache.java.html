<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TopicDestinationCache.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">66_openjms</a> &gt; <a href="index.source.html" class="el_package">org.exolab.jms.messagemgr</a> &gt; <span class="el_source">TopicDestinationCache.java</span></div><h1>TopicDestinationCache.java</h1><pre class="source lang-java linenums">/**
 * Redistribution and use of this software and associated documentation
 * (&quot;Software&quot;), with or without modification, are permitted provided
 * that the following conditions are met:
 *
 * 1. Redistributions of source code must retain copyright
 *    statements and notices.  Redistributions must also contain a
 *    copy of this document.
 *
 * 2. Redistributions in binary form must reproduce the
 *    above copyright notice, this list of conditions and the
 *    following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 *
 * 3. The name &quot;Exolab&quot; must not be used to endorse or promote
 *    products derived from this Software without prior written
 *    permission of Exoffice Technologies.  For written permission,
 *    please contact info@exolab.org.
 *
 * 4. Products derived from this Software may not be called &quot;Exolab&quot;
 *    nor may &quot;Exolab&quot; appear in their names without prior written
 *    permission of Exoffice Technologies. Exolab is a registered
 *    trademark of Exoffice Technologies.
 *
 * 5. Due credit should be given to the Exolab Project
 *    (http://www.exolab.org/).
 *
 * THIS SOFTWARE IS PROVIDED BY EXOFFICE TECHNOLOGIES AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * EXOFFICE TECHNOLOGIES OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Copyright 2001-2005 (C) Exoffice Technologies Inc. All Rights Reserved.
 *
 * $Id: TopicDestinationCache.java,v 1.6 2005/12/20 20:39:45 tanderson Exp $
 */
package org.exolab.jms.messagemgr;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;
import javax.jms.JMSException;

import org.exolab.jms.client.JmsDestination;
import org.exolab.jms.client.JmsTopic;
import org.exolab.jms.lease.LeaseManager;
import org.exolab.jms.message.MessageImpl;
import org.exolab.jms.persistence.DatabaseService;
import org.exolab.jms.persistence.PersistenceException;


/**
 * A {@link DestinationCache} for topics.
 *
 * @author &lt;a href=&quot;mailto:jima@comware.com.au&quot;&gt;Jim Alateras&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:tma@netspace.net.au&quot;&gt;Tim Anderson&lt;/a&gt;
 * @version $Revision: 1.6 $ $Date: 2005/12/20 20:39:45 $
 */
class TopicDestinationCache extends AbstractDestinationCache {

    /**
     * Construct a new &lt;code&gt;TopicDestinationCache&lt;/code&gt;.
     *
     * @param topic    the topic to cache messages for
     * @param database the database service
     * @param leases   the lease manager
     */
    public TopicDestinationCache(JmsTopic topic, DatabaseService database,
                                 LeaseManager leases) {
<span class="nc" id="L80">        super(topic, database, leases);</span>
<span class="nc" id="L81">    }</span>

    /**
     * Register a consumer with this cache.
     *
     * @param consumer the message consumer for this destination
     * @return &lt;code&gt;true&lt;/code&gt; if registered; otherwise &lt;code&gt;false&lt;/code&gt;
     */
    public boolean addConsumer(ConsumerEndpoint consumer) {

<span class="nc" id="L91">        boolean result = false;</span>

        // check to see that the consumer can actually subscribe to
        // this destination
<span class="nc" id="L95">        JmsTopic cdest = (JmsTopic) consumer.getDestination();</span>
<span class="nc" id="L96">        JmsTopic ddest = (JmsTopic) getDestination();</span>

<span class="nc bnc" id="L98" title="All 2 branches missed.">        if (cdest.match(ddest)) {</span>
<span class="nc" id="L99">            result = super.addConsumer(consumer);</span>
        }

<span class="nc" id="L102">        return result;</span>
    }

    /**
     * Invoked when the {@link MessageMgr} receives a non-persistent message.
     *
     * @param destination the message's destination
     * @param message     the message
     * @throws JMSException if the listener fails to handle the message
     */
    public void messageAdded(JmsDestination destination, MessageImpl message)
            throws JMSException {
<span class="nc" id="L114">        boolean processed = false;</span>
<span class="nc" id="L115">        MessageRef reference =</span>
<span class="nc" id="L116">                new CachedMessageRef(message, false, getMessageCache());</span>

<span class="nc" id="L118">        reference.reference(); // temporary reference to ensure the message has</span>
                               // a non-zero reference while passing it to each
                               // of the consumers, to avoid premature
                               // destruction
<span class="nc" id="L122">        addMessage(reference, message);</span>
<span class="nc" id="L123">        MessageHandle handle = new SharedMessageHandle(this, reference,</span>
                                                       message);

<span class="nc" id="L126">        ConsumerEndpoint[] consumers = getConsumerArray();</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        for (int index = 0; index &lt; consumers.length; index++) {</span>
<span class="nc" id="L128">            ConsumerEndpoint consumer = consumers[index];</span>
<span class="nc" id="L129">            processed |= consumer.messageAdded(handle, message);</span>
        }

        // create a lease iff one is required and the message has actually
        // been accepted by at least one endpoint
<span class="nc bnc" id="L134" title="All 2 branches missed.">        if (processed) {</span>
<span class="nc" id="L135">            checkMessageExpiry(reference, message);</span>
<span class="nc" id="L136">            reference.dereference(); // remove temporary reference</span>
        } else {
            // no consumer picked up the message, so toss it
<span class="nc" id="L139">            reference.destroy();</span>
            // @todo - inefficient. Don't really want to add the message
            // just to remove it again if there are no consumers for it
        }
<span class="nc" id="L143">    }</span>

    /**
     * Invoked when the {@link MessageMgr} receives a persistent message.
     *
     * @param destination the message's destination
     * @param message     the message
     * @throws JMSException         if the listener fails to handle the message
     * @throws PersistenceException if there is a persistence related problem
     */
    public void persistentMessageAdded(JmsDestination destination,
                                       MessageImpl message)
            throws JMSException, PersistenceException {
<span class="nc" id="L156">        boolean processed = false;</span>
<span class="nc" id="L157">        MessageRef reference = new CachedMessageRef(message, true,</span>
<span class="nc" id="L158">                                                    getMessageCache());</span>
<span class="nc" id="L159">        reference.reference(); // temporary reference to ensure the message has</span>
                               // a non-zero reference while passing it to each
                               // of the consumers, to avoid premature
                               // destruction
<span class="nc" id="L163">        addMessage(reference, message);</span>
<span class="nc" id="L164">        SharedMessageHandle handle = new SharedMessageHandle(this, reference,</span>
                                                             message);

        // now send the message to all active consumers
<span class="nc" id="L168">        ConsumerEndpoint[] consumers = getConsumerArray();</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        for (int index = 0; index &lt; consumers.length; index++) {</span>
<span class="nc" id="L170">            ConsumerEndpoint consumer = consumers[index];</span>
<span class="nc" id="L171">            processed |= consumer.persistentMessageAdded(handle, message);</span>
        }

        // for each inactive durable consumer, add a persistent handle
        // @todo - possible race condition between inactive subscription
        // becoming active again - potential for message loss?
/*
        JmsTopic topic = (JmsTopic) getDestination();
        List inactive = _consumers.getInactiveSubscriptions(
                topic);
        if (!inactive.isEmpty()) {
            Iterator iterator = inactive.iterator();
            while (iterator.hasNext()) {
                String name = (String) iterator.next();
                TopicConsumerMessageHandle durable
                        = new TopicConsumerMessageHandle(handle, name);
                durable.add(connection);
            }
            processed = true;
        }
*/

        // create a lease iff one is required and the message has actually
        // been accepted by at least one endpoint
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (processed) {</span>
<span class="nc" id="L196">            checkMessageExpiry(reference, message);</span>
<span class="nc" id="L197">            reference.dereference(); // remove temporary reference</span>
        } else {
            // no consumer picked up the message, so toss it
<span class="nc" id="L200">            handle.destroy();</span>
            // @todo - inefficient. Don't really want to make the message
            // persistent, just to remove it again if there are no consumers
            // for it
        }

<span class="nc" id="L206">    }</span>

    /**
     * Return a message handle back to the cache, to recover unsent or
     * unacknowledged messages.
     *
     * @param handle the message handle to return
     */
    public void returnMessageHandle(MessageHandle handle) {
<span class="nc" id="L215">        long consumerId = handle.getConsumerId();</span>
<span class="nc" id="L216">        AbstractTopicConsumerEndpoint endpoint =</span>
<span class="nc" id="L217">                (AbstractTopicConsumerEndpoint) getConsumerEndpoint(consumerId);</span>
        // if the endpoint is still active then return the message
        // back to it
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (endpoint != null) {</span>
<span class="nc" id="L221">            endpoint.returnMessage(handle);</span>
        } else {
            // @todo - need to destroy the handle?
        }
<span class="nc" id="L225">    }</span>

    /**
     * Load the state of a durable consumer.
     *
     * @param name       the durable subscription name
     * @return a list of {@link MessageHandle} instances
     * @throws JMSException         for any JMS error
     */
    public List getDurableMessageHandles(String name)
            throws JMSException, PersistenceException {
<span class="nc" id="L236">        DatabaseService service = DatabaseService.getInstance();</span>
<span class="nc" id="L237">        Connection connection = service.getConnection();</span>
<span class="nc" id="L238">        Vector handles = service.getAdapter().getMessageHandles(</span>
<span class="nc" id="L239">                connection, getDestination(), name);</span>
<span class="nc" id="L240">        List result = new ArrayList(handles.size());</span>

<span class="nc" id="L242">        MessageCache cache = getMessageCache();</span>

<span class="nc" id="L244">        Iterator iterator = handles.iterator();</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        while (iterator.hasNext()) {</span>
<span class="nc" id="L246">            PersistentMessageHandle handle =</span>
<span class="nc" id="L247">                    (PersistentMessageHandle) iterator.next();</span>
<span class="nc" id="L248">            String messageId = handle.getMessageId();</span>
<span class="nc" id="L249">            MessageRef reference = cache.getMessageRef(messageId);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (reference == null) {</span>
<span class="nc" id="L251">                reference = new CachedMessageRef(messageId, true, cache);</span>
            }
<span class="nc" id="L253">            cache.addMessageRef(reference);</span>
<span class="nc" id="L254">            handle.reference(reference);</span>
<span class="nc" id="L255">            handle.setDestinationCache(this);</span>
<span class="nc" id="L256">            result.add(handle);</span>

<span class="nc" id="L258">            checkMessageExpiry(reference, handle.getExpiryTime());</span>
<span class="nc" id="L259">        }</span>
<span class="nc" id="L260">        return result;</span>
    }

    /**
     * Remove an expired persistent message, and notify any listeners.
     *
     * @param reference  a handle to the expired message
     * @throws JMSException         if a listener fails to handle the
     *                              expiration
     * @throws PersistenceException if there is a persistence related problem
     */
    protected void persistentMessageExpired(MessageRef reference)
            throws JMSException, PersistenceException {
<span class="nc" id="L273">        String messageId = reference.getMessageId();</span>
<span class="nc" id="L274">        ConsumerEndpoint[] consumers = getConsumerArray();</span>

<span class="nc bnc" id="L276" title="All 2 branches missed.">        for (int i = 0; i &lt; consumers.length; ++i) {</span>
<span class="nc" id="L277">            consumers[i].persistentMessageRemoved(messageId);</span>
        }
<span class="nc" id="L279">    }</span>

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>