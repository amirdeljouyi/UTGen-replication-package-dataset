<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractDestinationCache.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">66_openjms</a> &gt; <a href="index.source.html" class="el_package">org.exolab.jms.messagemgr</a> &gt; <span class="el_source">AbstractDestinationCache.java</span></div><h1>AbstractDestinationCache.java</h1><pre class="source lang-java linenums">/**
 * Redistribution and use of this software and associated documentation
 * (&quot;Software&quot;), with or without modification, are permitted provided
 * that the following conditions are met:
 *
 * 1. Redistributions of source code must retain copyright
 *    statements and notices.  Redistributions must also contain a
 *    copy of this document.
 *
 * 2. Redistributions in binary form must reproduce the
 *    above copyright notice, this list of conditions and the
 *    following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 *
 * 3. The name &quot;Exolab&quot; must not be used to endorse or promote
 *    products derived from this Software without prior written
 *    permission of Exoffice Technologies.  For written permission,
 *    please contact info@exolab.org.
 *
 * 4. Products derived from this Software may not be called &quot;Exolab&quot;
 *    nor may &quot;Exolab&quot; appear in their names without prior written
 *    permission of Exoffice Technologies. Exolab is a registered
 *    trademark of Exoffice Technologies.
 *
 * 5. Due credit should be given to the Exolab Project
 *    (http://www.exolab.org/).
 *
 * THIS SOFTWARE IS PROVIDED BY EXOFFICE TECHNOLOGIES AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * EXOFFICE TECHNOLOGIES OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Copyright 2001-2005 (C) Exoffice Technologies Inc. All Rights Reserved.
 *
 * $Id: AbstractDestinationCache.java,v 1.4 2007/01/24 12:00:28 tanderson Exp $
 */
package org.exolab.jms.messagemgr;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import javax.jms.JMSException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.exolab.jms.client.JmsDestination;
import org.exolab.jms.lease.LeaseEventListenerIfc;
import org.exolab.jms.lease.LeaseManager;
import org.exolab.jms.message.MessageImpl;
import org.exolab.jms.persistence.PersistenceException;
import org.exolab.jms.persistence.DatabaseService;


/**
 * Abstract implementation of the {@link DestinationCache} interface.
 *
 * @author &lt;a href=&quot;mailto:tma@netspace.net.au&quot;&gt;Tim Anderson&lt;/a&gt;
 * @version $Revision: 1.4 $ $Date: 2007/01/24 12:00:28 $
 */
public abstract class AbstractDestinationCache implements DestinationCache,
        LeaseEventListenerIfc {

    /**
     * The destination to cache messages for.
     */
    private final JmsDestination _destination;

    /**
     * The message cache for this destination.
     */
<span class="nc" id="L80">    private DefaultMessageCache _cache = new DefaultMessageCache();</span>

    /**
     * The set of consumers that have subscribed to this cache, keyed on id.
     */
<span class="nc" id="L85">    private Map _consumers = Collections.synchronizedMap(new HashMap());</span>

    /**
     * A map of String -&gt; MessageLease objects, representing the active leases
     * keyed on JMSMessageID.
     */
<span class="nc" id="L91">    private final HashMap _leases = new HashMap();</span>

    /**
     * The database service.
     */
    private final DatabaseService _database;

    /**
     * The lease manager.
     */
    private final LeaseManager _leaseMgr;

    /**
     * The logger.
     */
<span class="nc" id="L106">    private static final Log _log = LogFactory.getLog(</span>
            AbstractDestinationCache.class);


    /**
     * Construct a new &lt;code&gt;AbstractDestinationCache&lt;/code&gt;.
     *
     * @param destination the destination to cache messages for
     * @param database    the database service
     * @param leases      the lease manager
     */
    public AbstractDestinationCache(JmsDestination destination,
                                    DatabaseService database,
<span class="nc" id="L119">                                    LeaseManager leases) {</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (destination == null) {</span>
<span class="nc" id="L121">            throw new IllegalArgumentException(</span>
                    &quot;Argument 'destination' is null&quot;);
        }
<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (database == null) {</span>
<span class="nc" id="L125">            throw new IllegalArgumentException(&quot;Argument 'database' is null&quot;);</span>
        }
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (leases == null) {</span>
<span class="nc" id="L128">            throw new IllegalArgumentException(&quot;Argument 'leases' is null&quot;);</span>
        }
<span class="nc" id="L130">        _destination = destination;</span>
<span class="nc" id="L131">        _database = database;</span>
<span class="nc" id="L132">        _leaseMgr = leases;</span>
<span class="nc" id="L133">    }</span>

    /**
     * Returns the destination that messages are being cached for.
     *
     * @return the destination that messages are being cached for
     */
    public JmsDestination getDestination() {
<span class="nc" id="L141">        return _destination;</span>
    }

    /**
     * Register a consumer with this cache.
     *
     * @param consumer the message consumer for this destination
     * @return &lt;code&gt;true&lt;/code&gt; if registered; otherwise &lt;code&gt;false&lt;/code&gt;
     */
    public boolean addConsumer(ConsumerEndpoint consumer) {
<span class="nc" id="L151">        boolean result = false;</span>

        // check to see that the consumer is actually one for this
        // destination
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (consumer.getDestination().equals(getDestination())) {</span>
<span class="nc" id="L156">            Long key = new Long(consumer.getId());</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (!_consumers.containsKey(key)) {</span>
<span class="nc" id="L158">                _consumers.put(key, consumer);</span>
<span class="nc" id="L159">                result = true;</span>
            }
        }

<span class="nc" id="L163">        return result;</span>
    }

    /**
     * Remove the consumer for the list of registered consumers.
     *
     * @param consumer the consumer to remove
     */
    public void removeConsumer(ConsumerEndpoint consumer) {
<span class="nc" id="L172">        Long key = new Long(consumer.getId());</span>
<span class="nc" id="L173">        _consumers.remove(key);</span>
<span class="nc" id="L174">    }</span>

    /**
     * Determines if the cache has any consumers.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cache has consumers; otherwise
     *         &lt;code&gt;false&lt;/code&gt;
     */
    public boolean hasConsumers() {
<span class="nc bnc" id="L183" title="All 2 branches missed.">        return !_consumers.isEmpty();</span>
    }

    /**
     * Returns the number of messages in the cache.
     *
     * @return the number of messages in the cache
     */
    public int getMessageCount() {
<span class="nc" id="L192">        return _cache.getMessageCount();</span>
    }

    /**
     * Determines if this cache can be destroyed. This implementation returns
     * &lt;code&gt;true&lt;/code&gt; if there are no active consumers.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cache can be destroyed, otherwise
     *         &lt;code&gt;false&lt;/code&gt;
     */
    public boolean canDestroy() {
<span class="nc bnc" id="L203" title="All 2 branches missed.">        return !hasConsumers();</span>
    }

    /**
     * Destroy this cache.
     */
    public synchronized void destroy() {
        // clear the cache
<span class="nc" id="L211">        _cache.clear();</span>

        // remove the consumers
<span class="nc" id="L214">        _consumers.clear();</span>

        // remove the leases
        MessageLease[] leases;
<span class="nc" id="L218">        synchronized (_leases) {</span>
<span class="nc" id="L219">            leases = (MessageLease[]) _leases.values().toArray(</span>
                    new MessageLease[0]);
<span class="nc" id="L221">            _leases.clear();</span>
<span class="nc" id="L222">        }</span>

<span class="nc bnc" id="L224" title="All 2 branches missed.">        for (int i = 0; i &lt; leases.length; ++i) {</span>
<span class="nc" id="L225">            MessageLease lease = leases[i];</span>
<span class="nc" id="L226">            _leaseMgr.removeLease(lease);</span>
        }
<span class="nc" id="L228">    }</span>

    /**
     * Invoked when a message lease has expired.
     *
     * @param object an instance of {@link MessageRef}
     */
    public void onLeaseExpired(Object object) {
<span class="nc" id="L236">        MessageRef reference = (MessageRef) object;</span>
<span class="nc" id="L237">        String messageId = reference.getMessageId();</span>
<span class="nc" id="L238">        synchronized (_leases) {</span>
<span class="nc" id="L239">            _leases.remove(messageId);</span>
<span class="nc" id="L240">        }</span>

        // determine whether the message is persistent or not and take
        // the corresponding action
        try {
<span class="nc" id="L245">            _database.begin();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (reference.isPersistent()) {</span>
<span class="nc" id="L247">                persistentMessageExpired(reference);</span>
            } else {
<span class="nc" id="L249">                messageExpired(reference);</span>
            }
<span class="nc" id="L251">            reference.destroy();</span>
<span class="nc" id="L252">            _database.commit();</span>
<span class="nc" id="L253">        } catch (Exception exception) {</span>
<span class="nc" id="L254">            _log.error(&quot;Failed to expire message&quot;, exception);</span>
            try {
<span class="nc" id="L256">                _database.rollback();</span>
<span class="nc" id="L257">            } catch (PersistenceException error) {</span>
<span class="nc" id="L258">                _log.warn(&quot;Failed to rollback&quot;, error);</span>
<span class="nc" id="L259">            }</span>
<span class="nc" id="L260">        }</span>
<span class="nc" id="L261">    }</span>

    public void collectGarbage(boolean aggressive) {
<span class="nc bnc" id="L264" title="All 2 branches missed.">        if (aggressive) {</span>
            // clear all persistent messages in the cache
<span class="nc" id="L266">            _cache.clearPersistentMessages();</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">            if (_log.isDebugEnabled()) {</span>
<span class="nc" id="L268">                _log.debug(&quot;Evicted all persistent messages from cache &quot;</span>
<span class="nc" id="L269">                           + getDestination().getName());</span>
            }
        }

<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (_log.isDebugEnabled()) {</span>
<span class="nc" id="L274">            _log.debug(&quot;DESTCACHE -&quot; + getDestination().getName()</span>
<span class="nc" id="L275">                       + &quot; Messages: P[&quot; + _cache.getPersistentCount()</span>
<span class="nc" id="L276">                       + &quot;] T[&quot; + _cache.getTransientCount() + &quot;] Total: [&quot;</span>
<span class="nc" id="L277">                       + _cache.getMessageCount() + &quot;]&quot;);</span>
        }
<span class="nc" id="L279">    }</span>

    /**
     * Add a message reference and its corresponding message to the cache
     *
     * @param reference the reference to the message
     * @param message   the message
     */
    protected void addMessage(MessageRef reference, MessageImpl message) {
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (_log.isDebugEnabled()) {</span>
<span class="nc" id="L289">            _log.debug(&quot;addMessage(reference=[JMSMessageID=&quot;</span>
<span class="nc" id="L290">                    + reference.getMessageId() + &quot;])&quot;);</span>
        }
<span class="nc" id="L292">        _cache.addMessage(reference, message);</span>
<span class="nc" id="L293">    }</span>

    /**
     * Returns the message cache.
     *
     * @return the message cache
     */
    protected DefaultMessageCache getMessageCache() {
<span class="nc" id="L301">        return _cache;</span>
    }

    /**
     * Returns a consumer endpoint, given its id.
     *
     * @param consumerId the consumer identity
     * @return the consumer corresponding to &lt;code&gt;id&lt;/code&gt;, or
     *         &lt;code&gt;null&lt;/code&gt; if none is registered
     */
    protected ConsumerEndpoint getConsumerEndpoint(long consumerId) {
<span class="nc" id="L312">        return (ConsumerEndpoint) _consumers.get(new Long(consumerId));</span>
    }

    /**
     * Helper to return the consumers as an array.
     *
     * @return the consumers of this cache
     */
    protected ConsumerEndpoint[] getConsumerArray() {
<span class="nc" id="L321">        return (ConsumerEndpoint[]) _consumers.values().toArray(</span>
                new ConsumerEndpoint[0]);
    }

    /**
     * Remove an expired non-peristent message, and notify any listeners.
     *
     * @param reference the reference to the expired message
     * @throws JMSException for any error
     */
    protected void messageExpired(MessageRef reference)
            throws JMSException {
        // notify consumers
<span class="nc" id="L334">        String messageId = reference.getMessageId();</span>
<span class="nc" id="L335">        ConsumerEndpoint[] consumers = getConsumerArray();</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">        for (int i = 0; i &lt; consumers.length; ++i) {</span>
<span class="nc" id="L337">            consumers[i].messageRemoved(messageId);</span>
        }
<span class="nc" id="L339">    }</span>

    /**
     * Remove an expired persistent message, and notify any listeners.
     *
     * @param reference  the reference to the expired message
     * @throws JMSException         if a listener fails to handle the
     *                              expiration
     * @throws PersistenceException if there is a persistence related problem
     */
    protected void persistentMessageExpired(MessageRef reference)
            throws JMSException, PersistenceException {
        // notify consumers
<span class="nc" id="L352">        String messageId = reference.getMessageId();</span>
<span class="nc" id="L353">        ConsumerEndpoint[] consumers = getConsumerArray();</span>

<span class="nc bnc" id="L355" title="All 2 branches missed.">        for (int i = 0; i &lt; consumers.length; ++i) {</span>
<span class="nc" id="L356">            consumers[i].persistentMessageRemoved(messageId);</span>
        }
<span class="nc" id="L358">    }</span>

    /**
     * Check to see if the message has a TTL. If so then set up a lease for it.
     * An expiry time of 0 means that the message never expires
     *
     * @param reference a reference to the message
     * @param message   the message
     * @throws JMSException if the JMSExpiration property can't be accessed
     */
    protected void checkMessageExpiry(MessageRef reference,
                                      MessageImpl message) throws JMSException {
<span class="nc" id="L370">        checkMessageExpiry(reference, message.getJMSExpiration());</span>
<span class="nc" id="L371">    }</span>

    /**
     * Check to see if the message has a TTL. If so then set up a lease for it.
     * An expiry time of 0 means that the message never expires
     *
     * @param reference  a reference to the message
     * @param expiryTime the time when the message expires
     */
    protected void checkMessageExpiry(MessageRef reference,
                                      long expiryTime) {
<span class="nc bnc" id="L382" title="All 2 branches missed.">        if (expiryTime != 0) {</span>
<span class="nc" id="L383">            synchronized (_leases) {</span>
                // ensure that a lease for this message does not already exist.
<span class="nc bnc" id="L385" title="All 2 branches missed.">                if (!_leases.containsKey(reference.getMessageId())) {</span>
<span class="nc" id="L386">                    long duration = expiryTime - System.currentTimeMillis();</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">                    if (duration &lt;= 0) {</span>
<span class="nc" id="L388">                        duration = 1;</span>
                    }
<span class="nc" id="L390">                    MessageLease lease = new MessageLease(reference, duration,</span>
                                                          this);
<span class="nc" id="L392">                    _leaseMgr.addLease(lease);</span>
<span class="nc" id="L393">                    _leases.put(reference.getMessageId(), lease);</span>
                }
<span class="nc" id="L395">            }</span>
        }
<span class="nc" id="L397">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>