<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Destinations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">66_openjms</a> &gt; <a href="index.source.html" class="el_package">org.exolab.jms.persistence</a> &gt; <span class="el_source">Destinations.java</span></div><h1>Destinations.java</h1><pre class="source lang-java linenums">/**
 * Redistribution and use of this software and associated documentation
 * (&quot;Software&quot;), with or without modification, are permitted provided
 * that the following conditions are met:
 *
 * 1. Redistributions of source code must retain copyright
 *    statements and notices.  Redistributions must also contain a
 *    copy of this document.
 *
 * 2. Redistributions in binary form must reproduce the
 *    above copyright notice, this list of conditions and the
 *    following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 *
 * 3. The name &quot;Exolab&quot; must not be used to endorse or promote
 *    products derived from this Software without prior written
 *    permission of Exoffice Technologies.  For written permission,
 *    please contact info@exolab.org.
 *
 * 4. Products derived from this Software may not be called &quot;Exolab&quot;
 *    nor may &quot;Exolab&quot; appear in their names without prior written
 *    permission of Exoffice Technologies. Exolab is a registered
 *    trademark of Exoffice Technologies.
 *
 * 5. Due credit should be given to the Exolab Project
 *    (http://www.exolab.org/).
 *
 * THIS SOFTWARE IS PROVIDED BY EXOFFICE TECHNOLOGIES AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * EXOFFICE TECHNOLOGIES OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Copyright 2000-2005 (C) Exoffice Technologies Inc. All Rights Reserved.
 */
package org.exolab.jms.persistence;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Vector;

import org.exolab.jms.client.JmsDestination;
import org.exolab.jms.client.JmsQueue;
import org.exolab.jms.client.JmsTopic;


/**
 * This class provides persistency for JmsDestination objects in an RDBMS
 * database.
 *
 * @author &lt;a href=&quot;mailto:tma@netspace.net.au&quot;&gt;Tim Anderson&lt;/a&gt;
 * @version $Revision: 1.5 $ $Date: 2007/04/16 02:50:21 $
 */
class Destinations {

    /**
     * The seed generator.
     */
    private final SeedGenerator _seeds;

    /**
     * The consumer manager.
     */
    private final Consumers _consumers;

    /**
     * Cache of all destinations indexed on names.
     */
<span class="nc" id="L79">    private final HashMap _destinations = new HashMap();</span>

    /**
     * Cache of all destinations indexed on identity.
     */
<span class="nc" id="L84">    private final HashMap _ids = new HashMap();</span>

    /**
     * This is the name of the destination id generator, which uniquely created
     * identities for destinations.
     */
    private static final String DESTINATION_ID_SEED = &quot;destinationId&quot;;

    /**
     * Create a new &lt;code&gt;Destinations&lt;/code&gt;.
     *
     * @param seeds the seed manager
     * @param consumers the consumer manager
     * @param connection the connection to initialise from
     * @throws PersistenceException if initialisation fails
     */
    public Destinations(SeedGenerator seeds,
                        Consumers consumers,
<span class="nc" id="L102">                        Connection connection) throws PersistenceException {</span>
<span class="nc" id="L103">        _seeds = seeds;</span>
<span class="nc" id="L104">        _consumers = consumers;</span>
<span class="nc" id="L105">        load(connection);</span>
<span class="nc" id="L106">    }</span>

    /**
     * Add a new destination to the database. This method will also assign it a
     * unique identity.
     *
     * @param connection  the connection to use.
     * @param destination the destination to add
     * @throws PersistenceException if the destination cannot be added
     */
    public synchronized void add(Connection connection,
                                 JmsDestination destination)
            throws PersistenceException {

<span class="nc" id="L120">        PreparedStatement insert = null;</span>
        try {
<span class="nc" id="L122">            long Id = _seeds.next(connection, DESTINATION_ID_SEED);</span>
<span class="nc" id="L123">            boolean isQueue = (destination instanceof JmsQueue);</span>

<span class="nc" id="L125">            insert = connection.prepareStatement(</span>
                    &quot;insert into destinations (name, isQueue, destinationId) &quot;
                    + &quot;values (?, ?, ?)&quot;);
<span class="nc" id="L128">            insert.setString(1, destination.getName());</span>
<span class="nc" id="L129">            insert.setBoolean(2, isQueue);</span>
<span class="nc" id="L130">            insert.setLong(3, Id);</span>
<span class="nc" id="L131">            insert.executeUpdate();</span>
<span class="nc" id="L132">            cache(destination, Id);</span>
<span class="nc" id="L133">        } catch (Exception error) {</span>
<span class="nc" id="L134">            throw new PersistenceException(&quot;Destinations.add failed with &quot; +</span>
<span class="nc" id="L135">                                           error.toString());</span>
        } finally {
<span class="nc" id="L137">            SQLHelper.close(insert);</span>
        }
<span class="nc" id="L139">    }</span>

    /**
     * Remove a destination from the database. This removes all associated
     * consumers, and messages.
     *
     * @param connection  the connection to use
     * @param destination the destination
     * @return &lt;code&gt;true&lt;/cpde&gt; if it was removed
     * @throws PersistenceException if the request fails
     */
    public synchronized boolean remove(Connection connection,
                                       JmsDestination destination)
            throws PersistenceException {

<span class="nc" id="L154">        boolean success = false;</span>
<span class="nc" id="L155">        PreparedStatement deleteDestinations = null;</span>
<span class="nc" id="L156">        PreparedStatement deleteMessages = null;</span>
<span class="nc" id="L157">        PreparedStatement deleteConsumers = null;</span>
<span class="nc" id="L158">        PreparedStatement deleteMessageHandles = null;</span>

<span class="nc" id="L160">        Pair pair = (Pair) _destinations.get(destination.getName());</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (pair != null) {</span>
            try {
<span class="nc" id="L163">                deleteDestinations = connection.prepareStatement(</span>
                        &quot;delete from destinations where name=?&quot;);
<span class="nc" id="L165">                deleteDestinations.setString(1, destination.getName());</span>

<span class="nc" id="L167">                deleteMessages = connection.prepareStatement(</span>
                        &quot;delete from messages where destinationId=?&quot;);
<span class="nc" id="L169">                deleteMessages.setLong(1, pair.Id);</span>

<span class="nc" id="L171">                deleteMessageHandles = connection.prepareStatement(</span>
                        &quot;delete from message_handles where destinationId=?&quot;);
<span class="nc" id="L173">                deleteMessageHandles.setLong(1, pair.Id);</span>

<span class="nc" id="L175">                deleteConsumers = connection.prepareStatement(</span>
                        &quot;delete from consumers where destinationId=?&quot;);
<span class="nc" id="L177">                deleteConsumers.setLong(1, pair.Id);</span>


<span class="nc" id="L180">                deleteDestinations.executeUpdate();</span>
<span class="nc" id="L181">                deleteMessages.executeUpdate();</span>
<span class="nc" id="L182">                deleteMessageHandles.executeUpdate();</span>
<span class="nc" id="L183">                deleteConsumers.executeUpdate();</span>

<span class="nc" id="L185">                _consumers.removeCached(pair.Id);</span>
<span class="nc" id="L186">                _destinations.remove(destination.getName());</span>
<span class="nc" id="L187">                _ids.remove(new Long(pair.Id));</span>
<span class="nc" id="L188">                success = true;</span>
<span class="nc" id="L189">            } catch (Exception error) {</span>
<span class="nc" id="L190">                throw new PersistenceException(&quot;Failed to remove destination&quot;,</span>
                                               error);
            } finally {
<span class="nc" id="L193">                SQLHelper.close(deleteDestinations);</span>
<span class="nc" id="L194">                SQLHelper.close(deleteMessages);</span>
<span class="nc" id="L195">                SQLHelper.close(deleteConsumers);</span>
<span class="nc" id="L196">                SQLHelper.close(deleteMessageHandles);</span>
            }
        }

<span class="nc" id="L200">        return success;</span>
    }

    /**
     * Returns the destination associated with name.
     *
     * @param name the name of the destination
     * @return the destination, or null
     */
    public synchronized JmsDestination get(String name) {
<span class="nc" id="L210">        Pair pair = (Pair) _destinations.get(name);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        return (pair != null) ? pair.destination : null;</span>
    }

    /**
     * Returns the destination associated with Id.
     *
     * @param id the destination Id
     * @return the destination or null
     */
    public synchronized JmsDestination get(long id) {
<span class="nc" id="L221">        Pair pair = (Pair) _ids.get(new Long(id));</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        return (pair != null) ? pair.destination : null;</span>
    }

    /**
     * Returns the Id for a given destination name
     *
     * @param name the destination name
     * @return the destination Id, or 0 if it doesn't exist
     */
    public synchronized long getId(String name) {
<span class="nc" id="L232">        Pair pair = (Pair) _destinations.get(name);</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        return (pair != null) ? pair.Id : 0;</span>
    }

    /**
     * Returns the list of destination names.
     *
     * @return list of destination names
     */
    public synchronized Vector getNames() {
        // return a Vector for legacy reasons.
<span class="nc" id="L243">        Vector result = new Vector(_destinations.size());</span>
<span class="nc" id="L244">        Iterator iter = _destinations.keySet().iterator();</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L246">            result.add((String) iter.next());</span>
        }

<span class="nc" id="L249">        return result;</span>
    }

    /**
     * Returns the list of destination objects.
     *
     * @return list of destination objects
     */
    public synchronized Vector getDestinations() {
        // return a Vector for legacy reasons.
<span class="nc" id="L259">        Vector result = new Vector(_destinations.size());</span>
<span class="nc" id="L260">        Iterator iter = _destinations.values().iterator();</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L262">            result.add(((Pair) iter.next()).destination);</span>
        }

<span class="nc" id="L265">        return result;</span>
    }

    /**
     * Deallocates resources owned or referenced by the instance.
     */
    public synchronized void close() {
<span class="nc" id="L272">        _destinations.clear();</span>
<span class="nc" id="L273">        _ids.clear();</span>
<span class="nc" id="L274">    }</span>

    /**
     * Load all the destinations in memory. It uses the transaction service and
     * the database service to access the appropriate resources.
     *
     * @param connection the connection to use
     * @throws PersistenceException if the
     */
    private void load(Connection connection)
            throws PersistenceException {

<span class="nc" id="L286">        PreparedStatement select = null;</span>
<span class="nc" id="L287">        ResultSet set = null;</span>
        try {
<span class="nc" id="L289">            select = connection.prepareStatement(</span>
                    &quot;select name, isQueue, destinationId from destinations&quot;);

<span class="nc" id="L292">            set = select.executeQuery();</span>
<span class="nc" id="L293">            String name = null;</span>
<span class="nc" id="L294">            boolean isQueue = false;</span>
<span class="nc" id="L295">            JmsDestination destination = null;</span>
<span class="nc" id="L296">            long Id = 0;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">            while (set.next()) {</span>
<span class="nc" id="L298">                name = set.getString(1);</span>
<span class="nc" id="L299">                isQueue = set.getBoolean(2);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">                destination = (isQueue)</span>
                        ? (JmsDestination) new JmsQueue(name)
                        : (JmsDestination) new JmsTopic(name);
<span class="nc" id="L303">                Id = set.getLong(3);</span>
<span class="nc" id="L304">                destination.setPersistent(true);</span>
<span class="nc" id="L305">                cache(destination, Id);</span>
            }
<span class="nc" id="L307">        } catch (Exception exception) {</span>
<span class="nc" id="L308">            throw new PersistenceException(&quot;Failed to load destinations&quot;,</span>
                                           exception);
        } finally {
<span class="nc" id="L311">            SQLHelper.close(set);</span>
<span class="nc" id="L312">            SQLHelper.close(select);</span>
        }
<span class="nc" id="L314">    }</span>

    /**
     * Cache a destination.
     *
     * @param destination the destination to cache
     * @param Id          the destination identity
     */
    private void cache(JmsDestination destination, long Id) {
<span class="nc" id="L323">        Pair pair = new Pair(destination, Id);</span>

<span class="nc" id="L325">        _destinations.put(destination.getName(), pair);</span>
<span class="nc" id="L326">        _ids.put(new Long(Id), pair);</span>
<span class="nc" id="L327">    }</span>


    /**
     * This private static class holds the name and identity of the destination
     */
    private static class Pair {

<span class="nc" id="L335">        public Pair(JmsDestination destination, long Id) {</span>
<span class="nc" id="L336">            this.destination = destination;</span>
<span class="nc" id="L337">            this.Id = Id;</span>
<span class="nc" id="L338">        }</span>

        public JmsDestination destination;
        public long Id;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>