<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MessageFormatter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">43_lilith</a> &gt; <a href="index.source.html" class="el_package">de.huxhorn.lilith.data.logging</a> &gt; <span class="el_source">MessageFormatter.java</span></div><h1>MessageFormatter.java</h1><pre class="source lang-java linenums">/*
 * Lilith - a log event viewer.
 * Copyright (C) 2007-2009 Joern Huxhorn
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package de.huxhorn.lilith.data.logging;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * &lt;p&gt;Replacement for org.slf4j.helpers.MessageFormatter.&lt;/p&gt;
 * &lt;p&gt;
 * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message
 * is split into three parts:
 * &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;Counting of placeholders in the message pattern (cheap)&lt;/li&gt;
 * &lt;li&gt;Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as
 * an optional Throwable if available (relatively cheap)&lt;/li&gt;
 * &lt;li&gt;Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;p&gt;
 * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the
 * actual construction of the message, is only done on demand.
 * &lt;/p&gt;
 */
<span class="nc" id="L45">public class MessageFormatter</span>
{
	private static final char DELIM_START = '{';
	private static final char DELIM_STOP = '}';
	private static final char ESCAPE_CHAR = '\\';

	public static final String RECURSION_PREFIX = &quot;[...&quot;;
	public static final String RECURSION_SUFFIX = &quot;...]&quot;;

	public static final String ERROR_PREFIX = &quot;[!!!&quot;;
	public static final String ERROR_SEPARATOR = &quot;=&gt;&quot;;
	public static final String ERROR_MSG_SEPARATOR = &quot;:&quot;;
	public static final String ERROR_SUFFIX = &quot;!!!]&quot;;

	/**
	 * Replace placeholders in the given messagePattern with arguments.
	 *
	 * @param messagePattern the message pattern containing placeholders.
	 * @param arguments      the arguments to be used to replace placeholders.
	 * @return the formatted message.
	 */
	public static String format(String messagePattern, String[] arguments)
	{
<span class="nc bnc" id="L68" title="All 6 branches missed.">		if(messagePattern == null || arguments == null || arguments.length == 0)</span>
		{
<span class="nc" id="L70">			return messagePattern;</span>
		}

<span class="nc" id="L73">		StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L74">		int escapeCounter = 0;</span>
<span class="nc" id="L75">		int currentArgument = 0;</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">		for(int i = 0; i &lt; messagePattern.length(); i++)</span>
		{
<span class="nc" id="L78">			char curChar = messagePattern.charAt(i);</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">			if(curChar == ESCAPE_CHAR)</span>
			{
<span class="nc" id="L81">				escapeCounter++;</span>
			}
			else
			{
<span class="nc bnc" id="L85" title="All 2 branches missed.">				if(curChar == DELIM_START)</span>
				{
<span class="nc bnc" id="L87" title="All 2 branches missed.">					if(i &lt; messagePattern.length() - 1)</span>
					{
<span class="nc bnc" id="L89" title="All 2 branches missed.">						if(messagePattern.charAt(i + 1) == DELIM_STOP)</span>
						{
							// write escaped escape chars
<span class="nc" id="L92">							int escapedEscapes = escapeCounter / 2;</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">							for(int j = 0; j &lt; escapedEscapes; j++)</span>
							{
<span class="nc" id="L95">								result.append(ESCAPE_CHAR);</span>
							}

<span class="nc bnc" id="L98" title="All 2 branches missed.">							if(escapeCounter % 2 == 1)</span>
							{
								// i.e. escaped
								// write escaped escape chars
<span class="nc" id="L102">								result.append(DELIM_START);</span>
<span class="nc" id="L103">								result.append(DELIM_STOP);</span>
							}
							else
							{
								// unescaped
<span class="nc bnc" id="L108" title="All 2 branches missed.">								if(currentArgument &lt; arguments.length)</span>
								{
<span class="nc" id="L110">									result.append(arguments[currentArgument]);</span>
								}
								else
								{
<span class="nc" id="L114">									result.append(DELIM_START).append(DELIM_STOP);</span>
								}
<span class="nc" id="L116">								currentArgument++;</span>
							}
<span class="nc" id="L118">							i++;</span>
<span class="nc" id="L119">							escapeCounter = 0;</span>
<span class="nc" id="L120">							continue;</span>
						}
					}
				}
				// any other char beside ESCAPE or DELIM_START/STOP-combo
				// write unescaped escape chars
<span class="nc bnc" id="L126" title="All 2 branches missed.">				if(escapeCounter &gt; 0)</span>
				{
<span class="nc bnc" id="L128" title="All 2 branches missed.">					for(int j = 0; j &lt; escapeCounter; j++)</span>
					{
<span class="nc" id="L130">						result.append(ESCAPE_CHAR);</span>
					}
<span class="nc" id="L132">					escapeCounter = 0;</span>
				}
<span class="nc" id="L134">				result.append(curChar);</span>
			}
		}
<span class="nc" id="L137">		return result.toString();</span>
	}

	/**
	 * Counts the number of unescaped placeholders in the given messagePattern.
	 *
	 * @param messagePattern the message pattern to be analyzed.
	 * @return the number of unescaped placeholders.
	 */
	public static int countArgumentPlaceholders(String messagePattern)
	{
<span class="nc bnc" id="L148" title="All 2 branches missed.">		if(messagePattern == null)</span>
		{
<span class="nc" id="L150">			return 0;</span>
		}

<span class="nc" id="L153">		int delim = messagePattern.indexOf(DELIM_START);</span>

<span class="nc bnc" id="L155" title="All 2 branches missed.">		if(delim == -1)</span>
		{
			// special case, no placeholders at all.
<span class="nc" id="L158">			return 0;</span>
		}
<span class="nc" id="L160">		int result = 0;</span>
<span class="nc" id="L161">		boolean isEscaped = false;</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">		for(int i = 0; i &lt; messagePattern.length(); i++)</span>
		{
<span class="nc" id="L164">			char curChar = messagePattern.charAt(i);</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">			if(curChar == ESCAPE_CHAR)</span>
			{
<span class="nc bnc" id="L167" title="All 2 branches missed.">				isEscaped = !isEscaped;</span>
			}
<span class="nc bnc" id="L169" title="All 2 branches missed.">			else if(curChar == DELIM_START)</span>
			{
<span class="nc bnc" id="L171" title="All 2 branches missed.">				if(!isEscaped)</span>
				{
<span class="nc bnc" id="L173" title="All 2 branches missed.">					if(i &lt; messagePattern.length() - 1)</span>
					{
<span class="nc bnc" id="L175" title="All 2 branches missed.">						if(messagePattern.charAt(i + 1) == DELIM_STOP)</span>
						{
<span class="nc" id="L177">							result++;</span>
<span class="nc" id="L178">							i++;</span>
						}
					}
				}
<span class="nc" id="L182">				isEscaped = false;</span>
			}
			else
			{
<span class="nc" id="L186">				isEscaped = false;</span>
			}
		}
<span class="nc" id="L189">		return result;</span>
	}

	/**
	 * &lt;p&gt;This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String
	 * as well as an optional Throwable.&lt;/p&gt;
	 * &lt;p/&gt;
	 * &lt;p&gt;If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
	 * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].&lt;br/&gt;
	 * If it is used up getThrowable will return null even if the last argument was a Throwable!&lt;/p&gt;
	 *
	 * @param messagePattern the message pattern that to be checked for placeholders.
	 * @param arguments      the argument array to be converted.
	 * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.
	 */
	public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments)
	{
<span class="nc bnc" id="L206" title="All 2 branches missed.">		if(arguments == null)</span>
		{
<span class="nc" id="L208">			return null;</span>
		}
<span class="nc" id="L210">		int argsCount = countArgumentPlaceholders(messagePattern);</span>
<span class="nc" id="L211">		int resultArgCount = arguments.length;</span>
<span class="nc" id="L212">		Throwable throwable = null;</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">		if(argsCount &lt; arguments.length)</span>
		{
<span class="nc bnc" id="L215" title="All 2 branches missed.">			if(arguments[arguments.length - 1] instanceof Throwable)</span>
			{
<span class="nc" id="L217">				throwable = (Throwable) arguments[arguments.length - 1];</span>
<span class="nc" id="L218">				resultArgCount--;</span>
			}
		}

		String[] stringArgs;
<span class="nc bnc" id="L223" title="All 6 branches missed.">		if(argsCount == 1 &amp;&amp; throwable == null &amp;&amp; arguments.length &gt; 1)</span>
		{
			// special case
<span class="nc" id="L226">			stringArgs = new String[1];</span>
<span class="nc" id="L227">			stringArgs[0] = deepToString(arguments);</span>
		}
		else
		{
<span class="nc" id="L231">			stringArgs = new String[resultArgCount];</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">			for(int i = 0; i &lt; stringArgs.length; i++)</span>
			{
<span class="nc" id="L234">				stringArgs[i] = deepToString(arguments[i]);</span>
			}
		}
<span class="nc" id="L237">		return new ArgumentResult(stringArgs, throwable);</span>
	}

	public static String deepToString(Object o)
	{
<span class="nc bnc" id="L242" title="All 2 branches missed.">		if(o == null)</span>
		{
<span class="nc" id="L244">			return null;</span>
		}
<span class="nc bnc" id="L246" title="All 2 branches missed.">		if(o instanceof String)</span>
		{
<span class="nc" id="L248">			return (String) o;</span>
		}
<span class="nc" id="L250">		StringBuilder str = new StringBuilder();</span>
<span class="nc" id="L251">		Set&lt;String&gt; dejaVu = new HashSet&lt;String&gt;(); // that's actually a neat name ;)</span>
<span class="nc" id="L252">		recursiveDeepToString(o, str, dejaVu);</span>
<span class="nc" id="L253">		return str.toString();</span>
	}

	/**
	 * This method performs a deep toString of the given Object.
	 * Primitive arrays are converted using their respective Arrays.toString methods while
	 * special handling is implemented for &quot;container types&quot;, i.e. Object[], Map and Collection because those could
	 * contain themselves.
	 * &lt;p/&gt;
	 * dejaVu is used in case of those container types to prevent an endless recursion.
	 * &lt;p/&gt;
	 * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.
	 * They only check if the container is directly contained in itself, but not if a contained container contains the
	 * original one. Because of that, Arrays.toString(Object[]) isn't safe either.
	 * Confusing? Just read the last paragraph again and check the respective toString() implementation.
	 * &lt;p/&gt;
	 * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
	 * would produce a relatively hard-to-debug StackOverflowError.
	 *
	 * @param o      the Object to convert into a String
	 * @param str    the StringBuilder that o will be appended to
	 * @param dejaVu a list of container identities that were already used.
	 */
	private static void recursiveDeepToString(Object o, StringBuilder str, Set&lt;String&gt; dejaVu)
	{
<span class="nc bnc" id="L278" title="All 2 branches missed.">		if(o == null)</span>
		{
<span class="nc" id="L280">			str.append(&quot;null&quot;);</span>
<span class="nc" id="L281">			return;</span>
		}
<span class="nc bnc" id="L283" title="All 2 branches missed.">		if(o instanceof String)</span>
		{
<span class="nc" id="L285">			str.append(o);</span>
<span class="nc" id="L286">			return;</span>
		}

<span class="nc" id="L289">		Class oClass = o.getClass();</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">		if(oClass.isArray())</span>
		{
<span class="nc bnc" id="L292" title="All 2 branches missed.">			if(oClass == byte[].class)</span>
			{
<span class="nc" id="L294">				str.append(Arrays.toString((byte[]) o));</span>
			}
<span class="nc bnc" id="L296" title="All 2 branches missed.">			else if(oClass == short[].class)</span>
			{
<span class="nc" id="L298">				str.append(Arrays.toString((short[]) o));</span>
			}
<span class="nc bnc" id="L300" title="All 2 branches missed.">			else if(oClass == int[].class)</span>
			{
<span class="nc" id="L302">				str.append(Arrays.toString((int[]) o));</span>
			}
<span class="nc bnc" id="L304" title="All 2 branches missed.">			else if(oClass == long[].class)</span>
			{
<span class="nc" id="L306">				str.append(Arrays.toString((long[]) o));</span>
			}
<span class="nc bnc" id="L308" title="All 2 branches missed.">			else if(oClass == float[].class)</span>
			{
<span class="nc" id="L310">				str.append(Arrays.toString((float[]) o));</span>
			}
<span class="nc bnc" id="L312" title="All 2 branches missed.">			else if(oClass == double[].class)</span>
			{
<span class="nc" id="L314">				str.append(Arrays.toString((double[]) o));</span>
			}
<span class="nc bnc" id="L316" title="All 2 branches missed.">			else if(oClass == boolean[].class)</span>
			{
<span class="nc" id="L318">				str.append(Arrays.toString((boolean[]) o));</span>
			}
<span class="nc bnc" id="L320" title="All 2 branches missed.">			else if(oClass == char[].class)</span>
			{
<span class="nc" id="L322">				str.append(Arrays.toString((char[]) o));</span>
			}
			else
			{
				// special handling of container Object[]
<span class="nc" id="L327">				String id = identityToString(o);</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">				if(dejaVu.contains(id))</span>
				{
<span class="nc" id="L330">					str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);</span>
				}
				else
				{
<span class="nc" id="L334">					dejaVu.add(id);</span>
<span class="nc" id="L335">					Object[] oArray = (Object[]) o;</span>
<span class="nc" id="L336">					str.append(&quot;[&quot;);</span>
<span class="nc" id="L337">					boolean first = true;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">					for(Object current : oArray)</span>
					{
<span class="nc bnc" id="L340" title="All 2 branches missed.">						if(first)</span>
						{
<span class="nc" id="L342">							first = false;</span>
						}
						else
						{
<span class="nc" id="L346">							str.append(&quot;, &quot;);</span>
						}
<span class="nc" id="L348">						recursiveDeepToString(current, str, new HashSet&lt;String&gt;(dejaVu));</span>
					}
<span class="nc" id="L350">					str.append(&quot;]&quot;);</span>
				}
				//str.append(Arrays.deepToString((Object[]) o));
<span class="nc" id="L353">			}</span>
		}
<span class="nc bnc" id="L355" title="All 2 branches missed.">		else if(o instanceof Map)</span>
		{
			// special handling of container Map
<span class="nc" id="L358">			String id = identityToString(o);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">			if(dejaVu.contains(id))</span>
			{
<span class="nc" id="L361">				str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);</span>
			}
			else
			{
<span class="nc" id="L365">				dejaVu.add(id);</span>
<span class="nc" id="L366">				Map&lt;?, ?&gt; oMap = (Map&lt;?, ?&gt;) o;</span>
<span class="nc" id="L367">				str.append(&quot;{&quot;);</span>
<span class="nc" id="L368">				boolean isFirst = true;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">				for(Map.Entry&lt;?, ?&gt; current : oMap.entrySet())</span>
				{
<span class="nc bnc" id="L371" title="All 2 branches missed.">					if(isFirst)</span>
					{
<span class="nc" id="L373">						isFirst = false;</span>
					}
					else
					{
<span class="nc" id="L377">						str.append(&quot;, &quot;);</span>
					}
<span class="nc" id="L379">					Object key = current.getKey();</span>
<span class="nc" id="L380">					Object value = current.getValue();</span>
<span class="nc" id="L381">					recursiveDeepToString(key, str, new HashSet&lt;String&gt;(dejaVu));</span>
<span class="nc" id="L382">					str.append(&quot;=&quot;);</span>
<span class="nc" id="L383">					recursiveDeepToString(value, str, new HashSet&lt;String&gt;(dejaVu));</span>
<span class="nc" id="L384">				}</span>
<span class="nc" id="L385">				str.append(&quot;}&quot;);</span>
			}
<span class="nc" id="L387">		}</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">		else if(o instanceof Collection)</span>
		{
			// special handling of container Collection
<span class="nc" id="L391">			String id = identityToString(o);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">			if(dejaVu.contains(id))</span>
			{
<span class="nc" id="L394">				str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);</span>
			}
			else
			{
<span class="nc" id="L398">				dejaVu.add(id);</span>
<span class="nc" id="L399">				Collection&lt;?&gt; oCol = (Collection&lt;?&gt;) o;</span>
<span class="nc" id="L400">				str.append(&quot;[&quot;);</span>
<span class="nc" id="L401">				boolean isFirst = true;</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">				for(Object current : oCol)</span>
				{
<span class="nc bnc" id="L404" title="All 2 branches missed.">					if(isFirst)</span>
					{
<span class="nc" id="L406">						isFirst = false;</span>
					}
					else
					{
<span class="nc" id="L410">						str.append(&quot;, &quot;);</span>
					}
<span class="nc" id="L412">					recursiveDeepToString(current, str, new HashSet&lt;String&gt;(dejaVu));</span>
<span class="nc" id="L413">				}</span>
<span class="nc" id="L414">				str.append(&quot;]&quot;);</span>
			}
<span class="nc" id="L416">		}</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">		else if(o instanceof Date)</span>
		{
<span class="nc" id="L419">			Date date = (Date) o;</span>
<span class="nc" id="L420">			SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss.SSSZ&quot;);</span>
			// I'll leave it like this for the moment... this could probably be optimized using ThreadLocal...
<span class="nc" id="L422">			str.append(format.format(date));</span>
<span class="nc" id="L423">		}</span>
		else
		{
			// it's just some other Object, we can only use toString().
			try
			{
<span class="nc" id="L429">				str.append(o.toString());</span>
			}
<span class="nc" id="L431">			catch(Throwable t)</span>
			{
<span class="nc" id="L433">				str.append(ERROR_PREFIX);</span>
<span class="nc" id="L434">				str.append(identityToString(o));</span>
<span class="nc" id="L435">				str.append(ERROR_SEPARATOR);</span>
<span class="nc" id="L436">				String msg = t.getMessage();</span>
<span class="nc" id="L437">				String className = t.getClass().getName();</span>
<span class="nc" id="L438">				str.append(className);</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">				if(!className.equals(msg))</span>
				{
<span class="nc" id="L441">					str.append(ERROR_MSG_SEPARATOR);</span>
<span class="nc" id="L442">					str.append(msg);</span>
				}
<span class="nc" id="L444">				str.append(ERROR_SUFFIX);</span>
<span class="nc" id="L445">			}</span>
		}
<span class="nc" id="L447">	}</span>

	/**
	 * This method returns the same as if Object.toString() would not have been
	 * overridden in obj.
	 * &lt;p/&gt;
	 * Note that this isn't 100% secure as collisions can always happen with hash codes.
	 * &lt;p/&gt;
	 * Copied from Object.hashCode():
	 * As much as is reasonably practical, the hashCode method defined by
	 * class &lt;tt&gt;Object&lt;/tt&gt; does return distinct integers for distinct
	 * objects. (This is typically implemented by converting the internal
	 * address of the object into an integer, but this implementation
	 * technique is not required by the
	 * Java&lt;font size=&quot;-2&quot;&gt;&lt;sup&gt;TM&lt;/sup&gt;&lt;/font&gt; programming language.)
	 *
	 * @param obj the Object that is to be converted into an identity string.
	 * @return the identity string as also defined in Object.toString()
	 */
	public static String identityToString(Object obj)
	{
<span class="nc bnc" id="L468" title="All 2 branches missed.">		if(obj == null)</span>
		{
<span class="nc" id="L470">			return null;</span>
		}
<span class="nc" id="L472">		return obj.getClass().getName() + &quot;@&quot; + Integer.toHexString(System.identityHashCode(obj));</span>
	}

	/**
	 * &lt;p&gt;This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to
	 * return two results, i.e. the resulting String[] and the optional Throwable.&lt;/p&gt;
	 * &lt;p/&gt;
	 * &lt;p&gt;This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed
	 * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not
	 * available/different in the deserializing VM.&lt;/p&gt;
	 */
	public static class ArgumentResult
	{
		private Throwable throwable;
		private String[] arguments;

		public ArgumentResult(String[] arguments, Throwable throwable)
<span class="nc" id="L489">		{</span>
<span class="nc" id="L490">			this.throwable = throwable;</span>
<span class="nc" id="L491">			this.arguments = arguments;</span>
<span class="nc" id="L492">		}</span>

		public Throwable getThrowable()
		{
<span class="nc" id="L496">			return throwable;</span>
		}

		public String[] getArguments()
		{
<span class="nc" id="L501">			return arguments;</span>
		}

		@Override
		public String toString()
		{
<span class="nc" id="L507">			StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L508">			result.append(&quot;ArgumentResult[throwable=&quot;).append(throwable);</span>
<span class="nc" id="L509">			result.append(&quot;, arguments=&quot;);</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">			if(arguments != null)</span>
			{
<span class="nc" id="L512">				result.append(&quot;[&quot;);</span>
<span class="nc" id="L513">				boolean isFirst = true;</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">				for(String current : arguments)</span>
				{
<span class="nc bnc" id="L516" title="All 2 branches missed.">					if(!isFirst)</span>
					{
<span class="nc" id="L518">						result.append(&quot;, &quot;);</span>
					}
					else
					{
<span class="nc" id="L522">						isFirst = false;</span>
					}
<span class="nc bnc" id="L524" title="All 2 branches missed.">					if(current != null)</span>
					{
<span class="nc" id="L526">						result.append(&quot;'&quot;).append(current).append(&quot;'&quot;);</span>
					}
					else
					{
<span class="nc" id="L530">						result.append(&quot;null&quot;);</span>
					}
				}
<span class="nc" id="L533">				result.append(&quot;]&quot;);</span>
			}
<span class="nc" id="L535">			return result.toString();</span>
		}

		public boolean equals(Object o)
		{
<span class="nc bnc" id="L540" title="All 2 branches missed.">			if(this == o) return true;</span>
<span class="nc bnc" id="L541" title="All 4 branches missed.">			if(o == null || getClass() != o.getClass()) return false;</span>

<span class="nc" id="L543">			ArgumentResult result = (ArgumentResult) o;</span>

<span class="nc bnc" id="L545" title="All 2 branches missed.">			if(!Arrays.equals(arguments, result.arguments)) return false;</span>
<span class="nc bnc" id="L546" title="All 6 branches missed.">			if(throwable != null ? !throwable.equals(result.throwable) : result.throwable != null) return false;</span>

<span class="nc" id="L548">			return true;</span>
		}

		public int hashCode()
		{
			int result;
<span class="nc bnc" id="L554" title="All 2 branches missed.">			result = (throwable != null ? throwable.hashCode() : 0);</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">			result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);</span>
<span class="nc" id="L556">			return result;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>