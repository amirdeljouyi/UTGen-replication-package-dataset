<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AboutPanel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">43_lilith</a> &gt; <a href="index.source.html" class="el_package">de.huxhorn.lilith.swing</a> &gt; <span class="el_source">AboutPanel.java</span></div><h1>AboutPanel.java</h1><pre class="source lang-java linenums">/*
 * Lilith - a log event viewer.
 * Copyright (C) 2007-2009 Joern Huxhorn
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package de.huxhorn.lilith.swing;

import de.huxhorn.sulky.swing.GraphicsUtilities;
import de.huxhorn.sulky.swing.filters.ColorTintFilter;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

import javax.swing.*;
import javax.swing.event.MouseInputAdapter;

// TODO: get/setMouseHandling/MouseInputMode
// TODO: setVersionHeight(versionHeight);
// TODO: setVersionString(versionString);
// TODO: correct versionHeight if string would be outside background.
// TODO: VersionString centered to bg/scroll.
// TODO: relative ScrollAreas (values given as % of backgroundImage)
// TODO: Handle errors in Image-Loading
// TODO: offscreenImage h�chstens so gro� wie die size / nicht gesamten bg malen
// TODO: paint background-color for rest of component (not only behind bg-image)
// TODO: scroll-area defined by object-array containing icons and strings...
// TODO: transient attributes
// TODO: serialVersion

// TODO: use ResourceSupport
/**
 * &lt;code&gt;AboutPanel&lt;/code&gt; is a component which has a background-image and a
 * rectangle in which a given text is scrolling (the scroll-area). You may also
 * specify an Image (e.g. a png-file with alpha-channel) that is drawn before
 * the scroll-text itself. An optional version-string may be given that will be
 * painted centered relative to the scroll-area.
 *
 * @author Joern Huxhorn
 */
public class AboutPanel
	extends JComponent
{
<span class="nc" id="L73">	private final Logger logger = LoggerFactory.getLogger(AboutPanel.class);</span>

	public static final String BACKGROUND_IMAGE_RESOURCE = &quot;background.png&quot;;
	public static final String ABOUT_IMAGE_RESOURCE = &quot;about.png&quot;;

	public static final String TEXT_RESOURCE_PREFIX = &quot;about.&quot;;

	public static final String SCROLL_TEXT_RESOURCE =
		TEXT_RESOURCE_PREFIX + &quot;scroll.text&quot;;
	public static final String VERSION_TEXT_RESOURCE =
		TEXT_RESOURCE_PREFIX + &quot;version.text&quot;;
	public static final String VERSION_HEIGHT_RESOURCE =
		TEXT_RESOURCE_PREFIX + &quot;version.height&quot;;
	public static final String SCROLL_AREA_RESOURCE_BASE =
		TEXT_RESOURCE_PREFIX + &quot;scroll.area.&quot;;
	public static final String SCROLL_AREA_X_RESOURCE =
		SCROLL_AREA_RESOURCE_BASE + &quot;x&quot;;
	public static final String SCROLL_AREA_Y_RESOURCE =
		SCROLL_AREA_RESOURCE_BASE + &quot;y&quot;;
	public static final String SCROLL_AREA_WIDTH_RESOURCE =
		SCROLL_AREA_RESOURCE_BASE + &quot;width&quot;;
	public static final String SCROLL_AREA_HEIGHT_RESOURCE =
		SCROLL_AREA_RESOURCE_BASE + &quot;height&quot;;
	public static final String SCROLL_AREA_TOOLTIP_TEXT_RESOURCE =
		SCROLL_AREA_RESOURCE_BASE + &quot;tooltip.text&quot;;


	public static final String TEXT_RESOURCE_BUNDLE_RESOURCE = &quot;TextResources&quot;;

	public static final int MOUSE_DISABLED = 0;
	public static final int MOUSE_COMPONENT = 1;
	public static final int MOUSE_SCROLLAREA = 2;
	public static final int MOUSE_BACKGROUND = 3;

	//private static final int SCROLL_SLEEP_TIME = 50;
	private static final int SCROLL_PIXELS = 1;
	//private static final int SCROLL_THREAD_PRIORITY = Thread.NORM_PRIORITY+1;

	//private final ResourceSupport resourceSupport;

	private BufferedImage backgroundImage;
	private BufferedImage aboutImage;
	//private ImageIcon backgroundImageIcon;
	//private ImageIcon aboutImageIcon;
	private FontMetrics fontMetrics;

	private Insets insets;
	private Dimension size;
	private Dimension preferredSize;
	private Point offscreenOffset;
	private String[] scrollLines;
	private String versionText;
	private String scrollAreaToolTipText;
	private int versionHeight;
	private int scrollPosition;
	private int maxScrollPosition;
	private int minScrollPosition;
	private Rectangle maxScrollArea;
	private Rectangle backgroundImageArea;
	private Rectangle translatedBackgroundImageArea;
	private Rectangle translatedScrollArea;
	private Rectangle scrollArea;
	private Rectangle paintArea;
	private BufferedImage offscreenImage;
	private BufferedImage scrollImage;
	private boolean scrolling;
	//private boolean offscreenInitialized = false;
	//private boolean scrollInitialized = false;
	//private boolean painted;
<span class="nc" id="L142">	private int mouseEventHandling = MOUSE_BACKGROUND;</span>
	//private transient Thread scrollThread;
	private boolean debug;
	private Timer timer;
	//private String scrollText;
	//private Map textBundleMap;
	//private int mouseEventHandling=MOUSE_DISABLED;

	/**
	 * Creates a new &lt;code&gt;AboutPanel&lt;/code&gt; initialized with the given parameters.
	 *
	 * @param backgroundImageUrl The URL to the Background-Image of the
	 *                           AboutPanel. This parameter is mandatory.
	 * @param scrollArea         The Rectangle inside the background-image where
	 *                           scrolling should take place. This parameter is optional. If it's null
	 *                           then the scroll-area is set to (0, 0, background.width,
	 *                           background.height).
	 */
	public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText)
		throws IOException
	{
<span class="nc" id="L163">		this(backgroundImageUrl, scrollArea, scrollText, null, null, -1);</span>
<span class="nc" id="L164">	}</span>

	public boolean isDebug()
	{
<span class="nc" id="L168">		return debug;</span>
	}

	public void setDebug(boolean debug)
	{
<span class="nc" id="L173">		this.debug = debug;</span>
<span class="nc" id="L174">	}</span>

	/**
	 * Creates a new &lt;code&gt;AboutPanel&lt;/code&gt; initialized with the given parameters.
	 *
	 * @param backgroundImageUrl The URL to the Background-Image of the
	 *                           AboutPanel. This parameter is mandatory.
	 * @param scrollArea         The Rectangle inside the background-image where
	 *                           scrolling should take place. This parameter is optional. If it's null
	 *                           then the scroll-area is set to (0, 0, background.width,
	 *                           background.height).
	 * @param versionText        The String describing the version of the program.
	 *                           It is painted centered to the scroll-rectangle at the specified height.
	 *                           This parameter is optional.
	 * @param versionHeight      The height at which the version-string is
	 *                           supposed to be painted. This parameter is optional but should be given
	 *                           a correct value if versionText!=null..
	 */
	public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, String versionText, int versionHeight)
		throws IOException
	{
<span class="nc" id="L195">		this(backgroundImageUrl, scrollArea, scrollText, null, versionText, versionHeight);</span>
<span class="nc" id="L196">	}</span>


	/**
	 * Creates a new &lt;code&gt;AboutPanel&lt;/code&gt; initialized with the given parameters.
	 *
	 * @param backgroundImageUrl The URL to the Background-Image of the
	 *                           AboutPanel. This parameter is mandatory.
	 * @param scrollArea         The Rectangle inside the background-image where
	 *                           scrolling should take place. This parameter is optional. If it's null
	 *                           then the scroll-area is set to (0, 0, background.width,
	 *                           background.height).
	 * @param imageUrl           The URL to the Image that will be painted at the
	 *                           start of the scroll-area. This parameter is optional.
	 * @param versionText        The String describing the version of the program.
	 *                           It is painted centered to the scroll-rectangle at the specified height.
	 *                           This parameter is optional.
	 * @param versionHeight      The height at which the version-string is
	 *                           supposed to be painted. This parameter is optional but should be given
	 *                           a correct value if versionText!=null..
	 */
	public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, URL imageUrl, String versionText, int versionHeight)
		throws IOException
	{
<span class="nc" id="L220">		this();</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">		if(backgroundImageUrl == null)</span>
		{
<span class="nc" id="L223">			throw new NullPointerException(&quot;backgroundImageUrl must not be null!&quot;);</span>
		}
<span class="nc bnc" id="L225" title="All 2 branches missed.">		if(scrollText == null)</span>
		{
<span class="nc" id="L227">			throw new NullPointerException(&quot;scrollText must not be null!&quot;);</span>
		}
<span class="nc" id="L229">		init(backgroundImageUrl, scrollArea, scrollText, imageUrl, versionText, versionHeight);</span>
<span class="nc" id="L230">	}</span>

	public AboutPanel()
<span class="nc" id="L233">	{</span>
<span class="nc" id="L234">		ActionListener timerListener = new TimerActionListener();</span>
<span class="nc" id="L235">		timer = new Timer(10, timerListener);</span>
		//this.resourceSupport=new ResourceSupport(this);
<span class="nc" id="L237">		initAttributes();</span>

<span class="nc" id="L239">		addPropertyChangeListener(new AboutPropertyChangeListener());</span>
<span class="nc" id="L240">		addComponentListener(new AboutComponentListener());</span>

<span class="nc" id="L242">		setFont(null);// initializes to Label.font</span>
<span class="nc" id="L243">		AboutMouseInputListener mouseInputListener = new AboutMouseInputListener();</span>
<span class="nc" id="L244">		addMouseListener(mouseInputListener);</span>
<span class="nc" id="L245">		addMouseMotionListener(mouseInputListener);</span>

		//this.scrollThread=null;

<span class="nc" id="L249">		setScrolling(false);</span>
//		initResources();
<span class="nc" id="L251">	}</span>


//	protected void initResources()
//	{
//		initTextBundleMap();
//
//		//URL backgroundImageUrl=resourceSupport.getResource(BACKGROUND_IMAGE_RESOURCE);
//		//URL imageUrl=resourceSupport.getResource(ABOUT_IMAGE_RESOURCE);
//		//scrollText=getTextResource(SCROLL_TEXT_RESOURCE, null);
//		versionText=getTextResource(VERSION_TEXT_RESOURCE, null);
//		int versionHeight=-1;
//		try
//		{
//			versionHeight=Integer.parseInt(getTextResource(VERSION_HEIGHT_RESOURCE, &quot;-1&quot;));
//		}
//		catch(NumberFormatException ex)
//		{
//			if(logger.isWarnEnabled()) logger.warn(&quot;Illegal integer value!&quot;, ex);
//		}
//
//		Rectangle scrollArea=new Rectangle(-1, -1, -1, -1);
//		try
//		{
//			scrollArea.x=Integer.parseInt(getTextResource(SCROLL_AREA_X_RESOURCE, &quot;-1&quot;));
//		}
//		catch(NumberFormatException ex)
//		{
//			if(logger.isWarnEnabled()) logger.warn(&quot;Illegal integer value!&quot;, ex);
//		}
//		try
//		{
//			scrollArea.y=Integer.parseInt(getTextResource(SCROLL_AREA_Y_RESOURCE, &quot;-1&quot;));
//		}
//		catch(NumberFormatException ex)
//		{
//			if(logger.isWarnEnabled()) logger.warn(&quot;Illegal integer value!&quot;, ex);
//		}
//		try
//		{
//			scrollArea.width=Integer.parseInt(getTextResource(SCROLL_AREA_WIDTH_RESOURCE, &quot;-1&quot;));
//		}
//		catch(NumberFormatException ex)
//		{
//			if(logger.isWarnEnabled()) logger.warn(&quot;Illegal integer value!&quot;, ex);
//		}
//		try
//		{
//			scrollArea.height=Integer.parseInt(getTextResource(SCROLL_AREA_HEIGHT_RESOURCE, &quot;-1&quot;));
//		}
//		catch(NumberFormatException ex)
//		{
//			if(logger.isWarnEnabled()) logger.warn(&quot;Illegal integer value!&quot;, ex);
//		}
//		if(	scrollArea.x == -1 ||
//			scrollArea.y == -1 ||
//			scrollArea.width == -1 ||
//			scrollArea.height == -1 )
//		{
//			// ignore if scroll-area isn't fully specified
//			scrollArea = null;
//		}
//		init(backgroundImageUrl, scrollArea, scrollText, imageUrl, versionText, versionHeight );
//		//setScrollAreaToolTipText(getTextResource(SCROLL_AREA_TOOLTIP_TEXT_RESOURCE, null));
//	}

//	protected void initTextBundleMap()
//	{
//		textBundleMap=resourceSupport.getResourceMap(TEXT_RESOURCE_BUNDLE_RESOURCE, getLocale());
//		if(logger.isDebugEnabled() &amp;&amp; textBundleMap!=null)
//		{
//			StringBuffer buffer=new StringBuffer();
//
//			Iterator iter=textBundleMap.keySet().iterator();
//			while(iter.hasNext())
//			{
//				Object key=iter.next();
//				Object value=textBundleMap.get(key);
//				buffer.append(&quot;Key: &quot;);
//				buffer.append(key);
//				buffer.append(&quot;    Value: &quot;);
//				buffer.append(value);
//				buffer.append(&quot;\n&quot;);
//
//			}
//			logger.debug(&quot;BundleMap \&quot;&quot;+TEXT_RESOURCE_BUNDLE_RESOURCE+&quot;\&quot; of class &quot;+getClass().getName()+&quot;:\n&quot;+buffer.toString());
//		}
//		if(logger.isInfoEnabled() &amp;&amp; textBundleMap==null)
//		{
//			logger.info(&quot;Couldn't find BundleMap \&quot;&quot;+TEXT_RESOURCE_BUNDLE_RESOURCE+&quot;\&quot; of class &quot;+getClass().getName()+&quot;.&quot;);
//		}
//	}

//	protected String getTextResource(final String resourceName, final String defaultValue)
//	{
//		String result=null;
//		if(textBundleMap!=null)
//		{
//			result=(String)textBundleMap.get(resourceName);
//		}
//		if(result==null)
//		{
//			result=defaultValue;
//			if(logger.isDebugEnabled()) logger.debug(&quot;Using default-value '&quot;+defaultValue+&quot;' for text-resource '&quot;+resourceName+&quot;'.&quot;);
//		}
//
//		return result;
//	}

	private void init(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, URL imageUrl, String versionText, int versionHeight)
		throws IOException
	{
<span class="nc bnc" id="L363" title="All 2 branches missed.">		if(logger.isDebugEnabled())</span>
		{
<span class="nc" id="L365">			logger.debug(&quot;init called with following arguments: backgroundImageUrl=&quot; + backgroundImageUrl + &quot;, &quot; +</span>
				&quot;scrollArea=&quot; + scrollArea + &quot;, scrollText=&quot; + scrollText + &quot;, imageUrl=&quot; + imageUrl + &quot;, versionText=&quot; + versionText + &quot;, versionHeight=&quot; + versionHeight);
		}
<span class="nc" id="L368">		setBackgroundImage(backgroundImageUrl);</span>
<span class="nc" id="L369">		setScrollArea(scrollArea);</span>
<span class="nc" id="L370">		setAboutImage(imageUrl);</span>
<span class="nc" id="L371">		this.versionText = versionText;</span>
<span class="nc" id="L372">		this.versionHeight = versionHeight;</span>
<span class="nc" id="L373">		setScrollText(scrollText);</span>
<span class="nc" id="L374">	}</span>

	/*
	protected synchronized boolean isPainted()
	{
		return painted;
	}

	protected synchronized void setPainted(boolean painted)
	{
		if(this.painted!=painted)
		{
			this.painted=painted;
			notifyAll();
		}
	}
    */

	private void initAttributes()
	{
		//setPainted(true);
<span class="nc" id="L395">		preferredSize = new Dimension();</span>
<span class="nc" id="L396">		offscreenOffset = new Point();</span>
<span class="nc" id="L397">		backgroundImageArea = new Rectangle();</span>
<span class="nc" id="L398">		translatedScrollArea = new Rectangle();</span>
<span class="nc" id="L399">		translatedBackgroundImageArea = new Rectangle();</span>
<span class="nc" id="L400">		scrollArea = new Rectangle();</span>
<span class="nc" id="L401">		paintArea = new Rectangle();</span>
<span class="nc" id="L402">		insets = getInsets();</span>
<span class="nc" id="L403">	}</span>


	public void setScrollText(String ScrollText)
	{
<span class="nc" id="L408">		StringTokenizer st = new StringTokenizer(ScrollText, &quot;\n&quot;, true);</span>

<span class="nc" id="L410">		List&lt;String&gt; lines = new ArrayList&lt;String&gt;(st.countTokens() / 2);</span>
<span class="nc" id="L411">		String prevToken = null;</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">		while(st.hasMoreTokens())</span>
		{
<span class="nc" id="L414">			String token = st.nextToken();</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">			if(token.equals(&quot;\n&quot;))</span>
			{
<span class="nc bnc" id="L417" title="All 4 branches missed.">				if(prevToken != null &amp;&amp; !prevToken.equals(&quot;\n&quot;))</span>
				{
<span class="nc" id="L419">					lines.add(prevToken);</span>
				}
				else
				{
<span class="nc" id="L423">					lines.add(&quot;&quot;);</span>
				}
			}
<span class="nc" id="L426">			prevToken = token;</span>
<span class="nc" id="L427">		}</span>
<span class="nc bnc" id="L428" title="All 4 branches missed.">		if(prevToken != null &amp;&amp; !prevToken.equals(&quot;\n&quot;))</span>
		{
<span class="nc" id="L430">			lines.add(prevToken);</span>
		}

<span class="nc" id="L433">		String loScrollLines[] = new String[lines.size()];</span>
<span class="nc" id="L434">		loScrollLines = lines.toArray(loScrollLines);</span>
<span class="nc" id="L435">		setScrollLines(loScrollLines);</span>
<span class="nc" id="L436">	}</span>

	protected void setScrollLines(String[] scrollLines)
	{
<span class="nc bnc" id="L440" title="All 2 branches missed.">		if(scrollLines == null)</span>
		{
<span class="nc" id="L442">			NullPointerException ex = new NullPointerException(&quot;scrollLines must not be null!&quot;);</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">			if(logger.isDebugEnabled())</span>
			{
<span class="nc" id="L445">				logger.debug(&quot;Parameter 'scrollLines' of method 'setScrollLines' must not be null!&quot;, ex);</span>
			}
<span class="nc" id="L447">			throw ex;</span>
		}

<span class="nc" id="L450">		this.scrollLines = scrollLines.clone();</span>
<span class="nc" id="L451">		flushScrollImage();</span>
<span class="nc" id="L452">	}</span>

	/**
	 * Sets the backgroundImage attribute of the &lt;code&gt;AboutPanel&lt;/code&gt; object
	 */
	public void setBackgroundImage(URL imageUrl)
		throws IOException
	{
<span class="nc" id="L460">		setBackgroundImage(GraphicsUtilities.loadCompatibleImage(imageUrl));</span>
<span class="nc" id="L461">	}</span>


	/**
	 * Sets the backgroundImage attribute of the &lt;code&gt;AboutPanel&lt;/code&gt; object
	 *
	 * @param BackgroundImage The new backgroundImage value
	 */
	public void setBackgroundImage(BufferedImage BackgroundImage)
	{
<span class="nc bnc" id="L471" title="All 2 branches missed.">		if(backgroundImage != null)</span>
		{
<span class="nc" id="L473">			backgroundImage.flush();</span>
<span class="nc" id="L474">			backgroundImage = null;</span>
		}
<span class="nc" id="L476">		backgroundImage = BackgroundImage;</span>
<span class="nc" id="L477">		updateBackgroundAttributes();</span>
<span class="nc" id="L478">	}</span>


	public void setAboutImage(URL imageUrl)
		throws IOException
	{
<span class="nc" id="L484">		setAboutImage(GraphicsUtilities.loadCompatibleImage(imageUrl));</span>
<span class="nc" id="L485">	}</span>


	public void setAboutImage(BufferedImage AboutImage)
	{
<span class="nc bnc" id="L490" title="All 2 branches missed.">		if(aboutImage != null)</span>
		{
<span class="nc" id="L492">			aboutImage.flush();</span>
<span class="nc" id="L493">			aboutImage = null;</span>
		}
<span class="nc" id="L495">		aboutImage = AboutImage;</span>
<span class="nc" id="L496">		flushScrollImage();</span>
<span class="nc" id="L497">	}</span>

	/**
	 * Sets the scrollArea attribute of the &lt;code&gt;AboutPanel&lt;/code&gt; object
	 *
	 * @param ScrollArea The new scrollArea value
	 */
	public void setScrollArea(Rectangle ScrollArea)
	{
<span class="nc bnc" id="L506" title="All 2 branches missed.">		if(ScrollArea != null)</span>
		{
<span class="nc" id="L508">			maxScrollArea = backgroundImageArea.intersection(ScrollArea);</span>
		}
		else
		{
<span class="nc" id="L512">			maxScrollArea = (Rectangle) backgroundImageArea.clone();</span>
		}
<span class="nc" id="L514">		minScrollPosition = -maxScrollArea.height;</span>
<span class="nc" id="L515">		calculateAttributes();</span>
<span class="nc" id="L516">		flushScrollImage();</span>
<span class="nc" id="L517">	}</span>


	/**
	 * Description of the Method
	 */
	private void flushScrollImage()
	{
<span class="nc bnc" id="L525" title="All 2 branches missed.">		if(scrollImage != null)</span>
		{
<span class="nc bnc" id="L527" title="All 2 branches missed.">			if(logger.isInfoEnabled()) logger.info(&quot;Flushing ScrollImage&quot;);</span>
<span class="nc" id="L528">			scrollImage.flush();</span>
<span class="nc" id="L529">			scrollImage = null;</span>
		}
<span class="nc" id="L531">		setScrollPosition(minScrollPosition);</span>
<span class="nc" id="L532">	}</span>


	/**
	 * Description of the Method
	 */
	private void flushOffscreenImage()
	{
<span class="nc bnc" id="L540" title="All 2 branches missed.">		if(offscreenImage != null)</span>
		{
<span class="nc bnc" id="L542" title="All 2 branches missed.">			if(logger.isInfoEnabled()) logger.info(&quot;Flushing OffscreenImage&quot;);</span>
<span class="nc" id="L543">			offscreenImage.flush();</span>
<span class="nc" id="L544">			offscreenImage = null;</span>
		}
<span class="nc" id="L546">	}</span>


	/**
	 * Description of the Method
	 */
	private void updateBackgroundAttributes()
	{
<span class="nc" id="L554">		backgroundImageArea.x = 0;</span>
<span class="nc" id="L555">		backgroundImageArea.y = 0;</span>
<span class="nc" id="L556">		backgroundImageArea.width = backgroundImage.getWidth();</span>
<span class="nc" id="L557">		backgroundImageArea.height = backgroundImage.getHeight();</span>

<span class="nc" id="L559">		calculatePreferredSize();</span>

<span class="nc bnc" id="L561" title="All 2 branches missed.">		if(maxScrollArea != null)</span>
		{
<span class="nc" id="L563">			maxScrollArea = maxScrollArea.intersection(backgroundImageArea);</span>
		}
		else
		{
<span class="nc" id="L567">			maxScrollArea = (Rectangle) backgroundImageArea.clone();</span>
		}
<span class="nc" id="L569">		flushOffscreenImage();</span>
<span class="nc" id="L570">		flushScrollImage();</span>
<span class="nc" id="L571">		repaint();</span>
<span class="nc" id="L572">	}</span>


	/**
	 * Sets the ToolTipText that will appear if the user moves the mouse over the
	 * scroll-area of this component.
	 *
	 * @param toolTipText The new ScrollAreaToolTipText value
	 */
	public void setScrollAreaToolTipText(String toolTipText)
	{
<span class="nc" id="L583">		scrollAreaToolTipText = toolTipText;</span>
<span class="nc" id="L584">	}</span>


	/**
	 * Gets the ScrollAreaToolTipText attribute of the &lt;code&gt;AboutPanel&lt;/code&gt;
	 * object
	 *
	 * @return The ScrollAreaToolTipText value
	 */
	public String getScrollAreaToolTipText()
	{
<span class="nc" id="L595">		return scrollAreaToolTipText;</span>
	}


	/**
	 * This method returns ScrollAreaToolTipText if the point of the &lt;code&gt;MouseEvent&lt;/code&gt;
	 * is inside the scroll-area and &lt;code&gt;null&lt;/code&gt; otherwise.&lt;p /&gt;
	 * &lt;p/&gt;
	 * It's needed by the &lt;code&gt;ToolTipManager&lt;/code&gt; .
	 *
	 * @param evt a &lt;code&gt;MouseEvent&lt;/code&gt;.
	 * @return The toolTipText value for the &lt;code&gt;ToolTipManager&lt;/code&gt;.
	 */
	public String getToolTipText(MouseEvent evt)
	{
<span class="nc bnc" id="L610" title="All 2 branches missed.">		if(handleMouseEvent(evt))</span>
		{
<span class="nc" id="L612">			return scrollAreaToolTipText;</span>
		}
<span class="nc" id="L614">		return null;</span>
	}

	protected boolean handleMouseEvent(MouseEvent evt)
	{
<span class="nc" id="L619">		Rectangle loArea = null;</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">		if(mouseEventHandling == MOUSE_BACKGROUND)</span>
		{
<span class="nc" id="L622">			loArea = translatedBackgroundImageArea;</span>
		}
<span class="nc bnc" id="L624" title="All 2 branches missed.">		else if(mouseEventHandling == MOUSE_SCROLLAREA)</span>
		{
<span class="nc" id="L626">			loArea = translatedScrollArea;</span>
		}
<span class="nc bnc" id="L628" title="All 2 branches missed.">		else if(mouseEventHandling == MOUSE_DISABLED)</span>
		{
<span class="nc" id="L630">			return false;</span>
		}
<span class="nc" id="L632">		Point loPoint = evt.getPoint();</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">		if(loArea == null)</span>
		{	// -&gt; default: MOUSE_COMPONENT
<span class="nc" id="L635">			return contains(loPoint);</span>
		}
<span class="nc bnc" id="L637" title="All 2 branches missed.">		if(loArea.contains(loPoint))</span>
		{	// MOUSE_BACKGROUND / MOUSE_SCROLLAREA
<span class="nc" id="L639">			return true;</span>
		}
<span class="nc" id="L641">		return false;</span>
	}


	/**
	 * Increases the ScrollPosition by SCROLL_PIXELS. This method is called by the
	 * scroll-thread and calls &lt;code&gt;setScrollPosition&lt;/code&gt;, therefore causing a
	 * repaint of the scroll-area..
	 *
	 * @see #setScrollPosition
	 */
	protected void increaseScrollPosition()
	{
<span class="nc" id="L654">		setScrollPosition(scrollPosition + SCROLL_PIXELS);</span>
<span class="nc" id="L655">	}</span>


	/**
	 * Sets the scrollPosition attribute of the &lt;code&gt;AboutPanel&lt;/code&gt; object. The
	 * value will be corrected according Minimum- and MaximumScrollPosition.
	 * Changing the scroll-position will result in a repaint of the scroll-area.
	 *
	 * @param scrollPosition The new scrollPosition value. This value indicates
	 *                       the height-offset of the scroll-area.
	 * @see #getMinimumScrollPosition
	 * @see #getMaximumScrollPosition
	 */
	public void setScrollPosition(int scrollPosition)
	{
<span class="nc bnc" id="L670" title="All 2 branches missed.">		if(scrollPosition &gt; maxScrollPosition)</span>
		{
<span class="nc" id="L672">			int remainder = scrollPosition % maxScrollPosition;</span>

<span class="nc" id="L674">			scrollPosition = minScrollPosition + remainder;</span>
<span class="nc" id="L675">		}</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">		else if(scrollPosition &lt; minScrollPosition)</span>
		{
<span class="nc" id="L678">			int remainder = scrollPosition % minScrollPosition;</span>

<span class="nc" id="L680">			scrollPosition = maxScrollPosition + remainder;</span>
		}
<span class="nc bnc" id="L682" title="All 2 branches missed.">		if(this.scrollPosition != scrollPosition)</span>
		{
<span class="nc" id="L684">			this.scrollPosition = scrollPosition;</span>
<span class="nc" id="L685">			repaintScrollArea();</span>
		}
<span class="nc" id="L687">	}</span>


	/**
	 * Gets the ScrollPosition attribute of the &lt;code&gt;AboutPanel&lt;/code&gt; object
	 *
	 * @return this value indicates the height-offset of the scroll-area.
	 */
	public int getScrollPosition()
	{
<span class="nc" id="L697">		return scrollPosition;</span>
	}


	/**
	 * Gets the MinimumScrollPosition attribute of the &lt;code&gt;AboutPanel&lt;/code&gt;
	 * object. It's value is the negated value of the scroll-area-height.
	 *
	 * @return The MinimumScrollPosition value
	 */
	public int getMinimumScrollPosition()
	{
<span class="nc" id="L709">		return minScrollPosition;</span>
	}


	/**
	 * Gets the MaximumScrollPosition attribute of the &lt;code&gt;AboutPanel&lt;/code&gt;
	 * object. It's value is the height needed for all lines of text plus (if
	 * available) the height of the image with an additional empty line.
	 *
	 * @return The MaximumScrollPosition value
	 */
	public int getMaximumScrollPosition()
	{
<span class="nc" id="L722">		return maxScrollPosition;</span>
	}


	/**
	 * This method creates the offscreen-image when needed (when called for the
	 * first time or recreated because of a changed font) and updates it on
	 * subsequent calls by calling &lt;code&gt;updateOffscreenImage()&lt;/code&gt;.
	 */
	private void processOffscreenImage()
	{
		Graphics2D g;
<span class="nc bnc" id="L734" title="All 2 branches missed.">		if(offscreenImage == null)</span>
		{
<span class="nc bnc" id="L736" title="All 2 branches missed.">			if(logger.isInfoEnabled()) logger.info(&quot;Creating offscreen-image&quot;);</span>
<span class="nc" id="L737">			boolean opaque = false;</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">			if(isOpaque())</span>
			{
<span class="nc" id="L740">				offscreenImage = GraphicsUtilities</span>
<span class="nc" id="L741">					.createOpaqueCompatibleImage(backgroundImageArea.width, backgroundImageArea.height);</span>
<span class="nc" id="L742">				opaque = true;</span>
			}
			else
			{
<span class="nc" id="L746">				offscreenImage = GraphicsUtilities</span>
<span class="nc" id="L747">					.createTranslucentCompatibleImage(backgroundImageArea.width, backgroundImageArea.height);</span>
			}
<span class="nc" id="L749">			g = (Graphics2D) offscreenImage.getGraphics();</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">			if(opaque)</span>
			{
<span class="nc" id="L752">				g.setColor(getBackground());</span>
<span class="nc" id="L753">				g.fillRect(backgroundImageArea.x, backgroundImageArea.y, backgroundImageArea.width, backgroundImageArea.height);</span>
			}
<span class="nc" id="L755">			g.drawImage(backgroundImage, 0, 0, null);</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">			if(versionText != null)</span>
			{
				// draw version-text...
<span class="nc" id="L759">				g.setColor(getForeground());</span>
<span class="nc" id="L760">				g.drawString(versionText, maxScrollArea.x +</span>
<span class="nc" id="L761">					(maxScrollArea.width - fontMetrics.stringWidth(versionText)) / 2,</span>
					versionHeight);
			}
<span class="nc" id="L764">		}</span>
		else
		{
<span class="nc" id="L767">			g = (Graphics2D) offscreenImage.getGraphics();</span>
		}


<span class="nc" id="L771">		g.setFont(getFont());</span>

<span class="nc" id="L773">		drawScrollArea(g);</span>
<span class="nc" id="L774">		g.dispose();</span>
<span class="nc" id="L775">	}</span>


	/**
	 * Updates the offscreen-image to represent the current scroll-position. It
	 * calls &lt;code&gt;initScrollImage()&lt;/code&gt;.
	 *
	 * @param g &lt;code&gt;Graphics&lt;/code&gt;-object
	 */
	private void drawScrollArea(Graphics2D g)
	{
<span class="nc" id="L786">		initScrollImage();</span>
		// only draw in the scroll-area
<span class="nc" id="L788">		g.setClip(scrollArea.x, scrollArea.y, scrollArea.width, scrollArea.height);</span>
		// clear background for transparent bg-images
<span class="nc" id="L790">		g.setColor(getBackground());</span>
<span class="nc" id="L791">		g.fillRect(scrollArea.x, scrollArea.y, scrollArea.width, scrollArea.height);</span>
		// draw background-image
<span class="nc" id="L793">		g.drawImage(backgroundImage, 0, 0, this);</span>
		// redraw version-text if available.
<span class="nc bnc" id="L795" title="All 2 branches missed.">		if(versionText != null)</span>
		{
<span class="nc" id="L797">			g.setColor(getForeground());</span>

<span class="nc" id="L799">			g.drawString(versionText, maxScrollArea.x +</span>
<span class="nc" id="L800">				(maxScrollArea.width - fontMetrics.stringWidth(versionText)) / 2,</span>
				versionHeight);
		}
		// draw proper part of precalculated scroll-image.
<span class="nc" id="L804">		g.drawImage(scrollImage, scrollArea.x,</span>
			scrollArea.y - scrollPosition, this);
<span class="nc bnc" id="L806" title="All 2 branches missed.">		if(debug)</span>
		{
<span class="nc" id="L808">			g.setColor(Color.YELLOW);</span>
<span class="nc" id="L809">			g.drawRect(scrollArea.x, scrollArea.y, scrollArea.width - 1, scrollArea.height - 1);</span>
		}
<span class="nc" id="L811">	}</span>


	/**
	 * Initializes the scroll-image if needed. The scroll-image is as high as
	 * needed to contain all the scroll-lines and (if available) the image.
	 */
	private void initScrollImage()
	{
<span class="nc" id="L820">		int fontHeight = fontMetrics.getHeight();</span>

<span class="nc" id="L822">		maxScrollPosition = fontHeight * (scrollLines.length);</span>

<span class="nc" id="L824">		int additionalImageOffset = 0;</span>
<span class="nc" id="L825">		int imageWidth = 0;</span>

<span class="nc bnc" id="L827" title="All 2 branches missed.">		if(aboutImage != null)</span>
		{
<span class="nc" id="L829">			imageWidth = aboutImage.getWidth();</span>
<span class="nc" id="L830">			additionalImageOffset = aboutImage.getHeight() + 2 * fontHeight;</span>
<span class="nc" id="L831">			maxScrollPosition = maxScrollPosition + additionalImageOffset;</span>
		}

<span class="nc bnc" id="L834" title="All 4 branches missed.">		if(scrollImage != null &amp;&amp; scrollImage.getHeight() != maxScrollPosition)</span>
		{
<span class="nc" id="L836">			flushScrollImage();</span>
		}
<span class="nc bnc" id="L838" title="All 2 branches missed.">		if(scrollImage == null)</span>
		{
<span class="nc" id="L840">			int maxWidth = imageWidth + 2 * fontHeight;</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">			if(logger.isInfoEnabled()) logger.info(&quot;imageWidth={}, maxWidth={}&quot;, imageWidth, maxWidth);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">			for(String scrollLine : scrollLines)</span>
			{
<span class="nc" id="L844">				int curWidth = fontMetrics.stringWidth(scrollLine);</span>

<span class="nc bnc" id="L846" title="All 2 branches missed.">				if(curWidth &gt; maxWidth)</span>
				{
<span class="nc" id="L848">					maxWidth = curWidth;</span>
				}
			}
<span class="nc bnc" id="L851" title="All 2 branches missed.">			if(maxWidth &gt; maxScrollArea.width)</span>
			{
<span class="nc bnc" id="L853" title="All 2 branches missed.">				if(logger.isInfoEnabled()) logger.info(&quot;maxWidth={} != maxScrollArea=&quot;, maxWidth, maxScrollArea);</span>
<span class="nc" id="L854">				maxWidth = maxScrollArea.width;</span>
			}

<span class="nc" id="L857">			scrollArea.x = maxScrollArea.x + (maxScrollArea.width - maxWidth) / 2;</span>
<span class="nc" id="L858">			scrollArea.y = maxScrollArea.y;</span>
<span class="nc" id="L859">			scrollArea.width = maxWidth;</span>
<span class="nc" id="L860">			scrollArea.height = maxScrollArea.height;</span>

<span class="nc" id="L862">			scrollImage = GraphicsUtilities.createTranslucentCompatibleImage(scrollArea.width, maxScrollPosition);</span>

<span class="nc" id="L864">			Color foreground = getForeground();</span>


			Graphics2D g;
<span class="nc" id="L868">			g = (Graphics2D) scrollImage.getGraphics();</span>

<span class="nc" id="L870">			g.setFont(getFont());</span>

<span class="nc bnc" id="L872" title="All 2 branches missed.">			if(aboutImage != null)</span>
			{
<span class="nc" id="L874">				g.drawImage(aboutImage, (((scrollArea.width - imageWidth) / 2)), fontHeight, null);</span>
			}
<span class="nc" id="L876">			g.setColor(foreground);</span>

<span class="nc" id="L878">			int y = fontMetrics.getAscent() + additionalImageOffset;</span>

<span class="nc bnc" id="L880" title="All 2 branches missed.">			for(String line : scrollLines)</span>
			{
<span class="nc" id="L882">				g.drawString(line, (scrollArea.width</span>
<span class="nc" id="L883">					- fontMetrics.stringWidth(line)) / 2, y);</span>
<span class="nc" id="L884">				y += fontHeight;</span>
			}
<span class="nc" id="L886">			g.dispose();</span>

<span class="nc" id="L888">			BufferedImage copy = GraphicsUtilities.createCompatibleCopy(scrollImage);</span>
			BufferedImageOp filter;
<span class="nc" id="L890">			final int blurSize = 10;</span>
<span class="nc" id="L891">			filter = getGaussianBlurFilter(blurSize, false);</span>
<span class="nc" id="L892">			scrollImage = filter.filter(scrollImage, null);</span>

<span class="nc" id="L894">			filter = getGaussianBlurFilter(blurSize, true);</span>
<span class="nc" id="L895">			scrollImage = filter.filter(scrollImage, null);</span>


<span class="nc" id="L898">			filter = new ColorTintFilter(Color.GREEN, 1.0f);</span>
<span class="nc" id="L899">			scrollImage = filter.filter(scrollImage, null);</span>

<span class="nc" id="L901">			g = (Graphics2D) scrollImage.getGraphics();</span>

<span class="nc" id="L903">			g.setComposite(AlphaComposite.SrcOver);</span>
<span class="nc" id="L904">			g.drawImage(copy, 0, 0, null);</span>

<span class="nc bnc" id="L906" title="All 2 branches missed.">			if(debug)</span>
			{
<span class="nc" id="L908">				g.setColor(Color.RED);</span>
<span class="nc" id="L909">				g.drawRect(0, 0, scrollImage.getWidth() - 1, scrollImage.getHeight() - 1);</span>

<span class="nc" id="L911">				g.setColor(Color.GREEN);</span>
<span class="nc" id="L912">				g.drawRect((((scrollArea.width - imageWidth) / 2)), fontHeight, aboutImage.getWidth(), aboutImage.getHeight());</span>
			}

<span class="nc" id="L915">			g.dispose();</span>
<span class="nc" id="L916">			copy.flush();</span>
		}


<span class="nc" id="L920">	}</span>

	public static ConvolveOp getGaussianBlurFilter(int radius, boolean horizontal)
	{
<span class="nc" id="L924">		final Logger logger = LoggerFactory.getLogger(AboutPanel.class);</span>

<span class="nc bnc" id="L926" title="All 2 branches missed.">		if(radius &lt; 1)</span>
		{
<span class="nc" id="L928">			throw new IllegalArgumentException(&quot;Radius must be &gt;= 1&quot;);</span>
		}

<span class="nc" id="L931">		int size = radius * 2 + 1;</span>
<span class="nc" id="L932">		float[] data = new float[size];</span>

<span class="nc" id="L934">		float sigma = radius / 3.0f;</span>
<span class="nc" id="L935">		float twoSigmaSquare = 2.0f * sigma * sigma;</span>
<span class="nc" id="L936">		float sigmaRoot = (float) Math.sqrt(twoSigmaSquare * Math.PI);</span>
<span class="nc" id="L937">		float total = 0.0f;</span>

<span class="nc bnc" id="L939" title="All 2 branches missed.">		for(int i = -radius; i &lt;= radius; i++)</span>
		{
<span class="nc" id="L941">			float distance = i * i;</span>
<span class="nc" id="L942">			int index = i + radius;</span>
<span class="nc" id="L943">			data[index] = (float) Math.exp(-distance / twoSigmaSquare) / sigmaRoot;</span>
<span class="nc" id="L944">			total += data[index];</span>
		}

<span class="nc bnc" id="L947" title="All 2 branches missed.">		for(int i = 0; i &lt; data.length; i++)</span>
		{
<span class="nc" id="L949">			data[i] /= total;</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">			if(logger.isDebugEnabled()) logger.debug(&quot;data[{}]={}&quot;, i, data[i]);</span>
		}

<span class="nc" id="L953">		Kernel kernel = null;</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">		if(horizontal)</span>
		{
<span class="nc" id="L956">			kernel = new Kernel(size, 1, data);</span>
		}
		else
		{
<span class="nc" id="L960">			kernel = new Kernel(1, size, data);</span>
		}
<span class="nc" id="L962">		return new ConvolveOp(kernel, ConvolveOp.EDGE_NO_OP, null);</span>
	}

	/**
	 * Sets the font attribute of the &lt;code&gt;AboutPanel&lt;/code&gt; object. Setting it
	 * will result in the recreation of all buffers. The font can even be safely
	 * changed while the component is visible. It will be used for the version- and
	 * scroll-text.&lt;p /&gt;
	 * &lt;p/&gt;
	 * If the parameter is &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;UIManager.getFont( &quot;Label.font&quot; )&lt;/code&gt;
	 * will be used.
	 *
	 * @param newFont The new font value.
	 */
	public void setFont(Font newFont)
	{
<span class="nc bnc" id="L978" title="All 2 branches missed.">		if(newFont == null)</span>
		{
<span class="nc" id="L980">			newFont = UIManager.getFont(&quot;Label.font&quot;);</span>
		}
<span class="nc bnc" id="L982" title="All 4 branches missed.">		if(newFont != null &amp;&amp; !newFont.equals(getFont()))</span>
		{
<span class="nc" id="L984">			super.setFont(newFont);</span>
<span class="nc" id="L985">			fontMetrics = getFontMetrics(newFont);</span>
<span class="nc" id="L986">			flushScrollImage();</span>
		}
<span class="nc" id="L988">	}</span>


	/*
	FontRenderContext frc = g2.getFontRenderContext();
        Font f = new Font(&quot;sansserif&quot;,Font.PLAIN,w/8);
        Font f1 = new Font(&quot;sansserif&quot;,Font.ITALIC,w/8);
        String s = &quot;AttributedString&quot;;
        AttributedString as = new AttributedString(s);


        // applies the TextAttribute.Font attribute to the AttributedString
        // with the range 0 to 10, which encompasses the letters 'A' through
        // 'd' of the String &quot;AttributedString&quot;
        as.addAttribute(TextAttribute.FONT, f, 0, 10 );

        // applies the TextAttribute.Font attribute to the AttributedString
        // with the range 10 to the length of the String s, which encompasses
        // the letters 'S' through 'g' of String &quot;AttributedString&quot;
        as.addAttribute(TextAttribute.FONT, f1, 10, s.length() );

        AttributedCharacterIterator aci = as.getIterator();

        // creates a TextLayout from the AttributedCharacterIterator
        TextLayout tl = new TextLayout (aci, frc);
        float sw = (float) tl.getBounds().getWidth();
        float sh = (float) tl.getBounds().getHeight();

        // creates an outline shape from the TextLayout and centers it
        // with respect to the width of the surface
        Shape sha = tl.getOutline(AffineTransform.getTranslateInstance(w/2-sw/2, h*0.2+sh/2));
        g2.setColor(Color.blue);
        g2.setStroke(new BasicStroke(1.5f));
        g2.draw(sha);
        g2.setColor(Color.magenta);
        g2.fill(sha);
	*/

	/**
	 * Paints this component.
	 *
	 * @param _g &lt;code&gt;Graphics&lt;/code&gt;-object
	 */
	public void paintComponent(Graphics _g)
	{
<span class="nc" id="L1033">		super.paintComponent(_g);</span>

<span class="nc" id="L1035">		processOffscreenImage();</span>

		// we need to create a copy of the given graphics since we
		// change the clip. Otherwise the border wouldn't be painted
		// propertly (not at all in this case).
<span class="nc" id="L1040">		Graphics2D g = (Graphics2D) _g.create();</span>

<span class="nc" id="L1042">		g.setClip(paintArea.x, paintArea.y, paintArea.width, paintArea.height);</span>

<span class="nc" id="L1044">		g.drawImage(offscreenImage, paintArea.x + offscreenOffset.x, paintArea.y + offscreenOffset.y, this);</span>
<span class="nc" id="L1045">		g.dispose();</span>
		//setPainted(true);
<span class="nc" id="L1047">	}</span>


	/**
	 * Makes sure that the private attributes size, paintArea, offscreenOffset and
	 * translated areas have sane values. It's called on component-resize.
	 */
	private void calculateAttributes()
	{
<span class="nc" id="L1056">		size = getSize(size);</span>

<span class="nc" id="L1058">		paintArea.x = insets.left;</span>
<span class="nc" id="L1059">		paintArea.y = insets.top;</span>
<span class="nc" id="L1060">		paintArea.width = size.width - insets.left - insets.right;</span>
<span class="nc" id="L1061">		paintArea.height = size.height - insets.top - insets.bottom;</span>

<span class="nc" id="L1063">		int loOffscreenOffsetX = (paintArea.width - preferredSize.width) / 2;</span>
<span class="nc" id="L1064">		int loOffscreenOffsetY = (paintArea.height - preferredSize.height) / 2;</span>

<span class="nc bnc" id="L1066" title="All 2 branches missed.">		if(loOffscreenOffsetX &lt; 0)</span>
		{
<span class="nc" id="L1068">			loOffscreenOffsetX = 0;</span>
		}
<span class="nc bnc" id="L1070" title="All 2 branches missed.">		if(loOffscreenOffsetY &lt; 0)</span>
		{
<span class="nc" id="L1072">			loOffscreenOffsetY = 0;</span>
		}
<span class="nc" id="L1074">		offscreenOffset.x = loOffscreenOffsetX;</span>
<span class="nc" id="L1075">		offscreenOffset.y = loOffscreenOffsetY;</span>

<span class="nc" id="L1077">		translatedScrollArea.x = maxScrollArea.x + offscreenOffset.x;</span>
<span class="nc" id="L1078">		translatedScrollArea.y = maxScrollArea.y + offscreenOffset.y;</span>
<span class="nc" id="L1079">		translatedScrollArea.width = maxScrollArea.width;</span>
<span class="nc" id="L1080">		translatedScrollArea.height = maxScrollArea.height;</span>

<span class="nc" id="L1082">		translatedBackgroundImageArea.x = backgroundImageArea.x + offscreenOffset.x;</span>
<span class="nc" id="L1083">		translatedBackgroundImageArea.y = backgroundImageArea.y + offscreenOffset.y;</span>
<span class="nc" id="L1084">		translatedBackgroundImageArea.width = backgroundImageArea.width;</span>
<span class="nc" id="L1085">		translatedBackgroundImageArea.height = backgroundImageArea.height;</span>
<span class="nc" id="L1086">		repaint();</span>
<span class="nc" id="L1087">	}</span>


	/**
	 * This methods takes the insets (the border) of this component into account
	 * when the preferred size is calculated. Any border will work. It is called by
	 * the property-change-listener if the border was changed.
	 */
	protected void calculatePreferredSize()
	{
<span class="nc" id="L1097">		insets = getInsets(insets);</span>
<span class="nc" id="L1098">		preferredSize.width = insets.left + insets.right + backgroundImageArea.width;</span>
<span class="nc" id="L1099">		preferredSize.height = insets.top + insets.bottom + backgroundImageArea.height;</span>
<span class="nc" id="L1100">		setPreferredSize(preferredSize);</span>
<span class="nc" id="L1101">		invalidate();</span>
<span class="nc" id="L1102">	}</span>


	/**
	 * This method requests a repaint of the scroll-area. The rest of the component
	 * will not be repainted. It is called by &lt;code&gt;setScrollPosition()&lt;/code&gt; .
	 *
	 * @see
	 */
	private void repaintScrollArea()
	{
		//setPainted(false);

<span class="nc" id="L1115">		repaint(scrollArea.x + offscreenOffset.x,</span>
			scrollArea.y + offscreenOffset.y,
			scrollArea.width, // + 1,
			scrollArea.height);// + 1 );
<span class="nc" id="L1119">	}</span>


	/**
	 * This method calls &lt;code&gt;super.addNotify()&lt;/code&gt; and notifies the
	 * scroll-thread by calling &lt;code&gt;setScrolling(true)&lt;/code&gt;. It also
	 * (re)initializes the scroll-position to MinimumScrollPosition (this is always
	 * the negative height of the scroll-rectangle) and registers tbis component at
	 * the &lt;code&gt;ToolTipManager&lt;/code&gt;.
	 *
	 * @see #setScrolling
	 * @see #setScrollPosition
	 * @see #getMinimumScrollPosition
	 */
	public void addNotify()
	{
<span class="nc" id="L1135">		super.addNotify();</span>

<span class="nc" id="L1137">		setScrolling(true);</span>
<span class="nc" id="L1138">		ToolTipManager.sharedInstance().registerComponent(this);</span>
<span class="nc" id="L1139">	}</span>


	/**
	 * This method calls &lt;code&gt;super.removeNotify()&lt;/code&gt; and sends the
	 * scroll-thread into a wait-state by calling &lt;code&gt;setScrolling(false)&lt;/code&gt;
	 * . It also unregisters this component from the &lt;code&gt;ToolTipManager&lt;/code&gt;.
	 *
	 * @see #setScrolling
	 */
	public void removeNotify()
	{
<span class="nc" id="L1151">		super.removeNotify();</span>

<span class="nc" id="L1153">		setScrolling(false);</span>
<span class="nc" id="L1154">		ToolTipManager.sharedInstance().unregisterComponent(this);</span>

		// flush used buffer-images.
<span class="nc" id="L1157">		flushOffscreenImage();</span>
<span class="nc" id="L1158">		flushScrollImage();</span>
<span class="nc" id="L1159">	}</span>


	/**
	 * This method is used to set the scrolling-property of this component. A value
	 * of &lt;code&gt;true&lt;/code&gt; will notify the scroll-thread that it has to resume
	 * work. A value of &lt;code&gt;false&lt;/code&gt; will send it into wait-state instead.
	 *
	 * @param Scrolling The new scrolling value
	 */
	public void setScrolling(boolean Scrolling)
	{
<span class="nc bnc" id="L1171" title="All 2 branches missed.">		if(scrolling != Scrolling)</span>
		{
<span class="nc" id="L1173">			scrolling = Scrolling;</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">			if(scrolling)</span>
			{
<span class="nc" id="L1176">				timer.start();</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">				if(logger.isInfoEnabled()) logger.info(&quot;Timer started.&quot;);</span>
			}
			else
			{
<span class="nc" id="L1181">				timer.stop();</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">				if(logger.isInfoEnabled()) logger.info(&quot;Timer stopped.&quot;);</span>
			}
		}
<span class="nc" id="L1185">	}</span>


	/**
	 * This method returns &lt;code&gt;true&lt;/code&gt; if scrolling is currently active. If
	 * it returns &lt;code&gt;false&lt;/code&gt; then the scroll-thread is waiting.
	 *
	 * @return The scrolling value
	 */
	public boolean isScrolling()
	{
<span class="nc" id="L1196">		return scrolling;</span>
	}


	/**
	 * Description of the Class
	 *
	 * @author Joern Huxhorn
	 */
<span class="nc" id="L1205">	class AboutComponentListener</span>
		extends ComponentAdapter
	{
		/**
		 * Description of the Method
		 *
		 * @param e Description of the Parameter
		 */
		public void componentResized(ComponentEvent e)
		{
<span class="nc" id="L1215">			AboutPanel.this.calculateAttributes();</span>
<span class="nc" id="L1216">		}</span>
	}


	/**
	 * Description of the Class
	 *
	 * @author Joern Huxhorn
	 */
<span class="nc" id="L1225">	class AboutPropertyChangeListener</span>
		implements PropertyChangeListener
	{
		/**
		 * Description of the Method
		 *
		 * @param evt Description of the Parameter
		 */
		public void propertyChange(PropertyChangeEvent evt)
		{
<span class="nc" id="L1235">			String propertyName = evt.getPropertyName();</span>

<span class="nc bnc" id="L1237" title="All 2 branches missed.">			if(propertyName.equals(&quot;border&quot;))</span>
			{
<span class="nc" id="L1239">				calculatePreferredSize();</span>
			}
<span class="nc bnc" id="L1241" title="All 2 branches missed.">			else if(propertyName.equals(&quot;foreground&quot;))</span>
			{
<span class="nc" id="L1243">				flushScrollImage();</span>
			}
<span class="nc bnc" id="L1245" title="All 2 branches missed.">			else if(propertyName.equals(&quot;background&quot;))</span>
			{
<span class="nc" id="L1247">				flushScrollImage();</span>
			}
//			else if ( propertyName.equals( &quot;locale&quot; ) )
//			{
//				initResources();
//			}
<span class="nc" id="L1253">		}</span>
	}


	/**
	 * This &lt;code&gt;MouseInputListener&lt;/code&gt; handles the pause/resume on click as
	 * well as the dragging inside the scroll-area.
	 *
	 * @author Joern Huxhorn
	 */
<span class="nc" id="L1263">	class AboutMouseInputListener</span>
		extends MouseInputAdapter
	{
<span class="nc" id="L1266">		Point lastPoint = null;</span>
<span class="nc" id="L1267">		boolean scrollingBeforePress = false;</span>
<span class="nc" id="L1268">		boolean dragged = false;</span>


		/**
		 * Description of the Method
		 *
		 * @param evt Description of the Parameter
		 */
		public void mousePressed(MouseEvent evt)
		{
<span class="nc bnc" id="L1278" title="All 2 branches missed.">			if(handleMouseEvent(evt))</span>
			{
				// always stop scrolling if mouse is pressed inside
				// the scroll-area
<span class="nc" id="L1282">				lastPoint = evt.getPoint();</span>
<span class="nc" id="L1283">				scrollingBeforePress = isScrolling();</span>
<span class="nc" id="L1284">				setScrolling(false);</span>
			}
			else
			{
<span class="nc" id="L1288">				lastPoint = null;</span>
			}
<span class="nc" id="L1290">			dragged = false;</span>
<span class="nc" id="L1291">		}</span>


		/**
		 * Description of the Method
		 *
		 * @param evt Description of the Parameter
		 */
		public void mouseReleased(MouseEvent evt)
		{
<span class="nc bnc" id="L1301" title="All 2 branches missed.">			if(dragged)</span>
			{
				// set scrolling-attribute to the value before the user dragged.
<span class="nc" id="L1304">				lastPoint = null;</span>
<span class="nc" id="L1305">				setScrolling(scrollingBeforePress);</span>
			}
<span class="nc" id="L1307">		}</span>


		/**
		 * Description of the Method
		 *
		 * @param evt Description of the Parameter
		 */
		public void mouseClicked(MouseEvent evt)
		{
			// this is only called after mouseReleased if no drag occurred.
<span class="nc bnc" id="L1318" title="All 2 branches missed.">			if(handleMouseEvent(evt))</span>
			{
				// toggle scrolling.
<span class="nc bnc" id="L1321" title="All 2 branches missed.">				setScrolling(!scrollingBeforePress);</span>
			}
<span class="nc" id="L1323">			dragged = false;</span>
<span class="nc" id="L1324">		}</span>


		/**
		 * Description of the Method
		 *
		 * @param evt Description of the Parameter
		 */
		public void mouseDragged(MouseEvent evt)
		{
			// only drag if original press was inside scroll-rectangle
<span class="nc bnc" id="L1335" title="All 2 branches missed.">			if(lastPoint != null)</span>
			{
<span class="nc" id="L1337">				dragged = true;</span>

<span class="nc" id="L1339">				Point currentPoint = evt.getPoint();</span>
<span class="nc" id="L1340">				int yOffset = lastPoint.y - currentPoint.y;</span>

<span class="nc" id="L1342">				setScrollPosition(getScrollPosition() + yOffset);</span>
<span class="nc" id="L1343">				lastPoint = currentPoint;</span>
			}
<span class="nc" id="L1345">		}</span>
	}


<span class="nc" id="L1349">	private class TimerActionListener</span>
		implements ActionListener
	{
<span class="nc" id="L1352">		private final Logger logger = LoggerFactory.getLogger(AboutPanel.class);</span>

		private long lastRepaintStart;
<span class="nc" id="L1355">		private long frequency = 25;</span>

		public void actionPerformed(ActionEvent e)
		{
<span class="nc" id="L1359">			long currentTime = System.nanoTime() / 1000000;</span>
<span class="nc" id="L1360">			long meanTime = currentTime - lastRepaintStart;</span>
<span class="nc bnc" id="L1361" title="All 2 branches missed.">			if(meanTime &gt; frequency)</span>
			{
<span class="nc bnc" id="L1363" title="All 2 branches missed.">				if(logger.isDebugEnabled()) logger.debug(&quot;Tick! meanTime={}&quot;, meanTime);</span>
<span class="nc" id="L1364">				increaseScrollPosition();</span>
<span class="nc" id="L1365">				lastRepaintStart = currentTime;</span>
			}
<span class="nc" id="L1367">		}</span>
	}

//	public static class Example
//	{
//		private JFrame dummyFrame;
//		private JDialog dialog;
//
//		private AboutPanel theAboutPanel;
//		private static JFileChooser chooser=new JFileChooser(new File(&quot;.&quot;));
//
//		abstract class SelectionAction extends AbstractAction
//		{
//			protected SelectionAction(String name)
//			{
//				super(name);
//			}
//
//			public abstract void setImage(URL url);
//
//			public void actionPerformed(ActionEvent evt)
//			{
//				int returnVal = chooser.showOpenDialog(dialog);
//				if(returnVal == JFileChooser.APPROVE_OPTION)
//				{
//					File file = chooser.getSelectedFile();
//					System.out.println(&quot;You chose to open this file: &quot; + file.getName());
//					try
//					{
//						setImage(file.toURL());
//						AboutPanel.Example.this.theAboutPanel.setScrollArea(null);
//						dialog.pack();
//					}
//					catch(Exception loEx)
//					{
//						System.out.println(loEx);
//					}
//				}
//			}
//		}
//
//		class ImageSelectionAction extends SelectionAction
//		{
//			ImageSelectionAction()
//			{
//				super(&quot;Select image&quot;);
//			}
//
//			public void setImage(URL url)
//			{
//				AboutPanel.Example.this.theAboutPanel.setAboutImage(url);
//			}
//		}
//
//		class BackgroundImageSelectionAction extends SelectionAction
//		{
//			BackgroundImageSelectionAction()
//			{
//				super(&quot;Select background-image&quot;);
//			}
//
//			public void setImage(URL url)
//			{
//				AboutPanel.Example.this.theAboutPanel.setBackgroundImage(url);
//			}
//		}
//
//		class CloseAction extends AbstractAction
//		{
//			CloseAction()
//			{
//				super(&quot;Close&quot;);
//			}
//
//			public void actionPerformed( ActionEvent evt )
//			{
//				dialog.dispose();
//			}
//		}
//
//		class FontSizeAction extends AbstractAction
//		{
//			int fontChange;
//
//
//			public FontSizeAction( String name, int FontChange )
//			{
//				super(name);
//				fontChange = FontChange;
//			}
//
//
//			public void actionPerformed( java.awt.event.ActionEvent evt )
//			{
//				Font loFont = AboutPanel.Example.this.theAboutPanel.getFont();
//				float loSize = loFont.getSize2D() + fontChange;
//
//				AboutPanel.Example.this.theAboutPanel.setFont( loFont.deriveFont( loSize ) );
//			}
//		}
//
//		abstract class ChooseColorAction extends AbstractAction
//		{
//			private JColorChooser chooser;
//			private String chooserTitle;
//
//			public ChooseColorAction( String name)//, String chooserTitle)
//			{
//				super(name);
//				chooserTitle=name;
//				chooser=new JColorChooser();
////			this.chooserTitle=chooserTitle;
//			}
//
//
//			public void actionPerformed( java.awt.event.ActionEvent evt )
//			{
//				Color c=chooser.showDialog(dialog, chooserTitle, getSelectColor());
//				if(c!=null)
//				{
//					setSelectColor(c);
//				}
//			}
//
//			public abstract Color getSelectColor();
//			public abstract void setSelectColor(Color c);
//		}
//
//		class ChooseBackgroundColorAction extends ChooseColorAction
//		{
//			public ChooseBackgroundColorAction()
//			{
//				super(&quot;Choose background-color&quot;);
//			}
//
//			public Color getSelectColor()
//			{
//				return AboutPanel.Example.this.theAboutPanel.getBackground();
//			}
//
//			public void setSelectColor(Color c)
//			{
//				AboutPanel.Example.this.theAboutPanel.setBackground(c);
//			}
//		}
//
//		class ChooseTextColorAction extends ChooseColorAction
//		{
//			public ChooseTextColorAction()
//			{
//				super(&quot;Choose text-color&quot;);
//			}
//
//			public Color getSelectColor()
//			{
//				return AboutPanel.Example.this.theAboutPanel.getForeground();
//			}
//
//			public void setSelectColor(Color c)
//			{
//				AboutPanel.Example.this.theAboutPanel.setForeground(c);
//			}
//		}
//
//		class ResetAction extends AbstractAction
//		{
//			public ResetAction()
//			{
//				super(&quot;Reset dialog&quot;);
//			}
//
//			public void actionPerformed(ActionEvent evt)
//			{
//				AboutPanel panel = AboutPanel.Example.this.theAboutPanel;
////				panel.initResources();
//				dialog.pack();
//			}
//		}
//
//		class PackAction extends AbstractAction
//		{
//			public PackAction()
//			{
//				super(&quot;Pack dialog&quot;);
//			}
//
//			public void actionPerformed(ActionEvent evt)
//			{
//				dialog.pack();
//			}
//		}
//
//		class ShowDialogAction extends AbstractAction
//		{
//			public ShowDialogAction()
//			{
//				super(&quot;Show dialog&quot;);
//			}
//
//			public void actionPerformed(ActionEvent evt)
//			{
//				dialog.setVisible(true);
//			}
//		}
//
//		class ExitMenuAction extends AbstractAction
//		{
//			public ExitMenuAction()
//			{
//				super(&quot;Exit&quot;);
//			}
//
//			public void actionPerformed(ActionEvent evt)
//			{
//				exit();
//			}
//		}
//
//		// TODO: Select font
//		// TODO: Select scroll-area
//		// TODO: Select scroll-text
//		// TODO: Select version-text/height
//
//		public Example()
//		{
//			JMenuBar menuBar=new JMenuBar();
//			dummyFrame=new JFrame( &quot;DummyFrame&quot; );
//			dummyFrame.setDefaultCloseOperation( javax.swing.JFrame.EXIT_ON_CLOSE );
//			dummyFrame.setJMenuBar(menuBar);
//			JMenu fileMenu=new JMenu(&quot;File&quot;);
//			menuBar.add(fileMenu);
//			fileMenu.add(new JMenuItem(new ShowDialogAction()));
//			fileMenu.addSeparator();
//			fileMenu.add(new JMenuItem(new ExitMenuAction()));
//
//			dummyFrame.setBounds(10,10,100,100);
//			dialog = new JDialog( dummyFrame, &quot;About example&quot;, false );
//
//			JPanel content = new JPanel( new BorderLayout() );
//
//			dialog.setContentPane( content );
//			content.setBorder( new EmptyBorder( 12, 12, 12, 12 ) );
//
//
//			AboutPanel aboutPanel = new AboutPanel();
//
//			content.add(BorderLayout.CENTER,aboutPanel);
//
//			theAboutPanel=aboutPanel;
//
//			CloseAction closeAction = new CloseAction();
//			JButton closeButton = new JButton( closeAction );
//
//			dialog.getRootPane().setDefaultButton( closeButton );
//			JPanel buttonPanel = new JPanel();
//
//			buttonPanel.setLayout( new BoxLayout( buttonPanel, BoxLayout.X_AXIS ) );
//			buttonPanel.setBorder( new EmptyBorder( 12, 0, 0, 0 ) );
//			buttonPanel.add( Box.createGlue() );
//			buttonPanel.add( closeButton );
//			buttonPanel.add( Box.createGlue() );
//			content.add( BorderLayout.SOUTH, buttonPanel );
//
//			JMenuBar dialogBar=new JMenuBar();
//			dialog.setJMenuBar(dialogBar);
//			JMenu optionsMenu=new JMenu(&quot;Options&quot;);
//			dialogBar.add(optionsMenu);
//
//			JMenuItem bgImageItem = new JMenuItem( new BackgroundImageSelectionAction() );
//			JMenuItem imageItem = new JMenuItem( new ImageSelectionAction() );
//			JMenuItem textColorItem = new JMenuItem( new ChooseTextColorAction() );
//			JMenuItem bgColorItem = new JMenuItem( new ChooseBackgroundColorAction() );
//			JMenuItem fontPlusItem = new JMenuItem( new FontSizeAction(&quot;Increase font-size&quot;, 1));
//			JMenuItem fontMinusItem = new JMenuItem(  new FontSizeAction(&quot;Decrease font-size&quot;, -1));
//			JMenuItem packItem = new JMenuItem( new PackAction() );
//			JMenuItem resetItem = new JMenuItem( new ResetAction() );
//			JMenuItem closeItem = new JMenuItem( closeAction );
//			JMenuItem exitItem = new JMenuItem( new ExitMenuAction() );
//
//			optionsMenu.add( bgImageItem );
//			optionsMenu.add( imageItem );
//			optionsMenu.add( textColorItem );
//			optionsMenu.add( bgColorItem );
//			optionsMenu.add( fontPlusItem );
//			optionsMenu.add( fontMinusItem );
//			optionsMenu.addSeparator();
//			optionsMenu.add( packItem );
//			optionsMenu.add( resetItem );
//			optionsMenu.addSeparator();
//			optionsMenu.add( closeItem );
//			optionsMenu.add( exitItem );
//
//			dialog.pack();
//			dummyFrame.setVisible(true);
//		}
//
//		public void showDialog()
//		{
//			dialog.setVisible(true);
//		}
//
//		public void exit()
//		{
//			System.exit(0);
//		}
//
//		public static void main(String args[])
//		{
//            Example example=new Example();
//			example.showDialog();
//		}
//	}
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>