<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ApplicationPreferences.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">43_lilith</a> &gt; <a href="index.source.html" class="el_package">de.huxhorn.lilith.swing</a> &gt; <span class="el_source">ApplicationPreferences.java</span></div><h1>ApplicationPreferences.java</h1><pre class="source lang-java linenums">/*
 * Lilith - a log event viewer.
 * Copyright (C) 2007-2009 Joern Huxhorn
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package de.huxhorn.lilith.swing;

import de.huxhorn.lilith.Lilith;
import de.huxhorn.lilith.LilithSounds;
import de.huxhorn.lilith.data.access.HttpStatus;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;
import de.huxhorn.lilith.swing.preferences.SavedCondition;
import de.huxhorn.lilith.swing.table.ColorScheme;
import de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;
import de.huxhorn.sulky.conditions.Condition;

import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.awt.*;
import java.beans.Encoder;
import java.beans.Expression;
import java.beans.PersistenceDelegate;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;

import javax.swing.*;

public class ApplicationPreferences
{
<span class="nc" id="L72">	public static enum SourceFiltering</span>
	{
<span class="nc" id="L74">		NONE, BLACKLIST, WHITELIST</span>
	}

<span class="nc" id="L77">	private static final Preferences PREFERENCES =</span>
<span class="nc" id="L78">		Preferences.userNodeForPackage(ApplicationPreferences.class);</span>

	private static final String STATUS_COLORS_XML_FILENAME = &quot;statusColors.xml&quot;;
	private static final String LEVEL_COLORS_XML_FILENAME = &quot;levelColors.xml&quot;;

	private static final String DETAILS_VIEW_ROOT_FOLDER = &quot;detailsView&quot;;
	public static final String DETAILS_VIEW_CSS_FILENAME = &quot;detailsView.css&quot;;
	public static final String DETAILS_VIEW_GROOVY_FILENAME = &quot;detailsView.groovy&quot;;
	private static final String CONDITIONS_XML_FILENAME = &quot;savedConditions.xml&quot;;

	public static final String STATUS_COLORS_PROPERTY = &quot;statusColors&quot;;
	public static final String LEVEL_COLORS_PROPERTY = &quot;levelColors&quot;;
	public static final String LOOK_AND_FEEL_PROPERTY = &quot;lookAndFeel&quot;;
	public static final String CLEANING_LOGS_ON_EXIT_PROPERTY = &quot;cleaningLogsOnExit&quot;;
	public static final String COLORING_WHOLE_ROW_PROPERTY = &quot;coloringWholeRow&quot;;
	public static final String SHOWING_IDENTIFIER_PROPERTY = &quot;showingIdentifier&quot;;
	public static final String SHOWING_FULL_CALLSTACK_PROPERTY = &quot;showingFullCallstack&quot;;
	public static final String SHOWING_STACKTRACE_PROPERTY = &quot;showingStackTrace&quot;;
	public static final String CHECKING_FOR_UPDATE_PROPERTY = &quot;checkingForUpdate&quot;;
	public static final String SOURCE_FILTERING_PROPERTY = &quot;sourceFiltering&quot;;
	public static final String SOUND_LOCATIONS_PROPERTY = &quot;soundLocations&quot;;
	public static final String MUTE_PROPERTY = &quot;mute&quot;;
	public static final String USING_INTERNAL_FRAMES_PROPERTY = &quot;usingInternalFrames&quot;;
	public static final String SCROLLING_TO_BOTTOM_PROPERTY = &quot;scrollingToBottom&quot;;
	public static final String SOURCE_NAMES_PROPERTY = &quot;sourceNames&quot;;
	public static final String APPLICATION_PATH_PROPERTY = &quot;applicationPath&quot;;
	public static final String AUTO_OPENING_PROPERTY = &quot;autoOpening&quot;;
	public static final String AUTO_CLOSING_PROPERTY = &quot;autoClosing&quot;;
	public static final String IMAGE_PATH_PROPERTY = &quot;imagePath&quot;;
	public static final String SOUND_PATH_PROPERTY = &quot;soundPath&quot;;
	public static final String AUTO_FOCUSING_WINDOW_PROPERTY = &quot;autoFocusingWindow&quot;;
	public static final String SOURCE_LISTS_PROPERTY = &quot;sourceLists&quot;;
	public static final String BLACK_LIST_NAME_PROPERTY = &quot;blackListName&quot;;
	public static final String WHITE_LIST_NAME_PROPERTY = &quot;whiteListName&quot;;
	public static final String CONDITIONS_PROPERTY = &quot;conditions&quot;;
	public static final String SPLASH_SCREEN_DISABLED_PROPERTY = &quot;splashScreenDisabled&quot;;
	public static final String ASKING_BEFORE_QUIT_PROPERTY = &quot;askingBeforeQuit&quot;;

	public static final String LOGGING_LAYOUT_GLOBAL_XML_FILENAME = &quot;loggingLayoutGlobal.xml&quot;;
	public static final String LOGGING_LAYOUT_XML_FILENAME = &quot;loggingLayout.xml&quot;;
	public static final String ACCESS_LAYOUT_GLOBAL_XML_FILENAME = &quot;accessLayoutGlobal.xml&quot;;
	public static final String ACCESS_LAYOUT_XML_FILENAME = &quot;accessLayout.xml&quot;;

	public static final String SOURCE_NAMES_XML_FILENAME = &quot;SourceNames.xml&quot;;
	public static final String SOURCE_LISTS_XML_FILENAME = &quot;SourceLists.xml&quot;;
	public static final String SOURCE_NAMES_PROPERTIES_FILENAME = &quot;SourceNames.properties&quot;;
	public static final String SOUND_LOCATIONS_XML_FILENAME = &quot;SoundLocations.xml&quot;;
	public static final String SOUND_LOCATIONS_PROPERTIES_FILENAME = &quot;SoundLocations.properties&quot;;
	public static final String PREVIOUS_APPLICATION_PATH_FILENAME = &quot;.previous.application.path&quot;;

	private static final String OLD_LICENSED_PREFERENCES_KEY = &quot;licensed&quot;;
	private static final String LICENSED_PREFERENCES_KEY = &quot;licensedVersion&quot;;
	public static final String USER_HOME;
	public static final String DEFAULT_APPLICATION_PATH;
	private static final Map&lt;String, String&gt; DEFAULT_SOURCE_NAMES;
	private static final Map&lt;String, String&gt; DEFAULT_SOUND_LOCATIONS;
	private static final Map&lt;LoggingEvent.Level, ColorScheme&gt; DEFAULT_LEVEL_COLORS;
	private static final Map&lt;HttpStatus.Type, ColorScheme&gt; DEFAULT_STATUS_COLORS;
	private static final String PREVIOUS_OPEN_PATH_PROPERTY = &quot;previousOpenPath&quot;;
	private static final String PREVIOUS_IMPORT_PATH_PROPERTY = &quot;previousImportPath&quot;;

	public static final String STARTUP_LOOK_AND_FEEL;

	private static final long CONDITIONS_CHECK_INTERVAL = 30000;
	private static final String GROOVY_SUFFIX = &quot;.groovy&quot;;
	private static final String EXAMPLE_GROOVY_BASE = &quot;/conditions/&quot;;
	private static final String EXAMPLE_GROOVY_LIST = &quot;conditions.txt&quot;;

	static
	{
<span class="nc" id="L148">		PREFERENCES.remove(OLD_LICENSED_PREFERENCES_KEY); // remove garbage</span>

<span class="nc" id="L150">		USER_HOME = System.getProperty(&quot;user.home&quot;);</span>
<span class="nc" id="L151">		File defaultAppPath = new File(USER_HOME, &quot;.lilith&quot;);</span>
<span class="nc" id="L152">		DEFAULT_APPLICATION_PATH = defaultAppPath.getAbsolutePath();</span>

<span class="nc" id="L154">		Map&lt;String, String&gt; defaultSoundLocations = new HashMap&lt;String, String&gt;();</span>
<span class="nc" id="L155">		defaultSoundLocations.put(LilithSounds.SOURCE_ADDED, &quot;/events/SourceAdded.mp3&quot;);</span>
<span class="nc" id="L156">		defaultSoundLocations.put(LilithSounds.SOURCE_REMOVED, &quot;/events/SourceRemoved.mp3&quot;);</span>
<span class="nc" id="L157">		defaultSoundLocations.put(LilithSounds.ERROR_EVENT_ALARM, &quot;/events/ErrorEventAlarm.mp3&quot;);</span>
<span class="nc" id="L158">		DEFAULT_SOUND_LOCATIONS = Collections.unmodifiableMap(defaultSoundLocations);</span>

<span class="nc" id="L160">		Map&lt;String, String&gt; defaultSourceNames = new HashMap&lt;String, String&gt;();</span>
<span class="nc" id="L161">		defaultSourceNames.put(&quot;127.0.0.1&quot;, &quot;Localhost&quot;);</span>
<span class="nc" id="L162">		DEFAULT_SOURCE_NAMES = Collections.unmodifiableMap(defaultSourceNames);</span>

<span class="nc" id="L164">		HashMap&lt;LoggingEvent.Level, ColorScheme&gt; defaultLevelColors = new HashMap&lt;LoggingEvent.Level, ColorScheme&gt;();</span>
<span class="nc" id="L165">		defaultLevelColors</span>
<span class="nc" id="L166">			.put(LoggingEvent.Level.TRACE, new ColorScheme(new Color(0x1F, 0x44, 0x58), new Color(0x80, 0xBA, 0xD9)));</span>
<span class="nc" id="L167">		defaultLevelColors.put(LoggingEvent.Level.DEBUG, new ColorScheme(Color.BLACK, Color.GREEN));</span>
<span class="nc" id="L168">		defaultLevelColors.put(LoggingEvent.Level.INFO, new ColorScheme(Color.BLACK, Color.WHITE));</span>
<span class="nc" id="L169">		defaultLevelColors.put(LoggingEvent.Level.WARN, new ColorScheme(Color.BLACK, Color.YELLOW));</span>
<span class="nc" id="L170">		defaultLevelColors.put(LoggingEvent.Level.ERROR, new ColorScheme(Color.YELLOW, Color.RED, Color.ORANGE));</span>
<span class="nc" id="L171">		DEFAULT_LEVEL_COLORS = Collections.unmodifiableMap(defaultLevelColors);</span>

<span class="nc" id="L173">		HashMap&lt;HttpStatus.Type, ColorScheme&gt; defaultStatusColors = new HashMap&lt;HttpStatus.Type, ColorScheme&gt;();</span>
<span class="nc" id="L174">		defaultStatusColors.put(HttpStatus.Type.SUCCESSFUL, new ColorScheme(Color.BLACK, Color.GREEN));</span>
<span class="nc" id="L175">		defaultStatusColors.put(HttpStatus.Type.INFORMATIONAL, new ColorScheme(Color.BLACK, Color.WHITE));</span>
<span class="nc" id="L176">		defaultStatusColors.put(HttpStatus.Type.REDIRECTION, new ColorScheme(Color.BLACK, Color.YELLOW));</span>
<span class="nc" id="L177">		defaultStatusColors.put(HttpStatus.Type.CLIENT_ERROR, new ColorScheme(Color.GREEN, Color.RED, Color.ORANGE));</span>
<span class="nc" id="L178">		defaultStatusColors.put(HttpStatus.Type.SERVER_ERROR, new ColorScheme(Color.YELLOW, Color.RED, Color.ORANGE));</span>
<span class="nc" id="L179">		DEFAULT_STATUS_COLORS = Collections.unmodifiableMap(defaultStatusColors);</span>

<span class="nc" id="L181">		STARTUP_LOOK_AND_FEEL = UIManager.getLookAndFeel().getName();</span>
<span class="nc" id="L182">	}</span>

<span class="nc" id="L184">	private final Logger logger = LoggerFactory.getLogger(ApplicationPreferences.class);</span>

	private PropertyChangeSupport propertyChangeSupport;

	private File startupApplicationPath;

	private File detailsViewRoot;

	private ArrayList&lt;String&gt; installedLookAndFeels;
	private String[] conditionScriptFiles;
	private long lastConditionsCheck;

	private Map&lt;LoggingEvent.Level, ColorScheme&gt; levelColors;
	private Map&lt;HttpStatus.Type, ColorScheme&gt; statusColors;

	private URL detailsViewRootUrl;

	/**
	 * Identifier =&gt; Name
	 */
	private Map&lt;String, String&gt; sourceNames;
	private long lastSourceNamesModified;

	private long lastConditionsModified;

	private Map&lt;String, String&gt; soundLocations;
	private long lastSoundLocationsModified;

	private Map&lt;String, Set&lt;String&gt;&gt; sourceLists;
	private long lastSourceListsModified;

	private SourceFiltering sourceFiltering;

	private Set&lt;String&gt; blackList;
	private Set&lt;String&gt; whiteList;
	private List&lt;SavedCondition&gt; conditions;

	private File groovyConditionsPath;

	public ApplicationPreferences()
<span class="nc" id="L224">	{</span>
<span class="nc" id="L225">		lastSourceNamesModified = -1;</span>
<span class="nc" id="L226">		lastConditionsModified = -1;</span>
<span class="nc" id="L227">		propertyChangeSupport = new PropertyChangeSupport(this);</span>
<span class="nc" id="L228">		startupApplicationPath = getApplicationPath();</span>

<span class="nc" id="L230">		installedLookAndFeels = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">		for(UIManager.LookAndFeelInfo info : UIManager.getInstalledLookAndFeels())</span>
		{
<span class="nc" id="L233">			installedLookAndFeels.add(info.getName());</span>
		}
<span class="nc" id="L235">		Collections.sort(installedLookAndFeels);</span>

<span class="nc" id="L237">		groovyConditionsPath = new File(startupApplicationPath, &quot;conditions&quot;);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">		if(groovyConditionsPath.mkdirs())</span>
		{
			// groovy Conditions was generated, create examples...
<span class="nc" id="L241">			installExampleConditions();</span>
		}
<span class="nc" id="L243">	}</span>

	public File resolveConditionScriptFile(String input)
	{
<span class="nc bnc" id="L247" title="All 2 branches missed.">		if(!input.endsWith(GROOVY_SUFFIX))</span>
		{
<span class="nc" id="L249">			input = input + GROOVY_SUFFIX;</span>
		}
<span class="nc" id="L251">		File scriptFile = new File(groovyConditionsPath, input);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">		if(scriptFile.isFile())</span>
		{
<span class="nc" id="L254">			return scriptFile;</span>
		}
<span class="nc" id="L256">		return null;</span>
	}

	public String[] getAllConditionScriptFiles()
	{
<span class="nc bnc" id="L261" title="All 2 branches missed.">		if(conditionScriptFiles == null || ((System</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">			.currentTimeMillis() - lastConditionsCheck) &gt; CONDITIONS_CHECK_INTERVAL))</span>
		{

<span class="nc" id="L265">			File[] groovyFiles = groovyConditionsPath.listFiles(new GroovyConditionFileFilter());</span>
<span class="nc bnc" id="L266" title="All 4 branches missed.">			if(groovyFiles != null &amp;&amp; groovyFiles.length &gt; 0)</span>
			{
<span class="nc" id="L268">				conditionScriptFiles = new String[groovyFiles.length];</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">				for(int i = 0; i &lt; groovyFiles.length; i++)</span>
				{
<span class="nc" id="L271">					File current = groovyFiles[i];</span>
<span class="nc" id="L272">					conditionScriptFiles[i] = current.getName();</span>
				}
<span class="nc" id="L274">				Arrays.sort(conditionScriptFiles);</span>
<span class="nc" id="L275">				lastConditionsCheck = System.currentTimeMillis();</span>
			}
		}
<span class="nc" id="L278">		return conditionScriptFiles;</span>
	}

	public void installExampleConditions()
	{
<span class="nc" id="L283">		String path = EXAMPLE_GROOVY_BASE + EXAMPLE_GROOVY_LIST;</span>
<span class="nc" id="L284">		URL url = ApplicationPreferences.class.getResource(path);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">		if(url == null)</span>
		{
<span class="nc bnc" id="L287" title="All 2 branches missed.">			if(logger.isErrorEnabled()) logger.error(&quot;Couldn't find resource at &quot; + path + &quot;!&quot;);</span>
		}
		else
		{
<span class="nc" id="L291">			List&lt;String&gt; lines = readLines(url);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">			for(String current : lines)</span>
			{
<span class="nc" id="L294">				path = EXAMPLE_GROOVY_BASE + current;</span>
<span class="nc" id="L295">				url = ApplicationPreferences.class.getResource(path);</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">				if(url == null)</span>
				{
<span class="nc bnc" id="L298" title="All 2 branches missed.">					if(logger.isErrorEnabled()) logger.error(&quot;Couldn't find resource at &quot; + path + &quot;!&quot;);</span>
					continue;
				}
<span class="nc" id="L301">				File target = new File(groovyConditionsPath, current);</span>
<span class="nc" id="L302">				copy(url, target, true);</span>
<span class="nc" id="L303">			}</span>
		}
<span class="nc" id="L305">	}</span>

	private void initLevelColors()
	{
<span class="nc bnc" id="L309" title="All 2 branches missed.">		if(levelColors == null)</span>
		{
<span class="nc" id="L311">			File appPath = getStartupApplicationPath();</span>
<span class="nc" id="L312">			File levelColorsFile = new File(appPath, LEVEL_COLORS_XML_FILENAME);</span>

<span class="nc bnc" id="L314" title="All 2 branches missed.">			if(levelColorsFile.isFile())</span>
			{
<span class="nc" id="L316">				XMLDecoder d = null;</span>
				try
				{
<span class="nc" id="L319">					d = new XMLDecoder(</span>
						new BufferedInputStream(
							new FileInputStream(levelColorsFile)));

					//noinspection unchecked
<span class="nc" id="L324">					levelColors = (Map&lt;LoggingEvent.Level, ColorScheme&gt;) d.readObject();</span>
				}
<span class="nc" id="L326">				catch(Throwable ex)</span>
				{
<span class="nc bnc" id="L328" title="All 2 branches missed.">					if(logger.isWarnEnabled())</span>
					{
<span class="nc" id="L330">						logger</span>
<span class="nc" id="L331">							.warn(&quot;Exception while loading level colors from sourceListsFile '&quot; + levelColorsFile</span>
<span class="nc" id="L332">								.getAbsolutePath() + &quot;'!&quot;, ex);</span>
					}
<span class="nc" id="L334">					levelColors = null;</span>
				}
				finally
				{
<span class="nc bnc" id="L338" title="All 2 branches missed.">					if(d != null)</span>
					{
<span class="nc" id="L340">						d.close();</span>
					}
				}
			}
		}

<span class="nc bnc" id="L346" title="All 4 branches missed.">		if(levelColors != null &amp;&amp; levelColors.size() != DEFAULT_LEVEL_COLORS.size())</span>
		{
<span class="nc bnc" id="L348" title="All 2 branches missed.">			if(logger.isWarnEnabled()) logger.warn(&quot;Reverting level colors to defaults.&quot;);</span>
<span class="nc" id="L349">			levelColors = null;</span>
		}

<span class="nc bnc" id="L352" title="All 2 branches missed.">		if(levelColors == null)</span>
		{
<span class="nc" id="L354">			levelColors = cloneLevelColors(DEFAULT_LEVEL_COLORS);</span>
		}
<span class="nc" id="L356">	}</span>

	private Map&lt;LoggingEvent.Level, ColorScheme&gt; cloneLevelColors(Map&lt;LoggingEvent.Level, ColorScheme&gt; input)
	{
<span class="nc bnc" id="L360" title="All 4 branches missed.">		if(input != null &amp;&amp; input.size() != DEFAULT_LEVEL_COLORS.size())</span>
		{
<span class="nc bnc" id="L362" title="All 2 branches missed.">			if(logger.isWarnEnabled()) logger.warn(&quot;Reverting colors to defaults.&quot;);</span>
<span class="nc" id="L363">			input = null;</span>
		}

<span class="nc bnc" id="L366" title="All 2 branches missed.">		if(input == null)</span>
		{
<span class="nc" id="L368">			input = DEFAULT_LEVEL_COLORS;</span>
		}

<span class="nc" id="L371">		Map&lt;LoggingEvent.Level, ColorScheme&gt; result = new HashMap&lt;LoggingEvent.Level, ColorScheme&gt;();</span>

		try
		{
<span class="nc bnc" id="L375" title="All 2 branches missed.">			for(Map.Entry&lt;LoggingEvent.Level, ColorScheme&gt; current : input.entrySet())</span>
			{
<span class="nc" id="L377">				result.put(current.getKey(), current.getValue().clone());</span>
<span class="nc" id="L378">			}</span>
		}
<span class="nc" id="L380">		catch(Throwable e)</span>
		{
<span class="nc bnc" id="L382" title="All 2 branches missed.">			if(logger.isErrorEnabled()) logger.error(&quot;Exception while cloning colors!&quot;, e);</span>
<span class="nc" id="L383">		}</span>
<span class="nc" id="L384">		return result;</span>
	}

	public void setLevelColors(Map&lt;LoggingEvent.Level, ColorScheme&gt; colors)
	{
<span class="nc" id="L389">		Object oldValue = getLevelColors();</span>
<span class="nc" id="L390">		colors = cloneLevelColors(colors);</span>
<span class="nc" id="L391">		writeLevelColors(colors);</span>
<span class="nc" id="L392">		this.levelColors = colors;</span>
<span class="nc" id="L393">		Object newValue = getLevelColors();</span>
<span class="nc" id="L394">		propertyChangeSupport.firePropertyChange(LEVEL_COLORS_PROPERTY, oldValue, newValue);</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">		if(logger.isInfoEnabled()) logger.info(&quot;LevelColors set to {}.&quot;, this.levelColors);</span>
<span class="nc" id="L396">	}</span>

	private void writeLevelColors(Map&lt;LoggingEvent.Level, ColorScheme&gt; colors)
	{
<span class="nc" id="L400">		File appPath = getStartupApplicationPath();</span>
<span class="nc" id="L401">		File file = new File(appPath, LEVEL_COLORS_XML_FILENAME);</span>
<span class="nc" id="L402">		Throwable error = null;</span>
		try
		{
<span class="nc" id="L405">			BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));</span>
<span class="nc" id="L406">			XMLEncoder e = new XMLEncoder(bos);</span>
<span class="nc" id="L407">			PersistenceDelegate delegate = new EnumPersistenceDelegate();</span>
<span class="nc" id="L408">			e.setPersistenceDelegate(LoggingEvent.Level.class, delegate);</span>
<span class="nc" id="L409">			e.writeObject(colors);</span>
<span class="nc" id="L410">			e.close();</span>
		}
<span class="nc" id="L412">		catch(Throwable ex)</span>
		{
<span class="nc" id="L414">			error = ex;</span>
<span class="nc" id="L415">		}</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">		if(error != null)</span>
		{
<span class="nc bnc" id="L418" title="All 2 branches missed.">			if(logger.isWarnEnabled()) logger.warn(&quot;Exception while writing colors!&quot;, error);</span>
		}
<span class="nc" id="L420">	}</span>

	public Map&lt;LoggingEvent.Level, ColorScheme&gt; getLevelColors()
	{
<span class="nc bnc" id="L424" title="All 2 branches missed.">		if(levelColors == null)</span>
		{
<span class="nc" id="L426">			initLevelColors();</span>
		}
<span class="nc" id="L428">		return cloneLevelColors(levelColors);</span>
	}

	private void initStatusColors()
	{
<span class="nc bnc" id="L433" title="All 2 branches missed.">		if(statusColors == null)</span>
		{
<span class="nc" id="L435">			File appPath = getStartupApplicationPath();</span>
<span class="nc" id="L436">			File statusColorsFile = new File(appPath, STATUS_COLORS_XML_FILENAME);</span>

<span class="nc bnc" id="L438" title="All 2 branches missed.">			if(statusColorsFile.isFile())</span>
			{
<span class="nc" id="L440">				XMLDecoder d = null;</span>
				try
				{
<span class="nc" id="L443">					d = new XMLDecoder(</span>
						new BufferedInputStream(
							new FileInputStream(statusColorsFile)));

					//noinspection unchecked
<span class="nc" id="L448">					statusColors = (Map&lt;HttpStatus.Type, ColorScheme&gt;) d.readObject();</span>
				}
<span class="nc" id="L450">				catch(Throwable ex)</span>
				{
<span class="nc bnc" id="L452" title="All 2 branches missed.">					if(logger.isWarnEnabled())</span>
					{
<span class="nc" id="L454">						logger</span>
<span class="nc" id="L455">							.warn(&quot;Exception while loading status colors from sourceListsFile '&quot; + statusColorsFile</span>
<span class="nc" id="L456">								.getAbsolutePath() + &quot;'!&quot;, ex);</span>
					}
<span class="nc" id="L458">					statusColors = null;</span>
				}
				finally
				{
<span class="nc bnc" id="L462" title="All 2 branches missed.">					if(d != null)</span>
					{
<span class="nc" id="L464">						d.close();</span>
					}
				}
			}
		}

<span class="nc bnc" id="L470" title="All 4 branches missed.">		if(statusColors != null &amp;&amp; statusColors.size() != DEFAULT_STATUS_COLORS.size())</span>
		{
<span class="nc bnc" id="L472" title="All 2 branches missed.">			if(logger.isWarnEnabled()) logger.warn(&quot;Reverting status colors to defaults.&quot;);</span>
<span class="nc" id="L473">			statusColors = null;</span>
		}

<span class="nc bnc" id="L476" title="All 2 branches missed.">		if(statusColors == null)</span>
		{
<span class="nc" id="L478">			statusColors = cloneStatusColors(DEFAULT_STATUS_COLORS);</span>
		}
<span class="nc" id="L480">	}</span>

	private Map&lt;HttpStatus.Type, ColorScheme&gt; cloneStatusColors(Map&lt;HttpStatus.Type, ColorScheme&gt; input)
	{
<span class="nc bnc" id="L484" title="All 4 branches missed.">		if(input != null &amp;&amp; input.size() != DEFAULT_STATUS_COLORS.size())</span>
		{
<span class="nc bnc" id="L486" title="All 2 branches missed.">			if(logger.isWarnEnabled()) logger.warn(&quot;Reverting colors to defaults.&quot;);</span>
<span class="nc" id="L487">			input = null;</span>
		}

<span class="nc bnc" id="L490" title="All 2 branches missed.">		if(input == null)</span>
		{
<span class="nc" id="L492">			input = DEFAULT_STATUS_COLORS;</span>
		}

<span class="nc" id="L495">		Map&lt;HttpStatus.Type, ColorScheme&gt; result = new HashMap&lt;HttpStatus.Type, ColorScheme&gt;();</span>

		try
		{
<span class="nc bnc" id="L499" title="All 2 branches missed.">			for(Map.Entry&lt;HttpStatus.Type, ColorScheme&gt; current : input.entrySet())</span>
			{
<span class="nc" id="L501">				result.put(current.getKey(), current.getValue().clone());</span>
<span class="nc" id="L502">			}</span>
		}
<span class="nc" id="L504">		catch(Throwable e)</span>
		{
<span class="nc bnc" id="L506" title="All 2 branches missed.">			if(logger.isErrorEnabled()) logger.error(&quot;Exception while cloning colors!&quot;, e);</span>
<span class="nc" id="L507">		}</span>
<span class="nc" id="L508">		return result;</span>
	}

	public void setStatusColors(Map&lt;HttpStatus.Type, ColorScheme&gt; colors)
	{
<span class="nc" id="L513">		Object oldValue = getStatusColors();</span>
<span class="nc" id="L514">		colors = cloneStatusColors(colors);</span>
<span class="nc" id="L515">		writeStatusColors(colors);</span>
<span class="nc" id="L516">		this.statusColors = colors;</span>
<span class="nc" id="L517">		Object newValue = getStatusColors();</span>
<span class="nc" id="L518">		propertyChangeSupport.firePropertyChange(STATUS_COLORS_PROPERTY, oldValue, newValue);</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">		if(logger.isInfoEnabled()) logger.info(&quot;StatusColors set to {}.&quot;, this.statusColors);</span>
<span class="nc" id="L520">	}</span>

	private void writeStatusColors(Map&lt;HttpStatus.Type, ColorScheme&gt; colors)
	{
<span class="nc" id="L524">		File appPath = getStartupApplicationPath();</span>
<span class="nc" id="L525">		File file = new File(appPath, STATUS_COLORS_XML_FILENAME);</span>
<span class="nc" id="L526">		Throwable error = null;</span>
		try
		{
<span class="nc" id="L529">			BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));</span>
<span class="nc" id="L530">			XMLEncoder e = new XMLEncoder(bos);</span>
<span class="nc" id="L531">			PersistenceDelegate delegate = new EnumPersistenceDelegate();</span>
<span class="nc" id="L532">			e.setPersistenceDelegate(HttpStatus.Type.class, delegate);</span>
<span class="nc" id="L533">			e.writeObject(colors);</span>
<span class="nc" id="L534">			e.close();</span>
		}
<span class="nc" id="L536">		catch(Throwable ex)</span>
		{
<span class="nc" id="L538">			error = ex;</span>
<span class="nc" id="L539">		}</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">		if(error != null)</span>
		{
<span class="nc bnc" id="L542" title="All 2 branches missed.">			if(logger.isWarnEnabled()) logger.warn(&quot;Exception while writing colors!&quot;, error);</span>
		}
<span class="nc" id="L544">	}</span>

	public Map&lt;HttpStatus.Type, ColorScheme&gt; getStatusColors()
	{
<span class="nc bnc" id="L548" title="All 2 branches missed.">		if(statusColors == null)</span>
		{
<span class="nc" id="L550">			initStatusColors();</span>
		}
<span class="nc" id="L552">		return cloneStatusColors(statusColors);</span>
	}

	public void setSourceFiltering(SourceFiltering sourceFiltering)
	{
<span class="nc" id="L557">		Object oldValue = getSourceFiltering();</span>
<span class="nc" id="L558">		PREFERENCES.put(SOURCE_FILTERING_PROPERTY, sourceFiltering.toString());</span>
<span class="nc" id="L559">		this.sourceFiltering = sourceFiltering;</span>
<span class="nc" id="L560">		propertyChangeSupport.firePropertyChange(SOURCE_FILTERING_PROPERTY, oldValue, sourceFiltering);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">		if(logger.isInfoEnabled()) logger.info(&quot;SourceFiltering set to {}.&quot;, this.sourceFiltering);</span>
<span class="nc" id="L562">	}</span>

	private void initSourceLists()
	{
<span class="nc" id="L566">		File appPath = getStartupApplicationPath();</span>
<span class="nc" id="L567">		File sourceListsFile = new File(appPath, SOURCE_LISTS_XML_FILENAME);</span>

<span class="nc bnc" id="L569" title="All 2 branches missed.">		if(sourceListsFile.isFile())</span>
		{
<span class="nc" id="L571">			long lastModified = sourceListsFile.lastModified();</span>
<span class="nc bnc" id="L572" title="All 4 branches missed.">			if(sourceLists != null &amp;&amp; lastSourceListsModified &gt;= lastModified)</span>
			{
<span class="nc bnc" id="L574" title="All 2 branches missed.">				if(logger.isDebugEnabled()) logger.debug(&quot;Won't reload source lists.&quot;);</span>
<span class="nc" id="L575">				return;</span>
			}
<span class="nc" id="L577">			XMLDecoder d = null;</span>
			try
			{
<span class="nc" id="L580">				d = new XMLDecoder(</span>
					new BufferedInputStream(
						new FileInputStream(sourceListsFile)));

				//noinspection unchecked
<span class="nc" id="L585">				sourceLists = (Map&lt;String, Set&lt;String&gt;&gt;) d.readObject();</span>
<span class="nc" id="L586">				lastSourceListsModified = lastModified;</span>
			}
<span class="nc" id="L588">			catch(Throwable ex)</span>
			{
<span class="nc bnc" id="L590" title="All 2 branches missed.">				if(logger.isWarnEnabled())</span>
				{
<span class="nc" id="L592">					logger</span>
<span class="nc" id="L593">						.warn(&quot;Exception while loading source lists from sourceListsFile '&quot; + sourceListsFile</span>
<span class="nc" id="L594">							.getAbsolutePath() + &quot;'!&quot;, ex);</span>
				}
<span class="nc" id="L596">				sourceLists = new HashMap&lt;String, Set&lt;String&gt;&gt;();</span>
			}
			finally
			{
<span class="nc bnc" id="L600" title="All 2 branches missed.">				if(d != null)</span>
				{
<span class="nc" id="L602">					d.close();</span>
				}
			}
<span class="nc" id="L605">		}</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">		else if(sourceLists == null)</span>
		{
<span class="nc" id="L608">			sourceLists = new HashMap&lt;String, Set&lt;String&gt;&gt;();</span>
		}
<span class="nc" id="L610">	}</span>

	public Map&lt;String, Set&lt;String&gt;&gt; getSourceLists()
	{
<span class="nc" id="L614">		initSourceLists();</span>
<span class="nc" id="L615">		return new HashMap&lt;String, Set&lt;String&gt;&gt;(sourceLists);</span>
	}

	public void setSourceLists(Map&lt;String, Set&lt;String&gt;&gt; sourceLists)
	{
<span class="nc" id="L620">		Object oldValue = getSourceLists();</span>
<span class="nc" id="L621">		writeSourceLists(sourceLists);</span>
<span class="nc" id="L622">		Object newValue = getSourceLists();</span>
<span class="nc" id="L623">		blackList = null;</span>
<span class="nc" id="L624">		whiteList = null;</span>
<span class="nc" id="L625">		propertyChangeSupport.firePropertyChange(SOURCE_LISTS_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L626">	}</span>

	public SourceFiltering getSourceFiltering()
	{
<span class="nc bnc" id="L630" title="All 2 branches missed.">		if(sourceFiltering != null)</span>
		{
<span class="nc" id="L632">			return sourceFiltering;</span>
		}
<span class="nc" id="L634">		String sf = PREFERENCES.get(SOURCE_FILTERING_PROPERTY, &quot;NONE&quot;);</span>
		try
		{
<span class="nc" id="L637">			sourceFiltering = SourceFiltering.valueOf(sf);</span>
		}
<span class="nc" id="L639">		catch(IllegalArgumentException e)</span>
		{
<span class="nc" id="L641">			sourceFiltering = SourceFiltering.NONE;</span>
<span class="nc" id="L642">		}</span>
<span class="nc" id="L643">		return sourceFiltering;</span>
	}

	public void initDetailsViewRoot(boolean overwriteAlways)
	{
<span class="nc" id="L648">		detailsViewRoot = new File(startupApplicationPath, DETAILS_VIEW_ROOT_FOLDER);</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">		if(detailsViewRoot.mkdirs())</span>
		{
<span class="nc bnc" id="L651" title="All 2 branches missed.">			if(logger.isInfoEnabled()) logger.info(&quot;Created directory {}.&quot;, detailsViewRoot.getAbsolutePath());</span>
		}
		try
		{
<span class="nc" id="L655">			detailsViewRootUrl = detailsViewRoot.toURI().toURL();</span>
		}
<span class="nc" id="L657">		catch(MalformedURLException e)</span>
		{
<span class="nc bnc" id="L659" title="All 2 branches missed.">			if(logger.isWarnEnabled())</span>
			{
<span class="nc" id="L661">				logger.warn(&quot;Exception while creating detailsViewRootUrl for '{}'!&quot;, detailsViewRoot.getAbsolutePath());</span>
			}
<span class="nc" id="L663">			detailsViewRootUrl = null;</span>
<span class="nc" id="L664">		}</span>

		{
<span class="nc" id="L667">			String resourcePath = &quot;/detailsView/&quot; + DETAILS_VIEW_CSS_FILENAME;</span>
<span class="nc" id="L668">			String historyBasePath = &quot;/detailsView/history/detailsView.css/&quot;;</span>
<span class="nc" id="L669">			File detailsViewCssFile = new File(detailsViewRoot, DETAILS_VIEW_CSS_FILENAME);</span>

<span class="nc" id="L671">			initIfNecessary(detailsViewCssFile, resourcePath, historyBasePath, overwriteAlways);</span>
		}

		{
<span class="nc" id="L675">			String resourcePath = &quot;/detailsView/&quot; + DETAILS_VIEW_GROOVY_FILENAME;</span>
<span class="nc" id="L676">			String historyBasePath = &quot;/detailsView/history/detailsView.groovy/&quot;;</span>
<span class="nc" id="L677">			File detailsViewGroovyFile = new File(detailsViewRoot, DETAILS_VIEW_GROOVY_FILENAME);</span>

<span class="nc" id="L679">			initIfNecessary(detailsViewGroovyFile, resourcePath, historyBasePath, overwriteAlways);</span>
		}
<span class="nc" id="L681">	}</span>

	private void initIfNecessary(File file, String resourcePath, String historyBasePath, boolean overwriteAlways)
	{
<span class="nc" id="L685">		boolean delete = false;</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">		if(overwriteAlways)</span>
		{
<span class="nc" id="L688">			delete = true;</span>
		}
<span class="nc bnc" id="L690" title="All 2 branches missed.">		else if(file.isFile())</span>
		{
<span class="nc" id="L692">			byte[] available = null;</span>

			try
			{
<span class="nc" id="L696">				FileInputStream availableFile = new FileInputStream(file);</span>
<span class="nc" id="L697">				available = getMD5(availableFile);</span>
			}
<span class="nc" id="L699">			catch(FileNotFoundException e)</span>
			{
				// ignore
<span class="nc" id="L702">			}</span>

<span class="nc" id="L704">			byte[] current = getMD5(getClass().getResourceAsStream(resourcePath));</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">			if(Arrays.equals(available, current))</span>
			{
				// we are done already. The current version is the latest version.
<span class="nc bnc" id="L708" title="All 2 branches missed.">				if(logger.isDebugEnabled())</span>
				{
<span class="nc" id="L710">					logger.debug(&quot;The current version of {} is also the latest version.&quot;, file.getAbsolutePath());</span>
				}
<span class="nc" id="L712">				return;</span>
			}

<span class="nc bnc" id="L715" title="All 2 branches missed.">			if(available != null)</span>
			{
				// check older versions if available
<span class="nc" id="L718">				URL historyUrl = getClass().getResource(historyBasePath + &quot;history.txt&quot;);</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">				if(historyUrl != null)</span>
				{
<span class="nc" id="L721">					List&lt;String&gt; historyList = readLines(historyUrl);</span>

<span class="nc bnc" id="L723" title="All 2 branches missed.">					for(String currentLine : historyList)</span>
					{
<span class="nc" id="L725">						InputStream is = getClass().getResourceAsStream(historyBasePath + currentLine + &quot;.md5&quot;);</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">						if(is != null)</span>
						{
<span class="nc" id="L728">							DataInputStream dis = new DataInputStream(is);</span>
<span class="nc" id="L729">							byte[] checksum = new byte[16];</span>
							try
							{
<span class="nc" id="L732">								dis.readFully(checksum);</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">								if(Arrays.equals(available, checksum))</span>
								{
<span class="nc bnc" id="L735" title="All 2 branches missed.">									if(logger.isInfoEnabled())</span>
									{
<span class="nc" id="L737">										logger.info(&quot;Found old version of {}: {}&quot;, file.getAbsolutePath(), currentLine);</span>
									}
<span class="nc" id="L739">									delete = true;</span>
									break;
								}
							}
<span class="nc" id="L743">							catch(IOException e)</span>
							{
<span class="nc bnc" id="L745" title="All 2 branches missed.">								if(logger.isWarnEnabled())</span>
								{
<span class="nc" id="L747">									logger.warn(&quot;Exception while reading checksum of &quot; + currentLine + &quot;!&quot;, e);</span>
								}
							}
							finally
							{
								try
								{
<span class="nc" id="L754">									dis.close();</span>
								}
<span class="nc" id="L756">								catch(IOException e)</span>
								{
									// ignore
<span class="nc" id="L759">								}</span>
							}
						}
<span class="nc" id="L762">					}</span>
				}
<span class="nc" id="L764">			}</span>
			else
			{
				// we couldn't calculate the checksum. Try to delete it...
<span class="nc" id="L768">				delete = true;</span>
			}
		}

<span class="nc" id="L772">		URL resourceUrl = ApplicationPreferences.class.getResource(resourcePath);</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">		if(resourceUrl == null)</span>
		{
<span class="nc bnc" id="L775" title="All 2 branches missed.">			if(logger.isErrorEnabled()) logger.error(&quot;Couldn't find resource {}!&quot;, resourcePath);</span>
<span class="nc" id="L776">			return;</span>
		}
<span class="nc" id="L778">		copy(resourceUrl, file, delete);</span>
<span class="nc" id="L779">	}</span>

	private void copy(URL source, File target, boolean overwrite)
	{
<span class="nc bnc" id="L783" title="All 2 branches missed.">		if(overwrite)</span>
		{
<span class="nc bnc" id="L785" title="All 2 branches missed.">			if(target.isFile())</span>
			{
<span class="nc bnc" id="L787" title="All 2 branches missed.">				if(target.delete())</span>
				{
<span class="nc bnc" id="L789" title="All 2 branches missed.">					if(logger.isInfoEnabled()) logger.info(&quot;Deleted {}. &quot;, target.getAbsolutePath());</span>
				}
				else
				{
<span class="nc bnc" id="L793" title="All 2 branches missed.">					if(logger.isWarnEnabled())</span>
					{
<span class="nc" id="L795">						logger.warn(&quot;Tried to delete {} but couldn't!&quot;, target.getAbsolutePath());</span>
					}
				}
			}
		}

<span class="nc bnc" id="L801" title="All 2 branches missed.">		if(!target.isFile())</span>
		{
<span class="nc" id="L803">			InputStream is = null;</span>
<span class="nc" id="L804">			FileOutputStream os = null;</span>
			try
			{
<span class="nc" id="L807">				os = new FileOutputStream(target);</span>
<span class="nc" id="L808">				is = source.openStream();</span>
<span class="nc" id="L809">				IOUtils.copy(is, os);</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">				if(logger.isInfoEnabled())</span>
				{
<span class="nc" id="L812">					logger.info(&quot;Initialized file at '{}' with data from '{}'.&quot;, target.getAbsolutePath(), source);</span>
				}
			}
<span class="nc" id="L815">			catch(IOException e)</span>
			{
<span class="nc bnc" id="L817" title="All 2 branches missed.">				if(logger.isWarnEnabled())</span>
				{
<span class="nc" id="L819">					logger.warn(&quot;Exception while initializing '&quot; + target</span>
<span class="nc" id="L820">						.getAbsolutePath() + &quot;' with data from '&quot; + source + &quot;'.!&quot;, e);</span>
				}
			}
			finally
			{
<span class="nc" id="L825">				IOUtils.closeQuietly(is);</span>
<span class="nc" id="L826">				IOUtils.closeQuietly(os);</span>
			}
<span class="nc" id="L828">		}</span>
		else
		{
<span class="nc bnc" id="L831" title="All 2 branches missed.">			if(logger.isInfoEnabled()) logger.info(&quot;Won't overwrite '{}'.&quot;, target.getAbsolutePath());</span>
		}
<span class="nc" id="L833">	}</span>

	/**
	 * Returns a list of strings containing all non-empty, non-comment lines found in the given URL.
	 * Commented lines start with a #.
	 *
	 * @param url the URL to read the lines from.
	 * @return a List of type String containing all non-empty, non-comment lines.
	 */
	private List&lt;String&gt; readLines(URL url)
	{
<span class="nc" id="L844">		List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L845">		BufferedReader reader = null;</span>
		try
		{
<span class="nc" id="L848">			reader = new BufferedReader(new InputStreamReader(url.openStream()));</span>
			for(; ;)
			{
<span class="nc" id="L851">				String currentLine = reader.readLine();</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">				if(currentLine == null)</span>
				{
<span class="nc" id="L854">					break;</span>
				}
<span class="nc" id="L856">				currentLine = currentLine.trim();</span>
<span class="nc bnc" id="L857" title="All 4 branches missed.">				if(!&quot;&quot;.equals(currentLine) &amp;&amp; !currentLine.startsWith(&quot;#&quot;))</span>
				{
<span class="nc" id="L859">					result.add(currentLine);</span>
				}
<span class="nc" id="L861">			}</span>
		}
<span class="nc" id="L863">		catch(IOException e)</span>
		{
<span class="nc bnc" id="L865" title="All 2 branches missed.">			if(logger.isWarnEnabled()) logger.warn(&quot;Exception while reading lines from &quot; + url + &quot;!&quot;, e);</span>
		}
		finally
		{
<span class="nc bnc" id="L869" title="All 2 branches missed.">			if(reader != null)</span>
			{
				try
				{
<span class="nc" id="L873">					reader.close();</span>
				}
<span class="nc" id="L875">				catch(IOException e)</span>
				{
					// ignore
<span class="nc" id="L878">				}</span>
			}
		}
<span class="nc" id="L881">		return result;</span>
	}

	public File getDetailsViewRoot()
	{
<span class="nc bnc" id="L886" title="All 2 branches missed.">		if(detailsViewRoot != null)</span>
		{
<span class="nc" id="L888">			return detailsViewRoot;</span>
		}
<span class="nc" id="L890">		initDetailsViewRoot(false);</span>
<span class="nc" id="L891">		return detailsViewRoot;</span>
	}

	public URL getDetailsViewRootUrl()
	{
<span class="nc bnc" id="L896" title="All 2 branches missed.">		if(detailsViewRootUrl != null)</span>
		{
<span class="nc" id="L898">			return detailsViewRootUrl;</span>
		}
<span class="nc" id="L900">		initDetailsViewRoot(false);</span>
<span class="nc" id="L901">		return detailsViewRootUrl;</span>
	}

	public boolean isValidSource(String source)
	{
<span class="nc bnc" id="L906" title="All 2 branches missed.">		if(source == null)</span>
		{
<span class="nc" id="L908">			return false;</span>
		}
<span class="nc" id="L910">		SourceFiltering filtering = getSourceFiltering();</span>
<span class="nc bnc" id="L911" title="All 3 branches missed.">		switch(filtering)</span>
		{
			case BLACKLIST:
<span class="nc bnc" id="L914" title="All 2 branches missed.">				return !isBlackListed(source);</span>
			case WHITELIST:
<span class="nc" id="L916">				return isWhiteListed(source);</span>
		}
<span class="nc" id="L918">		return true;</span>
	}

	public boolean isBlackListed(String source)
	{
<span class="nc bnc" id="L923" title="All 2 branches missed.">		if(blackList == null)</span>
		{
<span class="nc" id="L925">			String listName = getBlackListName();</span>
<span class="nc" id="L926">			initSourceLists();</span>
<span class="nc" id="L927">			blackList = sourceLists.get(listName);</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">			if(blackList == null)</span>
			{
				// meaning there was no list of the given blacklist name.
<span class="nc bnc" id="L931" title="All 2 branches missed.">				if(logger.isInfoEnabled()) logger.info(&quot;Couldn't find blacklist '{}'!&quot;, listName);</span>
<span class="nc" id="L932">				setSourceFiltering(SourceFiltering.NONE);</span>
<span class="nc" id="L933">				setBlackListName(&quot;&quot;);</span>
<span class="nc" id="L934">				return true;</span>
			}
		}
<span class="nc" id="L937">		return blackList.contains(source);</span>
	}

	public void setBlackListName(String name)
	{
<span class="nc" id="L942">		Object oldValue = getBlackListName();</span>
<span class="nc" id="L943">		PREFERENCES.put(BLACK_LIST_NAME_PROPERTY, name);</span>
<span class="nc" id="L944">		Object newValue = getBlackListName();</span>
<span class="nc" id="L945">		propertyChangeSupport.firePropertyChange(BLACK_LIST_NAME_PROPERTY, oldValue, newValue);</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">		if(logger.isInfoEnabled()) logger.info(&quot;BlackListName set to {}.&quot;, newValue);</span>
<span class="nc" id="L947">	}</span>

	public String getBlackListName()
	{
<span class="nc" id="L951">		return PREFERENCES.get(BLACK_LIST_NAME_PROPERTY, &quot;&quot;);</span>
	}

	public boolean isWhiteListed(String source)
	{
<span class="nc bnc" id="L956" title="All 2 branches missed.">		if(whiteList == null)</span>
		{
<span class="nc" id="L958">			String listName = getWhiteListName();</span>
<span class="nc" id="L959">			initSourceLists();</span>
<span class="nc" id="L960">			whiteList = sourceLists.get(listName);</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">			if(whiteList == null)</span>
			{
				// meaning there was no list of the given blacklist name.
<span class="nc bnc" id="L964" title="All 2 branches missed.">				if(logger.isInfoEnabled()) logger.info(&quot;Couldn't find whitelist '{}'!&quot;, listName);</span>
<span class="nc" id="L965">				setSourceFiltering(SourceFiltering.NONE);</span>
<span class="nc" id="L966">				setWhiteListName(&quot;&quot;);</span>
<span class="nc" id="L967">				return true;</span>
			}
		}
<span class="nc" id="L970">		return whiteList.contains(source);</span>
	}

	public void setWhiteListName(String name)
	{
<span class="nc" id="L975">		Object oldValue = getWhiteListName();</span>
<span class="nc" id="L976">		PREFERENCES.put(WHITE_LIST_NAME_PROPERTY, name);</span>
<span class="nc" id="L977">		Object newValue = getWhiteListName();</span>
<span class="nc" id="L978">		propertyChangeSupport.firePropertyChange(WHITE_LIST_NAME_PROPERTY, oldValue, newValue);</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">		if(logger.isInfoEnabled()) logger.info(&quot;WhiteListName set to {}.&quot;, newValue);</span>
<span class="nc" id="L980">	}</span>

	public String getWhiteListName()
	{
<span class="nc" id="L984">		return PREFERENCES.get(WHITE_LIST_NAME_PROPERTY, &quot;&quot;);</span>
	}

	public void setLookAndFeel(String name)
	{
<span class="nc" id="L989">		Object oldValue = getLookAndFeel();</span>
<span class="nc" id="L990">		PREFERENCES.put(LOOK_AND_FEEL_PROPERTY, name);</span>
<span class="nc" id="L991">		Object newValue = getLookAndFeel();</span>
<span class="nc" id="L992">		propertyChangeSupport.firePropertyChange(LOOK_AND_FEEL_PROPERTY, oldValue, newValue);</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">		if(logger.isInfoEnabled()) logger.info(&quot;LookAndFeel set to {}.&quot;, newValue);</span>
<span class="nc" id="L994">	}</span>

	public String getLookAndFeel()
	{
<span class="nc" id="L998">		String result = PREFERENCES.get(LOOK_AND_FEEL_PROPERTY, STARTUP_LOOK_AND_FEEL);</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">		if(!installedLookAndFeels.contains(result))</span>
		{
<span class="nc" id="L1001">			result = STARTUP_LOOK_AND_FEEL;</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">			if(logger.isInfoEnabled()) logger.info(&quot;Look and Feel corrected to \&quot;{}\&quot;.&quot;, result);</span>
		}
<span class="nc" id="L1004">		return result;</span>
	}

	private void initConditions()
	{
<span class="nc" id="L1009">		File appPath = getStartupApplicationPath();</span>
<span class="nc" id="L1010">		File conditionsFile = new File(appPath, CONDITIONS_XML_FILENAME);</span>

<span class="nc bnc" id="L1012" title="All 2 branches missed.">		if(conditionsFile.isFile())</span>
		{
<span class="nc" id="L1014">			long lastModified = conditionsFile.lastModified();</span>
<span class="nc bnc" id="L1015" title="All 4 branches missed.">			if(conditions != null &amp;&amp; lastConditionsModified &gt;= lastModified)</span>
			{
<span class="nc bnc" id="L1017" title="All 2 branches missed.">				if(logger.isDebugEnabled()) logger.debug(&quot;Won't reload conditions.&quot;);</span>
<span class="nc" id="L1018">				return;</span>
			}
<span class="nc" id="L1020">			XMLDecoder d = null;</span>
			try
			{
<span class="nc" id="L1023">				d = new XMLDecoder(</span>
					new BufferedInputStream(
						new FileInputStream(conditionsFile)));

				//noinspection unchecked
<span class="nc" id="L1028">				conditions = (List&lt;SavedCondition&gt;) d.readObject();</span>
<span class="nc" id="L1029">				lastConditionsModified = lastModified;</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">				if(logger.isDebugEnabled()) logger.debug(&quot;Loaded conditions {}.&quot;, conditions);</span>
			}
<span class="nc" id="L1032">			catch(Throwable ex)</span>
			{
<span class="nc bnc" id="L1034" title="All 2 branches missed.">				if(logger.isWarnEnabled())</span>
				{
<span class="nc" id="L1036">					logger.warn(&quot;Exception while loading conditions from file '&quot; + conditionsFile</span>
<span class="nc" id="L1037">						.getAbsolutePath() + &quot;'!&quot;, ex);</span>
				}
			}
			finally
			{
<span class="nc bnc" id="L1042" title="All 2 branches missed.">				if(d != null)</span>
				{
<span class="nc" id="L1044">					d.close();</span>
				}
			}
		}

<span class="nc bnc" id="L1049" title="All 2 branches missed.">		if(conditions == null)</span>
		{
<span class="nc" id="L1051">			conditions = new ArrayList&lt;SavedCondition&gt;();</span>
		}
<span class="nc" id="L1053">	}</span>

	public SavedCondition resolveSavedCondition(Condition condition)
	{
<span class="nc bnc" id="L1057" title="All 2 branches missed.">		if(condition == null)</span>
		{
<span class="nc" id="L1059">			return null;</span>
		}
<span class="nc" id="L1061">		initConditions();</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">		for(SavedCondition current : conditions)</span>
		{
<span class="nc bnc" id="L1064" title="All 2 branches missed.">			if(condition.equals(current.getCondition()))</span>
			{
				try
				{
<span class="nc" id="L1068">					return current.clone();</span>
				}
<span class="nc" id="L1070">				catch(CloneNotSupportedException e)</span>
				{
<span class="nc" id="L1072">					return null;</span>
				}
			}
<span class="nc" id="L1075">		}</span>
<span class="nc" id="L1076">		return null;</span>
	}

	public SavedCondition resolveSavedCondition(String conditionName)
	{
<span class="nc bnc" id="L1081" title="All 2 branches missed.">		if(conditionName == null)</span>
		{
<span class="nc" id="L1083">			return null;</span>
		}
<span class="nc" id="L1085">		initConditions();</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">		for(SavedCondition current : conditions)</span>
		{
<span class="nc bnc" id="L1088" title="All 2 branches missed.">			if(conditionName.equals(current.getName()))</span>
			{
				try
				{
<span class="nc" id="L1092">					return current.clone();</span>
				}
<span class="nc" id="L1094">				catch(CloneNotSupportedException e)</span>
				{
<span class="nc" id="L1096">					return null;</span>
				}
			}
<span class="nc" id="L1099">		}</span>
<span class="nc" id="L1100">		return null;</span>
	}


	public List&lt;SavedCondition&gt; getConditions()
	{
<span class="nc" id="L1106">		initConditions();</span>

		// perform deep clone... otherwise no propchange would be fired.
<span class="nc" id="L1109">		ArrayList&lt;SavedCondition&gt; result = new ArrayList&lt;SavedCondition&gt;(conditions.size());</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">		for(SavedCondition current : conditions)</span>
		{
			try
			{
<span class="nc" id="L1114">				result.add(current.clone());</span>
			}
<span class="nc" id="L1116">			catch(CloneNotSupportedException e)</span>
			{
				// ignore
<span class="nc" id="L1119">			}</span>
<span class="nc" id="L1120">		}</span>

<span class="nc" id="L1122">		return result;</span>
	}

	public void setConditions(List&lt;SavedCondition&gt; conditions)
	{
<span class="nc" id="L1127">		Object oldValue = getConditions();</span>
<span class="nc" id="L1128">		writeConditions(conditions);</span>
<span class="nc" id="L1129">		Object newValue = getConditions();</span>
<span class="nc" id="L1130">		propertyChangeSupport.firePropertyChange(CONDITIONS_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1131">	}</span>

	public void setAutoOpening(boolean autoOpening)
	{
<span class="nc" id="L1135">		Object oldValue = isAutoOpening();</span>
<span class="nc" id="L1136">		PREFERENCES.putBoolean(AUTO_OPENING_PROPERTY, autoOpening);</span>
<span class="nc" id="L1137">		Object newValue = isAutoOpening();</span>
<span class="nc" id="L1138">		propertyChangeSupport.firePropertyChange(AUTO_OPENING_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1139">	}</span>

	public boolean isAutoOpening()
	{
<span class="nc" id="L1143">		return PREFERENCES.getBoolean(AUTO_OPENING_PROPERTY, true);</span>
	}

	public void setShowingIdentifier(boolean showingIdentifierWithName)
	{
<span class="nc" id="L1148">		Object oldValue = isShowingIdentifier();</span>
<span class="nc" id="L1149">		PREFERENCES.putBoolean(SHOWING_IDENTIFIER_PROPERTY, showingIdentifierWithName);</span>
<span class="nc" id="L1150">		Object newValue = isShowingIdentifier();</span>
<span class="nc" id="L1151">		propertyChangeSupport.firePropertyChange(SHOWING_IDENTIFIER_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1152">	}</span>

	public boolean isShowingIdentifier()
	{
<span class="nc" id="L1156">		return PREFERENCES.getBoolean(SHOWING_IDENTIFIER_PROPERTY, true);</span>
	}

	public void setSplashScreenDisabled(boolean splashScreenDisabled)
	{
<span class="nc" id="L1161">		Object oldValue = isSplashScreenDisabled();</span>
<span class="nc" id="L1162">		PREFERENCES.putBoolean(SPLASH_SCREEN_DISABLED_PROPERTY, splashScreenDisabled);</span>
<span class="nc" id="L1163">		Object newValue = isSplashScreenDisabled();</span>
<span class="nc" id="L1164">		propertyChangeSupport.firePropertyChange(SPLASH_SCREEN_DISABLED_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1165">	}</span>

	public boolean isSplashScreenDisabled()
	{
<span class="nc" id="L1169">		return PREFERENCES.getBoolean(SPLASH_SCREEN_DISABLED_PROPERTY, false);</span>
	}

	public void setAskingBeforeQuit(boolean askingBeforeQuit)
	{
<span class="nc" id="L1174">		Object oldValue = isAskingBeforeQuit();</span>
<span class="nc" id="L1175">		PREFERENCES.putBoolean(ASKING_BEFORE_QUIT_PROPERTY, askingBeforeQuit);</span>
<span class="nc" id="L1176">		Object newValue = isAskingBeforeQuit();</span>
<span class="nc" id="L1177">		propertyChangeSupport.firePropertyChange(ASKING_BEFORE_QUIT_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1178">	}</span>

	public boolean isAskingBeforeQuit()
	{
<span class="nc" id="L1182">		return PREFERENCES.getBoolean(ASKING_BEFORE_QUIT_PROPERTY, false);</span>
	}

	public void setShowingFullCallstack(boolean showingFullCallstack)
	{
<span class="nc" id="L1187">		Object oldValue = isShowingFullCallstack();</span>
<span class="nc" id="L1188">		PREFERENCES.putBoolean(SHOWING_FULL_CALLSTACK_PROPERTY, showingFullCallstack);</span>
<span class="nc" id="L1189">		Object newValue = isShowingFullCallstack();</span>
<span class="nc" id="L1190">		propertyChangeSupport.firePropertyChange(SHOWING_FULL_CALLSTACK_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1191">	}</span>

	public boolean isShowingFullCallstack()
	{
<span class="nc" id="L1195">		return PREFERENCES.getBoolean(SHOWING_FULL_CALLSTACK_PROPERTY, false);</span>
	}

	public void setShowingStackTrace(boolean showingStackTrace)
	{
<span class="nc" id="L1200">		Object oldValue = isShowingStackTrace();</span>
<span class="nc" id="L1201">		PREFERENCES.putBoolean(SHOWING_STACKTRACE_PROPERTY, showingStackTrace);</span>
<span class="nc" id="L1202">		Object newValue = isShowingStackTrace();</span>
<span class="nc" id="L1203">		propertyChangeSupport.firePropertyChange(SHOWING_STACKTRACE_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1204">	}</span>

	public boolean isShowingStackTrace()
	{
<span class="nc" id="L1208">		return PREFERENCES.getBoolean(SHOWING_STACKTRACE_PROPERTY, true);</span>
	}

	public void setCleaningLogsOnExit(boolean cleaningLogsOnExit)
	{
<span class="nc" id="L1213">		Object oldValue = isCleaningLogsOnExit();</span>
<span class="nc" id="L1214">		PREFERENCES.putBoolean(CLEANING_LOGS_ON_EXIT_PROPERTY, cleaningLogsOnExit);</span>
<span class="nc" id="L1215">		Object newValue = isCleaningLogsOnExit();</span>
<span class="nc" id="L1216">		propertyChangeSupport.firePropertyChange(CLEANING_LOGS_ON_EXIT_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1217">	}</span>

	public boolean isCleaningLogsOnExit()
	{
<span class="nc" id="L1221">		return PREFERENCES.getBoolean(CLEANING_LOGS_ON_EXIT_PROPERTY, false);</span>
	}

	public void setColoringWholeRow(boolean coloringWholeRow)
	{
<span class="nc" id="L1226">		Object oldValue = isColoringWholeRow();</span>
<span class="nc" id="L1227">		PREFERENCES.putBoolean(COLORING_WHOLE_ROW_PROPERTY, coloringWholeRow);</span>
<span class="nc" id="L1228">		Object newValue = isColoringWholeRow();</span>
<span class="nc" id="L1229">		propertyChangeSupport.firePropertyChange(COLORING_WHOLE_ROW_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1230">	}</span>

	public boolean isColoringWholeRow()
	{
<span class="nc" id="L1234">		return PREFERENCES.getBoolean(COLORING_WHOLE_ROW_PROPERTY, false);</span>
	}

	public void setCheckingForUpdate(boolean checkingForUpdate)
	{
<span class="nc" id="L1239">		Object oldValue = isCheckingForUpdate();</span>
<span class="nc" id="L1240">		PREFERENCES.putBoolean(CHECKING_FOR_UPDATE_PROPERTY, checkingForUpdate);</span>
<span class="nc" id="L1241">		Object newValue = isCheckingForUpdate();</span>
<span class="nc" id="L1242">		propertyChangeSupport.firePropertyChange(CHECKING_FOR_UPDATE_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1243">	}</span>

	public boolean isCheckingForUpdate()
	{
<span class="nc" id="L1247">		return PREFERENCES.getBoolean(CHECKING_FOR_UPDATE_PROPERTY, true);</span>
	}

	public void setAutoClosing(boolean autoClosing)
	{
<span class="nc" id="L1252">		Object oldValue = isAutoClosing();</span>
<span class="nc" id="L1253">		PREFERENCES.putBoolean(AUTO_CLOSING_PROPERTY, autoClosing);</span>
<span class="nc" id="L1254">		Object newValue = isAutoClosing();</span>
<span class="nc" id="L1255">		propertyChangeSupport.firePropertyChange(AUTO_CLOSING_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1256">	}</span>

	public boolean isAutoClosing()
	{
<span class="nc" id="L1260">		return PREFERENCES.getBoolean(AUTO_CLOSING_PROPERTY, false);</span>
	}

	public File getImagePath()
	{
<span class="nc" id="L1265">		String imagePath = PREFERENCES.get(IMAGE_PATH_PROPERTY, USER_HOME);</span>
<span class="nc" id="L1266">		File result = new File(imagePath);</span>
<span class="nc bnc" id="L1267" title="All 2 branches missed.">		if(!result.isDirectory())</span>
		{
<span class="nc" id="L1269">			result = new File(USER_HOME);</span>
		}
<span class="nc" id="L1271">		return result;</span>
	}

	public void setImagePath(File imagePath)
	{
<span class="nc bnc" id="L1276" title="All 2 branches missed.">		if(!imagePath.isDirectory())</span>
		{
<span class="nc" id="L1278">			throw new IllegalArgumentException(&quot;'&quot; + imagePath.getAbsolutePath() + &quot;' is not a directory!&quot;);</span>
		}
<span class="nc" id="L1280">		Object oldValue = getImagePath();</span>
<span class="nc" id="L1281">		PREFERENCES.put(IMAGE_PATH_PROPERTY, imagePath.getAbsolutePath());</span>
<span class="nc" id="L1282">		Object newValue = getImagePath();</span>
<span class="nc" id="L1283">		propertyChangeSupport.firePropertyChange(IMAGE_PATH_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1284">	}</span>

	public File getPreviousOpenPath()
	{
<span class="nc" id="L1288">		String imagePath = PREFERENCES.get(PREVIOUS_OPEN_PATH_PROPERTY, USER_HOME);</span>
<span class="nc" id="L1289">		File result = new File(imagePath);</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">		if(!result.isDirectory())</span>
		{
<span class="nc" id="L1292">			result = new File(USER_HOME);</span>
		}
<span class="nc" id="L1294">		return result;</span>
	}

	public void setPreviousOpenPath(File openPath)
	{
<span class="nc bnc" id="L1299" title="All 2 branches missed.">		if(!openPath.isDirectory())</span>
		{
<span class="nc" id="L1301">			throw new IllegalArgumentException(&quot;'&quot; + openPath.getAbsolutePath() + &quot;' is not a directory!&quot;);</span>
		}
<span class="nc" id="L1303">		Object oldValue = getPreviousOpenPath();</span>
<span class="nc" id="L1304">		PREFERENCES.put(PREVIOUS_OPEN_PATH_PROPERTY, openPath.getAbsolutePath());</span>
<span class="nc" id="L1305">		Object newValue = getPreviousOpenPath();</span>
<span class="nc" id="L1306">		propertyChangeSupport.firePropertyChange(PREVIOUS_OPEN_PATH_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1307">	}</span>

	public File getPreviousImportPath()
	{
<span class="nc" id="L1311">		String imagePath = PREFERENCES.get(PREVIOUS_IMPORT_PATH_PROPERTY, USER_HOME);</span>
<span class="nc" id="L1312">		File result = new File(imagePath);</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">		if(!result.isDirectory())</span>
		{
<span class="nc" id="L1315">			result = new File(USER_HOME);</span>
		}
<span class="nc" id="L1317">		return result;</span>
	}

	public void setPreviousImportPath(File importPath)
	{
<span class="nc bnc" id="L1322" title="All 2 branches missed.">		if(!importPath.isDirectory())</span>
		{
<span class="nc" id="L1324">			throw new IllegalArgumentException(&quot;'&quot; + importPath.getAbsolutePath() + &quot;' is not a directory!&quot;);</span>
		}
<span class="nc" id="L1326">		Object oldValue = getPreviousImportPath();</span>
<span class="nc" id="L1327">		PREFERENCES.put(PREVIOUS_IMPORT_PATH_PROPERTY, importPath.getAbsolutePath());</span>
<span class="nc" id="L1328">		Object newValue = getPreviousImportPath();</span>
<span class="nc" id="L1329">		propertyChangeSupport.firePropertyChange(PREVIOUS_IMPORT_PATH_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1330">	}</span>

	public File getSoundPath()
	{
<span class="nc" id="L1334">		String soundPath = PREFERENCES.get(SOUND_PATH_PROPERTY, USER_HOME);</span>
<span class="nc" id="L1335">		File result = new File(soundPath);</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">		if(!result.isDirectory())</span>
		{
<span class="nc" id="L1338">			result = new File(USER_HOME);</span>
		}
<span class="nc" id="L1340">		return result;</span>
	}

	public void setSoundPath(File soundPath)
	{
<span class="nc bnc" id="L1345" title="All 2 branches missed.">		if(!soundPath.isDirectory())</span>
		{
<span class="nc" id="L1347">			throw new IllegalArgumentException(&quot;'&quot; + soundPath.getAbsolutePath() + &quot;' is not a directory!&quot;);</span>
		}
<span class="nc" id="L1349">		Object oldValue = getSoundPath();</span>
<span class="nc" id="L1350">		PREFERENCES.put(SOUND_PATH_PROPERTY, soundPath.getAbsolutePath());</span>
<span class="nc" id="L1351">		Object newValue = getSoundPath();</span>
<span class="nc" id="L1352">		propertyChangeSupport.firePropertyChange(SOUND_PATH_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1353">	}</span>

	public void setMute(boolean mute)
	{
<span class="nc" id="L1357">		Object oldValue = isMute();</span>
<span class="nc" id="L1358">		PREFERENCES.putBoolean(MUTE_PROPERTY, mute);</span>
<span class="nc" id="L1359">		Object newValue = isMute();</span>
<span class="nc" id="L1360">		propertyChangeSupport.firePropertyChange(MUTE_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1361">	}</span>

	public boolean isMute()
	{
<span class="nc" id="L1365">		return PREFERENCES.getBoolean(MUTE_PROPERTY, false);</span>
	}

	public void setLicensed(boolean licensed)
	{
<span class="nc" id="L1370">		Object oldValue = isLicensed();</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">		if(licensed)</span>
		{
<span class="nc" id="L1373">			PREFERENCES.put(LICENSED_PREFERENCES_KEY, Lilith.APP_VERSION);</span>
		}
		else
		{
<span class="nc" id="L1377">			PREFERENCES.remove(LICENSED_PREFERENCES_KEY);</span>
		}
<span class="nc" id="L1379">		Object newValue = isLicensed();</span>
<span class="nc" id="L1380">		propertyChangeSupport.firePropertyChange(LICENSED_PREFERENCES_KEY, oldValue, newValue);</span>
<span class="nc" id="L1381">	}</span>

	public boolean isLicensed()
	{
<span class="nc" id="L1385">		return Lilith.APP_VERSION.equals(PREFERENCES.get(LICENSED_PREFERENCES_KEY, null));</span>
	}

	public void setApplicationPath(File applicationPath)
	{
<span class="nc bnc" id="L1390" title="All 2 branches missed.">		if(applicationPath.mkdirs())</span>
		{
<span class="nc bnc" id="L1392" title="All 2 branches missed.">			if(logger.isInfoEnabled()) logger.info(&quot;Created directory {}.&quot;, applicationPath.getAbsolutePath());</span>
		}
<span class="nc bnc" id="L1394" title="All 2 branches missed.">		if(!applicationPath.isDirectory())</span>
		{
<span class="nc" id="L1396">			throw new IllegalArgumentException(&quot;'&quot; + applicationPath.getAbsolutePath() + &quot;' is not a directory!&quot;);</span>
		}
<span class="nc" id="L1398">		Object oldValue = getStartupApplicationPath(); // !!!</span>
<span class="nc" id="L1399">		PREFERENCES.put(APPLICATION_PATH_PROPERTY, applicationPath.getAbsolutePath());</span>
<span class="nc" id="L1400">		Object newValue = getApplicationPath();</span>
<span class="nc" id="L1401">		propertyChangeSupport.firePropertyChange(APPLICATION_PATH_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1402">	}</span>

	public File getApplicationPath()
	{
<span class="nc" id="L1406">		String appPath = PREFERENCES.get(APPLICATION_PATH_PROPERTY, DEFAULT_APPLICATION_PATH);</span>
<span class="nc" id="L1407">		File result = new File(appPath);</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">		if(result.mkdirs())</span>
		{
<span class="nc bnc" id="L1410" title="All 2 branches missed.">			if(logger.isInfoEnabled()) logger.info(&quot;Created directory {}.&quot;, result.getAbsolutePath());</span>
		}
<span class="nc" id="L1412">		return result;</span>
	}

	/**
	 * The StartupApplicationPath is initialized on application startup via ApplicationPreferences.getApplicationPath.
	 * If a part of the application needs the application path it should *always* use this method instead of
	 * getApplicationPath() since the application path might change while this one will always stay
	 * the same.
	 * &lt;p/&gt;
	 * A switch of the application path while the application is running isn't safe so it's changed for real
	 * upon next restart.
	 *
	 * @return the application path at startup time.
	 */
	public File getStartupApplicationPath()
	{
<span class="nc" id="L1428">		return startupApplicationPath;</span>
	}

	public void setUsingInternalFrames(boolean usingInternalFrames)
	{
<span class="nc" id="L1433">		Object oldValue = isUsingInternalFrames();</span>
<span class="nc" id="L1434">		PREFERENCES.putBoolean(USING_INTERNAL_FRAMES_PROPERTY, usingInternalFrames);</span>
<span class="nc" id="L1435">		Object newValue = isUsingInternalFrames();</span>
<span class="nc" id="L1436">		propertyChangeSupport.firePropertyChange(USING_INTERNAL_FRAMES_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1437">	}</span>

	public boolean isUsingInternalFrames()
	{
<span class="nc" id="L1441">		return PREFERENCES.getBoolean(USING_INTERNAL_FRAMES_PROPERTY, true);</span>
	}

	public void setAutoFocusingWindow(boolean autoFocusingWindow)
	{
<span class="nc" id="L1446">		Object oldValue = isAutoFocusingWindow();</span>
<span class="nc" id="L1447">		PREFERENCES.putBoolean(AUTO_FOCUSING_WINDOW_PROPERTY, autoFocusingWindow);</span>
<span class="nc" id="L1448">		Object newValue = isAutoFocusingWindow();</span>
<span class="nc" id="L1449">		propertyChangeSupport.firePropertyChange(AUTO_FOCUSING_WINDOW_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1450">	}</span>

	public boolean isAutoFocusingWindow()
	{
<span class="nc" id="L1454">		return PREFERENCES.getBoolean(AUTO_FOCUSING_WINDOW_PROPERTY, false);</span>
	}

	public void setSourceNames(Map&lt;String, String&gt; sourceNames)
	{
<span class="nc" id="L1459">		Object oldValue = getSourceNames();</span>
<span class="nc" id="L1460">		writeSourceNames(sourceNames);</span>
<span class="nc" id="L1461">		Object newValue = getSourceNames();</span>
<span class="nc" id="L1462">		propertyChangeSupport.firePropertyChange(SOURCE_NAMES_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1463">	}</span>

	public Map&lt;String, String&gt; getSourceNames()
	{
<span class="nc" id="L1467">		File appPath = getStartupApplicationPath();</span>
<span class="nc" id="L1468">		File sourceNamesFile = new File(appPath, SOURCE_NAMES_XML_FILENAME);</span>

<span class="nc bnc" id="L1470" title="All 2 branches missed.">		if(sourceNamesFile.isFile())</span>
		{
<span class="nc bnc" id="L1472" title="All 2 branches missed.">			if(loadSourceNamesXml(sourceNamesFile))</span>
			{
<span class="nc" id="L1474">				return new HashMap&lt;String, String&gt;(sourceNames);</span>
			}
		}

<span class="nc" id="L1478">		sourceNamesFile = new File(appPath, SOURCE_NAMES_PROPERTIES_FILENAME);</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">		if(sourceNamesFile.isFile())</span>
		{
<span class="nc bnc" id="L1481" title="All 2 branches missed.">			if(loadSourceNamesProperties(sourceNamesFile))</span>
			{
<span class="nc" id="L1483">				return new HashMap&lt;String, String&gt;(sourceNames);</span>
			}
		}
<span class="nc" id="L1486">		return new HashMap&lt;String, String&gt;(DEFAULT_SOURCE_NAMES);</span>
	}


	public Map&lt;String, String&gt; getSoundLocations()
	{
<span class="nc" id="L1492">		File appPath = getStartupApplicationPath();</span>
<span class="nc" id="L1493">		File file = new File(appPath, SOUND_LOCATIONS_XML_FILENAME);</span>

<span class="nc bnc" id="L1495" title="All 2 branches missed.">		if(file.isFile())</span>
		{
<span class="nc bnc" id="L1497" title="All 2 branches missed.">			if(loadSoundLocationsXml(file))</span>
			{
<span class="nc" id="L1499">				return new HashMap&lt;String, String&gt;(soundLocations);</span>
			}
		}

<span class="nc" id="L1503">		return new HashMap&lt;String, String&gt;(DEFAULT_SOUND_LOCATIONS);</span>
	}

	public void setSoundLocations(Map&lt;String, String&gt; soundLocations)
	{
<span class="nc" id="L1508">		Object oldValue = getSoundLocations();</span>
<span class="nc" id="L1509">		writeSoundLocations(soundLocations);</span>
<span class="nc" id="L1510">		Object newValue = getSoundLocations();</span>
<span class="nc" id="L1511">		propertyChangeSupport.firePropertyChange(SOUND_LOCATIONS_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1512">	}</span>

	public void resetSoundLocations()
	{
<span class="nc bnc" id="L1516" title="All 2 branches missed.">		if(logger.isInfoEnabled()) logger.info(&quot;Initializing preferences with default sound locations.&quot;);</span>
<span class="nc" id="L1517">		setSoundLocations(DEFAULT_SOUND_LOCATIONS);</span>
<span class="nc" id="L1518">	}</span>

	public void addPropertyChangeListener(PropertyChangeListener listener)
	{
<span class="nc" id="L1522">		propertyChangeSupport.addPropertyChangeListener(listener);</span>
<span class="nc" id="L1523">	}</span>

	public void removePropertyChangeListener(PropertyChangeListener listener)
	{
<span class="nc" id="L1527">		propertyChangeSupport.removePropertyChangeListener(listener);</span>
<span class="nc" id="L1528">	}</span>

	public void reset()
	{
<span class="nc" id="L1532">		final Logger logger = LoggerFactory.getLogger(ApplicationPreferences.class);</span>
<span class="nc" id="L1533">		boolean licensed = isLicensed();</span>
		try
		{
<span class="nc" id="L1536">			PREFERENCES.clear();</span>
<span class="nc" id="L1537">			resetSoundLocations();</span>
<span class="nc" id="L1538">			setLicensed(licensed);</span>
<span class="nc" id="L1539">			setApplicationPath(new File(DEFAULT_APPLICATION_PATH));</span>
		}
<span class="nc" id="L1541">		catch(BackingStoreException e)</span>
		{
<span class="nc bnc" id="L1543" title="All 2 branches missed.">			if(logger.isWarnEnabled()) logger.warn(&quot;Exception while clearing preferences!&quot;);</span>
<span class="nc" id="L1544">		}</span>
<span class="nc" id="L1545">	}</span>


	public void setScrollingToBottom(boolean scrollingToBottom)
	{
<span class="nc" id="L1550">		Object oldValue = isScrollingToBottom();</span>
<span class="nc" id="L1551">		PREFERENCES.putBoolean(SCROLLING_TO_BOTTOM_PROPERTY, scrollingToBottom);</span>
<span class="nc" id="L1552">		Object newValue = isScrollingToBottom();</span>
<span class="nc" id="L1553">		propertyChangeSupport.firePropertyChange(SCROLLING_TO_BOTTOM_PROPERTY, oldValue, newValue);</span>
<span class="nc" id="L1554">	}</span>

	public boolean isScrollingToBottom()
	{
<span class="nc" id="L1558">		return PREFERENCES.getBoolean(SCROLLING_TO_BOTTOM_PROPERTY, true);</span>
	}

	private boolean loadSoundLocationsXml(File file)
	{
<span class="nc" id="L1563">		long lastModified = file.lastModified();</span>
<span class="nc bnc" id="L1564" title="All 4 branches missed.">		if(soundLocations != null &amp;&amp; lastSoundLocationsModified &gt;= lastModified)</span>
		{
<span class="nc bnc" id="L1566" title="All 2 branches missed.">			if(logger.isDebugEnabled()) logger.debug(&quot;Won't reload sound locations.&quot;);</span>
<span class="nc" id="L1567">			return true;</span>
		}
<span class="nc" id="L1569">		Map&lt;String, String&gt; props = loadPropertiesXml(file);</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">		if(props != null)</span>
		{
<span class="nc" id="L1572">			lastSoundLocationsModified = lastModified;</span>
<span class="nc" id="L1573">			soundLocations = props;</span>
<span class="nc" id="L1574">			return true;</span>
		}
<span class="nc" id="L1576">		return false;</span>
	}

	private boolean writeSoundLocations(Map&lt;String, String&gt; sourceNames)
	{
<span class="nc" id="L1581">		File appPath = getStartupApplicationPath();</span>
<span class="nc" id="L1582">		File file = new File(appPath, SOUND_LOCATIONS_XML_FILENAME);</span>
<span class="nc" id="L1583">		return writePropertiesXml(file, sourceNames, &quot;Sound locations&quot;);</span>
	}

	private boolean loadSourceNamesXml(File file)
	{
<span class="nc" id="L1588">		long lastModified = file.lastModified();</span>
<span class="nc bnc" id="L1589" title="All 4 branches missed.">		if(sourceNames != null &amp;&amp; lastSourceNamesModified &gt;= lastModified)</span>
		{
<span class="nc bnc" id="L1591" title="All 2 branches missed.">			if(logger.isDebugEnabled()) logger.debug(&quot;Won't reload source names.&quot;);</span>
<span class="nc" id="L1592">			return true;</span>
		}
<span class="nc" id="L1594">		Map&lt;String, String&gt; props = loadPropertiesXml(file);</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">		if(props != null)</span>
		{
<span class="nc" id="L1597">			lastSourceNamesModified = lastModified;</span>
<span class="nc" id="L1598">			sourceNames = props;</span>
<span class="nc" id="L1599">			return true;</span>
		}
<span class="nc" id="L1601">		return false;</span>
	}

	private boolean loadSourceNamesProperties(File sourceNamesFile)
	{
<span class="nc" id="L1606">		long lastModified = sourceNamesFile.lastModified();</span>
<span class="nc bnc" id="L1607" title="All 4 branches missed.">		if(sourceNames != null &amp;&amp; lastSourceNamesModified &gt;= lastModified)</span>
		{
<span class="nc bnc" id="L1609" title="All 2 branches missed.">			if(logger.isDebugEnabled()) logger.debug(&quot;Won't reload source names.&quot;);</span>
<span class="nc" id="L1610">			return true;</span>
		}

<span class="nc" id="L1613">		Map&lt;String, String&gt; props = loadProperties(sourceNamesFile);</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">		if(props != null)</span>
		{
<span class="nc" id="L1616">			lastSourceNamesModified = lastModified;</span>
<span class="nc" id="L1617">			sourceNames = props;</span>
<span class="nc" id="L1618">			return true;</span>
		}
<span class="nc" id="L1620">		return false;</span>
	}

	private boolean writeSourceNames(Map&lt;String, String&gt; sourceNames)
	{
<span class="nc" id="L1625">		File appPath = getStartupApplicationPath();</span>
<span class="nc" id="L1626">		File file = new File(appPath, SOURCE_NAMES_XML_FILENAME);</span>
<span class="nc" id="L1627">		return writePropertiesXml(file, sourceNames, &quot;Source names&quot;);</span>
	}

	private boolean writeSourceLists(Map&lt;String, Set&lt;String&gt;&gt; sourceLists)
	{
<span class="nc" id="L1632">		File appPath = getStartupApplicationPath();</span>
<span class="nc" id="L1633">		File file = new File(appPath, SOURCE_LISTS_XML_FILENAME);</span>
<span class="nc" id="L1634">		XMLEncoder e = null;</span>
<span class="nc" id="L1635">		Throwable error = null;</span>
		try
		{
<span class="nc" id="L1638">			BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));</span>
<span class="nc" id="L1639">			e = new XMLEncoder(bos);</span>
<span class="nc" id="L1640">			e.writeObject(sourceLists);</span>
		}
<span class="nc" id="L1642">		catch(FileNotFoundException ex)</span>
		{
<span class="nc" id="L1644">			error = ex;</span>
		}
		finally
		{
<span class="nc bnc" id="L1648" title="All 2 branches missed.">			if(e != null)</span>
			{
<span class="nc" id="L1650">				e.close();</span>
			}
		}
<span class="nc bnc" id="L1653" title="All 2 branches missed.">		if(error != null)</span>
		{
<span class="nc bnc" id="L1655" title="All 2 branches missed.">			if(logger.isWarnEnabled()) logger.warn(&quot;Exception while writing source lists!&quot;, error);</span>
<span class="nc" id="L1656">			return false;</span>
		}
<span class="nc" id="L1658">		return true;</span>
	}

	private boolean writeConditions(List&lt;SavedCondition&gt; conditions)
	{
<span class="nc" id="L1663">		File appPath = getStartupApplicationPath();</span>
<span class="nc" id="L1664">		File file = new File(appPath, CONDITIONS_XML_FILENAME);</span>
<span class="nc" id="L1665">		XMLEncoder e = null;</span>
<span class="nc" id="L1666">		Throwable error = null;</span>
		try
		{
<span class="nc" id="L1669">			BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));</span>
<span class="nc" id="L1670">			e = new XMLEncoder(bos);</span>
<span class="nc" id="L1671">			e.writeObject(conditions);</span>
<span class="nc bnc" id="L1672" title="All 2 branches missed.">			if(logger.isInfoEnabled()) logger.info(&quot;Wrote conditions {}.&quot;, conditions);</span>
		}
<span class="nc" id="L1674">		catch(FileNotFoundException ex)</span>
		{
<span class="nc" id="L1676">			error = ex;</span>
		}
		finally
		{
<span class="nc bnc" id="L1680" title="All 2 branches missed.">			if(e != null)</span>
			{
<span class="nc" id="L1682">				e.close();</span>
			}
		}
<span class="nc bnc" id="L1685" title="All 2 branches missed.">		if(error != null)</span>
		{
<span class="nc bnc" id="L1687" title="All 2 branches missed.">			if(logger.isWarnEnabled()) logger.warn(&quot;Exception while writing source lists!&quot;, error);</span>
<span class="nc" id="L1688">			return false;</span>
		}
<span class="nc" id="L1690">		return true;</span>
	}

	/**
	 * @noinspection MismatchedQueryAndUpdateOfCollection
	 */
	private Map&lt;String, String&gt; loadPropertiesXml(File file)
	{
<span class="nc" id="L1698">		InputStream is = null;</span>
		try
		{
<span class="nc" id="L1701">			is = new BufferedInputStream(new FileInputStream(file));</span>
<span class="nc" id="L1702">			Properties props = new Properties();</span>
<span class="nc" id="L1703">			props.loadFromXML(is);</span>
<span class="nc" id="L1704">			Map&lt;String, String&gt; result = new HashMap&lt;String, String&gt;();</span>
<span class="nc bnc" id="L1705" title="All 2 branches missed.">			for(Object keyObj : props.keySet())</span>
			{
<span class="nc" id="L1707">				String key = (String) keyObj;</span>
<span class="nc" id="L1708">				String value = (String) props.get(key);</span>
<span class="nc bnc" id="L1709" title="All 2 branches missed.">				if(value != null)</span>
				{
<span class="nc" id="L1711">					result.put(key, value);</span>
				}
<span class="nc" id="L1713">			}</span>
<span class="nc" id="L1714">			return result;</span>
		}
<span class="nc" id="L1716">		catch(IOException e)</span>
		{
<span class="nc bnc" id="L1718" title="All 2 branches missed.">			if(logger.isWarnEnabled())</span>
			{
<span class="nc" id="L1720">				logger.warn(&quot;Couldn't load properties from '&quot; + file.getAbsolutePath() + &quot;'!&quot;, e);</span>
			}
		}
		finally
		{
<span class="nc" id="L1725">			IOUtils.closeQuietly(is);</span>
		}
<span class="nc" id="L1727">		return null;</span>
	}

	/**
	 * @noinspection MismatchedQueryAndUpdateOfCollection
	 */
	private boolean writePropertiesXml(File file, Map&lt;String, String&gt; sourceNames, String comment)
	{
<span class="nc" id="L1735">		Properties output = new Properties();</span>
<span class="nc bnc" id="L1736" title="All 2 branches missed.">		for(Map.Entry&lt;String, String&gt; entry : sourceNames.entrySet())</span>
		{
<span class="nc" id="L1738">			String key = entry.getKey();</span>
<span class="nc" id="L1739">			String value = entry.getValue();</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">			if(value != null)</span>
			{
<span class="nc" id="L1742">				output.put(key, value);</span>
			}
<span class="nc" id="L1744">		}</span>
<span class="nc" id="L1745">		OutputStream os = null;</span>
<span class="nc" id="L1746">		Throwable error = null;</span>
		try
		{
<span class="nc" id="L1749">			os = new BufferedOutputStream(new FileOutputStream(file));</span>
<span class="nc" id="L1750">			output.storeToXML(os, comment, &quot;UTF-8&quot;);</span>
		}
<span class="nc" id="L1752">		catch(FileNotFoundException e)</span>
		{
<span class="nc" id="L1754">			error = e;</span>
		}
<span class="nc" id="L1756">		catch(IOException e)</span>
		{
<span class="nc" id="L1758">			error = e;</span>
		}
		finally
		{
<span class="nc" id="L1762">			IOUtils.closeQuietly(os);</span>
		}
<span class="nc bnc" id="L1764" title="All 2 branches missed.">		if(error != null)</span>
		{
<span class="nc bnc" id="L1766" title="All 2 branches missed.">			if(logger.isWarnEnabled()) logger.warn(&quot;Exception while writing source names!&quot;, error);</span>
<span class="nc" id="L1767">			return false;</span>
		}
<span class="nc" id="L1769">		return true;</span>
	}


	private Map&lt;String, String&gt; loadProperties(File file)
	{
<span class="nc" id="L1775">		InputStream is = null;</span>
		try
		{
<span class="nc" id="L1778">			is = new BufferedInputStream(new FileInputStream(file));</span>
<span class="nc" id="L1779">			Properties props = new Properties();</span>
<span class="nc" id="L1780">			props.load(is);</span>
<span class="nc" id="L1781">			Map&lt;String, String&gt; result = new HashMap&lt;String, String&gt;();</span>
<span class="nc bnc" id="L1782" title="All 2 branches missed.">			for(Object keyObj : props.keySet())</span>
			{
<span class="nc" id="L1784">				String key = (String) keyObj;</span>
<span class="nc" id="L1785">				String value = (String) props.get(key);</span>
<span class="nc bnc" id="L1786" title="All 2 branches missed.">				if(value != null)</span>
				{
<span class="nc" id="L1788">					result.put(key, value);</span>
				}
<span class="nc" id="L1790">			}</span>
<span class="nc" id="L1791">			return result;</span>
		}
<span class="nc" id="L1793">		catch(IOException e)</span>
		{
<span class="nc bnc" id="L1795" title="All 2 branches missed.">			if(logger.isWarnEnabled())</span>
			{
<span class="nc" id="L1797">				logger.warn(&quot;Couldn't load properties from '&quot; + file.getAbsolutePath() + &quot;'!&quot;, e);</span>
			}
		}
		finally
		{
<span class="nc" id="L1802">			IOUtils.closeQuietly(is);</span>
		}
<span class="nc" id="L1804">		return null;</span>
	}

	public void writeLoggingColumnLayout(boolean global, List&lt;PersistentTableColumnModel.TableColumnLayoutInfo&gt; layoutInfos)
	{
<span class="nc" id="L1809">		File appPath = getStartupApplicationPath();</span>
		File file;
<span class="nc bnc" id="L1811" title="All 2 branches missed.">		if(global)</span>
		{
<span class="nc" id="L1813">			file = new File(appPath, LOGGING_LAYOUT_GLOBAL_XML_FILENAME);</span>
		}
		else
		{
<span class="nc" id="L1817">			file = new File(appPath, LOGGING_LAYOUT_XML_FILENAME);</span>
		}
<span class="nc" id="L1819">		writeColumnLayout(file, layoutInfos);</span>
<span class="nc" id="L1820">	}</span>

	public void writeAccessColumnLayout(boolean global, List&lt;PersistentTableColumnModel.TableColumnLayoutInfo&gt; layoutInfos)
	{
<span class="nc" id="L1824">		File appPath = getStartupApplicationPath();</span>
		File file;
<span class="nc bnc" id="L1826" title="All 2 branches missed.">		if(global)</span>
		{
<span class="nc" id="L1828">			file = new File(appPath, ACCESS_LAYOUT_GLOBAL_XML_FILENAME);</span>
		}
		else
		{
<span class="nc" id="L1832">			file = new File(appPath, ACCESS_LAYOUT_XML_FILENAME);</span>
		}
<span class="nc" id="L1834">		writeColumnLayout(file, layoutInfos);</span>
<span class="nc" id="L1835">	}</span>

	public List&lt;PersistentTableColumnModel.TableColumnLayoutInfo&gt; readLoggingColumnLayout(boolean global)
	{
<span class="nc" id="L1839">		File appPath = getStartupApplicationPath();</span>
		File file;
<span class="nc bnc" id="L1841" title="All 2 branches missed.">		if(global)</span>
		{
<span class="nc" id="L1843">			file = new File(appPath, LOGGING_LAYOUT_GLOBAL_XML_FILENAME);</span>
		}
		else
		{
<span class="nc" id="L1847">			file = new File(appPath, LOGGING_LAYOUT_XML_FILENAME);</span>
		}
<span class="nc" id="L1849">		return readColumnLayout(file);</span>
	}

	public List&lt;PersistentTableColumnModel.TableColumnLayoutInfo&gt; readAccessColumnLayout(boolean global)
	{
<span class="nc" id="L1854">		File appPath = getStartupApplicationPath();</span>
		File file;
<span class="nc bnc" id="L1856" title="All 2 branches missed.">		if(global)</span>
		{
<span class="nc" id="L1858">			file = new File(appPath, ACCESS_LAYOUT_GLOBAL_XML_FILENAME);</span>
		}
		else
		{
<span class="nc" id="L1862">			file = new File(appPath, ACCESS_LAYOUT_XML_FILENAME);</span>
		}
<span class="nc" id="L1864">		return readColumnLayout(file);</span>
	}

	private boolean writeColumnLayout(File file, List&lt;PersistentTableColumnModel.TableColumnLayoutInfo&gt; layoutInfos)
	{
<span class="nc" id="L1869">		XMLEncoder e = null;</span>
<span class="nc" id="L1870">		Throwable error = null;</span>
		try
		{
<span class="nc" id="L1873">			BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));</span>
<span class="nc" id="L1874">			e = new XMLEncoder(bos);</span>
<span class="nc" id="L1875">			e.writeObject(layoutInfos);</span>
<span class="nc bnc" id="L1876" title="All 2 branches missed.">			if(logger.isInfoEnabled())</span>
			{
<span class="nc" id="L1878">				logger.info(&quot;Wrote layouts {} to file '{}'.&quot;, layoutInfos, file.getAbsolutePath());</span>
			}
		}
<span class="nc" id="L1881">		catch(FileNotFoundException ex)</span>
		{
<span class="nc" id="L1883">			error = ex;</span>
		}
		finally
		{
<span class="nc bnc" id="L1887" title="All 2 branches missed.">			if(e != null)</span>
			{
<span class="nc" id="L1889">				e.close();</span>
			}
		}
<span class="nc bnc" id="L1892" title="All 2 branches missed.">		if(error != null)</span>
		{
<span class="nc bnc" id="L1894" title="All 2 branches missed.">			if(logger.isWarnEnabled())</span>
			{
<span class="nc" id="L1896">				logger.warn(&quot;Exception while writing layouts to file '&quot; + file.getAbsolutePath() + &quot;'!&quot;, error);</span>
			}
<span class="nc" id="L1898">			return false;</span>
		}
<span class="nc" id="L1900">		return true;</span>
	}

	private List&lt;PersistentTableColumnModel.TableColumnLayoutInfo&gt; readColumnLayout(File file)
	{
<span class="nc" id="L1905">		XMLDecoder d = null;</span>
		List&lt;PersistentTableColumnModel.TableColumnLayoutInfo&gt; result;
		try
		{
<span class="nc" id="L1909">			d = new XMLDecoder(</span>
				new BufferedInputStream(
					new FileInputStream(file)));

			//noinspection unchecked
<span class="nc" id="L1914">			result = (List&lt;PersistentTableColumnModel.TableColumnLayoutInfo&gt;) d.readObject();</span>
		}
<span class="nc" id="L1916">		catch(Throwable ex)</span>
		{
<span class="nc bnc" id="L1918" title="All 2 branches missed.">			if(logger.isInfoEnabled())</span>
			{
<span class="nc" id="L1920">				logger</span>
<span class="nc" id="L1921">					.info(&quot;Exception while loading layouts from file '{}'':&quot;, file.getAbsolutePath(), ex.getMessage());</span>
			}
<span class="nc" id="L1923">			result = null;</span>
		}
		finally
		{
<span class="nc bnc" id="L1927" title="All 2 branches missed.">			if(d != null)</span>
			{
<span class="nc" id="L1929">				d.close();</span>
			}
		}
<span class="nc" id="L1932">		return result;</span>
	}

	/**
	 * Quick &amp; dirty MD5 checksum function.
	 * Returns null in case of error.
	 *
	 * @param input the input
	 * @return the checksum
	 */
	public static byte[] getMD5(InputStream input)
	{
<span class="nc bnc" id="L1944" title="All 2 branches missed.">		if(input == null)</span>
		{
<span class="nc" id="L1946">			return null;</span>
		}
		MessageDigest messageDigest;
		try
		{
<span class="nc" id="L1951">			messageDigest = MessageDigest.getInstance(&quot;MD5&quot;);</span>
<span class="nc" id="L1952">			byte[] buffer = new byte[1024];</span>
			for(; ;)
			{
<span class="nc" id="L1955">				int read = input.read(buffer);</span>
<span class="nc bnc" id="L1956" title="All 2 branches missed.">				if(read &lt; 0)</span>
				{
<span class="nc" id="L1958">					break;</span>
				}
<span class="nc" id="L1960">				messageDigest.update(buffer, 0, read);</span>
<span class="nc" id="L1961">			}</span>
<span class="nc" id="L1962">			return messageDigest.digest();</span>
		}
<span class="nc" id="L1964">		catch(Throwable t)</span>
		{
<span class="nc" id="L1966">			final Logger logger = LoggerFactory.getLogger(ApplicationPreferences.class);</span>
<span class="nc bnc" id="L1967" title="All 2 branches missed.">			if(logger.isWarnEnabled()) logger.warn(&quot;Exception while calculating checksum!&quot;, t);</span>
		}
		finally
		{
			try
			{
<span class="nc" id="L1973">				input.close();</span>
			}
<span class="nc" id="L1975">			catch(IOException e)</span>
			{
				// ignore
<span class="nc" id="L1978">			}</span>
		}
<span class="nc" id="L1980">		return null;</span>
	}

	public void flush()
	{
		try
		{
<span class="nc" id="L1987">			PREFERENCES.flush();</span>
		}
<span class="nc" id="L1989">		catch(BackingStoreException e)</span>
		{
<span class="nc bnc" id="L1991" title="All 2 branches missed.">			if(logger.isWarnEnabled()) logger.warn(&quot;Exception while flushing preferences!&quot;, e);</span>
<span class="nc" id="L1992">		}</span>
<span class="nc" id="L1993">	}</span>

	/**
	 * As described in http://weblogs.java.net/blog/malenkov/archive/2006/08/how_to_encode_e.html
	 */
<span class="nc" id="L1998">	static class EnumPersistenceDelegate</span>
		extends PersistenceDelegate
	{
		protected boolean mutatesTo(Object oldInstance, Object newInstance)
		{
<span class="nc bnc" id="L2003" title="All 2 branches missed.">			return oldInstance == newInstance;</span>
		}

		protected Expression instantiate(Object oldInstance, Encoder out)
		{
<span class="nc" id="L2008">			Enum e = (Enum) oldInstance;</span>
<span class="nc" id="L2009">			return new Expression(e, e.getClass(), &quot;valueOf&quot;, new Object[]{e.name()});</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>