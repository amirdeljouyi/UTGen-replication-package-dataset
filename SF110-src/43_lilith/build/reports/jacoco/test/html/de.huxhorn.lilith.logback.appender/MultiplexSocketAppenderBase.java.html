<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MultiplexSocketAppenderBase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">43_lilith</a> &gt; <a href="index.source.html" class="el_package">de.huxhorn.lilith.logback.appender</a> &gt; <span class="el_source">MultiplexSocketAppenderBase.java</span></div><h1>MultiplexSocketAppenderBase.java</h1><pre class="source lang-java linenums">/*
 * Lilith - a log event viewer.
 * Copyright (C) 2007-2009 Joern Huxhorn
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package de.huxhorn.lilith.logback.appender;


import de.huxhorn.lilith.sender.HeartbeatRunnable;
import de.huxhorn.lilith.sender.MessageWriteByteStrategy;
import de.huxhorn.lilith.sender.MultiplexSendBytesService;
import de.huxhorn.lilith.sender.WriteByteStrategy;
import de.huxhorn.sulky.codec.Encoder;

import ch.qos.logback.core.UnsynchronizedAppenderBase;

import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

public abstract class MultiplexSocketAppenderBase&lt;E&gt;
	extends UnsynchronizedAppenderBase&lt;E&gt;
{
	private static final int DEFAULT_QUEUE_SIZE = 1000;

	private Encoder&lt;E&gt; encoder;
	private int port;
	private List&lt;String&gt; remoteHostsList;
	private String applicationIdentifier;
	private Thread heartbeatThread;
	private int reconnectionDelay;
	private WriteByteStrategy writeByteStrategy;
	private int queueSize;
	private MultiplexSendBytesService multiplexSendBytes;
	private boolean debug;

	public MultiplexSocketAppenderBase()
	{
<span class="nc" id="L52">		this(new MessageWriteByteStrategy());</span>
<span class="nc" id="L53">	}</span>

	public MultiplexSocketAppenderBase(WriteByteStrategy writeByteStrategy)
	{
<span class="nc" id="L57">		this(writeByteStrategy, DEFAULT_QUEUE_SIZE);</span>
<span class="nc" id="L58">	}</span>

	public MultiplexSocketAppenderBase(WriteByteStrategy writeByteStrategy, int queueSize)
<span class="nc" id="L61">	{</span>
<span class="nc" id="L62">		this.writeByteStrategy = writeByteStrategy;</span>
<span class="nc" id="L63">		setQueueSize(queueSize);</span>
<span class="nc" id="L64">	}</span>

	public boolean isDebug()
	{
<span class="nc" id="L68">		return debug;</span>
	}

	public void setDebug(boolean debug)
	{
<span class="nc" id="L73">		this.debug = debug;</span>
<span class="nc" id="L74">	}</span>

	public int getQueueSize()
	{
<span class="nc" id="L78">		return queueSize;</span>
	}

	public void setQueueSize(int queueSize)
	{
<span class="nc" id="L83">		this.queueSize = queueSize;</span>
<span class="nc" id="L84">	}</span>

	public String getApplicationIdentifier()
	{
<span class="nc" id="L88">		return applicationIdentifier;</span>
	}

	public void setApplicationIdentifier(String applicationIdentifier)
	{
<span class="nc" id="L93">		this.applicationIdentifier = applicationIdentifier;</span>
<span class="nc" id="L94">		applicationIdentifierChanged();</span>
<span class="nc" id="L95">	}</span>

	protected abstract void applicationIdentifierChanged(); 

	public int getReconnectionDelay()
	{
<span class="nc" id="L101">		return reconnectionDelay;</span>
	}

	public void setReconnectionDelay(int reconnectionDelay)
	{
<span class="nc" id="L106">		this.reconnectionDelay = reconnectionDelay;</span>
<span class="nc" id="L107">	}</span>

	public int getPort()
	{
<span class="nc" id="L111">		return port;</span>
	}

	public void setPort(int port)
	{
<span class="nc" id="L116">		this.port = port;</span>
<span class="nc" id="L117">	}</span>

	public List&lt;String&gt; getRemoteHostsList()
	{
<span class="nc" id="L121">		return new ArrayList&lt;String&gt;(remoteHostsList);</span>
	}

	/**
	 * Sets the remote host list by splitting the string remoteHosts. It is expected to be comma-separated.
	 *
	 * @param remoteHosts comma-seperated list of hosts.
	 */
	public void setRemoteHosts(String remoteHosts)
	{
<span class="nc" id="L131">		StringTokenizer tok = new StringTokenizer(remoteHosts, &quot;,&quot;, false);</span>
<span class="nc" id="L132">		List&lt;String&gt; hosts = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">		while(tok.hasMoreTokens())</span>
		{
<span class="nc" id="L135">			String current = tok.nextToken();</span>
<span class="nc" id="L136">			current = current.trim();</span>
<span class="nc bnc" id="L137" title="All 4 branches missed.">			if(!&quot;&quot;.equals(current) &amp;&amp; !hosts.contains(current))</span>
			{
<span class="nc" id="L139">				hosts.add(current);</span>
			}
<span class="nc" id="L141">		}</span>
<span class="nc" id="L142">		setRemoteHostsList(hosts);</span>
<span class="nc" id="L143">	}</span>

	/**
	 * Sets the list of remote hosts.
	 * &lt;p/&gt;
	 * This method should also be called setRemoteHosts but Joran explodes if it has the same name as the String version.
	 *
	 * @param remoteHostsList the list of remote hosts.
	 */
	public void setRemoteHostsList(List&lt;String&gt; remoteHostsList)
	{
<span class="nc bnc" id="L154" title="All 2 branches missed.">		if(debug)</span>
		{
<span class="nc" id="L156">			System.err.println(&quot;RemoteHosts: &quot; + remoteHostsList);</span>
		}
<span class="nc" id="L158">		this.remoteHostsList = remoteHostsList;</span>
<span class="nc" id="L159">	}</span>

	/**
	 * Start this appender.
	 */
	public void start()
	{
<span class="nc bnc" id="L166" title="All 2 branches missed.">		if(!started)</span>
		{
<span class="nc" id="L168">			int errorCount = 0;</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">			if(port == 0)</span>
			{
<span class="nc" id="L171">				errorCount++;</span>
<span class="nc" id="L172">				addError(&quot;No port was configured for appender&quot; + name + &quot;.&quot;);</span>
			}

<span class="nc bnc" id="L175" title="All 4 branches missed.">			if(remoteHostsList == null || remoteHostsList.size() == 0)</span>
			{
<span class="nc" id="L177">				errorCount++;</span>
<span class="nc" id="L178">				addError(&quot;No remote addresses were configured for appender&quot; + name + &quot;.&quot;);</span>
			}

<span class="nc bnc" id="L181" title="All 2 branches missed.">			if(queueSize &lt; 1)</span>
			{
<span class="nc" id="L183">				errorCount++;</span>
<span class="nc" id="L184">				addError(&quot;Invalid queue size configured for appender&quot; + name + &quot;. Queue size must be at least 1!&quot;);</span>
			}
<span class="nc bnc" id="L186" title="All 2 branches missed.">			if(errorCount == 0)</span>
			{
<span class="nc" id="L188">				initialize();</span>
<span class="nc" id="L189">				this.started = true;</span>
			}
<span class="nc" id="L191">			addInfo(&quot;Started &quot; + this);</span>
		}
<span class="nc" id="L193">	}</span>


	private void initialize()
	{
<span class="nc" id="L198">		multiplexSendBytes = new MultiplexSendBytesService(name, remoteHostsList, port, writeByteStrategy, reconnectionDelay, queueSize);</span>
<span class="nc" id="L199">		multiplexSendBytes.setDebug(debug);</span>
<span class="nc" id="L200">		multiplexSendBytes.startUp();</span>

		// TODO: add support for ip.ip.ip.ip:port
<span class="nc" id="L203">		heartbeatThread = new Thread(new HeartbeatRunnable(multiplexSendBytes), name + &quot; Heartbeat&quot;);</span>
<span class="nc" id="L204">		heartbeatThread.setDaemon(true);</span>
<span class="nc" id="L205">		heartbeatThread.start();</span>
<span class="nc" id="L206">	}</span>

	/**
	 * Stop this appender.
	 * &lt;p/&gt;
	 * This will mark the appender as closed and calls the {@link #cleanUp}
	 * method.
	 */
	@Override
	public void stop()
	{
<span class="nc bnc" id="L217" title="All 2 branches missed.">		if(!isStarted())</span>
		{
<span class="nc" id="L219">			return;</span>
		}

<span class="nc" id="L222">		this.started = false;</span>
<span class="nc" id="L223">		cleanUp();</span>
<span class="nc" id="L224">	}</span>

	private void cleanUp()
	{
<span class="nc" id="L228">		addInfo(&quot;Cleaning up &quot; + this + &quot;.&quot;);</span>
<span class="nc" id="L229">		heartbeatThread.interrupt();</span>
<span class="nc" id="L230">		multiplexSendBytes.shutDown();</span>
<span class="nc" id="L231">	}</span>

	protected void sendBytes(byte[] bytes)
	{
<span class="nc" id="L235">		multiplexSendBytes.sendBytes(bytes);</span>
<span class="nc" id="L236">	}</span>

	protected void append(E e)
	{
<span class="nc bnc" id="L240" title="All 2 branches missed.">		if(encoder != null)</span>
		{
<span class="nc" id="L242">			preProcess(e);</span>
<span class="nc" id="L243">			byte[] serialized = encoder.encode(e);</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">			if(serialized != null)</span>
			{
<span class="nc" id="L246">				sendBytes(serialized);</span>
			}
		}
<span class="nc" id="L249">	}</span>

	protected abstract void preProcess(E e);

	protected Encoder&lt;E&gt; getEncoder()
	{
<span class="nc" id="L255">		return encoder;</span>
	}

	protected void setEncoder(Encoder&lt;E&gt; encoder)
	{
<span class="nc" id="L260">		this.encoder = encoder;</span>
<span class="nc" id="L261">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>