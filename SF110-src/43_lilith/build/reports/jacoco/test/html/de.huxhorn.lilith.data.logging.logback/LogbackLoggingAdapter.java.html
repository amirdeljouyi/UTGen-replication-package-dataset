<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LogbackLoggingAdapter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">43_lilith</a> &gt; <a href="index.source.html" class="el_package">de.huxhorn.lilith.data.logging.logback</a> &gt; <span class="el_source">LogbackLoggingAdapter.java</span></div><h1>LogbackLoggingAdapter.java</h1><pre class="source lang-java linenums">/*
 * Lilith - a log event viewer.
 * Copyright (C) 2007-2009 Joern Huxhorn
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package de.huxhorn.lilith.data.logging.logback;

import de.huxhorn.lilith.data.logging.ExtendedStackTraceElement;
import de.huxhorn.lilith.data.logging.LoggerContext;
import de.huxhorn.lilith.data.logging.LoggingEvent;
import de.huxhorn.lilith.data.logging.Marker;
import de.huxhorn.lilith.data.logging.Message;
import de.huxhorn.lilith.data.logging.MessageFormatter;
import de.huxhorn.lilith.data.logging.ThreadInfo;
import de.huxhorn.lilith.data.logging.ThrowableInfo;
import de.huxhorn.lilith.logback.classic.NDC;

import ch.qos.logback.classic.spi.ClassPackagingData;
import ch.qos.logback.classic.spi.IThrowableProxy;
import ch.qos.logback.classic.spi.LoggerContextVO;
import ch.qos.logback.classic.spi.StackTraceElementProxy;
import ch.qos.logback.classic.spi.ThrowableProxy;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

<span class="nc" id="L40">public class LogbackLoggingAdapter</span>
{
	public LoggingEvent convert(ch.qos.logback.classic.spi.ILoggingEvent event, boolean inSameThread)
	{
<span class="nc bnc" id="L44" title="All 2 branches missed.">		if(event == null)</span>
		{
<span class="nc" id="L46">			return null;</span>
		}
<span class="nc" id="L48">		LoggingEvent result = new LoggingEvent();</span>
<span class="nc" id="L49">		String messagePattern = event.getMessage();</span>

<span class="nc" id="L51">		Object[] originalArguments = event.getArgumentArray();</span>
<span class="nc" id="L52">		MessageFormatter.ArgumentResult argumentResult =</span>
<span class="nc" id="L53">			MessageFormatter.evaluateArguments(messagePattern, originalArguments);</span>

<span class="nc" id="L55">		String[] arguments = null;</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">		if(argumentResult != null)</span>
		{
<span class="nc" id="L58">			arguments = argumentResult.getArguments();</span>
<span class="nc" id="L59">			Throwable t = argumentResult.getThrowable();</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">			if(t != null &amp;&amp; event</span>
<span class="nc bnc" id="L61" title="All 4 branches missed.">				.getThrowableProxy() == null &amp;&amp; event instanceof ch.qos.logback.classic.spi.LoggingEvent)</span>
			{
<span class="nc" id="L63">				ch.qos.logback.classic.spi.LoggingEvent le = (ch.qos.logback.classic.spi.LoggingEvent) event;</span>
<span class="nc" id="L64">				le.setThrowableProxy(new ThrowableProxy(t));</span>
			}
		}
<span class="nc bnc" id="L67" title="All 4 branches missed.">		if(messagePattern != null || arguments != null)</span>
		{
<span class="nc" id="L69">			Message message = new Message(messagePattern, arguments);</span>
<span class="nc" id="L70">			result.setMessage(message);</span>
		}
<span class="nc" id="L72">		event.prepareForDeferredProcessing();</span>
		// TODO: configurable calculation of packaging data?
<span class="nc" id="L74">		result.setThrowable(initFromThrowableProxy(event.getThrowableProxy(), true));</span>


		// TODO: configurable init of call stack, i.e. don't execute next line.
<span class="nc" id="L78">		result.setCallStack(convert(event.getCallerData()));</span>

<span class="nc" id="L80">		result.setLogger(event.getLoggerName());</span>

<span class="nc" id="L82">		result.setLevel(LoggingEvent.Level.valueOf(event.getLevel().toString()));</span>
<span class="nc" id="L83">		LoggerContextVO lcv = event.getLoggerContextVO();</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">		if(lcv != null)</span>
		{
<span class="nc" id="L86">			String name = lcv.getName();</span>
<span class="nc" id="L87">			Map&lt;String, String&gt; props = lcv.getPropertyMap();</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">			if(props != null)</span>
			{
				// TODO: lcv property map leak? yes, indeed. See http://jira.qos.ch/browse/LBCLASSIC-115
<span class="nc" id="L91">				props = new HashMap&lt;String, String&gt;(props);</span>
			}
<span class="nc" id="L93">			LoggerContext loggerContext = new LoggerContext();</span>
<span class="nc" id="L94">			loggerContext.setName(name);</span>
<span class="nc" id="L95">			loggerContext.setProperties(props);</span>
<span class="nc" id="L96">			loggerContext.setBirthTime(lcv.getBirthTime());</span>
<span class="nc" id="L97">			result.setLoggerContext(loggerContext);</span>
		}
<span class="nc" id="L99">		initMarker(event, result);</span>
<span class="nc" id="L100">		result.setMdc(event.getMDCPropertyMap());</span>
<span class="nc" id="L101">		String threadName = event.getThreadName();</span>

<span class="nc bnc" id="L103" title="All 2 branches missed.">		if(threadName != null)</span>
		{
<span class="nc" id="L105">			Long threadId = null;</span>
<span class="nc" id="L106">			String threadGroupName = null;</span>
<span class="nc" id="L107">			Long threadGroupId = null;</span>

<span class="nc bnc" id="L109" title="All 2 branches missed.">			if(inSameThread)</span>
			{
				// assuming this code is executed synchronously
<span class="nc" id="L112">				Thread t = Thread.currentThread();</span>
<span class="nc" id="L113">				threadId = t.getId();</span>

<span class="nc" id="L115">				ThreadGroup tg = t.getThreadGroup();</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">				if(tg != null)</span>
				{
<span class="nc" id="L118">					threadGroupName = tg.getName();</span>
<span class="nc" id="L119">					threadGroupId = (long) System.identityHashCode(tg);</span>
				}
			}
<span class="nc" id="L122">			ThreadInfo threadInfo = new ThreadInfo(threadId, threadName, threadGroupId, threadGroupName);</span>
<span class="nc" id="L123">			result.setThreadInfo(threadInfo);</span>
		}
<span class="nc" id="L125">		result.setTimeStamp(event.getTimeStamp());</span>

<span class="nc bnc" id="L127" title="All 2 branches missed.">		if(inSameThread)</span>
		{
<span class="nc bnc" id="L129" title="All 2 branches missed.">			if(!NDC.isEmpty())</span>
			{
				// TODO: configurable NDC evaluation
<span class="nc" id="L132">				result.setNdc(NDC.getContextStack());</span>
			}
		}

<span class="nc" id="L136">		return result;</span>
	}


	private ExtendedStackTraceElement[] convert(StackTraceElement[] stackTrace)
	{
<span class="nc bnc" id="L142" title="All 2 branches missed.">		if(stackTrace == null)</span>
		{
<span class="nc" id="L144">			return null;</span>
		}
<span class="nc" id="L146">		ExtendedStackTraceElement[] result = new ExtendedStackTraceElement[stackTrace.length];</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">		for(int i = 0; i &lt; stackTrace.length; i++)</span>
		{
<span class="nc" id="L149">			result[i] = new ExtendedStackTraceElement(stackTrace[i]);</span>
		}
<span class="nc" id="L151">		return result;</span>
	}

	ThrowableInfo initFromThrowableProxy(IThrowableProxy ti, boolean calculatePackagingData)
	{
<span class="nc bnc" id="L156" title="All 2 branches missed.">		if(ti == null)</span>
		{
<span class="nc" id="L158">			return null;</span>
		}
/* CHECK: java.lang.IllegalStateException: Packaging data has been already set
        if(calculatePackagingData &amp;&amp; ti instanceof ThrowableProxy)
        {
            ThrowableProxy tp= (ThrowableProxy) ti;
            tp.calculatePackagingData();
        }
*/
<span class="nc" id="L167">		ThrowableInfo result = new ThrowableInfo();</span>
<span class="nc" id="L168">		result.setName(ti.getClassName());</span>
<span class="nc" id="L169">		result.setOmittedElements(ti.getCommonFrames());</span>
<span class="nc" id="L170">		result.setMessage(ti.getMessage());</span>
<span class="nc" id="L171">		result.setStackTrace(initFromStackTraceElementProxyArray(ti.getStackTraceElementProxyArray()));</span>
<span class="nc" id="L172">		result.setCause(initFromThrowableProxy(ti.getCause(), calculatePackagingData));</span>
<span class="nc" id="L173">		return result;</span>
	}

	private ExtendedStackTraceElement[] initFromStackTraceElementProxyArray(StackTraceElementProxy[] stackTraceElementProxies)
	{
<span class="nc bnc" id="L178" title="All 2 branches missed.">		if(stackTraceElementProxies == null)</span>
		{
<span class="nc" id="L180">			return null;</span>
		}
<span class="nc" id="L182">		int elementCount = stackTraceElementProxies.length;</span>
<span class="nc" id="L183">		ExtendedStackTraceElement[] result = new ExtendedStackTraceElement[elementCount];</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">		for(int i = 0; i &lt; elementCount; i++)</span>
		{
<span class="nc" id="L186">			StackTraceElementProxy currentInput = stackTraceElementProxies[i];</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">			if(currentInput != null)</span>
			{
<span class="nc" id="L189">				ExtendedStackTraceElement current = new ExtendedStackTraceElement(currentInput.getStackTraceElement());</span>
<span class="nc" id="L190">				ClassPackagingData cpd = currentInput.getClassPackagingData();</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">				if(cpd != null)</span>
				{
<span class="nc" id="L193">					current.setCodeLocation(cpd.getCodeLocation());</span>
<span class="nc" id="L194">					current.setExact(cpd.isExact());</span>
<span class="nc" id="L195">					current.setVersion(cpd.getVersion());</span>
				}
<span class="nc" id="L197">				result[i] = current;</span>
			}
		}
<span class="nc" id="L200">		return result;</span>
	}

	private void initMarker(ch.qos.logback.classic.spi.ILoggingEvent src, LoggingEvent dst)
	{
<span class="nc" id="L205">		org.slf4j.Marker origMarker = src.getMarker();</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">		if(origMarker == null)</span>
		{
<span class="nc" id="L208">			return;</span>
		}
<span class="nc" id="L210">		Map&lt;String, Marker&gt; markers = new HashMap&lt;String, Marker&gt;();</span>
<span class="nc" id="L211">		dst.setMarker(initMarkerRecursive(origMarker, markers));</span>
<span class="nc" id="L212">	}</span>

	private Marker initMarkerRecursive(org.slf4j.Marker origMarker, Map&lt;String, Marker&gt; markers)
	{
<span class="nc bnc" id="L216" title="All 2 branches missed.">		if(origMarker == null)</span>
		{
<span class="nc" id="L218">			return null;</span>
		}
<span class="nc" id="L220">		String name = origMarker.getName();</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">		if(markers.containsKey(name))</span>
		{
<span class="nc" id="L223">			return markers.get(name);</span>
		}
<span class="nc" id="L225">		Marker newMarker = new Marker(name);</span>
<span class="nc" id="L226">		markers.put(name, newMarker);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">		if(origMarker.hasReferences())</span>
		{
<span class="nc" id="L229">			Iterator iter = origMarker.iterator();</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">			while(iter.hasNext())</span>
			{
<span class="nc" id="L232">				org.slf4j.Marker current = (org.slf4j.Marker) iter.next();</span>
<span class="nc" id="L233">				newMarker.add(initMarkerRecursive(current, markers));</span>
<span class="nc" id="L234">			}</span>
		}
<span class="nc" id="L236">		return newMarker;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>